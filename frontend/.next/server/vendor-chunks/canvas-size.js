"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/canvas-size";
exports.ids = ["vendor-chunks/canvas-size"];
exports.modules = {

/***/ "(ssr)/./node_modules/canvas-size/dist/canvas-size.esm.js":
/*!**********************************************************!*\
  !*** ./node_modules/canvas-size/dist/canvas-size.esm.js ***!
  \**********************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ canvasSize)\n/* harmony export */ });\n/*!\n * canvas-size\n * v1.2.6\n * https://github.com/jhildenbiddle/canvas-size\n * (c) 2015-2023 John Hildenbiddle <http://hildenbiddle.com>\n * MIT license\n */ function _iterableToArrayLimit(arr, i) {\n    var _i = null == arr ? null : \"undefined\" != typeof Symbol && arr[Symbol.iterator] || arr[\"@@iterator\"];\n    if (null != _i) {\n        var _s, _e, _x, _r, _arr = [], _n = !0, _d = !1;\n        try {\n            if (_x = (_i = _i.call(arr)).next, 0 === i) {\n                if (Object(_i) !== _i) return;\n                _n = !1;\n            } else for(; !(_n = (_s = _x.call(_i)).done) && (_arr.push(_s.value), _arr.length !== i); _n = !0);\n        } catch (err) {\n            _d = !0, _e = err;\n        } finally{\n            try {\n                if (!_n && null != _i.return && (_r = _i.return(), Object(_r) !== _r)) return;\n            } finally{\n                if (_d) throw _e;\n            }\n        }\n        return _arr;\n    }\n}\nfunction ownKeys(object, enumerableOnly) {\n    var keys = Object.keys(object);\n    if (Object.getOwnPropertySymbols) {\n        var symbols = Object.getOwnPropertySymbols(object);\n        enumerableOnly && (symbols = symbols.filter(function(sym) {\n            return Object.getOwnPropertyDescriptor(object, sym).enumerable;\n        })), keys.push.apply(keys, symbols);\n    }\n    return keys;\n}\nfunction _objectSpread2(target) {\n    for(var i = 1; i < arguments.length; i++){\n        var source = null != arguments[i] ? arguments[i] : {};\n        i % 2 ? ownKeys(Object(source), !0).forEach(function(key) {\n            _defineProperty(target, key, source[key]);\n        }) : Object.getOwnPropertyDescriptors ? Object.defineProperties(target, Object.getOwnPropertyDescriptors(source)) : ownKeys(Object(source)).forEach(function(key) {\n            Object.defineProperty(target, key, Object.getOwnPropertyDescriptor(source, key));\n        });\n    }\n    return target;\n}\nfunction _defineProperty(obj, key, value) {\n    key = _toPropertyKey(key);\n    if (key in obj) {\n        Object.defineProperty(obj, key, {\n            value: value,\n            enumerable: true,\n            configurable: true,\n            writable: true\n        });\n    } else {\n        obj[key] = value;\n    }\n    return obj;\n}\nfunction _objectWithoutPropertiesLoose(source, excluded) {\n    if (source == null) return {};\n    var target = {};\n    var sourceKeys = Object.keys(source);\n    var key, i;\n    for(i = 0; i < sourceKeys.length; i++){\n        key = sourceKeys[i];\n        if (excluded.indexOf(key) >= 0) continue;\n        target[key] = source[key];\n    }\n    return target;\n}\nfunction _objectWithoutProperties(source, excluded) {\n    if (source == null) return {};\n    var target = _objectWithoutPropertiesLoose(source, excluded);\n    var key, i;\n    if (Object.getOwnPropertySymbols) {\n        var sourceSymbolKeys = Object.getOwnPropertySymbols(source);\n        for(i = 0; i < sourceSymbolKeys.length; i++){\n            key = sourceSymbolKeys[i];\n            if (excluded.indexOf(key) >= 0) continue;\n            if (!Object.prototype.propertyIsEnumerable.call(source, key)) continue;\n            target[key] = source[key];\n        }\n    }\n    return target;\n}\nfunction _slicedToArray(arr, i) {\n    return _arrayWithHoles(arr) || _iterableToArrayLimit(arr, i) || _unsupportedIterableToArray(arr, i) || _nonIterableRest();\n}\nfunction _toConsumableArray(arr) {\n    return _arrayWithoutHoles(arr) || _iterableToArray(arr) || _unsupportedIterableToArray(arr) || _nonIterableSpread();\n}\nfunction _arrayWithoutHoles(arr) {\n    if (Array.isArray(arr)) return _arrayLikeToArray(arr);\n}\nfunction _arrayWithHoles(arr) {\n    if (Array.isArray(arr)) return arr;\n}\nfunction _iterableToArray(iter) {\n    if (typeof Symbol !== \"undefined\" && iter[Symbol.iterator] != null || iter[\"@@iterator\"] != null) return Array.from(iter);\n}\nfunction _unsupportedIterableToArray(o, minLen) {\n    if (!o) return;\n    if (typeof o === \"string\") return _arrayLikeToArray(o, minLen);\n    var n = Object.prototype.toString.call(o).slice(8, -1);\n    if (n === \"Object\" && o.constructor) n = o.constructor.name;\n    if (n === \"Map\" || n === \"Set\") return Array.from(o);\n    if (n === \"Arguments\" || /^(?:Ui|I)nt(?:8|16|32)(?:Clamped)?Array$/.test(n)) return _arrayLikeToArray(o, minLen);\n}\nfunction _arrayLikeToArray(arr, len) {\n    if (len == null || len > arr.length) len = arr.length;\n    for(var i = 0, arr2 = new Array(len); i < len; i++)arr2[i] = arr[i];\n    return arr2;\n}\nfunction _nonIterableSpread() {\n    throw new TypeError(\"Invalid attempt to spread non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _nonIterableRest() {\n    throw new TypeError(\"Invalid attempt to destructure non-iterable instance.\\nIn order to be iterable, non-array objects must have a [Symbol.iterator]() method.\");\n}\nfunction _toPrimitive(input, hint) {\n    if (typeof input !== \"object\" || input === null) return input;\n    var prim = input[Symbol.toPrimitive];\n    if (prim !== undefined) {\n        var res = prim.call(input, hint || \"default\");\n        if (typeof res !== \"object\") return res;\n        throw new TypeError(\"@@toPrimitive must return a primitive value.\");\n    }\n    return (hint === \"string\" ? String : Number)(input);\n}\nfunction _toPropertyKey(arg) {\n    var key = _toPrimitive(arg, \"string\");\n    return typeof key === \"symbol\" ? key : String(key);\n}\nfunction canvasTest(settings) {\n    var size = settings.sizes.shift();\n    var width = Math.max(Math.ceil(size[0]), 1);\n    var height = Math.max(Math.ceil(size[1]), 1);\n    var fill = [\n        width - 1,\n        height - 1,\n        1,\n        1\n    ];\n    var job = Date.now();\n    var isWorker = typeof WorkerGlobalScope !== \"undefined\" && self instanceof WorkerGlobalScope;\n    var cropCvs, testCvs;\n    if (isWorker) {\n        cropCvs = new OffscreenCanvas(1, 1);\n        testCvs = new OffscreenCanvas(width, height);\n    } else {\n        cropCvs = document.createElement(\"canvas\");\n        cropCvs.width = 1;\n        cropCvs.height = 1;\n        testCvs = document.createElement(\"canvas\");\n        testCvs.width = width;\n        testCvs.height = height;\n    }\n    var cropCtx = cropCvs.getContext(\"2d\");\n    var testCtx = testCvs.getContext(\"2d\");\n    if (testCtx) {\n        testCtx.fillRect.apply(testCtx, fill);\n        cropCtx.drawImage(testCvs, width - 1, height - 1, 1, 1, 0, 0, 1, 1);\n    }\n    var isTestPass = cropCtx && cropCtx.getImageData(0, 0, 1, 1).data[3] !== 0;\n    var benchmark = Date.now() - job;\n    [\n        cropCvs,\n        testCvs\n    ].forEach(function(cvs) {\n        cvs.height = 0;\n        cvs.width = 0;\n    });\n    if (isWorker) {\n        postMessage({\n            width: width,\n            height: height,\n            benchmark: benchmark,\n            isTestPass: isTestPass\n        });\n        if (!isTestPass && settings.sizes.length) {\n            canvasTest(settings);\n        }\n    } else if (isTestPass) {\n        settings.onSuccess(width, height, benchmark);\n    } else {\n        settings.onError(width, height, benchmark);\n        if (settings.sizes.length) {\n            canvasTest(settings);\n        }\n    }\n    return isTestPass;\n}\nvar testSizes = {\n    area: [\n        16384,\n        14188,\n        11402,\n        11180,\n        10836,\n        8192,\n        4096,\n        1\n    ],\n    height: [\n        8388607,\n        65535,\n        32767,\n        16384,\n        8192,\n        4096,\n        1\n    ],\n    width: [\n        4194303,\n        65535,\n        32767,\n        16384,\n        8192,\n        4096,\n        1\n    ]\n};\nvar _excluded = [\n    \"onError\",\n    \"onSuccess\"\n];\nvar defaults = {\n    max: null,\n    min: 1,\n    sizes: [],\n    step: 1024,\n    usePromise: false,\n    useWorker: false,\n    onError: Function.prototype,\n    onSuccess: Function.prototype\n};\nvar workerJobs = {};\nfunction createSizesArray(settings) {\n    var isArea = settings.width === settings.height;\n    var isWidth = settings.height === 1;\n    var isHeight = settings.width === 1;\n    var sizes = [];\n    if (!settings.width || !settings.height) {\n        settings.sizes.forEach(function(testSize) {\n            var width = isArea || isWidth ? testSize : 1;\n            var height = isArea || isHeight ? testSize : 1;\n            sizes.push([\n                width,\n                height\n            ]);\n        });\n    } else {\n        var testMin = settings.min || defaults.min;\n        var testStep = settings.step || defaults.step;\n        var testSize = Math.max(settings.width, settings.height);\n        while(testSize >= testMin){\n            var width = isArea || isWidth ? testSize : 1;\n            var height = isArea || isHeight ? testSize : 1;\n            sizes.push([\n                width,\n                height\n            ]);\n            testSize -= testStep;\n        }\n    }\n    return sizes;\n}\nfunction handleMethod(settings) {\n    var hasCanvasSupport = window && \"HTMLCanvasElement\" in window;\n    var hasOffscreenCanvasSupport = window && \"OffscreenCanvas\" in window;\n    var jobID = Date.now();\n    var _onError = settings.onError, _onSuccess = settings.onSuccess, settingsWithoutCallbacks = _objectWithoutProperties(settings, _excluded);\n    var worker = null;\n    if (!hasCanvasSupport) {\n        return false;\n    }\n    if (settings.useWorker && hasOffscreenCanvasSupport) {\n        var js = \"\\n            var canvasTest = \".concat(canvasTest.toString(), \";\\n            onmessage = function(e) {\\n                canvasTest(e.data);\\n            };\\n        \");\n        var blob = new Blob([\n            js\n        ], {\n            type: \"application/javascript\"\n        });\n        var blobURL = URL.createObjectURL(blob);\n        worker = new Worker(blobURL);\n        URL.revokeObjectURL(blobURL);\n        worker.onmessage = function(e) {\n            var _e$data = e.data, width = _e$data.width, height = _e$data.height, benchmark = _e$data.benchmark, isTestPass = _e$data.isTestPass;\n            if (isTestPass) {\n                workerJobs[jobID].onSuccess(width, height, benchmark);\n                delete workerJobs[jobID];\n            } else {\n                workerJobs[jobID].onError(width, height, benchmark);\n            }\n        };\n    }\n    if (settings.usePromise) {\n        return new Promise(function(resolve, reject) {\n            var promiseSettings = _objectSpread2(_objectSpread2({}, settings), {}, {\n                onError: function onError(width, height, benchmark) {\n                    var isLastTest;\n                    if (settings.sizes.length === 0) {\n                        isLastTest = true;\n                    } else {\n                        var _settings$sizes$slice = settings.sizes.slice(-1), _settings$sizes$slice2 = _slicedToArray(_settings$sizes$slice, 1), _settings$sizes$slice3 = _slicedToArray(_settings$sizes$slice2[0], 2), lastWidth = _settings$sizes$slice3[0], lastHeight = _settings$sizes$slice3[1];\n                        isLastTest = width === lastWidth && height === lastHeight;\n                    }\n                    _onError(width, height, benchmark);\n                    if (isLastTest) {\n                        reject({\n                            width: width,\n                            height: height,\n                            benchmark: benchmark\n                        });\n                    }\n                },\n                onSuccess: function onSuccess(width, height, benchmark) {\n                    _onSuccess(width, height, benchmark);\n                    resolve({\n                        width: width,\n                        height: height,\n                        benchmark: benchmark\n                    });\n                }\n            });\n            if (worker) {\n                var onError = promiseSettings.onError, onSuccess = promiseSettings.onSuccess;\n                workerJobs[jobID] = {\n                    onError: onError,\n                    onSuccess: onSuccess\n                };\n                worker.postMessage(settingsWithoutCallbacks);\n            } else {\n                canvasTest(promiseSettings);\n            }\n        });\n    } else {\n        if (worker) {\n            workerJobs[jobID] = {\n                onError: _onError,\n                onSuccess: _onSuccess\n            };\n            worker.postMessage(settingsWithoutCallbacks);\n        } else {\n            return canvasTest(settings);\n        }\n    }\n}\nvar canvasSize = {\n    maxArea: function maxArea() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var sizes = createSizesArray({\n            width: options.max,\n            height: options.max,\n            min: options.min,\n            step: options.step,\n            sizes: _toConsumableArray(testSizes.area)\n        });\n        var settings = _objectSpread2(_objectSpread2(_objectSpread2({}, defaults), options), {}, {\n            sizes: sizes\n        });\n        return handleMethod(settings);\n    },\n    maxHeight: function maxHeight() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var sizes = createSizesArray({\n            width: 1,\n            height: options.max,\n            min: options.min,\n            step: options.step,\n            sizes: _toConsumableArray(testSizes.height)\n        });\n        var settings = _objectSpread2(_objectSpread2(_objectSpread2({}, defaults), options), {}, {\n            sizes: sizes\n        });\n        return handleMethod(settings);\n    },\n    maxWidth: function maxWidth() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var sizes = createSizesArray({\n            width: options.max,\n            height: 1,\n            min: options.min,\n            step: options.step,\n            sizes: _toConsumableArray(testSizes.width)\n        });\n        var settings = _objectSpread2(_objectSpread2(_objectSpread2({}, defaults), options), {}, {\n            sizes: sizes\n        });\n        return handleMethod(settings);\n    },\n    test: function test() {\n        var options = arguments.length > 0 && arguments[0] !== undefined ? arguments[0] : {};\n        var settings = _objectSpread2(_objectSpread2({}, defaults), options);\n        settings.sizes = _toConsumableArray(settings.sizes);\n        if (settings.width && settings.height) {\n            settings.sizes = [\n                [\n                    settings.width,\n                    settings.height\n                ]\n            ];\n        }\n        return handleMethod(settings);\n    }\n};\n //# sourceMappingURL=canvas-size.esm.js.map\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvY2FudmFzLXNpemUvZGlzdC9jYW52YXMtc2l6ZS5lc20uanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBOzs7Ozs7Q0FNQyxHQUNELFNBQVNBLHNCQUFzQkMsR0FBRyxFQUFFQyxDQUFDO0lBQ2pDLElBQUlDLEtBQUssUUFBUUYsTUFBTSxPQUFPLGVBQWUsT0FBT0csVUFBVUgsR0FBRyxDQUFDRyxPQUFPQyxRQUFRLENBQUMsSUFBSUosR0FBRyxDQUFDLGFBQWE7SUFDdkcsSUFBSSxRQUFRRSxJQUFJO1FBQ1osSUFBSUcsSUFBSUMsSUFBSUMsSUFBSUMsSUFBSUMsT0FBTyxFQUFFLEVBQUVDLEtBQUssQ0FBQyxHQUFHQyxLQUFLLENBQUM7UUFDOUMsSUFBSTtZQUNBLElBQUlKLEtBQUssQ0FBQ0wsS0FBS0EsR0FBR1UsSUFBSSxDQUFDWixJQUFHLEVBQUdhLElBQUksRUFBRSxNQUFNWixHQUFHO2dCQUN4QyxJQUFJYSxPQUFPWixRQUFRQSxJQUFJO2dCQUN2QlEsS0FBSyxDQUFDO1lBQ1YsT0FBTyxNQUFNLENBQUVBLENBQUFBLEtBQUssQ0FBQ0wsS0FBS0UsR0FBR0ssSUFBSSxDQUFDVixHQUFFLEVBQUdhLElBQUksS0FBTU4sQ0FBQUEsS0FBS08sSUFBSSxDQUFDWCxHQUFHWSxLQUFLLEdBQUdSLEtBQUtTLE1BQU0sS0FBS2pCLENBQUFBLEdBQUlTLEtBQUssQ0FBQztRQUNwRyxFQUFFLE9BQU9TLEtBQUs7WUFDVlIsS0FBSyxDQUFDLEdBQUdMLEtBQUthO1FBQ2xCLFNBQVU7WUFDTixJQUFJO2dCQUNBLElBQUksQ0FBQ1QsTUFBTSxRQUFRUixHQUFHa0IsTUFBTSxJQUFLWixDQUFBQSxLQUFLTixHQUFHa0IsTUFBTSxJQUFJTixPQUFPTixRQUFRQSxFQUFDLEdBQUk7WUFDM0UsU0FBVTtnQkFDTixJQUFJRyxJQUFJLE1BQU1MO1lBQ2xCO1FBQ0o7UUFDQSxPQUFPRztJQUNYO0FBQ0o7QUFFQSxTQUFTWSxRQUFRQyxNQUFNLEVB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QVU5QixLQUFLO1FBQzdDO1FBQ0EsSUFBSUosV0FBV3pELGVBQWVBLGVBQWVBLGVBQWUsQ0FBQyxHQUFHOEYsV0FBV2dELFVBQVUsQ0FBQyxHQUFHO1lBQ3JGbkYsT0FBT0E7UUFDWDtRQUNBLE9BQU9pRCxhQUFhbkQ7SUFDeEI7SUFDQWYsTUFBTSxTQUFTQTtRQUNYLElBQUlvRyxVQUFVNUksVUFBVWhCLE1BQU0sR0FBRyxLQUFLZ0IsU0FBUyxDQUFDLEVBQUUsS0FBS2lELFlBQVlqRCxTQUFTLENBQUMsRUFBRSxHQUFHLENBQUM7UUFDbkYsSUFBSXVELFdBQVd6RCxlQUFlQSxlQUFlLENBQUMsR0FBRzhGLFdBQVdnRDtRQUM1RHJGLFNBQVNFLEtBQUssR0FBR2pDLG1CQUFtQitCLFNBQVNFLEtBQUs7UUFDbEQsSUFBSUYsU0FBU0ksS0FBSyxJQUFJSixTQUFTUSxNQUFNLEVBQUU7WUFDbkNSLFNBQVNFLEtBQUssR0FBRztnQkFBRTtvQkFBRUYsU0FBU0ksS0FBSztvQkFBRUosU0FBU1EsTUFBTTtpQkFBRTthQUFFO1FBQzVEO1FBQ0EsT0FBTzJDLGFBQWFuRDtJQUN4QjtBQUNKO0FBRWlDLENBQ2pDLDJDQUEyQyIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpYmUtM2QtY29kZS8uL25vZGVfbW9kdWxlcy9jYW52YXMtc2l6ZS9kaXN0L2NhbnZhcy1zaXplLmVzbS5qcz8wYjA0Il0sInNvdXJjZXNDb250ZW50IjpbIi8qIVxuICogY2FudmFzLXNpemVcbiAqIHYxLjIuNlxuICogaHR0cHM6Ly9naXRodWIuY29tL2poaWxkZW5iaWRkbGUvY2FudmFzLXNpemVcbiAqIChjKSAyMDE1LTIwMjMgSm9obiBIaWxkZW5iaWRkbGUgPGh0dHA6Ly9oaWxkZW5iaWRkbGUuY29tPlxuICogTUlUIGxpY2Vuc2VcbiAqL1xuZnVuY3Rpb24gX2l0ZXJhYmxlVG9BcnJheUxpbWl0KGFyciwgaSkge1xuICAgIHZhciBfaSA9IG51bGwgPT0gYXJyID8gbnVsbCA6IFwidW5kZWZpbmVkXCIgIT0gdHlwZW9mIFN5bWJvbCAmJiBhcnJbU3ltYm9sLml0ZXJhdG9yXSB8fCBhcnJbXCJAQGl0ZXJhdG9yXCJdO1xuICAgIGlmIChudWxsICE9IF9pKSB7XG4gICAgICAgIHZhciBfcywgX2UsIF94LCBfciwgX2FyciA9IFtdLCBfbiA9ICEwLCBfZCA9ICExO1xuICAgICAgICB0cnkge1xuICAgICAgICAgICAgaWYgKF94ID0gKF9pID0gX2kuY2FsbChhcnIpKS5uZXh0LCAwID09PSBpKSB7XG4gICAgICAgICAgICAgICAgaWYgKE9iamVjdChfaSkgIT09IF9pKSByZXR1cm47XG4gICAgICAgICAgICAgICAgX24gPSAhMTtcbiAgICAgICAgICAgIH0gZWxzZSBmb3IgKDshKF9uID0gKF9zID0gX3guY2FsbChfaSkpLmRvbmUpICYmIChfYXJyLnB1c2goX3MudmFsdWUpLCBfYXJyLmxlbmd0aCAhPT0gaSk7IF9uID0gITApIDtcbiAgICAgICAgfSBjYXRjaCAoZXJyKSB7XG4gICAgICAgICAgICBfZCA9ICEwLCBfZSA9IGVycjtcbiAgICAgICAgfSBmaW5hbGx5IHtcbiAgICAgICAgICAgIHRyeSB7XG4gICAgICAgICAgICAgICAgaWYgKCFfbiAmJiBudWxsICE9IF9pLnJldHVybiAmJiAoX3IgPSBfaS5yZXR1cm4oKSwgT2JqZWN0KF9yKSAhPT0gX3IpKSByZXR1cm47XG4gICAgICAgICAgICB9IGZpbmFsbHkge1xuICAgICAgICAgICAgICAgIGlmIChfZCkgdGhyb3cgX2U7XG4gICAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgICAgcmV0dXJuIF9hcnI7XG4gICAgfVxufVxuXG5mdW5jdGlvbiBvd25LZXlzKG9iamVjdCwgZW51bWVyYWJsZU9ubHkpIHtcbiAgICB2YXIga2V5cyA9IE9iamVjdC5rZXlzKG9iamVjdCk7XG4gICAgaWYgKE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMpIHtcbiAgICAgICAgdmFyIHN5bWJvbHMgPSBPYmplY3QuZ2V0T3duUHJvcGVydHlTeW1ib2xzKG9iamVjdCk7XG4gICAgICAgIGVudW1lcmFibGVPbmx5ICYmIChzeW1ib2xzID0gc3ltYm9scy5maWx0ZXIoKGZ1bmN0aW9uKHN5bSkge1xuICAgICAgICAgICAgcmV0dXJuIE9iamVjdC5nZXRPd25Qcm9wZXJ0eURlc2NyaXB0b3Iob2JqZWN0LCBzeW0pLmVudW1lcmFibGU7XG4gICAgICAgIH0pKSksIGtleXMucHVzaC5hcHBseShrZXlzLCBzeW1ib2xzKTtcbiAgICB9XG4gICAgcmV0dXJuIGtleXM7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RTcHJlYWQyKHRhcmdldCkge1xuICAgIGZvciAodmFyIGkgPSAxOyBpIDwgYXJndW1lbnRzLmxlbmd0aDsgaSsrKSB7XG4gICAgICAgIHZhciBzb3VyY2UgPSBudWxsICE9IGFyZ3VtZW50c1tpXSA/IGFyZ3VtZW50c1tpXSA6IHt9O1xuICAgICAgICBpICUgMiA/IG93bktleXMoT2JqZWN0KHNvdXJjZSksICEwKS5mb3JFYWNoKChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIF9kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgc291cmNlW2tleV0pO1xuICAgICAgICB9KSkgOiBPYmplY3QuZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyA/IE9iamVjdC5kZWZpbmVQcm9wZXJ0aWVzKHRhcmdldCwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcnMoc291cmNlKSkgOiBvd25LZXlzKE9iamVjdChzb3VyY2UpKS5mb3JFYWNoKChmdW5jdGlvbihrZXkpIHtcbiAgICAgICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eSh0YXJnZXQsIGtleSwgT2JqZWN0LmdldE93blByb3BlcnR5RGVzY3JpcHRvcihzb3VyY2UsIGtleSkpO1xuICAgICAgICB9KSk7XG4gICAgfVxuICAgIHJldHVybiB0YXJnZXQ7XG59XG5cbmZ1bmN0aW9uIF9kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwgdmFsdWUpIHtcbiAgICBrZXkgPSBfdG9Qcm9wZXJ0eUtleShrZXkpO1xuICAgIGlmIChrZXkgaW4gb2JqKSB7XG4gICAgICAgIE9iamVjdC5kZWZpbmVQcm9wZXJ0eShvYmosIGtleSwge1xuICAgICAgICAgICAgdmFsdWU6IHZhbHVlLFxuICAgICAgICAgICAgZW51bWVyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIGNvbmZpZ3VyYWJsZTogdHJ1ZSxcbiAgICAgICAgICAgIHdyaXRhYmxlOiB0cnVlXG4gICAgICAgIH0pO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIG9ialtrZXldID0gdmFsdWU7XG4gICAgfVxuICAgIHJldHVybiBvYmo7XG59XG5cbmZ1bmN0aW9uIF9vYmplY3RXaXRob3V0UHJvcGVydGllc0xvb3NlKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgICB2YXIgdGFyZ2V0ID0ge307XG4gICAgdmFyIHNvdXJjZUtleXMgPSBPYmplY3Qua2V5cyhzb3VyY2UpO1xuICAgIHZhciBrZXksIGk7XG4gICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZUtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAga2V5ID0gc291cmNlS2V5c1tpXTtcbiAgICAgICAgaWYgKGV4Y2x1ZGVkLmluZGV4T2Yoa2V5KSA+PSAwKSBjb250aW51ZTtcbiAgICAgICAgdGFyZ2V0W2tleV0gPSBzb3VyY2Vba2V5XTtcbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNvdXJjZSwgZXhjbHVkZWQpIHtcbiAgICBpZiAoc291cmNlID09IG51bGwpIHJldHVybiB7fTtcbiAgICB2YXIgdGFyZ2V0ID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzTG9vc2Uoc291cmNlLCBleGNsdWRlZCk7XG4gICAgdmFyIGtleSwgaTtcbiAgICBpZiAoT2JqZWN0LmdldE93blByb3BlcnR5U3ltYm9scykge1xuICAgICAgICB2YXIgc291cmNlU3ltYm9sS2V5cyA9IE9iamVjdC5nZXRPd25Qcm9wZXJ0eVN5bWJvbHMoc291cmNlKTtcbiAgICAgICAgZm9yIChpID0gMDsgaSA8IHNvdXJjZVN5bWJvbEtleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgICAgICAgIGtleSA9IHNvdXJjZVN5bWJvbEtleXNbaV07XG4gICAgICAgICAgICBpZiAoZXhjbHVkZWQuaW5kZXhPZihrZXkpID49IDApIGNvbnRpbnVlO1xuICAgICAgICAgICAgaWYgKCFPYmplY3QucHJvdG90eXBlLnByb3BlcnR5SXNFbnVtZXJhYmxlLmNhbGwoc291cmNlLCBrZXkpKSBjb250aW51ZTtcbiAgICAgICAgICAgIHRhcmdldFtrZXldID0gc291cmNlW2tleV07XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHRhcmdldDtcbn1cblxuZnVuY3Rpb24gX3NsaWNlZFRvQXJyYXkoYXJyLCBpKSB7XG4gICAgcmV0dXJuIF9hcnJheVdpdGhIb2xlcyhhcnIpIHx8IF9pdGVyYWJsZVRvQXJyYXlMaW1pdChhcnIsIGkpIHx8IF91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheShhcnIsIGkpIHx8IF9ub25JdGVyYWJsZVJlc3QoKTtcbn1cblxuZnVuY3Rpb24gX3RvQ29uc3VtYWJsZUFycmF5KGFycikge1xuICAgIHJldHVybiBfYXJyYXlXaXRob3V0SG9sZXMoYXJyKSB8fCBfaXRlcmFibGVUb0FycmF5KGFycikgfHwgX3Vuc3VwcG9ydGVkSXRlcmFibGVUb0FycmF5KGFycikgfHwgX25vbkl0ZXJhYmxlU3ByZWFkKCk7XG59XG5cbmZ1bmN0aW9uIF9hcnJheVdpdGhvdXRIb2xlcyhhcnIpIHtcbiAgICBpZiAoQXJyYXkuaXNBcnJheShhcnIpKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkoYXJyKTtcbn1cblxuZnVuY3Rpb24gX2FycmF5V2l0aEhvbGVzKGFycikge1xuICAgIGlmIChBcnJheS5pc0FycmF5KGFycikpIHJldHVybiBhcnI7XG59XG5cbmZ1bmN0aW9uIF9pdGVyYWJsZVRvQXJyYXkoaXRlcikge1xuICAgIGlmICh0eXBlb2YgU3ltYm9sICE9PSBcInVuZGVmaW5lZFwiICYmIGl0ZXJbU3ltYm9sLml0ZXJhdG9yXSAhPSBudWxsIHx8IGl0ZXJbXCJAQGl0ZXJhdG9yXCJdICE9IG51bGwpIHJldHVybiBBcnJheS5mcm9tKGl0ZXIpO1xufVxuXG5mdW5jdGlvbiBfdW5zdXBwb3J0ZWRJdGVyYWJsZVRvQXJyYXkobywgbWluTGVuKSB7XG4gICAgaWYgKCFvKSByZXR1cm47XG4gICAgaWYgKHR5cGVvZiBvID09PSBcInN0cmluZ1wiKSByZXR1cm4gX2FycmF5TGlrZVRvQXJyYXkobywgbWluTGVuKTtcbiAgICB2YXIgbiA9IE9iamVjdC5wcm90b3R5cGUudG9TdHJpbmcuY2FsbChvKS5zbGljZSg4LCAtMSk7XG4gICAgaWYgKG4gPT09IFwiT2JqZWN0XCIgJiYgby5jb25zdHJ1Y3RvcikgbiA9IG8uY29uc3RydWN0b3IubmFtZTtcbiAgICBpZiAobiA9PT0gXCJNYXBcIiB8fCBuID09PSBcIlNldFwiKSByZXR1cm4gQXJyYXkuZnJvbShvKTtcbiAgICBpZiAobiA9PT0gXCJBcmd1bWVudHNcIiB8fCAvXig/OlVpfEkpbnQoPzo4fDE2fDMyKSg/OkNsYW1wZWQpP0FycmF5JC8udGVzdChuKSkgcmV0dXJuIF9hcnJheUxpa2VUb0FycmF5KG8sIG1pbkxlbik7XG59XG5cbmZ1bmN0aW9uIF9hcnJheUxpa2VUb0FycmF5KGFyciwgbGVuKSB7XG4gICAgaWYgKGxlbiA9PSBudWxsIHx8IGxlbiA+IGFyci5sZW5ndGgpIGxlbiA9IGFyci5sZW5ndGg7XG4gICAgZm9yICh2YXIgaSA9IDAsIGFycjIgPSBuZXcgQXJyYXkobGVuKTsgaSA8IGxlbjsgaSsrKSBhcnIyW2ldID0gYXJyW2ldO1xuICAgIHJldHVybiBhcnIyO1xufVxuXG5mdW5jdGlvbiBfbm9uSXRlcmFibGVTcHJlYWQoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBzcHJlYWQgbm9uLWl0ZXJhYmxlIGluc3RhbmNlLlxcbkluIG9yZGVyIHRvIGJlIGl0ZXJhYmxlLCBub24tYXJyYXkgb2JqZWN0cyBtdXN0IGhhdmUgYSBbU3ltYm9sLml0ZXJhdG9yXSgpIG1ldGhvZC5cIik7XG59XG5cbmZ1bmN0aW9uIF9ub25JdGVyYWJsZVJlc3QoKSB7XG4gICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkludmFsaWQgYXR0ZW1wdCB0byBkZXN0cnVjdHVyZSBub24taXRlcmFibGUgaW5zdGFuY2UuXFxuSW4gb3JkZXIgdG8gYmUgaXRlcmFibGUsIG5vbi1hcnJheSBvYmplY3RzIG11c3QgaGF2ZSBhIFtTeW1ib2wuaXRlcmF0b3JdKCkgbWV0aG9kLlwiKTtcbn1cblxuZnVuY3Rpb24gX3RvUHJpbWl0aXZlKGlucHV0LCBoaW50KSB7XG4gICAgaWYgKHR5cGVvZiBpbnB1dCAhPT0gXCJvYmplY3RcIiB8fCBpbnB1dCA9PT0gbnVsbCkgcmV0dXJuIGlucHV0O1xuICAgIHZhciBwcmltID0gaW5wdXRbU3ltYm9sLnRvUHJpbWl0aXZlXTtcbiAgICBpZiAocHJpbSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciByZXMgPSBwcmltLmNhbGwoaW5wdXQsIGhpbnQgfHwgXCJkZWZhdWx0XCIpO1xuICAgICAgICBpZiAodHlwZW9mIHJlcyAhPT0gXCJvYmplY3RcIikgcmV0dXJuIHJlcztcbiAgICAgICAgdGhyb3cgbmV3IFR5cGVFcnJvcihcIkBAdG9QcmltaXRpdmUgbXVzdCByZXR1cm4gYSBwcmltaXRpdmUgdmFsdWUuXCIpO1xuICAgIH1cbiAgICByZXR1cm4gKGhpbnQgPT09IFwic3RyaW5nXCIgPyBTdHJpbmcgOiBOdW1iZXIpKGlucHV0KTtcbn1cblxuZnVuY3Rpb24gX3RvUHJvcGVydHlLZXkoYXJnKSB7XG4gICAgdmFyIGtleSA9IF90b1ByaW1pdGl2ZShhcmcsIFwic3RyaW5nXCIpO1xuICAgIHJldHVybiB0eXBlb2Yga2V5ID09PSBcInN5bWJvbFwiID8ga2V5IDogU3RyaW5nKGtleSk7XG59XG5cbmZ1bmN0aW9uIGNhbnZhc1Rlc3Qoc2V0dGluZ3MpIHtcbiAgICB2YXIgc2l6ZSA9IHNldHRpbmdzLnNpemVzLnNoaWZ0KCk7XG4gICAgdmFyIHdpZHRoID0gTWF0aC5tYXgoTWF0aC5jZWlsKHNpemVbMF0pLCAxKTtcbiAgICB2YXIgaGVpZ2h0ID0gTWF0aC5tYXgoTWF0aC5jZWlsKHNpemVbMV0pLCAxKTtcbiAgICB2YXIgZmlsbCA9IFsgd2lkdGggLSAxLCBoZWlnaHQgLSAxLCAxLCAxIF07XG4gICAgdmFyIGpvYiA9IERhdGUubm93KCk7XG4gICAgdmFyIGlzV29ya2VyID0gdHlwZW9mIFdvcmtlckdsb2JhbFNjb3BlICE9PSBcInVuZGVmaW5lZFwiICYmIHNlbGYgaW5zdGFuY2VvZiBXb3JrZXJHbG9iYWxTY29wZTtcbiAgICB2YXIgY3JvcEN2cywgdGVzdEN2cztcbiAgICBpZiAoaXNXb3JrZXIpIHtcbiAgICAgICAgY3JvcEN2cyA9IG5ldyBPZmZzY3JlZW5DYW52YXMoMSwgMSk7XG4gICAgICAgIHRlc3RDdnMgPSBuZXcgT2Zmc2NyZWVuQ2FudmFzKHdpZHRoLCBoZWlnaHQpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIGNyb3BDdnMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KFwiY2FudmFzXCIpO1xuICAgICAgICBjcm9wQ3ZzLndpZHRoID0gMTtcbiAgICAgICAgY3JvcEN2cy5oZWlnaHQgPSAxO1xuICAgICAgICB0ZXN0Q3ZzID0gZG9jdW1lbnQuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiKTtcbiAgICAgICAgdGVzdEN2cy53aWR0aCA9IHdpZHRoO1xuICAgICAgICB0ZXN0Q3ZzLmhlaWdodCA9IGhlaWdodDtcbiAgICB9XG4gICAgdmFyIGNyb3BDdHggPSBjcm9wQ3ZzLmdldENvbnRleHQoXCIyZFwiKTtcbiAgICB2YXIgdGVzdEN0eCA9IHRlc3RDdnMuZ2V0Q29udGV4dChcIjJkXCIpO1xuICAgIGlmICh0ZXN0Q3R4KSB7XG4gICAgICAgIHRlc3RDdHguZmlsbFJlY3QuYXBwbHkodGVzdEN0eCwgZmlsbCk7XG4gICAgICAgIGNyb3BDdHguZHJhd0ltYWdlKHRlc3RDdnMsIHdpZHRoIC0gMSwgaGVpZ2h0IC0gMSwgMSwgMSwgMCwgMCwgMSwgMSk7XG4gICAgfVxuICAgIHZhciBpc1Rlc3RQYXNzID0gY3JvcEN0eCAmJiBjcm9wQ3R4LmdldEltYWdlRGF0YSgwLCAwLCAxLCAxKS5kYXRhWzNdICE9PSAwO1xuICAgIHZhciBiZW5jaG1hcmsgPSBEYXRlLm5vdygpIC0gam9iO1xuICAgIFsgY3JvcEN2cywgdGVzdEN2cyBdLmZvckVhY2goKGZ1bmN0aW9uKGN2cykge1xuICAgICAgICBjdnMuaGVpZ2h0ID0gMDtcbiAgICAgICAgY3ZzLndpZHRoID0gMDtcbiAgICB9KSk7XG4gICAgaWYgKGlzV29ya2VyKSB7XG4gICAgICAgIHBvc3RNZXNzYWdlKHtcbiAgICAgICAgICAgIHdpZHRoOiB3aWR0aCxcbiAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgYmVuY2htYXJrOiBiZW5jaG1hcmssXG4gICAgICAgICAgICBpc1Rlc3RQYXNzOiBpc1Rlc3RQYXNzXG4gICAgICAgIH0pO1xuICAgICAgICBpZiAoIWlzVGVzdFBhc3MgJiYgc2V0dGluZ3Muc2l6ZXMubGVuZ3RoKSB7XG4gICAgICAgICAgICBjYW52YXNUZXN0KHNldHRpbmdzKTtcbiAgICAgICAgfVxuICAgIH0gZWxzZSBpZiAoaXNUZXN0UGFzcykge1xuICAgICAgICBzZXR0aW5ncy5vblN1Y2Nlc3Mod2lkdGgsIGhlaWdodCwgYmVuY2htYXJrKTtcbiAgICB9IGVsc2Uge1xuICAgICAgICBzZXR0aW5ncy5vbkVycm9yKHdpZHRoLCBoZWlnaHQsIGJlbmNobWFyayk7XG4gICAgICAgIGlmIChzZXR0aW5ncy5zaXplcy5sZW5ndGgpIHtcbiAgICAgICAgICAgIGNhbnZhc1Rlc3Qoc2V0dGluZ3MpO1xuICAgICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpc1Rlc3RQYXNzO1xufVxuXG52YXIgdGVzdFNpemVzID0ge1xuICAgIGFyZWE6IFsgMTYzODQsIDE0MTg4LCAxMTQwMiwgMTExODAsIDEwODM2LCA4MTkyLCA0MDk2LCAxIF0sXG4gICAgaGVpZ2h0OiBbIDgzODg2MDcsIDY1NTM1LCAzMjc2NywgMTYzODQsIDgxOTIsIDQwOTYsIDEgXSxcbiAgICB3aWR0aDogWyA0MTk0MzAzLCA2NTUzNSwgMzI3NjcsIDE2Mzg0LCA4MTkyLCA0MDk2LCAxIF1cbn07XG5cbnZhciBfZXhjbHVkZWQgPSBbIFwib25FcnJvclwiLCBcIm9uU3VjY2Vzc1wiIF07XG5cbnZhciBkZWZhdWx0cyA9IHtcbiAgICBtYXg6IG51bGwsXG4gICAgbWluOiAxLFxuICAgIHNpemVzOiBbXSxcbiAgICBzdGVwOiAxMDI0LFxuICAgIHVzZVByb21pc2U6IGZhbHNlLFxuICAgIHVzZVdvcmtlcjogZmFsc2UsXG4gICAgb25FcnJvcjogRnVuY3Rpb24ucHJvdG90eXBlLFxuICAgIG9uU3VjY2VzczogRnVuY3Rpb24ucHJvdG90eXBlXG59O1xuXG52YXIgd29ya2VySm9icyA9IHt9O1xuXG5mdW5jdGlvbiBjcmVhdGVTaXplc0FycmF5KHNldHRpbmdzKSB7XG4gICAgdmFyIGlzQXJlYSA9IHNldHRpbmdzLndpZHRoID09PSBzZXR0aW5ncy5oZWlnaHQ7XG4gICAgdmFyIGlzV2lkdGggPSBzZXR0aW5ncy5oZWlnaHQgPT09IDE7XG4gICAgdmFyIGlzSGVpZ2h0ID0gc2V0dGluZ3Mud2lkdGggPT09IDE7XG4gICAgdmFyIHNpemVzID0gW107XG4gICAgaWYgKCFzZXR0aW5ncy53aWR0aCB8fCAhc2V0dGluZ3MuaGVpZ2h0KSB7XG4gICAgICAgIHNldHRpbmdzLnNpemVzLmZvckVhY2goKGZ1bmN0aW9uKHRlc3RTaXplKSB7XG4gICAgICAgICAgICB2YXIgd2lkdGggPSBpc0FyZWEgfHwgaXNXaWR0aCA/IHRlc3RTaXplIDogMTtcbiAgICAgICAgICAgIHZhciBoZWlnaHQgPSBpc0FyZWEgfHwgaXNIZWlnaHQgPyB0ZXN0U2l6ZSA6IDE7XG4gICAgICAgICAgICBzaXplcy5wdXNoKFsgd2lkdGgsIGhlaWdodCBdKTtcbiAgICAgICAgfSkpO1xuICAgIH0gZWxzZSB7XG4gICAgICAgIHZhciB0ZXN0TWluID0gc2V0dGluZ3MubWluIHx8IGRlZmF1bHRzLm1pbjtcbiAgICAgICAgdmFyIHRlc3RTdGVwID0gc2V0dGluZ3Muc3RlcCB8fCBkZWZhdWx0cy5zdGVwO1xuICAgICAgICB2YXIgdGVzdFNpemUgPSBNYXRoLm1heChzZXR0aW5ncy53aWR0aCwgc2V0dGluZ3MuaGVpZ2h0KTtcbiAgICAgICAgd2hpbGUgKHRlc3RTaXplID49IHRlc3RNaW4pIHtcbiAgICAgICAgICAgIHZhciB3aWR0aCA9IGlzQXJlYSB8fCBpc1dpZHRoID8gdGVzdFNpemUgOiAxO1xuICAgICAgICAgICAgdmFyIGhlaWdodCA9IGlzQXJlYSB8fCBpc0hlaWdodCA/IHRlc3RTaXplIDogMTtcbiAgICAgICAgICAgIHNpemVzLnB1c2goWyB3aWR0aCwgaGVpZ2h0IF0pO1xuICAgICAgICAgICAgdGVzdFNpemUgLT0gdGVzdFN0ZXA7XG4gICAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIHNpemVzO1xufVxuXG5mdW5jdGlvbiBoYW5kbGVNZXRob2Qoc2V0dGluZ3MpIHtcbiAgICB2YXIgaGFzQ2FudmFzU3VwcG9ydCA9IHdpbmRvdyAmJiBcIkhUTUxDYW52YXNFbGVtZW50XCIgaW4gd2luZG93O1xuICAgIHZhciBoYXNPZmZzY3JlZW5DYW52YXNTdXBwb3J0ID0gd2luZG93ICYmIFwiT2Zmc2NyZWVuQ2FudmFzXCIgaW4gd2luZG93O1xuICAgIHZhciBqb2JJRCA9IERhdGUubm93KCk7XG4gICAgdmFyIF9vbkVycm9yID0gc2V0dGluZ3Mub25FcnJvciwgX29uU3VjY2VzcyA9IHNldHRpbmdzLm9uU3VjY2Vzcywgc2V0dGluZ3NXaXRob3V0Q2FsbGJhY2tzID0gX29iamVjdFdpdGhvdXRQcm9wZXJ0aWVzKHNldHRpbmdzLCBfZXhjbHVkZWQpO1xuICAgIHZhciB3b3JrZXIgPSBudWxsO1xuICAgIGlmICghaGFzQ2FudmFzU3VwcG9ydCkge1xuICAgICAgICByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIGlmIChzZXR0aW5ncy51c2VXb3JrZXIgJiYgaGFzT2Zmc2NyZWVuQ2FudmFzU3VwcG9ydCkge1xuICAgICAgICB2YXIganMgPSBcIlxcbiAgICAgICAgICAgIHZhciBjYW52YXNUZXN0ID0gXCIuY29uY2F0KGNhbnZhc1Rlc3QudG9TdHJpbmcoKSwgXCI7XFxuICAgICAgICAgICAgb25tZXNzYWdlID0gZnVuY3Rpb24oZSkge1xcbiAgICAgICAgICAgICAgICBjYW52YXNUZXN0KGUuZGF0YSk7XFxuICAgICAgICAgICAgfTtcXG4gICAgICAgIFwiKTtcbiAgICAgICAgdmFyIGJsb2IgPSBuZXcgQmxvYihbIGpzIF0sIHtcbiAgICAgICAgICAgIHR5cGU6IFwiYXBwbGljYXRpb24vamF2YXNjcmlwdFwiXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgYmxvYlVSTCA9IFVSTC5jcmVhdGVPYmplY3RVUkwoYmxvYik7XG4gICAgICAgIHdvcmtlciA9IG5ldyBXb3JrZXIoYmxvYlVSTCk7XG4gICAgICAgIFVSTC5yZXZva2VPYmplY3RVUkwoYmxvYlVSTCk7XG4gICAgICAgIHdvcmtlci5vbm1lc3NhZ2UgPSBmdW5jdGlvbihlKSB7XG4gICAgICAgICAgICB2YXIgX2UkZGF0YSA9IGUuZGF0YSwgd2lkdGggPSBfZSRkYXRhLndpZHRoLCBoZWlnaHQgPSBfZSRkYXRhLmhlaWdodCwgYmVuY2htYXJrID0gX2UkZGF0YS5iZW5jaG1hcmssIGlzVGVzdFBhc3MgPSBfZSRkYXRhLmlzVGVzdFBhc3M7XG4gICAgICAgICAgICBpZiAoaXNUZXN0UGFzcykge1xuICAgICAgICAgICAgICAgIHdvcmtlckpvYnNbam9iSURdLm9uU3VjY2Vzcyh3aWR0aCwgaGVpZ2h0LCBiZW5jaG1hcmspO1xuICAgICAgICAgICAgICAgIGRlbGV0ZSB3b3JrZXJKb2JzW2pvYklEXTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgd29ya2VySm9ic1tqb2JJRF0ub25FcnJvcih3aWR0aCwgaGVpZ2h0LCBiZW5jaG1hcmspO1xuICAgICAgICAgICAgfVxuICAgICAgICB9O1xuICAgIH1cbiAgICBpZiAoc2V0dGluZ3MudXNlUHJvbWlzZSkge1xuICAgICAgICByZXR1cm4gbmV3IFByb21pc2UoKGZ1bmN0aW9uKHJlc29sdmUsIHJlamVjdCkge1xuICAgICAgICAgICAgdmFyIHByb21pc2VTZXR0aW5ncyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBzZXR0aW5ncyksIHt9LCB7XG4gICAgICAgICAgICAgICAgb25FcnJvcjogZnVuY3Rpb24gb25FcnJvcih3aWR0aCwgaGVpZ2h0LCBiZW5jaG1hcmspIHtcbiAgICAgICAgICAgICAgICAgICAgdmFyIGlzTGFzdFRlc3Q7XG4gICAgICAgICAgICAgICAgICAgIGlmIChzZXR0aW5ncy5zaXplcy5sZW5ndGggPT09IDApIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIGlzTGFzdFRlc3QgPSB0cnVlO1xuICAgICAgICAgICAgICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgICAgICAgICAgICAgICAgdmFyIF9zZXR0aW5ncyRzaXplcyRzbGljZSA9IHNldHRpbmdzLnNpemVzLnNsaWNlKC0xKSwgX3NldHRpbmdzJHNpemVzJHNsaWNlMiA9IF9zbGljZWRUb0FycmF5KF9zZXR0aW5ncyRzaXplcyRzbGljZSwgMSksIF9zZXR0aW5ncyRzaXplcyRzbGljZTMgPSBfc2xpY2VkVG9BcnJheShfc2V0dGluZ3Mkc2l6ZXMkc2xpY2UyWzBdLCAyKSwgbGFzdFdpZHRoID0gX3NldHRpbmdzJHNpemVzJHNsaWNlM1swXSwgbGFzdEhlaWdodCA9IF9zZXR0aW5ncyRzaXplcyRzbGljZTNbMV07XG4gICAgICAgICAgICAgICAgICAgICAgICBpc0xhc3RUZXN0ID0gd2lkdGggPT09IGxhc3RXaWR0aCAmJiBoZWlnaHQgPT09IGxhc3RIZWlnaHQ7XG4gICAgICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgICAgICAgICAgX29uRXJyb3Iod2lkdGgsIGhlaWdodCwgYmVuY2htYXJrKTtcbiAgICAgICAgICAgICAgICAgICAgaWYgKGlzTGFzdFRlc3QpIHtcbiAgICAgICAgICAgICAgICAgICAgICAgIHJlamVjdCh7XG4gICAgICAgICAgICAgICAgICAgICAgICAgICAgd2lkdGg6IHdpZHRoLFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGhlaWdodDogaGVpZ2h0LFxuICAgICAgICAgICAgICAgICAgICAgICAgICAgIGJlbmNobWFyazogYmVuY2htYXJrXG4gICAgICAgICAgICAgICAgICAgICAgICB9KTtcbiAgICAgICAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgICAgIH0sXG4gICAgICAgICAgICAgICAgb25TdWNjZXNzOiBmdW5jdGlvbiBvblN1Y2Nlc3Mod2lkdGgsIGhlaWdodCwgYmVuY2htYXJrKSB7XG4gICAgICAgICAgICAgICAgICAgIF9vblN1Y2Nlc3Mod2lkdGgsIGhlaWdodCwgYmVuY2htYXJrKTtcbiAgICAgICAgICAgICAgICAgICAgcmVzb2x2ZSh7XG4gICAgICAgICAgICAgICAgICAgICAgICB3aWR0aDogd2lkdGgsXG4gICAgICAgICAgICAgICAgICAgICAgICBoZWlnaHQ6IGhlaWdodCxcbiAgICAgICAgICAgICAgICAgICAgICAgIGJlbmNobWFyazogYmVuY2htYXJrXG4gICAgICAgICAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgICAgaWYgKHdvcmtlcikge1xuICAgICAgICAgICAgICAgIHZhciBvbkVycm9yID0gcHJvbWlzZVNldHRpbmdzLm9uRXJyb3IsIG9uU3VjY2VzcyA9IHByb21pc2VTZXR0aW5ncy5vblN1Y2Nlc3M7XG4gICAgICAgICAgICAgICAgd29ya2VySm9ic1tqb2JJRF0gPSB7XG4gICAgICAgICAgICAgICAgICAgIG9uRXJyb3I6IG9uRXJyb3IsXG4gICAgICAgICAgICAgICAgICAgIG9uU3VjY2Vzczogb25TdWNjZXNzXG4gICAgICAgICAgICAgICAgfTtcbiAgICAgICAgICAgICAgICB3b3JrZXIucG9zdE1lc3NhZ2Uoc2V0dGluZ3NXaXRob3V0Q2FsbGJhY2tzKTtcbiAgICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAgICAgY2FudmFzVGVzdChwcm9taXNlU2V0dGluZ3MpO1xuICAgICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgfSBlbHNlIHtcbiAgICAgICAgaWYgKHdvcmtlcikge1xuICAgICAgICAgICAgd29ya2VySm9ic1tqb2JJRF0gPSB7XG4gICAgICAgICAgICAgICAgb25FcnJvcjogX29uRXJyb3IsXG4gICAgICAgICAgICAgICAgb25TdWNjZXNzOiBfb25TdWNjZXNzXG4gICAgICAgICAgICB9O1xuICAgICAgICAgICAgd29ya2VyLnBvc3RNZXNzYWdlKHNldHRpbmdzV2l0aG91dENhbGxiYWNrcyk7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICByZXR1cm4gY2FudmFzVGVzdChzZXR0aW5ncyk7XG4gICAgICAgIH1cbiAgICB9XG59XG5cbnZhciBjYW52YXNTaXplID0ge1xuICAgIG1heEFyZWE6IGZ1bmN0aW9uIG1heEFyZWEoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgICAgdmFyIHNpemVzID0gY3JlYXRlU2l6ZXNBcnJheSh7XG4gICAgICAgICAgICB3aWR0aDogb3B0aW9ucy5tYXgsXG4gICAgICAgICAgICBoZWlnaHQ6IG9wdGlvbnMubWF4LFxuICAgICAgICAgICAgbWluOiBvcHRpb25zLm1pbixcbiAgICAgICAgICAgIHN0ZXA6IG9wdGlvbnMuc3RlcCxcbiAgICAgICAgICAgIHNpemVzOiBfdG9Db25zdW1hYmxlQXJyYXkodGVzdFNpemVzLmFyZWEpXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgc2V0dGluZ3MgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZGVmYXVsdHMpLCBvcHRpb25zKSwge30sIHtcbiAgICAgICAgICAgIHNpemVzOiBzaXplc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZU1ldGhvZChzZXR0aW5ncyk7XG4gICAgfSxcbiAgICBtYXhIZWlnaHQ6IGZ1bmN0aW9uIG1heEhlaWdodCgpIHtcbiAgICAgICAgdmFyIG9wdGlvbnMgPSBhcmd1bWVudHMubGVuZ3RoID4gMCAmJiBhcmd1bWVudHNbMF0gIT09IHVuZGVmaW5lZCA/IGFyZ3VtZW50c1swXSA6IHt9O1xuICAgICAgICB2YXIgc2l6ZXMgPSBjcmVhdGVTaXplc0FycmF5KHtcbiAgICAgICAgICAgIHdpZHRoOiAxLFxuICAgICAgICAgICAgaGVpZ2h0OiBvcHRpb25zLm1heCxcbiAgICAgICAgICAgIG1pbjogb3B0aW9ucy5taW4sXG4gICAgICAgICAgICBzdGVwOiBvcHRpb25zLnN0ZXAsXG4gICAgICAgICAgICBzaXplczogX3RvQ29uc3VtYWJsZUFycmF5KHRlc3RTaXplcy5oZWlnaHQpXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgc2V0dGluZ3MgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZGVmYXVsdHMpLCBvcHRpb25zKSwge30sIHtcbiAgICAgICAgICAgIHNpemVzOiBzaXplc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZU1ldGhvZChzZXR0aW5ncyk7XG4gICAgfSxcbiAgICBtYXhXaWR0aDogZnVuY3Rpb24gbWF4V2lkdGgoKSB7XG4gICAgICAgIHZhciBvcHRpb25zID0gYXJndW1lbnRzLmxlbmd0aCA+IDAgJiYgYXJndW1lbnRzWzBdICE9PSB1bmRlZmluZWQgPyBhcmd1bWVudHNbMF0gOiB7fTtcbiAgICAgICAgdmFyIHNpemVzID0gY3JlYXRlU2l6ZXNBcnJheSh7XG4gICAgICAgICAgICB3aWR0aDogb3B0aW9ucy5tYXgsXG4gICAgICAgICAgICBoZWlnaHQ6IDEsXG4gICAgICAgICAgICBtaW46IG9wdGlvbnMubWluLFxuICAgICAgICAgICAgc3RlcDogb3B0aW9ucy5zdGVwLFxuICAgICAgICAgICAgc2l6ZXM6IF90b0NvbnN1bWFibGVBcnJheSh0ZXN0U2l6ZXMud2lkdGgpXG4gICAgICAgIH0pO1xuICAgICAgICB2YXIgc2V0dGluZ3MgPSBfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMihfb2JqZWN0U3ByZWFkMih7fSwgZGVmYXVsdHMpLCBvcHRpb25zKSwge30sIHtcbiAgICAgICAgICAgIHNpemVzOiBzaXplc1xuICAgICAgICB9KTtcbiAgICAgICAgcmV0dXJuIGhhbmRsZU1ldGhvZChzZXR0aW5ncyk7XG4gICAgfSxcbiAgICB0ZXN0OiBmdW5jdGlvbiB0ZXN0KCkge1xuICAgICAgICB2YXIgb3B0aW9ucyA9IGFyZ3VtZW50cy5sZW5ndGggPiAwICYmIGFyZ3VtZW50c1swXSAhPT0gdW5kZWZpbmVkID8gYXJndW1lbnRzWzBdIDoge307XG4gICAgICAgIHZhciBzZXR0aW5ncyA9IF9vYmplY3RTcHJlYWQyKF9vYmplY3RTcHJlYWQyKHt9LCBkZWZhdWx0cyksIG9wdGlvbnMpO1xuICAgICAgICBzZXR0aW5ncy5zaXplcyA9IF90b0NvbnN1bWFibGVBcnJheShzZXR0aW5ncy5zaXplcyk7XG4gICAgICAgIGlmIChzZXR0aW5ncy53aWR0aCAmJiBzZXR0aW5ncy5oZWlnaHQpIHtcbiAgICAgICAgICAgIHNldHRpbmdzLnNpemVzID0gWyBbIHNldHRpbmdzLndpZHRoLCBzZXR0aW5ncy5oZWlnaHQgXSBdO1xuICAgICAgICB9XG4gICAgICAgIHJldHVybiBoYW5kbGVNZXRob2Qoc2V0dGluZ3MpO1xuICAgIH1cbn07XG5cbmV4cG9ydCB7IGNhbnZhc1NpemUgYXMgZGVmYXVsdCB9O1xuLy8jIHNvdXJjZU1hcHBpbmdVUkw9Y2FudmFzLXNpemUuZXNtLmpzLm1hcFxuIl0sIm5hbWVzIjpbIl9pdGVyYWJsZVRvQXJyYXlMaW1pdCIsImFyciIsImkiLCJfaSIsIlN5bWJvbCIsIml0ZXJhdG9yIiwiX3MiLCJfZSIsIl94IiwiX3IiLCJfYXJyIiwiX24iLCJfZCIsImNhbGwiLCJuZXh0IiwiT2JqZWN0IiwiZG9uZSIsInB1c2giLCJ2YWx1ZSIsImxlbmd0aCIsImVyciIsInJldHVybiIsIm93bktleXMiLCJvYmplY3QiLCJlbnVtZXJhYmxlT25seSIsImtleXMiLCJnZXRPd25Qcm9wZXJ0eVN5bWJvbHMiLCJzeW1ib2xzIiwiZmlsdGVyIiwic3ltIiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9yIiwiZW51bWVyYWJsZSIsImFwcGx5IiwiX29iamVjdFNwcmVhZDIiLCJ0YXJnZXQiLCJhcmd1bWVudHMiLCJzb3VyY2UiLCJmb3JFYWNoIiwia2V5IiwiX2RlZmluZVByb3BlcnR5IiwiZ2V0T3duUHJvcGVydHlEZXNjcmlwdG9ycyIsImRlZmluZVByb3BlcnRpZXMiLCJkZWZpbmVQcm9wZXJ0eSIsIm9iaiIsIl90b1Byb3BlcnR5S2V5IiwiY29uZmlndXJhYmxlIiwid3JpdGFibGUiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXNMb29zZSIsImV4Y2x1ZGVkIiwic291cmNlS2V5cyIsImluZGV4T2YiLCJfb2JqZWN0V2l0aG91dFByb3BlcnRpZXMiLCJzb3VyY2VTeW1ib2xLZXlzIiwicHJvdG90eXBlIiwicHJvcGVydHlJc0VudW1lcmFibGUiLCJfc2xpY2VkVG9BcnJheSIsIl9hcnJheVdpdGhIb2xlcyIsIl91bnN1cHBvcnRlZEl0ZXJhYmxlVG9BcnJheSIsIl9ub25JdGVyYWJsZVJlc3QiLCJfdG9Db25zdW1hYmxlQXJyYXkiLCJfYXJyYXlXaXRob3V0SG9sZXMiLCJfaXRlcmFibGVUb0FycmF5IiwiX25vbkl0ZXJhYmxlU3ByZWFkIiwiQXJyYXkiLCJpc0FycmF5IiwiX2FycmF5TGlrZVRvQXJyYXkiLCJpdGVyIiwiZnJvbSIsIm8iLCJtaW5MZW4iLCJuIiwidG9TdHJpbmciLCJzbGljZSIsImNvbnN0cnVjdG9yIiwibmFtZSIsInRlc3QiLCJsZW4iLCJhcnIyIiwiVHlwZUVycm9yIiwiX3RvUHJpbWl0aXZlIiwiaW5wdXQiLCJoaW50IiwicHJpbSIsInRvUHJpbWl0aXZlIiwidW5kZWZpbmVkIiwicmVzIiwiU3RyaW5nIiwiTnVtYmVyIiwiYXJnIiwiY2FudmFzVGVzdCIsInNldHRpbmdzIiwic2l6ZSIsInNpemVzIiwic2hpZnQiLCJ3aWR0aCIsIk1hdGgiLCJtYXgiLCJjZWlsIiwiaGVpZ2h0IiwiZmlsbCIsImpvYiIsIkRhdGUiLCJub3ciLCJpc1dvcmtlciIsIldvcmtlckdsb2JhbFNjb3BlIiwic2VsZiIsImNyb3BDdnMiLCJ0ZXN0Q3ZzIiwiT2Zmc2NyZWVuQ2FudmFzIiwiZG9jdW1lbnQiLCJjcmVhdGVFbGVtZW50IiwiY3JvcEN0eCIsImdldENvbnRleHQiLCJ0ZXN0Q3R4IiwiZmlsbFJlY3QiLCJkcmF3SW1hZ2UiLCJpc1Rlc3RQYXNzIiwiZ2V0SW1hZ2VEYXRhIiwiZGF0YSIsImJlbmNobWFyayIsImN2cyIsInBvc3RNZXNzYWdlIiwib25TdWNjZXNzIiwib25FcnJvciIsInRlc3RTaXplcyIsImFyZWEiLCJfZXhjbHVkZWQiLCJkZWZhdWx0cyIsIm1pbiIsInN0ZXAiLCJ1c2VQcm9taXNlIiwidXNlV29ya2VyIiwiRnVuY3Rpb24iLCJ3b3JrZXJKb2JzIiwiY3JlYXRlU2l6ZXNBcnJheSIsImlzQXJlYSIsImlzV2lkdGgiLCJpc0hlaWdodCIsInRlc3RTaXplIiwidGVzdE1pbiIsInRlc3RTdGVwIiwiaGFuZGxlTWV0aG9kIiwiaGFzQ2FudmFzU3VwcG9ydCIsIndpbmRvdyIsImhhc09mZnNjcmVlbkNhbnZhc1N1cHBvcnQiLCJqb2JJRCIsIl9vbkVycm9yIiwiX29uU3VjY2VzcyIsInNldHRpbmdzV2l0aG91dENhbGxiYWNrcyIsIndvcmtlciIsImpzIiwiY29uY2F0IiwiYmxvYiIsIkJsb2IiLCJ0eXBlIiwiYmxvYlVSTCIsIlVSTCIsImNyZWF0ZU9iamVjdFVSTCIsIldvcmtlciIsInJldm9rZU9iamVjdFVSTCIsIm9ubWVzc2FnZSIsImUiLCJfZSRkYXRhIiwiUHJvbWlzZSIsInJlc29sdmUiLCJyZWplY3QiLCJwcm9taXNlU2V0dGluZ3MiLCJpc0xhc3RUZXN0IiwiX3NldHRpbmdzJHNpemVzJHNsaWNlIiwiX3NldHRpbmdzJHNpemVzJHNsaWNlMiIsIl9zZXR0aW5ncyRzaXplcyRzbGljZTMiLCJsYXN0V2lkdGgiLCJsYXN0SGVpZ2h0IiwiY2FudmFzU2l6ZSIsIm1heEFyZWEiLCJvcHRpb25zIiwibWF4SGVpZ2h0IiwibWF4V2lkdGgiLCJkZWZhdWx0Il0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/canvas-size/dist/canvas-size.esm.js\n");

/***/ })

};
;