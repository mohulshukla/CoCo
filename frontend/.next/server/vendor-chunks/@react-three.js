"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
exports.id = "vendor-chunks/@react-three";
exports.ids = ["vendor-chunks/@react-three"];
exports.modules = {

/***/ "(ssr)/./node_modules/@react-three/drei/core/GizmoHelper.js":
/*!************************************************************!*\
  !*** ./node_modules/@react-three/drei/core/GizmoHelper.js ***!
  \************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GizmoHelper: () => (/* binding */ GizmoHelper),\n/* harmony export */   useGizmoContext: () => (/* binding */ useGizmoContext)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/index-673ef987.esm.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var _OrthographicCamera_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./OrthographicCamera.js */ \"(ssr)/./node_modules/@react-three/drei/core/OrthographicCamera.js\");\n/* harmony import */ var _Hud_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./Hud.js */ \"(ssr)/./node_modules/@react-three/drei/core/Hud.js\");\n\n\n\n\n\nconst Context = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext({});\nconst useGizmoContext = ()=>{\n    return react__WEBPACK_IMPORTED_MODULE_0__.useContext(Context);\n};\nconst turnRate = 2 * Math.PI; // turn rate in angles per second\nconst dummy = new three__WEBPACK_IMPORTED_MODULE_1__.Object3D();\nconst matrix = new three__WEBPACK_IMPORTED_MODULE_1__.Matrix4();\nconst [q1, q2] = [\n    new three__WEBPACK_IMPORTED_MODULE_1__.Quaternion(),\n    new three__WEBPACK_IMPORTED_MODULE_1__.Quaternion()\n];\nconst target = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();\nconst targetPosition = new three__WEBPACK_IMPORTED_MODULE_1__.Vector3();\nconst isOrbitControls = (controls)=>{\n    return \"minPolarAngle\" in controls;\n};\nconst GizmoHelper = ({ alignment = \"bottom-right\", margin = [\n    80,\n    80\n], renderPriority = 1, onUpdate, onTarget, children })=>{\n    const size = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.z)((state)=>state.size);\n    const mainCamera = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.z)((state)=>state.camera); // @ts-ignore\n    const defaultControls = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.z)((state)=>state.controls);\n    const invalidate = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.z)((state)=>state.invalidate);\n    const gizmoRef = react__WEBPACK_IMPORTED_MODULE_0__.useRef();\n    const virtualCam = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    const animating = react__WEBPACK_IMPORTED_MODULE_0__.useRef(false);\n    const radius = react__WEBPACK_IMPORTED_MODULE_0__.useRef(0);\n    const focusPoint = react__WEBPACK_IMPORTED_MODULE_0__.useRef(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, 0));\n    const defaultUp = react__WEBPACK_IMPORTED_MODULE_0__.useRef(new three__WEBPACK_IMPORTED_MODULE_1__.Vector3(0, 0, 0));\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        defaultUp.current.copy(mainCamera.up);\n    }, [\n        mainCamera\n    ]);\n    const tweenCamera = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((direction)=>{\n        animating.current = true;\n        if (defaultControls || onTarget) focusPoint.current = (defaultControls == null ? void 0 : defaultControls.target) || (onTarget == null ? void 0 : onTarget());\n        radius.current = mainCamera.position.distanceTo(target); // Rotate from current camera orientation\n        q1.copy(mainCamera.quaternion); // To new current camera orientation\n        targetPosition.copy(direction).multiplyScalar(radius.current).add(target);\n        dummy.lookAt(targetPosition);\n        dummy.up.copy(mainCamera.up);\n        q2.copy(dummy.quaternion);\n        invalidate();\n    }, [\n        defaultControls,\n        mainCamera,\n        onTarget,\n        invalidate\n    ]);\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.A)((_, delta)=>{\n        if (virtualCam.current && gizmoRef.current) {\n            var _gizmoRef$current;\n            // Animate step\n            if (animating.current) {\n                if (q1.angleTo(q2) < 0.01) {\n                    animating.current = false; // Orbit controls uses UP vector as the orbit axes,\n                    // so we need to reset it after the animation is done\n                    // moving it around for the controls to work correctly\n                    if (isOrbitControls(defaultControls)) {\n                        mainCamera.up.copy(defaultUp.current);\n                    }\n                } else {\n                    const step = delta * turnRate; // animate position by doing a slerp and then scaling the position on the unit sphere\n                    q1.rotateTowards(q2, step); // animate orientation\n                    mainCamera.position.set(0, 0, 1).applyQuaternion(q1).multiplyScalar(radius.current).add(focusPoint.current);\n                    mainCamera.up.set(0, 1, 0).applyQuaternion(q1).normalize();\n                    mainCamera.quaternion.copy(q1);\n                    if (onUpdate) onUpdate();\n                    else if (defaultControls) defaultControls.update();\n                    invalidate();\n                }\n            } // Sync Gizmo with main camera orientation\n            matrix.copy(mainCamera.matrix).invert();\n            (_gizmoRef$current = gizmoRef.current) == null ? void 0 : _gizmoRef$current.quaternion.setFromRotationMatrix(matrix);\n        }\n    });\n    const gizmoHelperContext = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>({\n            tweenCamera\n        }), [\n        tweenCamera\n    ]); // Position gizmo component within scene\n    const [marginX, marginY] = margin;\n    const x = alignment.endsWith(\"-center\") ? 0 : alignment.endsWith(\"-left\") ? -size.width / 2 + marginX : size.width / 2 - marginX;\n    const y = alignment.startsWith(\"center-\") ? 0 : alignment.startsWith(\"top-\") ? size.height / 2 - marginY : -size.height / 2 + marginY;\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_Hud_js__WEBPACK_IMPORTED_MODULE_3__.Hud, {\n        renderPriority: renderPriority\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Context.Provider, {\n        value: gizmoHelperContext\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(_OrthographicCamera_js__WEBPACK_IMPORTED_MODULE_4__.OrthographicCamera, {\n        makeDefault: true,\n        ref: virtualCam,\n        position: [\n            0,\n            0,\n            200\n        ]\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"group\", {\n        ref: gizmoRef,\n        position: [\n            x,\n            y,\n            0\n        ]\n    }, children)));\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9HaXptb0hlbHBlci5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUErQjtBQUN5QjtBQUNPO0FBQ0Y7QUFDOUI7QUFFL0IsTUFBTVMsVUFBVSxXQUFXLEdBQUVULGdEQUFtQixDQUFDLENBQUM7QUFDbEQsTUFBTVcsa0JBQWtCO0lBQ3RCLE9BQU9YLDZDQUFnQixDQUFDUztBQUMxQjtBQUNBLE1BQU1JLFdBQVcsSUFBSUMsS0FBS0MsRUFBRSxFQUFFLGlDQUFpQztBQUUvRCxNQUFNQyxRQUFRLElBQUliLDJDQUFRQTtBQUMxQixNQUFNYyxTQUFTLElBQUliLDBDQUFPQTtBQUMxQixNQUFNLENBQUNjLElBQUlDLEdBQUcsR0FBRztJQUFDLElBQUlkLDZDQUFVQTtJQUFJLElBQUlBLDZDQUFVQTtDQUFHO0FBQ3JELE1BQU1lLFNBQVMsSUFBSWQsMENBQU9BO0FBQzFCLE1BQU1lLGlCQUFpQixJQUFJZiwwQ0FBT0E7QUFFbEMsTUFBTWdCLGtCQUFrQkMsQ0FBQUE7SUFDdEIsT0FBTyxtQkFBbUJBO0FBQzVCO0FBRUEsTUFBTUMsY0FBYyxDQUFDLEVBQ25CQyxZQUFZLGNBQWMsRUFDMUJDLFNBQVM7SUFBQztJQUFJO0NBQUcsRUFDakJDLGlCQUFpQixDQUFDLEVBQ2xCQyxRQUFRLEVBQ1JDLFFBQVEsRUFDUkMsUUFBUSxFQUNUO0lBQ0MsTUFBTUMsT0FBTzlCLHFEQUFRQSxDQUFDK0IsQ0FBQUEsUUFBU0EsTUFBTUQsSUFBSTtJQUN6QyxNQUFNRSxhQUFhaEMscURBQVFBLENBQUMrQixDQUFBQSxRQUFTQSxNQUFNRSxNQUFNLEdBQUcsYUFBYTtJQUVqRSxNQUFNQyxrQkFBa0JsQyxxREFBUUEsQ0FBQytCLENBQUFBLFFBQVNBLE1BQU1ULFFBQVE7SUFDeEQsTUFBTWEsYUFBYW5DLHFEQUFRQSxDQUFDK0IsQ0FBQUEsUUFBU0EsTUFBTUksVUFBVTtJQUNyRCxNQUFNQyxXQUFXckMseUNB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QU0sQ0FBQ3VCLFNBQVNDLFFBQVEsR0FBRzlDO0lBQzNCLE1BQU0rQyxJQUFJaEQsVUFBVWlELFFBQVEsQ0FBQyxhQUFhLElBQUlqRCxVQUFVaUQsUUFBUSxDQUFDLFdBQVcsQ0FBQzNDLEtBQUs0QyxLQUFLLEdBQUcsSUFBSUosVUFBVXhDLEtBQUs0QyxLQUFLLEdBQUcsSUFBSUo7SUFDekgsTUFBTUssSUFBSW5ELFVBQVVvRCxVQUFVLENBQUMsYUFBYSxJQUFJcEQsVUFBVW9ELFVBQVUsQ0FBQyxVQUFVOUMsS0FBSytDLE1BQU0sR0FBRyxJQUFJTixVQUFVLENBQUN6QyxLQUFLK0MsTUFBTSxHQUFHLElBQUlOO0lBQzlILE9BQU8sV0FBVyxHQUFFeEUsZ0RBQW1CLENBQUNRLHdDQUFHQSxFQUFFO1FBQzNDbUIsZ0JBQWdCQTtJQUNsQixHQUFHLFdBQVcsR0FBRTNCLGdEQUFtQixDQUFDUyxRQUFRdUUsUUFBUSxFQUFFO1FBQ3BEQyxPQUFPWjtJQUNULEdBQUcsV0FBVyxHQUFFckUsZ0RBQW1CLENBQUNPLHNFQUFrQkEsRUFBRTtRQUN0RDJFLGFBQWE7UUFDYkMsS0FBSzVDO1FBQ0xZLFVBQVU7WUFBQztZQUFHO1lBQUc7U0FBSTtJQUN2QixJQUFJLFdBQVcsR0FBRW5ELGdEQUFtQixDQUFDLFNBQVM7UUFDNUNtRixLQUFLOUM7UUFDTGMsVUFBVTtZQUFDc0I7WUFBR0c7WUFBRztTQUFFO0lBQ3JCLEdBQUc5QztBQUNMO0FBRXdDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmliZS0zZC1jb2RlLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL2NvcmUvR2l6bW9IZWxwZXIuanM/MDBmMSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VUaHJlZSwgdXNlRnJhbWUgfSBmcm9tICdAcmVhY3QtdGhyZWUvZmliZXInO1xuaW1wb3J0IHsgT2JqZWN0M0QsIE1hdHJpeDQsIFF1YXRlcm5pb24sIFZlY3RvcjMgfSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBPcnRob2dyYXBoaWNDYW1lcmEgfSBmcm9tICcuL09ydGhvZ3JhcGhpY0NhbWVyYS5qcyc7XG5pbXBvcnQgeyBIdWQgfSBmcm9tICcuL0h1ZC5qcyc7XG5cbmNvbnN0IENvbnRleHQgPSAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlQ29udGV4dCh7fSk7XG5jb25zdCB1c2VHaXptb0NvbnRleHQgPSAoKSA9PiB7XG4gIHJldHVybiBSZWFjdC51c2VDb250ZXh0KENvbnRleHQpO1xufTtcbmNvbnN0IHR1cm5SYXRlID0gMiAqIE1hdGguUEk7IC8vIHR1cm4gcmF0ZSBpbiBhbmdsZXMgcGVyIHNlY29uZFxuXG5jb25zdCBkdW1teSA9IG5ldyBPYmplY3QzRCgpO1xuY29uc3QgbWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcbmNvbnN0IFtxMSwgcTJdID0gW25ldyBRdWF0ZXJuaW9uKCksIG5ldyBRdWF0ZXJuaW9uKCldO1xuY29uc3QgdGFyZ2V0ID0gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IHRhcmdldFBvc2l0aW9uID0gbmV3IFZlY3RvcjMoKTtcblxuY29uc3QgaXNPcmJpdENvbnRyb2xzID0gY29udHJvbHMgPT4ge1xuICByZXR1cm4gJ21pblBvbGFyQW5nbGUnIGluIGNvbnRyb2xzO1xufTtcblxuY29uc3QgR2l6bW9IZWxwZXIgPSAoe1xuICBhbGlnbm1lbnQgPSAnYm90dG9tLXJpZ2h0JyxcbiAgbWFyZ2luID0gWzgwLCA4MF0sXG4gIHJlbmRlclByaW9yaXR5ID0gMSxcbiAgb25VcGRhdGUsXG4gIG9uVGFyZ2V0LFxuICBjaGlsZHJlblxufSkgPT4ge1xuICBjb25zdCBzaXplID0gdXNlVGhyZWUoc3RhdGUgPT4gc3RhdGUuc2l6ZSk7XG4gIGNvbnN0IG1haW5DYW1lcmEgPSB1c2VUaHJlZShzdGF0ZSA9PiBzdGF0ZS5jYW1lcmEpOyAvLyBAdHMtaWdub3JlXG5cbiAgY29uc3QgZGVmYXVsdENvbnRyb2xzID0gdXNlVGhyZWUoc3RhdGUgPT4gc3RhdGUuY29udHJvbHMpO1xuICBjb25zdCBpbnZhbGlkYXRlID0gdXNlVGhyZWUoc3RhdGUgPT4gc3RhdGUuaW52YWxpZGF0ZSk7XG4gIGNvbnN0IGdpem1vUmVmID0gUmVhY3QudXNlUmVmKCk7XG4gIGNvbnN0IHZpcnR1YWxDYW0gPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGFuaW1hdGluZyA9IFJlYWN0LnVzZVJlZihmYWxzZSk7XG4gIGNvbnN0IHJhZGl1cyA9IFJlYWN0LnVzZVJlZigwKTtcbiAgY29uc3QgZm9jdXNQb2ludCA9IFJlYWN0LnVzZVJlZihuZXcgVmVjdG9yMygwLCAwLCAwKSk7XG4gIGNvbnN0IGRlZmF1bHRVcCA9IFJlYWN0LnVzZVJlZihuZXcgVmVjdG9yMygwLCAwLCAwKSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgZGVmYXVsdFVwLmN1cnJlbnQuY29weShtYWluQ2FtZXJhLnVwKTtcbiAgfSwgW21haW5DYW1lcmFdKTtcbiAgY29uc3QgdHdlZW5DYW1lcmEgPSBSZWFjdC51c2VDYWxsYmFjayhkaXJlY3Rpb24gPT4ge1xuICAgIGFuaW1hdGluZy5jdXJyZW50ID0gdHJ1ZTtcbiAgICBpZiAoZGVmYXVsdENvbnRyb2xzIHx8IG9uVGFyZ2V0KSBmb2N1c1BvaW50LmN1cnJlbnQgPSAoZGVmYXVsdENvbnRyb2xzID09IG51bGwgPyB2b2lkIDAgOiBkZWZhdWx0Q29udHJvbHMudGFyZ2V0KSB8fCAob25UYXJnZXQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uVGFyZ2V0KCkpO1xuICAgIHJhZGl1cy5jdXJyZW50ID0gbWFpbkNhbWVyYS5wb3NpdGlvbi5kaXN0YW5jZVRvKHRhcmdldCk7IC8vIFJvdGF0ZSBmcm9tIGN1cnJlbnQgY2FtZXJhIG9yaWVudGF0aW9uXG5cbiAgICBxMS5jb3B5KG1haW5DYW1lcmEucXVhdGVybmlvbik7IC8vIFRvIG5ldyBjdXJyZW50IGNhbWVyYSBvcmllbnRhdGlvblxuXG4gICAgdGFyZ2V0UG9zaXRpb24uY29weShkaXJlY3Rpb24pLm11bHRpcGx5U2NhbGFyKHJhZGl1cy5jdXJyZW50KS5hZGQodGFyZ2V0KTtcbiAgICBkdW1teS5sb29rQXQodGFyZ2V0UG9zaXRpb24pO1xuICAgIGR1bW15LnVwLmNvcHkobWFpbkNhbWVyYS51cCk7XG4gICAgcTIuY29weShkdW1teS5xdWF0ZXJuaW9uKTtcbiAgICBpbnZhbGlkYXRlKCk7XG4gIH0sIFtkZWZhdWx0Q29udHJvbHMsIG1haW5DYW1lcmEsIG9uVGFyZ2V0LCBpbnZhbGlkYXRlXSk7XG4gIHVzZUZyYW1lKChfLCBkZWx0YSkgPT4ge1xuICAgIGlmICh2aXJ0dWFsQ2FtLmN1cnJlbnQgJiYgZ2l6bW9SZWYuY3VycmVudCkge1xuICAgICAgdmFyIF9naXptb1JlZiRjdXJyZW50O1xuXG4gICAgICAvLyBBbmltYXRlIHN0ZXBcbiAgICAgIGlmIChhbmltYXRpbmcuY3VycmVudCkge1xuICAgICAgICBpZiAocTEuYW5nbGVUbyhxMikgPCAwLjAxKSB7XG4gICAgICAgICAgYW5pbWF0aW5nLmN1cnJlbnQgPSBmYWxzZTsgLy8gT3JiaXQgY29udHJvbHMgdXNlcyBVUCB2ZWN0b3IgYXMgdGhlIG9yYml0IGF4ZXMsXG4gICAgICAgICAgLy8gc28gd2UgbmVlZCB0byByZXNldCBpdCBhZnRlciB0aGUgYW5pbWF0aW9uIGlzIGRvbmVcbiAgICAgICAgICAvLyBtb3ZpbmcgaXQgYXJvdW5kIGZvciB0aGUgY29udHJvbHMgdG8gd29yayBjb3JyZWN0bHlcblxuICAgICAgICAgIGlmIChpc09yYml0Q29udHJvbHMoZGVmYXVsdENvbnRyb2xzKSkge1xuICAgICAgICAgICAgbWFpbkNhbWVyYS51cC5jb3B5KGRlZmF1bHRVcC5jdXJyZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgY29uc3Qgc3RlcCA9IGRlbHRhICogdHVyblJhdGU7IC8vIGFuaW1hdGUgcG9zaXRpb24gYnkgZG9pbmcgYSBzbGVycCBhbmQgdGhlbiBzY2FsaW5nIHRoZSBwb3NpdGlvbiBvbiB0aGUgdW5pdCBzcGhlcmVcblxuICAgICAgICAgIHExLnJvdGF0ZVRvd2FyZHMocTIsIHN0ZXApOyAvLyBhbmltYXRlIG9yaWVudGF0aW9uXG5cbiAgICAgICAgICBtYWluQ2FtZXJhLnBvc2l0aW9uLnNldCgwLCAwLCAxKS5hcHBseVF1YXRlcm5pb24ocTEpLm11bHRpcGx5U2NhbGFyKHJhZGl1cy5jdXJyZW50KS5hZGQoZm9jdXNQb2ludC5jdXJyZW50KTtcbiAgICAgICAgICBtYWluQ2FtZXJhLnVwLnNldCgwLCAxLCAwKS5hcHBseVF1YXRlcm5pb24ocTEpLm5vcm1hbGl6ZSgpO1xuICAgICAgICAgIG1haW5DYW1lcmEucXVhdGVybmlvbi5jb3B5KHExKTtcbiAgICAgICAgICBpZiAob25VcGRhdGUpIG9uVXBkYXRlKCk7ZWxzZSBpZiAoZGVmYXVsdENvbnRyb2xzKSBkZWZhdWx0Q29udHJvbHMudXBkYXRlKCk7XG4gICAgICAgICAgaW52YWxpZGF0ZSgpO1xuICAgICAgICB9XG4gICAgICB9IC8vIFN5bmMgR2l6bW8gd2l0aCBtYWluIGNhbWVyYSBvcmllbnRhdGlvblxuXG5cbiAgICAgIG1hdHJpeC5jb3B5KG1haW5DYW1lcmEubWF0cml4KS5pbnZlcnQoKTtcbiAgICAgIChfZ2l6bW9SZWYkY3VycmVudCA9IGdpem1vUmVmLmN1cnJlbnQpID09IG51bGwgPyB2b2lkIDAgOiBfZ2l6bW9SZWYkY3VycmVudC5xdWF0ZXJuaW9uLnNldEZyb21Sb3RhdGlvbk1hdHJpeChtYXRyaXgpO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IGdpem1vSGVscGVyQ29udGV4dCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4gKHtcbiAgICB0d2VlbkNhbWVyYVxuICB9KSwgW3R3ZWVuQ2FtZXJhXSk7IC8vIFBvc2l0aW9uIGdpem1vIGNvbXBvbmVudCB3aXRoaW4gc2NlbmVcblxuICBjb25zdCBbbWFyZ2luWCwgbWFyZ2luWV0gPSBtYXJnaW47XG4gIGNvbnN0IHggPSBhbGlnbm1lbnQuZW5kc1dpdGgoJy1jZW50ZXInKSA/IDAgOiBhbGlnbm1lbnQuZW5kc1dpdGgoJy1sZWZ0JykgPyAtc2l6ZS53aWR0aCAvIDIgKyBtYXJnaW5YIDogc2l6ZS53aWR0aCAvIDIgLSBtYXJnaW5YO1xuICBjb25zdCB5ID0gYWxpZ25tZW50LnN0YXJ0c1dpdGgoJ2NlbnRlci0nKSA/IDAgOiBhbGlnbm1lbnQuc3RhcnRzV2l0aCgndG9wLScpID8gc2l6ZS5oZWlnaHQgLyAyIC0gbWFyZ2luWSA6IC1zaXplLmhlaWdodCAvIDIgKyBtYXJnaW5ZO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoSHVkLCB7XG4gICAgcmVuZGVyUHJpb3JpdHk6IHJlbmRlclByaW9yaXR5XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogZ2l6bW9IZWxwZXJDb250ZXh0XG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KE9ydGhvZ3JhcGhpY0NhbWVyYSwge1xuICAgIG1ha2VEZWZhdWx0OiB0cnVlLFxuICAgIHJlZjogdmlydHVhbENhbSxcbiAgICBwb3NpdGlvbjogWzAsIDAsIDIwMF1cbiAgfSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIiwge1xuICAgIHJlZjogZ2l6bW9SZWYsXG4gICAgcG9zaXRpb246IFt4LCB5LCAwXVxuICB9LCBjaGlsZHJlbikpKTtcbn07XG5cbmV4cG9ydCB7IEdpem1vSGVscGVyLCB1c2VHaXptb0NvbnRleHQgfTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsInVzZVRocmVlIiwidXNlRnJhbWUiLCJPYmplY3QzRCIsIk1hdHJpeDQiLCJRdWF0ZXJuaW9uIiwiVmVjdG9yMyIsIk9ydGhvZ3JhcGhpY0NhbWVyYSIsIkh1ZCIsIkNvbnRleHQiLCJjcmVhdGVDb250ZXh0IiwidXNlR2l6bW9Db250ZXh0IiwidXNlQ29udGV4dCIsInR1cm5SYXRlIiwiTWF0aCIsIlBJIiwiZHVtbXkiLCJtYXRyaXgiLCJxMSIsInEyIiwidGFyZ2V0IiwidGFyZ2V0UG9zaXRpb24iLCJpc09yYml0Q29udHJvbHMiLCJjb250cm9scyIsIkdpem1vSGVscGVyIiwiYWxpZ25tZW50IiwibWFyZ2luIiwicmVuZGVyUHJpb3JpdHkiLCJvblVwZGF0ZSIsIm9uVGFyZ2V0IiwiY2hpbGRyZW4iLCJzaXplIiwic3RhdGUiLCJtYWluQ2FtZXJhIiwiY2FtZXJhIiwiZGVmYXVsdENvbnRyb2xzIiwiaW52YWxpZGF0ZSIsImdpem1vUmVmIiwidXNlUmVmIiwidmlydHVhbENhbSIsImFuaW1hdGluZyIsInJhZGl1cyIsImZvY3VzUG9pbnQiLCJkZWZhdWx0VXAiLCJ1c2VFZmZlY3QiLCJjdXJyZW50IiwiY29weSIsInVwIiwidHdlZW5DYW1lcmEiLCJ1c2VDYWxsYmFjayIsImRpcmVjdGlvbiIsInBvc2l0aW9uIiwiZGlzdGFuY2VUbyIsInF1YXRlcm5pb24iLCJtdWx0aXBseVNjYWxhciIsImFkZCIsImxvb2tBdCIsIl8iLCJkZWx0YSIsIl9naXptb1JlZiRjdXJyZW50IiwiYW5nbGVUbyIsInN0ZXAiLCJyb3RhdGVUb3dhcmRzIiwic2V0IiwiYXBwbHlRdWF0ZXJuaW9uIiwibm9ybWFsaXplIiwidXBkYXRlIiwiaW52ZXJ0Iiwic2V0RnJvbVJvdGF0aW9uTWF0cml4IiwiZ2l6bW9IZWxwZXJDb250ZXh0IiwidXNlTWVtbyIsIm1hcmdpblgiLCJtYXJnaW5ZIiwieCIsImVuZHNXaXRoIiwid2lkdGgiLCJ5Iiwic3RhcnRzV2l0aCIsImhlaWdodCIsImNyZWF0ZUVsZW1lbnQiLCJQcm92aWRlciIsInZhbHVlIiwibWFrZURlZmF1bHQiLCJyZWYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/GizmoHelper.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/GizmoViewport.js":
/*!**************************************************************!*\
  !*** ./node_modules/@react-three/drei/core/GizmoViewport.js ***!
  \**************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   GizmoViewport: () => (/* binding */ GizmoViewport)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/index-673ef987.esm.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var _GizmoHelper_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./GizmoHelper.js */ \"(ssr)/./node_modules/@react-three/drei/core/GizmoHelper.js\");\n\n\n\n\n\nfunction Axis({ scale = [\n    0.8,\n    0.05,\n    0.05\n], color, rotation }) {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"group\", {\n        rotation: rotation\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"mesh\", {\n        position: [\n            0.4,\n            0,\n            0\n        ]\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"boxGeometry\", {\n        args: scale\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"meshBasicMaterial\", {\n        color: color,\n        toneMapped: false\n    })));\n}\nfunction AxisHead({ onClick, font, disabled, arcStyle, label, labelColor, axisHeadScale = 1, ...props }) {\n    const gl = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_2__.z)((state)=>state.gl);\n    const texture = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(()=>{\n        const canvas = document.createElement(\"canvas\");\n        canvas.width = 64;\n        canvas.height = 64;\n        const context = canvas.getContext(\"2d\");\n        context.beginPath();\n        context.arc(32, 32, 16, 0, 2 * Math.PI);\n        context.closePath();\n        context.fillStyle = arcStyle;\n        context.fill();\n        if (label) {\n            context.font = font;\n            context.textAlign = \"center\";\n            context.fillStyle = labelColor;\n            context.fillText(label, 32, 41);\n        }\n        return new three__WEBPACK_IMPORTED_MODULE_3__.CanvasTexture(canvas);\n    }, [\n        arcStyle,\n        label,\n        labelColor,\n        font\n    ]);\n    const [active, setActive] = react__WEBPACK_IMPORTED_MODULE_1__.useState(false);\n    const scale = (label ? 1 : 0.75) * (active ? 1.2 : 1) * axisHeadScale;\n    const handlePointerOver = (e)=>{\n        e.stopPropagation();\n        setActive(true);\n    };\n    const handlePointerOut = (e)=>{\n        e.stopPropagation();\n        setActive(false);\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"sprite\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        scale: scale,\n        onPointerOver: !disabled ? handlePointerOver : undefined,\n        onPointerOut: !disabled ? onClick || handlePointerOut : undefined\n    }, props), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"spriteMaterial\", {\n        map: texture,\n        \"map-anisotropy\": gl.capabilities.getMaxAnisotropy() || 1,\n        alphaTest: 0.3,\n        opacity: label ? 1 : 0.75,\n        toneMapped: false\n    }));\n}\nconst GizmoViewport = ({ hideNegativeAxes, hideAxisHeads, disabled, font = \"18px Inter var, Arial, sans-serif\", axisColors = [\n    \"#ff2060\",\n    \"#20df80\",\n    \"#2080ff\"\n], axisHeadScale = 1, axisScale, labels = [\n    \"X\",\n    \"Y\",\n    \"Z\"\n], labelColor = \"#000\", onClick, ...props })=>{\n    const [colorX, colorY, colorZ] = axisColors;\n    const { tweenCamera } = (0,_GizmoHelper_js__WEBPACK_IMPORTED_MODULE_4__.useGizmoContext)();\n    const axisHeadProps = {\n        font,\n        disabled,\n        labelColor,\n        onClick,\n        axisHeadScale,\n        onPointerDown: !disabled ? (e)=>{\n            tweenCamera(e.object.position);\n            e.stopPropagation();\n        } : undefined\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"group\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        scale: 40\n    }, props), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(Axis, {\n        color: colorX,\n        rotation: [\n            0,\n            0,\n            0\n        ],\n        scale: axisScale\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(Axis, {\n        color: colorY,\n        rotation: [\n            0,\n            0,\n            Math.PI / 2\n        ],\n        scale: axisScale\n    }), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(Axis, {\n        color: colorZ,\n        rotation: [\n            0,\n            -Math.PI / 2,\n            0\n        ],\n        scale: axisScale\n    }), !hideAxisHeads && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(AxisHead, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        arcStyle: colorX,\n        position: [\n            1,\n            0,\n            0\n        ],\n        label: labels[0]\n    }, axisHeadProps)), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(AxisHead, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        arcStyle: colorY,\n        position: [\n            0,\n            1,\n            0\n        ],\n        label: labels[1]\n    }, axisHeadProps)), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(AxisHead, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        arcStyle: colorZ,\n        position: [\n            0,\n            0,\n            1\n        ],\n        label: labels[2]\n    }, axisHeadProps)), !hideNegativeAxes && /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(AxisHead, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        arcStyle: colorX,\n        position: [\n            -1,\n            0,\n            0\n        ]\n    }, axisHeadProps)), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(AxisHead, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        arcStyle: colorY,\n        position: [\n            0,\n            -1,\n            0\n        ]\n    }, axisHeadProps)), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(AxisHead, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        arcStyle: colorZ,\n        position: [\n            0,\n            0,\n            -1\n        ]\n    }, axisHeadProps)))));\n};\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9HaXptb1ZpZXdwb3J0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBMEQ7QUFDM0I7QUFDZTtBQUNSO0FBQ2E7QUFFbkQsU0FBU0ssS0FBSyxFQUNaQyxRQUFRO0lBQUM7SUFBSztJQUFNO0NBQUssRUFDekJDLEtBQUssRUFDTEMsUUFBUSxFQUNUO0lBQ0MsT0FBTyxXQUFXLEdBQUVQLGdEQUFtQixDQUFDLFNBQVM7UUFDL0NPLFVBQVVBO0lBQ1osR0FBRyxXQUFXLEdBQUVQLGdEQUFtQixDQUFDLFFBQVE7UUFDMUNTLFVBQVU7WUFBQztZQUFLO1lBQUc7U0FBRTtJQUN2QixHQUFHLFdBQVcsR0FBRVQsZ0RBQW1CLENBQUMsZUFBZTtRQUNqRFUsTUFBTUw7SUFDUixJQUFJLFdBQVcsR0FBRUwsZ0RBQW1CLENBQUMscUJBQXFCO1FBQ3hETSxPQUFPQTtRQUNQSyxZQUFZO0lBQ2Q7QUFDRjtBQUVBLFNBQVNDLFNBQVMsRUFDaEJDLE9BQU8sRUFDUEMsSUFBSSxFQUNKQyxRQUFRLEVBQ1JDLFFBQVEsRUFDUkMsS0FBSyxFQUNMQyxVQUFVLEVBQ1ZDLGdCQUFnQixDQUFDLEVBQ2pCLEdBQUdDLE9BQ0o7SUFDQyxNQUFNQyxLQUFLcEIscURBQVFBLENBQUNxQixDQUFBQSxRQUFTQSxNQUFNRCxFQUFFO0lBQ3JDLE1BQU1FLFVBQVV2QiwwQ0FBYSxDQUFDO1FBQzVCLE1BQU15QixTQUFTQyxTQUFTbEIsYUFBYSxDQUFDO1FBQ3RDaUIsT0FBT0UsS0FBSyxHQUFHO1FBQ2ZGLE9BQU9HLE1BQU0sR0FBRztRQUNoQixNQUFNQyxVQUFVSixPQUFPSyxVQUFVLENBQUM7UUFDbENELFFBQVFFLFNBQVM7UUFDakJGLFFBQVFHLEdBQUcsQ0FBQyxJQUFJLElBQUksSUFBSSxHQUFHLElBQUlDLEtBQUtDLEVBQUU7UUFDdENMLFFBQVFNLFNBQVM7UUFDakJOLFFBQVFPLFNBQVMsR0FBR3BCO1FBQ3BC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QUFDLEVBQUU7SUFDbEIsR0FBR0ssaUJBQWlCLFdBQVcsR0FBRWpFLGdEQUFtQixDQUFDWSxVQUFVYiw4RUFBUUEsQ0FBQztRQUN0RWlCLFVBQVU4QztRQUNWckQsVUFBVTtZQUFDO1lBQUc7WUFBRztTQUFFO1FBQ25CUSxPQUFPMkMsTUFBTSxDQUFDLEVBQUU7SUFDbEIsR0FBR0ssaUJBQWlCLFdBQVcsR0FBRWpFLGdEQUFtQixDQUFDWSxVQUFVYiw4RUFBUUEsQ0FBQztRQUN0RWlCLFVBQVUrQztRQUNWdEQsVUFBVTtZQUFDO1lBQUc7WUFBRztTQUFFO1FBQ25CUSxPQUFPMkMsTUFBTSxDQUFDLEVBQUU7SUFDbEIsR0FBR0ssaUJBQWlCLENBQUNULG9CQUFvQixXQUFXLEdBQUV4RCxnREFBbUIsQ0FBQ0EsMkNBQWMsRUFBRSxNQUFNLFdBQVcsR0FBRUEsZ0RBQW1CLENBQUNZLFVBQVViLDhFQUFRQSxDQUFDO1FBQ2xKaUIsVUFBVTZDO1FBQ1ZwRCxVQUFVO1lBQUMsQ0FBQztZQUFHO1lBQUc7U0FBRTtJQUN0QixHQUFHd0QsaUJBQWlCLFdBQVcsR0FBRWpFLGdEQUFtQixDQUFDWSxVQUFVYiw4RUFBUUEsQ0FBQztRQUN0RWlCLFVBQVU4QztRQUNWckQsVUFBVTtZQUFDO1lBQUcsQ0FBQztZQUFHO1NBQUU7SUFDdEIsR0FBR3dELGlCQUFpQixXQUFXLEdBQUVqRSxnREFBbUIsQ0FBQ1ksVUFBVWIsOEVBQVFBLENBQUM7UUFDdEVpQixVQUFVK0M7UUFDVnRELFVBQVU7WUFBQztZQUFHO1lBQUcsQ0FBQztTQUFFO0lBQ3RCLEdBQUd3RDtBQUNMO0FBRXlCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmliZS0zZC1jb2RlLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL2NvcmUvR2l6bW9WaWV3cG9ydC5qcz9hNWUwIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IHVzZVRocmVlIH0gZnJvbSAnQHJlYWN0LXRocmVlL2ZpYmVyJztcbmltcG9ydCB7IENhbnZhc1RleHR1cmUgfSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyB1c2VHaXptb0NvbnRleHQgfSBmcm9tICcuL0dpem1vSGVscGVyLmpzJztcblxuZnVuY3Rpb24gQXhpcyh7XG4gIHNjYWxlID0gWzAuOCwgMC4wNSwgMC4wNV0sXG4gIGNvbG9yLFxuICByb3RhdGlvblxufSkge1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLCB7XG4gICAgcm90YXRpb246IHJvdGF0aW9uXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwibWVzaFwiLCB7XG4gICAgcG9zaXRpb246IFswLjQsIDAsIDBdXG4gIH0sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiYm94R2VvbWV0cnlcIiwge1xuICAgIGFyZ3M6IHNjYWxlXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcIm1lc2hCYXNpY01hdGVyaWFsXCIsIHtcbiAgICBjb2xvcjogY29sb3IsXG4gICAgdG9uZU1hcHBlZDogZmFsc2VcbiAgfSkpKTtcbn1cblxuZnVuY3Rpb24gQXhpc0hlYWQoe1xuICBvbkNsaWNrLFxuICBmb250LFxuICBkaXNhYmxlZCxcbiAgYXJjU3R5bGUsXG4gIGxhYmVsLFxuICBsYWJlbENvbG9yLFxuICBheGlzSGVhZFNjYWxlID0gMSxcbiAgLi4ucHJvcHNcbn0pIHtcbiAgY29uc3QgZ2wgPSB1c2VUaHJlZShzdGF0ZSA9PiBzdGF0ZS5nbCk7XG4gIGNvbnN0IHRleHR1cmUgPSBSZWFjdC51c2VNZW1vKCgpID0+IHtcbiAgICBjb25zdCBjYW52YXMgPSBkb2N1bWVudC5jcmVhdGVFbGVtZW50KCdjYW52YXMnKTtcbiAgICBjYW52YXMud2lkdGggPSA2NDtcbiAgICBjYW52YXMuaGVpZ2h0ID0gNjQ7XG4gICAgY29uc3QgY29udGV4dCA9IGNhbnZhcy5nZXRDb250ZXh0KCcyZCcpO1xuICAgIGNvbnRleHQuYmVnaW5QYXRoKCk7XG4gICAgY29udGV4dC5hcmMoMzIsIDMyLCAxNiwgMCwgMiAqIE1hdGguUEkpO1xuICAgIGNvbnRleHQuY2xvc2VQYXRoKCk7XG4gICAgY29udGV4dC5maWxsU3R5bGUgPSBhcmNTdHlsZTtcbiAgICBjb250ZXh0LmZpbGwoKTtcblxuICAgIGlmIChsYWJlbCkge1xuICAgICAgY29udGV4dC5mb250ID0gZm9udDtcbiAgICAgIGNvbnRleHQudGV4dEFsaWduID0gJ2NlbnRlcic7XG4gICAgICBjb250ZXh0LmZpbGxTdHlsZSA9IGxhYmVsQ29sb3I7XG4gICAgICBjb250ZXh0LmZpbGxUZXh0KGxhYmVsLCAzMiwgNDEpO1xuICAgIH1cblxuICAgIHJldHVybiBuZXcgQ2FudmFzVGV4dHVyZShjYW52YXMpO1xuICB9LCBbYXJjU3R5bGUsIGxhYmVsLCBsYWJlbENvbG9yLCBmb250XSk7XG4gIGNvbnN0IFthY3RpdmUsIHNldEFjdGl2ZV0gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IHNjYWxlID0gKGxhYmVsID8gMSA6IDAuNzUpICogKGFjdGl2ZSA/IDEuMiA6IDEpICogYXhpc0hlYWRTY2FsZTtcblxuICBjb25zdCBoYW5kbGVQb2ludGVyT3ZlciA9IGUgPT4ge1xuICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgc2V0QWN0aXZlKHRydWUpO1xuICB9O1xuXG4gIGNvbnN0IGhhbmRsZVBvaW50ZXJPdXQgPSBlID0+IHtcbiAgICBlLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgIHNldEFjdGl2ZShmYWxzZSk7XG4gIH07XG5cbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwic3ByaXRlXCIsIF9leHRlbmRzKHtcbiAgICBzY2FsZTogc2NhbGUsXG4gICAgb25Qb2ludGVyT3ZlcjogIWRpc2FibGVkID8gaGFuZGxlUG9pbnRlck92ZXIgOiB1bmRlZmluZWQsXG4gICAgb25Qb2ludGVyT3V0OiAhZGlzYWJsZWQgPyBvbkNsaWNrIHx8IGhhbmRsZVBvaW50ZXJPdXQgOiB1bmRlZmluZWRcbiAgfSwgcHJvcHMpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcInNwcml0ZU1hdGVyaWFsXCIsIHtcbiAgICBtYXA6IHRleHR1cmUsXG4gICAgXCJtYXAtYW5pc290cm9weVwiOiBnbC5jYXBhYmlsaXRpZXMuZ2V0TWF4QW5pc290cm9weSgpIHx8IDEsXG4gICAgYWxwaGFUZXN0OiAwLjMsXG4gICAgb3BhY2l0eTogbGFiZWwgPyAxIDogMC43NSxcbiAgICB0b25lTWFwcGVkOiBmYWxzZVxuICB9KSk7XG59XG5cbmNvbnN0IEdpem1vVmlld3BvcnQgPSAoe1xuICBoaWRlTmVnYXRpdmVBeGVzLFxuICBoaWRlQXhpc0hlYWRzLFxuICBkaXNhYmxlZCxcbiAgZm9udCA9ICcxOHB4IEludGVyIHZhciwgQXJpYWwsIHNhbnMtc2VyaWYnLFxuICBheGlzQ29sb3JzID0gWycjZmYyMDYwJywgJyMyMGRmODAnLCAnIzIwODBmZiddLFxuICBheGlzSGVhZFNjYWxlID0gMSxcbiAgYXhpc1NjYWxlLFxuICBsYWJlbHMgPSBbJ1gnLCAnWScsICdaJ10sXG4gIGxhYmVsQ29sb3IgPSAnIzAwMCcsXG4gIG9uQ2xpY2ssXG4gIC4uLnByb3BzXG59KSA9PiB7XG4gIGNvbnN0IFtjb2xvclgsIGNvbG9yWSwgY29sb3JaXSA9IGF4aXNDb2xvcnM7XG4gIGNvbnN0IHtcbiAgICB0d2VlbkNhbWVyYVxuICB9ID0gdXNlR2l6bW9Db250ZXh0KCk7XG4gIGNvbnN0IGF4aXNIZWFkUHJvcHMgPSB7XG4gICAgZm9udCxcbiAgICBkaXNhYmxlZCxcbiAgICBsYWJlbENvbG9yLFxuICAgIG9uQ2xpY2ssXG4gICAgYXhpc0hlYWRTY2FsZSxcbiAgICBvblBvaW50ZXJEb3duOiAhZGlzYWJsZWQgPyBlID0+IHtcbiAgICAgIHR3ZWVuQ2FtZXJhKGUub2JqZWN0LnBvc2l0aW9uKTtcbiAgICAgIGUuc3RvcFByb3BhZ2F0aW9uKCk7XG4gICAgfSA6IHVuZGVmaW5lZFxuICB9O1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLCBfZXh0ZW5kcyh7XG4gICAgc2NhbGU6IDQwXG4gIH0sIHByb3BzKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQXhpcywge1xuICAgIGNvbG9yOiBjb2xvclgsXG4gICAgcm90YXRpb246IFswLCAwLCAwXSxcbiAgICBzY2FsZTogYXhpc1NjYWxlXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBeGlzLCB7XG4gICAgY29sb3I6IGNvbG9yWSxcbiAgICByb3RhdGlvbjogWzAsIDAsIE1hdGguUEkgLyAyXSxcbiAgICBzY2FsZTogYXhpc1NjYWxlXG4gIH0pLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBeGlzLCB7XG4gICAgY29sb3I6IGNvbG9yWixcbiAgICByb3RhdGlvbjogWzAsIC1NYXRoLlBJIC8gMiwgMF0sXG4gICAgc2NhbGU6IGF4aXNTY2FsZVxuICB9KSwgIWhpZGVBeGlzSGVhZHMgJiYgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEF4aXNIZWFkLCBfZXh0ZW5kcyh7XG4gICAgYXJjU3R5bGU6IGNvbG9yWCxcbiAgICBwb3NpdGlvbjogWzEsIDAsIDBdLFxuICAgIGxhYmVsOiBsYWJlbHNbMF1cbiAgfSwgYXhpc0hlYWRQcm9wcykpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBeGlzSGVhZCwgX2V4dGVuZHMoe1xuICAgIGFyY1N0eWxlOiBjb2xvclksXG4gICAgcG9zaXRpb246IFswLCAxLCAwXSxcbiAgICBsYWJlbDogbGFiZWxzWzFdXG4gIH0sIGF4aXNIZWFkUHJvcHMpKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoQXhpc0hlYWQsIF9leHRlbmRzKHtcbiAgICBhcmNTdHlsZTogY29sb3JaLFxuICAgIHBvc2l0aW9uOiBbMCwgMCwgMV0sXG4gICAgbGFiZWw6IGxhYmVsc1syXVxuICB9LCBheGlzSGVhZFByb3BzKSksICFoaWRlTmVnYXRpdmVBeGVzICYmIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlYWN0LkZyYWdtZW50LCBudWxsLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBeGlzSGVhZCwgX2V4dGVuZHMoe1xuICAgIGFyY1N0eWxlOiBjb2xvclgsXG4gICAgcG9zaXRpb246IFstMSwgMCwgMF1cbiAgfSwgYXhpc0hlYWRQcm9wcykpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBeGlzSGVhZCwgX2V4dGVuZHMoe1xuICAgIGFyY1N0eWxlOiBjb2xvclksXG4gICAgcG9zaXRpb246IFswLCAtMSwgMF1cbiAgfSwgYXhpc0hlYWRQcm9wcykpLCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChBeGlzSGVhZCwgX2V4dGVuZHMoe1xuICAgIGFyY1N0eWxlOiBjb2xvclosXG4gICAgcG9zaXRpb246IFswLCAwLCAtMV1cbiAgfSwgYXhpc0hlYWRQcm9wcykpKSkpO1xufTtcblxuZXhwb3J0IHsgR2l6bW9WaWV3cG9ydCB9O1xuIl0sIm5hbWVzIjpbIl9leHRlbmRzIiwiUmVhY3QiLCJ1c2VUaHJlZSIsIkNhbnZhc1RleHR1cmUiLCJ1c2VHaXptb0NvbnRleHQiLCJBeGlzIiwic2NhbGUiLCJjb2xvciIsInJvdGF0aW9uIiwiY3JlYXRlRWxlbWVudCIsInBvc2l0aW9uIiwiYXJncyIsInRvbmVNYXBwZWQiLCJBeGlzSGVhZCIsIm9uQ2xpY2siLCJmb250IiwiZGlzYWJsZWQiLCJhcmNTdHlsZSIsImxhYmVsIiwibGFiZWxDb2xvciIsImF4aXNIZWFkU2NhbGUiLCJwcm9wcyIsImdsIiwic3RhdGUiLCJ0ZXh0dXJlIiwidXNlTWVtbyIsImNhbnZhcyIsImRvY3VtZW50Iiwid2lkdGgiLCJoZWlnaHQiLCJjb250ZXh0IiwiZ2V0Q29udGV4dCIsImJlZ2luUGF0aCIsImFyYyIsIk1hdGgiLCJQSSIsImNsb3NlUGF0aCIsImZpbGxTdHlsZSIsImZpbGwiLCJ0ZXh0QWxpZ24iLCJmaWxsVGV4dCIsImFjdGl2ZSIsInNldEFjdGl2ZSIsInVzZVN0YXRlIiwiaGFuZGxlUG9pbnRlck92ZXIiLCJlIiwic3RvcFByb3BhZ2F0aW9uIiwiaGFuZGxlUG9pbnRlck91dCIsIm9uUG9pbnRlck92ZXIiLCJ1bmRlZmluZWQiLCJvblBvaW50ZXJPdXQiLCJtYXAiLCJjYXBhYmlsaXRpZXMiLCJnZXRNYXhBbmlzb3Ryb3B5IiwiYWxwaGFUZXN0Iiwib3BhY2l0eSIsIkdpem1vVmlld3BvcnQiLCJoaWRlTmVnYXRpdmVBeGVzIiwiaGlkZUF4aXNIZWFkcyIsImF4aXNDb2xvcnMiLCJheGlzU2NhbGUiLCJsYWJlbHMiLCJjb2xvclgiLCJjb2xvclkiLCJjb2xvcloiLCJ0d2VlbkNhbWVyYSIsImF4aXNIZWFkUHJvcHMiLCJvblBvaW50ZXJEb3duIiwib2JqZWN0IiwiRnJhZ21lbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/GizmoViewport.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/Grid.js":
/*!*****************************************************!*\
  !*** ./node_modules/@react-three/drei/core/Grid.js ***!
  \*****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Grid: () => (/* binding */ Grid)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var react_merge_refs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-merge-refs */ \"(ssr)/./node_modules/react-merge-refs/dist/react-merge-refs.esm.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/index-673ef987.esm.js\");\n/* harmony import */ var _shaderMaterial_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./shaderMaterial.js */ \"(ssr)/./node_modules/@react-three/drei/core/shaderMaterial.js\");\n\n\n\n\n\n\nconst GridMaterial = (0,_shaderMaterial_js__WEBPACK_IMPORTED_MODULE_3__.shaderMaterial)({\n    cellSize: 0.5,\n    sectionSize: 1,\n    fadeDistance: 100,\n    fadeStrength: 1,\n    cellThickness: 0.5,\n    sectionThickness: 1,\n    cellColor: new three__WEBPACK_IMPORTED_MODULE_4__.Color(),\n    sectionColor: new three__WEBPACK_IMPORTED_MODULE_4__.Color(),\n    infiniteGrid: false,\n    followCamera: false,\n    worldCamProjPosition: new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(),\n    worldPlanePosition: new three__WEBPACK_IMPORTED_MODULE_4__.Vector3()\n}, /* glsl */ `\n    varying vec3 localPosition;\n    varying vec4 worldPosition;\n\n    uniform vec3 worldCamProjPosition;\n    uniform vec3 worldPlanePosition;\n    uniform float fadeDistance;\n    uniform bool infiniteGrid;\n    uniform bool followCamera;\n\n    void main() {\n      localPosition = position.xzy;\n      if (infiniteGrid) localPosition *= 1.0 + fadeDistance;\n      \n      worldPosition = modelMatrix * vec4(localPosition, 1.0);\n      if (followCamera) {\n        worldPosition.xyz += (worldCamProjPosition - worldPlanePosition);\n        localPosition = (inverse(modelMatrix) * worldPosition).xyz;\n      }\n\n      gl_Position = projectionMatrix * viewMatrix * worldPosition;\n    }\n  `, /* glsl */ `\n    varying vec3 localPosition;\n    varying vec4 worldPosition;\n\n    uniform vec3 worldCamProjPosition;\n    uniform float cellSize;\n    uniform float sectionSize;\n    uniform vec3 cellColor;\n    uniform vec3 sectionColor;\n    uniform float fadeDistance;\n    uniform float fadeStrength;\n    uniform float cellThickness;\n    uniform float sectionThickness;\n\n    float getGrid(float size, float thickness) {\n      vec2 r = localPosition.xz / size;\n      vec2 grid = abs(fract(r - 0.5) - 0.5) / fwidth(r);\n      float line = min(grid.x, grid.y) + 1.0 - thickness;\n      return 1.0 - min(line, 1.0);\n    }\n\n    void main() {\n      float g1 = getGrid(cellSize, cellThickness);\n      float g2 = getGrid(sectionSize, sectionThickness);\n\n      float dist = distance(worldCamProjPosition, worldPosition.xyz);\n      float d = 1.0 - min(dist / fadeDistance, 1.0);\n      vec3 color = mix(cellColor, sectionColor, min(1.0, sectionThickness * g2));\n\n      gl_FragColor = vec4(color, (g1 + g2) * pow(d, fadeStrength));\n      gl_FragColor.a = mix(0.75 * gl_FragColor.a, gl_FragColor.a, g2);\n      if (gl_FragColor.a <= 0.0) discard;\n\n      #include <tonemapping_fragment>\n      #include <${parseInt(three__WEBPACK_IMPORTED_MODULE_4__.REVISION.replace(/\\D+/g, \"\")) >= 154 ? \"colorspace_fragment\" : \"encodings_fragment\"}>\n    }\n  `);\nconst Grid = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({ args, cellColor = \"#000000\", sectionColor = \"#2080ff\", cellSize = 0.5, sectionSize = 1, followCamera = false, infiniteGrid = false, fadeDistance = 100, fadeStrength = 1, cellThickness = 0.5, sectionThickness = 1, side = three__WEBPACK_IMPORTED_MODULE_4__.BackSide, ...props }, fRef)=>{\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_5__.e)({\n        GridMaterial\n    });\n    const ref = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    const plane = new three__WEBPACK_IMPORTED_MODULE_4__.Plane();\n    const upVector = new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(0, 1, 0);\n    const zeroVector = new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(0, 0, 0);\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_5__.A)((state)=>{\n        plane.setFromNormalAndCoplanarPoint(upVector, zeroVector).applyMatrix4(ref.current.matrixWorld);\n        const gridMaterial = ref.current.material;\n        const worldCamProjPosition = gridMaterial.uniforms.worldCamProjPosition;\n        const worldPlanePosition = gridMaterial.uniforms.worldPlanePosition;\n        plane.projectPoint(state.camera.position, worldCamProjPosition.value);\n        worldPlanePosition.value.set(0, 0, 0).applyMatrix4(ref.current.matrixWorld);\n    });\n    const uniforms1 = {\n        cellSize,\n        sectionSize,\n        cellColor,\n        sectionColor,\n        cellThickness,\n        sectionThickness\n    };\n    const uniforms2 = {\n        fadeDistance,\n        fadeStrength,\n        infiniteGrid,\n        followCamera\n    };\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"mesh\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        ref: (0,react_merge_refs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            ref,\n            fRef\n        ]),\n        frustumCulled: false\n    }, props), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"gridMaterial\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        transparent: true,\n        \"extensions-derivatives\": true,\n        side: side\n    }, uniforms1, uniforms2)), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"planeGeometry\", {\n        args: args\n    }));\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9HcmlkLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7O0FBQTBEO0FBQzNCO0FBQ0E7QUFDVTtBQUNhO0FBQ0Q7QUFFckQsTUFBTU8sZUFBZUQsa0VBQWNBLENBQUM7SUFDbENFLFVBQVU7SUFDVkMsYUFBYTtJQUNiQyxjQUFjO0lBQ2RDLGNBQWM7SUFDZEMsZUFBZTtJQUNmQyxrQkFBa0I7SUFDbEJDLFdBQVcsSUFBSVosd0NBQVc7SUFDMUJjLGNBQWMsSUFBSWQsd0NBQVc7SUFDN0JlLGNBQWM7SUFDZEMsY0FBYztJQUNkQyxzQkFBc0IsSUFBSWpCLDBDQUFhO0lBQ3ZDbUIsb0JBQW9CLElBQUluQiwwQ0FBYTtBQUN2QyxHQUNBLFFBQVEsR0FDUixDQUFDOzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0VBc0JDLENBQUMsRUFDSCxRQUFRLEdBQ1IsQ0FBQzs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztnQkFrQ2UsRUFBRW9CLFNBQVNwQiwyQ0FBYyxDQUFDc0IsT0FBTyxDQUFDLFFBQVEsUUFBUSxNQUFNLHdCQUF3QixxQkFBcUI7O0VBRW5ILENBQUM7QUFDSCxNQUFNQyxPQUFPLFdBQVcsR0FBRXhCLDZDQUFnQixDQUFDLENBQUMsRUFDMUMwQixJQUFJLEVBQ0piLFlBQVksU0FBUyxFQUNyQkUsZUFBZSxTQUFTLEVBQ3hCUixXQUFXLEdBQUcsRUFDZEMsY0FBYyxDQUFDLEVBQ2ZTLGVBQWUsS0FBSyxFQUNwQkQsZUFBZSxLQUFLLEVBQ3BCUCxlQUFlLEdBQUcsRUFDbEJDLGVBQWUsQ0FBQyxFQUNoQkMsZ0JBQWdCLEdBQUcsRUFDbkJDLG1CQUFtQixDQUFDLEVBQ3BCZSxPQUFPMUIsMkNBQWMsRUFDckIsR0FBRzRCLE9BQ0osRUFBRUM7SUFDRDNCLHFEQUFNQSxDQUFDO1FBQ0xHO0lBQ0Y7SUFDQSxNQUFNeUIsTUFBTS9CLHlDQUFZLENBQUM7SUFDekIsTUFBTWlDLFFBQVEsSUFBSWhDLHdDQUFXO0lBQzdCLE1BQU1rQyxXQUFXLElBQUlsQywwQ0FBYSxDQUFDLEdBQUcsR0FBRztJQUN6QyxNQUFNbUMsYUFBYSxJQUFJbkMsMENBQWEsQ0FBQyxHQUFHLEdBQUc7SUFDM0NHLHFEQUFRQSxDQUFDaUMsQ0FBQUE7UUFDUEosTUFBTUssNkJBQTZCLENBQUNILFVBQVVDLFlBQVlHLFlBQVksQ0FBQ1IsSUFBSVMsT0FBTyxDQUFDQyxXQUFXO1FBQzlGLE1BQU1DLGVBQWVYLElBQUlTLE9BQU8sQ0FBQ0csUUFBUTtRQUN6QyxNQUFNekIsdUJBQXVCd0IsYUFBYUUsUUFBUSxDQUFDMUIsb0JBQW9CO1FBQ3ZFLE1BQU1FLHFCQUFxQnNCLGFBQWFFLFFBQVEsQ0FBQ3hCLGtCQUFrQjtRQUNuRWEsTUFBTVksWUFBWSxDQUFDUixNQUFNUyxNQUFNLENBQUNDLFFBQVEsRUFBRTdCLHFCQUFxQjhCLEtBQUs7UUFDcEU1QixtQkFBbUI0QixLQUFLLENBQUNDLEdBQUcsQ0FBQyxHQUFHLEdBQUcsR0FBR1YsWUFBWSxDQUFDUixJQUFJUyxPQUFPLENBQUNDLFdBQVc7SUFDNUU7SUFDQSxNQUFNUyxZQUFZO1FBQ2hCM0M7UUFDQUM7UUFDQUs7UUFDQUU7UUFDQUo7UUFDQUM7SUFDRjtJQUNBLE1BQU11QyxZQUFZO1FBQ2hCMUM7UUFDQUM7UUFDQU07UUFDQUM7SUFDRjtJQUNBLE9BQU8sV0FBVyxHQUFFakIsZ0RBQW1CLENBQUMsUUFBUUQsOEVBQVFBLENBQUM7UUFDdkRnQyxLQUFLN0IsNERBQVNBLENBQUM7WUFBQzZCO1lBQUtEO1NBQUs7UUFDMUJ1QixlQUFlO0lBQ2pCLEdBQUd4QixRQUFRLFdBQVcsR0FBRTdCLGdEQUFtQixDQUFDLGdCQUFnQkQsOEVBQVFBLENBQUM7UUFDbkV1RCxhQUFhO1FBQ2IsMEJBQTBCO1FBQzFCM0IsTUFBTUE7SUFDUixHQUFHdUIsV0FBV0MsYUFBYSxXQUFXLEdBQUVuRCxnREFBbUIsQ0FBQyxpQkFBaUI7UUFDM0UwQixNQUFNQTtJQUNSO0FBQ0Y7QUFFZ0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aWJlLTNkLWNvZGUvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9HcmlkLmpzPzJlZmUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9leHRlbmRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0IG1lcmdlUmVmcyBmcm9tICdyZWFjdC1tZXJnZS1yZWZzJztcbmltcG9ydCB7IGV4dGVuZCwgdXNlRnJhbWUgfSBmcm9tICdAcmVhY3QtdGhyZWUvZmliZXInO1xuaW1wb3J0IHsgc2hhZGVyTWF0ZXJpYWwgfSBmcm9tICcuL3NoYWRlck1hdGVyaWFsLmpzJztcblxuY29uc3QgR3JpZE1hdGVyaWFsID0gc2hhZGVyTWF0ZXJpYWwoe1xuICBjZWxsU2l6ZTogMC41LFxuICBzZWN0aW9uU2l6ZTogMSxcbiAgZmFkZURpc3RhbmNlOiAxMDAsXG4gIGZhZGVTdHJlbmd0aDogMSxcbiAgY2VsbFRoaWNrbmVzczogMC41LFxuICBzZWN0aW9uVGhpY2tuZXNzOiAxLFxuICBjZWxsQ29sb3I6IG5ldyBUSFJFRS5Db2xvcigpLFxuICBzZWN0aW9uQ29sb3I6IG5ldyBUSFJFRS5Db2xvcigpLFxuICBpbmZpbml0ZUdyaWQ6IGZhbHNlLFxuICBmb2xsb3dDYW1lcmE6IGZhbHNlLFxuICB3b3JsZENhbVByb2pQb3NpdGlvbjogbmV3IFRIUkVFLlZlY3RvcjMoKSxcbiAgd29ybGRQbGFuZVBvc2l0aW9uOiBuZXcgVEhSRUUuVmVjdG9yMygpXG59LFxuLyogZ2xzbCAqL1xuYFxuICAgIHZhcnlpbmcgdmVjMyBsb2NhbFBvc2l0aW9uO1xuICAgIHZhcnlpbmcgdmVjNCB3b3JsZFBvc2l0aW9uO1xuXG4gICAgdW5pZm9ybSB2ZWMzIHdvcmxkQ2FtUHJvalBvc2l0aW9uO1xuICAgIHVuaWZvcm0gdmVjMyB3b3JsZFBsYW5lUG9zaXRpb247XG4gICAgdW5pZm9ybSBmbG9hdCBmYWRlRGlzdGFuY2U7XG4gICAgdW5pZm9ybSBib29sIGluZmluaXRlR3JpZDtcbiAgICB1bmlmb3JtIGJvb2wgZm9sbG93Q2FtZXJhO1xuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgbG9jYWxQb3NpdGlvbiA9IHBvc2l0aW9uLnh6eTtcbiAgICAgIGlmIChpbmZpbml0ZUdyaWQpIGxvY2FsUG9zaXRpb24gKj0gMS4wICsgZmFkZURpc3RhbmNlO1xuICAgICAgXG4gICAgICB3b3JsZFBvc2l0aW9uID0gbW9kZWxNYXRyaXggKiB2ZWM0KGxvY2FsUG9zaXRpb24sIDEuMCk7XG4gICAgICBpZiAoZm9sbG93Q2FtZXJhKSB7XG4gICAgICAgIHdvcmxkUG9zaXRpb24ueHl6ICs9ICh3b3JsZENhbVByb2pQb3NpdGlvbiAtIHdvcmxkUGxhbmVQb3NpdGlvbik7XG4gICAgICAgIGxvY2FsUG9zaXRpb24gPSAoaW52ZXJzZShtb2RlbE1hdHJpeCkgKiB3b3JsZFBvc2l0aW9uKS54eXo7XG4gICAgICB9XG5cbiAgICAgIGdsX1Bvc2l0aW9uID0gcHJvamVjdGlvbk1hdHJpeCAqIHZpZXdNYXRyaXggKiB3b3JsZFBvc2l0aW9uO1xuICAgIH1cbiAgYCxcbi8qIGdsc2wgKi9cbmBcbiAgICB2YXJ5aW5nIHZlYzMgbG9jYWxQb3NpdGlvbjtcbiAgICB2YXJ5aW5nIHZlYzQgd29ybGRQb3NpdGlvbjtcblxuICAgIHVuaWZvcm0gdmVjMyB3b3JsZENhbVByb2pQb3NpdGlvbjtcbiAgICB1bmlmb3JtIGZsb2F0IGNlbGxTaXplO1xuICAgIHVuaWZvcm0gZmxvYXQgc2VjdGlvblNpemU7XG4gICAgdW5pZm9ybSB2ZWMzIGNlbGxDb2xvcjtcbiAgICB1bmlmb3JtIHZlYzMgc2VjdGlvbkNvbG9yO1xuICAgIHVuaWZvcm0gZmxvYXQgZmFkZURpc3RhbmNlO1xuICAgIHVuaWZvcm0gZmxvYXQgZmFkZVN0cmVuZ3RoO1xuICAgIHVuaWZvcm0gZmxvYXQgY2VsbFRoaWNrbmVzcztcbiAgICB1bmlmb3JtIGZsb2F0IHNlY3Rpb25UaGlja25lc3M7XG5cbiAgICBmbG9hdCBnZXRHcmlkKGZsb2F0IHNpemUsIGZsb2F0IHRoaWNrbmVzcykge1xuICAgICAgdmVjMiByID0gbG9jYWxQb3NpdGlvbi54eiAvIHNpemU7XG4gICAgICB2ZWMyIGdyaWQgPSBhYnMoZnJhY3QociAtIDAuNSkgLSAwLjUpIC8gZndpZHRoKHIpO1xuICAgICAgZmxvYXQgbGluZSA9IG1pbihncmlkLngsIGdyaWQueSkgKyAxLjAgLSB0aGlja25lc3M7XG4gICAgICByZXR1cm4gMS4wIC0gbWluKGxpbmUsIDEuMCk7XG4gICAgfVxuXG4gICAgdm9pZCBtYWluKCkge1xuICAgICAgZmxvYXQgZzEgPSBnZXRHcmlkKGNlbGxTaXplLCBjZWxsVGhpY2tuZXNzKTtcbiAgICAgIGZsb2F0IGcyID0gZ2V0R3JpZChzZWN0aW9uU2l6ZSwgc2VjdGlvblRoaWNrbmVzcyk7XG5cbiAgICAgIGZsb2F0IGRpc3QgPSBkaXN0YW5jZSh3b3JsZENhbVByb2pQb3NpdGlvbiwgd29ybGRQb3NpdGlvbi54eXopO1xuICAgICAgZmxvYXQgZCA9IDEuMCAtIG1pbihkaXN0IC8gZmFkZURpc3RhbmNlLCAxLjApO1xuICAgICAgdmVjMyBjb2xvciA9IG1peChjZWxsQ29sb3IsIHNlY3Rpb25Db2xvciwgbWluKDEuMCwgc2VjdGlvblRoaWNrbmVzcyAqIGcyKSk7XG5cbiAgICAgIGdsX0ZyYWdDb2xvciA9IHZlYzQoY29sb3IsIChnMSArIGcyKSAqIHBvdyhkLCBmYWRlU3RyZW5ndGgpKTtcbiAgICAgIGdsX0ZyYWdDb2xvci5hID0gbWl4KDAuNzUgKiBnbF9GcmFnQ29sb3IuYSwgZ2xfRnJhZ0NvbG9yLmEsIGcyKTtcbiAgICAgIGlmIChnbF9GcmFnQ29sb3IuYSA8PSAwLjApIGRpc2NhcmQ7XG5cbiAgICAgICNpbmNsdWRlIDx0b25lbWFwcGluZ19mcmFnbWVudD5cbiAgICAgICNpbmNsdWRlIDwke3BhcnNlSW50KFRIUkVFLlJFVklTSU9OLnJlcGxhY2UoL1xcRCsvZywgJycpKSA+PSAxNTQgPyAnY29sb3JzcGFjZV9mcmFnbWVudCcgOiAnZW5jb2RpbmdzX2ZyYWdtZW50J30+XG4gICAgfVxuICBgKTtcbmNvbnN0IEdyaWQgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigoe1xuICBhcmdzLFxuICBjZWxsQ29sb3IgPSAnIzAwMDAwMCcsXG4gIHNlY3Rpb25Db2xvciA9ICcjMjA4MGZmJyxcbiAgY2VsbFNpemUgPSAwLjUsXG4gIHNlY3Rpb25TaXplID0gMSxcbiAgZm9sbG93Q2FtZXJhID0gZmFsc2UsXG4gIGluZmluaXRlR3JpZCA9IGZhbHNlLFxuICBmYWRlRGlzdGFuY2UgPSAxMDAsXG4gIGZhZGVTdHJlbmd0aCA9IDEsXG4gIGNlbGxUaGlja25lc3MgPSAwLjUsXG4gIHNlY3Rpb25UaGlja25lc3MgPSAxLFxuICBzaWRlID0gVEhSRUUuQmFja1NpZGUsXG4gIC4uLnByb3BzXG59LCBmUmVmKSA9PiB7XG4gIGV4dGVuZCh7XG4gICAgR3JpZE1hdGVyaWFsXG4gIH0pO1xuICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IHBsYW5lID0gbmV3IFRIUkVFLlBsYW5lKCk7XG4gIGNvbnN0IHVwVmVjdG9yID0gbmV3IFRIUkVFLlZlY3RvcjMoMCwgMSwgMCk7XG4gIGNvbnN0IHplcm9WZWN0b3IgPSBuZXcgVEhSRUUuVmVjdG9yMygwLCAwLCAwKTtcbiAgdXNlRnJhbWUoc3RhdGUgPT4ge1xuICAgIHBsYW5lLnNldEZyb21Ob3JtYWxBbmRDb3BsYW5hclBvaW50KHVwVmVjdG9yLCB6ZXJvVmVjdG9yKS5hcHBseU1hdHJpeDQocmVmLmN1cnJlbnQubWF0cml4V29ybGQpO1xuICAgIGNvbnN0IGdyaWRNYXRlcmlhbCA9IHJlZi5jdXJyZW50Lm1hdGVyaWFsO1xuICAgIGNvbnN0IHdvcmxkQ2FtUHJvalBvc2l0aW9uID0gZ3JpZE1hdGVyaWFsLnVuaWZvcm1zLndvcmxkQ2FtUHJvalBvc2l0aW9uO1xuICAgIGNvbnN0IHdvcmxkUGxhbmVQb3NpdGlvbiA9IGdyaWRNYXRlcmlhbC51bmlmb3Jtcy53b3JsZFBsYW5lUG9zaXRpb247XG4gICAgcGxhbmUucHJvamVjdFBvaW50KHN0YXRlLmNhbWVyYS5wb3NpdGlvbiwgd29ybGRDYW1Qcm9qUG9zaXRpb24udmFsdWUpO1xuICAgIHdvcmxkUGxhbmVQb3NpdGlvbi52YWx1ZS5zZXQoMCwgMCwgMCkuYXBwbHlNYXRyaXg0KHJlZi5jdXJyZW50Lm1hdHJpeFdvcmxkKTtcbiAgfSk7XG4gIGNvbnN0IHVuaWZvcm1zMSA9IHtcbiAgICBjZWxsU2l6ZSxcbiAgICBzZWN0aW9uU2l6ZSxcbiAgICBjZWxsQ29sb3IsXG4gICAgc2VjdGlvbkNvbG9yLFxuICAgIGNlbGxUaGlja25lc3MsXG4gICAgc2VjdGlvblRoaWNrbmVzc1xuICB9O1xuICBjb25zdCB1bmlmb3JtczIgPSB7XG4gICAgZmFkZURpc3RhbmNlLFxuICAgIGZhZGVTdHJlbmd0aCxcbiAgICBpbmZpbml0ZUdyaWQsXG4gICAgZm9sbG93Q2FtZXJhXG4gIH07XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcIm1lc2hcIiwgX2V4dGVuZHMoe1xuICAgIHJlZjogbWVyZ2VSZWZzKFtyZWYsIGZSZWZdKSxcbiAgICBmcnVzdHVtQ3VsbGVkOiBmYWxzZVxuICB9LCBwcm9wcyksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZ3JpZE1hdGVyaWFsXCIsIF9leHRlbmRzKHtcbiAgICB0cmFuc3BhcmVudDogdHJ1ZSxcbiAgICBcImV4dGVuc2lvbnMtZGVyaXZhdGl2ZXNcIjogdHJ1ZSxcbiAgICBzaWRlOiBzaWRlXG4gIH0sIHVuaWZvcm1zMSwgdW5pZm9ybXMyKSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicGxhbmVHZW9tZXRyeVwiLCB7XG4gICAgYXJnczogYXJnc1xuICB9KSk7XG59KTtcblxuZXhwb3J0IHsgR3JpZCB9O1xuIl0sIm5hbWVzIjpbIl9leHRlbmRzIiwiUmVhY3QiLCJUSFJFRSIsIm1lcmdlUmVmcyIsImV4dGVuZCIsInVzZUZyYW1lIiwic2hhZGVyTWF0ZXJpYWwiLCJHcmlkTWF0ZXJpYWwiLCJjZWxsU2l6ZSIsInNlY3Rpb25TaXplIiwiZmFkZURpc3RhbmNlIiwiZmFkZVN0cmVuZ3RoIiwiY2VsbFRoaWNrbmVzcyIsInNlY3Rpb25UaGlja25lc3MiLCJjZWxsQ29sb3IiLCJDb2xvciIsInNlY3Rpb25Db2xvciIsImluZmluaXRlR3JpZCIsImZvbGxvd0NhbWVyYSIsIndvcmxkQ2FtUHJvalBvc2l0aW9uIiwiVmVjdG9yMyIsIndvcmxkUGxhbmVQb3NpdGlvbiIsInBhcnNlSW50IiwiUkVWSVNJT04iLCJyZXBsYWNlIiwiR3JpZCIsImZvcndhcmRSZWYiLCJhcmdzIiwic2lkZSIsIkJhY2tTaWRlIiwicHJvcHMiLCJmUmVmIiwicmVmIiwidXNlUmVmIiwicGxhbmUiLCJQbGFuZSIsInVwVmVjdG9yIiwiemVyb1ZlY3RvciIsInN0YXRlIiwic2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQiLCJhcHBseU1hdHJpeDQiLCJjdXJyZW50IiwibWF0cml4V29ybGQiLCJncmlkTWF0ZXJpYWwiLCJtYXRlcmlhbCIsInVuaWZvcm1zIiwicHJvamVjdFBvaW50IiwiY2FtZXJhIiwicG9zaXRpb24iLCJ2YWx1ZSIsInNldCIsInVuaWZvcm1zMSIsInVuaWZvcm1zMiIsImNyZWF0ZUVsZW1lbnQiLCJmcnVzdHVtQ3VsbGVkIiwidHJhbnNwYXJlbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/Grid.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/Hud.js":
/*!****************************************************!*\
  !*** ./node_modules/@react-three/drei/core/Hud.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Hud: () => (/* binding */ Hud)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/index-673ef987.esm.js\");\n\n\n\nfunction RenderHud({ defaultScene, defaultCamera, renderPriority = 1 }) {\n    const { gl, scene, camera } = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_1__.z)();\n    let oldCLear;\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_1__.A)(()=>{\n        oldCLear = gl.autoClear;\n        if (renderPriority === 1) {\n            // Clear scene and render the default scene\n            gl.autoClear = true;\n            gl.render(defaultScene, defaultCamera);\n        } // Disable cleaning and render the portal with its own camera\n        gl.autoClear = false;\n        gl.clearDepth();\n        gl.render(scene, camera); // Restore default\n        gl.autoClear = oldCLear;\n    }, renderPriority); // Without an element that receives pointer events state.pointer will always be 0/0\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(\"group\", {\n        onPointerOver: ()=>null\n    });\n}\nfunction Hud({ children, renderPriority = 1 }) {\n    const { scene: defaultScene, camera: defaultCamera } = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_1__.z)();\n    const [hudScene] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>new three__WEBPACK_IMPORTED_MODULE_2__.Scene());\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_1__.g)(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, children, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(RenderHud, {\n        defaultScene: defaultScene,\n        defaultCamera: defaultCamera,\n        renderPriority: renderPriority\n    })), hudScene, {\n        events: {\n            priority: renderPriority + 1\n        }\n    }));\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9IdWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBK0I7QUFDQTtBQUN1QztBQUV0RSxTQUFTSyxVQUFVLEVBQ2pCQyxZQUFZLEVBQ1pDLGFBQWEsRUFDYkMsaUJBQWlCLENBQUMsRUFDbkI7SUFDQyxNQUFNLEVBQ0pDLEVBQUUsRUFDRkMsS0FBSyxFQUNMQyxNQUFNLEVBQ1AsR0FBR1QscURBQVFBO0lBQ1osSUFBSVU7SUFDSlIscURBQVFBLENBQUM7UUFDUFEsV0FBV0gsR0FBR0ksU0FBUztRQUV2QixJQUFJTCxtQkFBbUIsR0FBRztZQUN4QiwyQ0FBMkM7WUFDM0NDLEdBQUdJLFNBQVMsR0FBRztZQUNmSixHQUFHSyxNQUFNLENBQUNSLGNBQWNDO1FBQzFCLEVBQUUsNkRBQTZEO1FBRy9ERSxHQUFHSSxTQUFTLEdBQUc7UUFDZkosR0FBR00sVUFBVTtRQUNiTixHQUFHSyxNQUFNLENBQUNKLE9BQU9DLFNBQVMsa0JBQWtCO1FBRTVDRixHQUFHSSxTQUFTLEdBQUdEO0lBQ2pCLEdBQUdKLGlCQUFpQixtRkFBbUY7SUFFdkcsT0FBTyxXQUFXLEdBQUVQLGdEQUFtQixDQUFDLFNBQVM7UUFDL0NnQixlQUFlLElBQU07SUFDdkI7QUFDRjtBQUVBLFNBQVNDLElBQUksRUFDWEMsUUFBUSxFQUNSWCxpQkFBaUIsQ0FBQyxFQUNuQjtJQUNDLE1BQU0sRUFDSkUsT0FBT0osWUFBWSxFQUNuQkssUUFBUUosYUFBYSxFQUN0QixHQUFHTCxxREFBUUE7SUFDWixNQUFNLENBQUNrQixTQUFTLEdBQUduQiwyQ0FBYyxDQUFDLElBQU0sSUFBSUQsd0NBQVc7SUFDdkQsT0FBTyxXQUFXLEdBQUVDLGdEQUFtQixDQUFDQSwyQ0FBYyxFQUFFLE1BQU1FLHFEQUFZQSxDQUFFLFdBQVcsR0FBRUYsZ0RBQW1CLENBQUNBLDJDQUFjLEVBQUUsTUFBTWtCLFVBQVUsV0FBVyxHQUFFbEIsZ0RBQW1CLENBQUNJLFdBQVc7UUFDdkxDLGNBQWNBO1FBQ2RDLGVBQWVBO1FBQ2ZDLGdCQUFnQkE7SUFDbEIsS0FBS1ksVUFBVTtRQUNiSSxRQUFRO1lBQ05DLFVBQVVqQixpQkFBaUI7UUFDN0I7SUFDRjtBQUNGO0FBRWUiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aWJlLTNkLWNvZGUvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9IdWQuanM/ODg5ZCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VUaHJlZSwgY3JlYXRlUG9ydGFsLCB1c2VGcmFtZSB9IGZyb20gJ0ByZWFjdC10aHJlZS9maWJlcic7XG5cbmZ1bmN0aW9uIFJlbmRlckh1ZCh7XG4gIGRlZmF1bHRTY2VuZSxcbiAgZGVmYXVsdENhbWVyYSxcbiAgcmVuZGVyUHJpb3JpdHkgPSAxXG59KSB7XG4gIGNvbnN0IHtcbiAgICBnbCxcbiAgICBzY2VuZSxcbiAgICBjYW1lcmFcbiAgfSA9IHVzZVRocmVlKCk7XG4gIGxldCBvbGRDTGVhcjtcbiAgdXNlRnJhbWUoKCkgPT4ge1xuICAgIG9sZENMZWFyID0gZ2wuYXV0b0NsZWFyO1xuXG4gICAgaWYgKHJlbmRlclByaW9yaXR5ID09PSAxKSB7XG4gICAgICAvLyBDbGVhciBzY2VuZSBhbmQgcmVuZGVyIHRoZSBkZWZhdWx0IHNjZW5lXG4gICAgICBnbC5hdXRvQ2xlYXIgPSB0cnVlO1xuICAgICAgZ2wucmVuZGVyKGRlZmF1bHRTY2VuZSwgZGVmYXVsdENhbWVyYSk7XG4gICAgfSAvLyBEaXNhYmxlIGNsZWFuaW5nIGFuZCByZW5kZXIgdGhlIHBvcnRhbCB3aXRoIGl0cyBvd24gY2FtZXJhXG5cblxuICAgIGdsLmF1dG9DbGVhciA9IGZhbHNlO1xuICAgIGdsLmNsZWFyRGVwdGgoKTtcbiAgICBnbC5yZW5kZXIoc2NlbmUsIGNhbWVyYSk7IC8vIFJlc3RvcmUgZGVmYXVsdFxuXG4gICAgZ2wuYXV0b0NsZWFyID0gb2xkQ0xlYXI7XG4gIH0sIHJlbmRlclByaW9yaXR5KTsgLy8gV2l0aG91dCBhbiBlbGVtZW50IHRoYXQgcmVjZWl2ZXMgcG9pbnRlciBldmVudHMgc3RhdGUucG9pbnRlciB3aWxsIGFsd2F5cyBiZSAwLzBcblxuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLCB7XG4gICAgb25Qb2ludGVyT3ZlcjogKCkgPT4gbnVsbFxuICB9KTtcbn1cblxuZnVuY3Rpb24gSHVkKHtcbiAgY2hpbGRyZW4sXG4gIHJlbmRlclByaW9yaXR5ID0gMVxufSkge1xuICBjb25zdCB7XG4gICAgc2NlbmU6IGRlZmF1bHRTY2VuZSxcbiAgICBjYW1lcmE6IGRlZmF1bHRDYW1lcmFcbiAgfSA9IHVzZVRocmVlKCk7XG4gIGNvbnN0IFtodWRTY2VuZV0gPSBSZWFjdC51c2VTdGF0ZSgoKSA9PiBuZXcgVEhSRUUuU2NlbmUoKSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgY3JlYXRlUG9ydGFsKCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgY2hpbGRyZW4sIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFJlbmRlckh1ZCwge1xuICAgIGRlZmF1bHRTY2VuZTogZGVmYXVsdFNjZW5lLFxuICAgIGRlZmF1bHRDYW1lcmE6IGRlZmF1bHRDYW1lcmEsXG4gICAgcmVuZGVyUHJpb3JpdHk6IHJlbmRlclByaW9yaXR5XG4gIH0pKSwgaHVkU2NlbmUsIHtcbiAgICBldmVudHM6IHtcbiAgICAgIHByaW9yaXR5OiByZW5kZXJQcmlvcml0eSArIDFcbiAgICB9XG4gIH0pKTtcbn1cblxuZXhwb3J0IHsgSHVkIH07XG4iXSwibmFtZXMiOlsiVEhSRUUiLCJSZWFjdCIsInVzZVRocmVlIiwiY3JlYXRlUG9ydGFsIiwidXNlRnJhbWUiLCJSZW5kZXJIdWQiLCJkZWZhdWx0U2NlbmUiLCJkZWZhdWx0Q2FtZXJhIiwicmVuZGVyUHJpb3JpdHkiLCJnbCIsInNjZW5lIiwiY2FtZXJhIiwib2xkQ0xlYXIiLCJhdXRvQ2xlYXIiLCJyZW5kZXIiLCJjbGVhckRlcHRoIiwiY3JlYXRlRWxlbWVudCIsIm9uUG9pbnRlck92ZXIiLCJIdWQiLCJjaGlsZHJlbiIsImh1ZFNjZW5lIiwidXNlU3RhdGUiLCJTY2VuZSIsIkZyYWdtZW50IiwiZXZlbnRzIiwicHJpb3JpdHkiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/Hud.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/OrthographicCamera.js":
/*!*******************************************************************!*\
  !*** ./node_modules/@react-three/drei/core/OrthographicCamera.js ***!
  \*******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OrthographicCamera: () => (/* binding */ OrthographicCamera)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/index-673ef987.esm.js\");\n/* harmony import */ var react_merge_refs__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-merge-refs */ \"(ssr)/./node_modules/react-merge-refs/dist/react-merge-refs.esm.js\");\n/* harmony import */ var _useFBO_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./useFBO.js */ \"(ssr)/./node_modules/@react-three/drei/core/useFBO.js\");\n\n\n\n\n\nconst isFunction = (node)=>typeof node === \"function\";\nconst OrthographicCamera = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({ envMap, resolution = 256, frames = Infinity, children, makeDefault, ...props }, ref)=>{\n    const set = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.z)(({ set })=>set);\n    const camera = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.z)(({ camera })=>camera);\n    const size = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.z)(({ size })=>size);\n    const cameraRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    const groupRef = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    const fbo = (0,_useFBO_js__WEBPACK_IMPORTED_MODULE_4__.useFBO)(resolution);\n    react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(()=>{\n        if (!props.manual) {\n            cameraRef.current.updateProjectionMatrix();\n        }\n    }, [\n        size,\n        props\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(()=>{\n        cameraRef.current.updateProjectionMatrix();\n    });\n    react__WEBPACK_IMPORTED_MODULE_1__.useLayoutEffect(()=>{\n        if (makeDefault) {\n            const oldCam = camera;\n            set(()=>({\n                    camera: cameraRef.current\n                }));\n            return ()=>set(()=>({\n                        camera: oldCam\n                    }));\n        } // The camera should not be part of the dependency list because this components camera is a stable reference\n    // that must exchange the default, and clean up after itself on unmount.\n    }, [\n        cameraRef,\n        makeDefault,\n        set\n    ]);\n    let count = 0;\n    let oldEnvMap = null;\n    const functional = isFunction(children);\n    (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_3__.A)((state)=>{\n        if (functional && (frames === Infinity || count < frames)) {\n            groupRef.current.visible = false;\n            state.gl.setRenderTarget(fbo);\n            oldEnvMap = state.scene.background;\n            if (envMap) state.scene.background = envMap;\n            state.gl.render(state.scene, cameraRef.current);\n            state.scene.background = oldEnvMap;\n            state.gl.setRenderTarget(null);\n            groupRef.current.visible = true;\n            count++;\n        }\n    });\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(react__WEBPACK_IMPORTED_MODULE_1__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"orthographicCamera\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        left: size.width / -2,\n        right: size.width / 2,\n        top: size.height / 2,\n        bottom: size.height / -2,\n        ref: (0,react_merge_refs__WEBPACK_IMPORTED_MODULE_2__[\"default\"])([\n            cameraRef,\n            ref\n        ])\n    }, props), !functional && children), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"group\", {\n        ref: groupRef\n    }, functional && children(fbo.texture)));\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9PcnRob2dyYXBoaWNDYW1lcmEuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUEwRDtBQUMzQjtBQUN5QjtBQUNmO0FBQ0o7QUFFckMsTUFBTU0sYUFBYUMsQ0FBQUEsT0FBUSxPQUFPQSxTQUFTO0FBRTNDLE1BQU1DLHFCQUFxQixXQUFXLEdBQUVQLDZDQUFnQixDQUFDLENBQUMsRUFDeERTLE1BQU0sRUFDTkMsYUFBYSxHQUFHLEVBQ2hCQyxTQUFTQyxRQUFRLEVBQ2pCQyxRQUFRLEVBQ1JDLFdBQVcsRUFDWCxHQUFHQyxPQUNKLEVBQUVDO0lBQ0QsTUFBTUMsTUFBTWhCLHFEQUFRQSxDQUFDLENBQUMsRUFDcEJnQixHQUFHLEVBQ0osR0FBS0E7SUFDTixNQUFNQyxTQUFTakIscURBQVFBLENBQUMsQ0FBQyxFQUN2QmlCLE1BQU0sRUFDUCxHQUFLQTtJQUNOLE1BQU1DLE9BQU9sQixxREFBUUEsQ0FBQyxDQUFDLEVBQ3JCa0IsSUFBSSxFQUNMLEdBQUtBO0lBQ04sTUFBTUMsWUFBWXBCLHlDQUFZLENBQUM7SUFDL0IsTUFBTXNCLFdBQVd0Qix5Q0FBWSxDQUFDO0lBQzlCLE1BQU11QixNQUFNbkIsa0RBQU1BLENBQUNNO0lBQ25CVixrREFBcUIsQ0FBQztRQUNwQixJQUFJLENBQUNlLE1BQU1VLE1BQU0sRUFBRTtZQUNqQkwsVUFBVU0sT0FBTyxDQUFDQyxzQkFBc0I7UUFDMUM7SUFDRixHQUFHO1FBQUNSO1FBQU1KO0tBQU07SUFDaEJmLGtEQUFxQixDQUFDO1FBQ3BCb0IsVUFBVU0sT0FBTyxDQUFDQyxzQkFBc0I7SUFDMUM7SUFDQTNCLGtEQUFxQixDQUFDO1FBQ3BCLElBQUljLGFBQWE7WUFDZixNQUFNYyxTQUFTVjtZQUNmRCxJQUFJLElBQU87b0JBQ1RDLFFBQVFFLFVBQVVNLE9BQU87Z0JBQzNCO1lBQ0EsT0FBTyxJQUFNVCxJQUFJLElBQU87d0JBQ3RCQyxRQUFRVTtvQkFDVjtRQUNGLEVBQUUsNEdBQTRHO0lBQzlHLHdFQUF3RTtJQUUxRSxHQUFHO1FBQUNSO1FBQVdOO1FBQWFHO0tBQUk7SUFDaEMsSUFBSVksUUFBUTtJQUNaLElBQUlDLFlBQVk7SUFDaEIsTUFBTUMsYUFBYTFCLFdBQVdRO0lBQzlCWCxxREFBUUEsQ0FBQzhCLENBQUFBO1FBQ1AsSUFBSUQsY0FBZXBCLENBQUFBLFdBQVdDLFlBQVlpQixRQUFRbEIsTUFBSyxHQUFJO1lBQ3pEVyxTQUFTSSxPQUFPLENBQUNPLE9BQU8sR0FBRztZQUMzQkQsTUFBTUUsRUFBRSxDQUFDQyxlQUFlLENBQUNaO1lBQ3pCTyxZQUFZRSxNQUFNSSxLQUFLLENBQUNDLFVBQVU7WUFDbEMsSUFBSTVCLFFBQVF1QixNQUFNSSxLQUFLLENBQUNDLFVBQVUsR0FBRzVCO1lBQ3JDdUIsTUFBTUUsRUFBRSxDQUFDSSxNQUFNLENBQUNOLE1BQU1JLEtBQUssRUFBRWhCLFVBQVVNLE9BQU87WUFDOUNNLE1BQU1JLEtBQUssQ0FBQ0MsVUFBVSxHQUFHUDtZQUN6QkUsTUFBTUUsRUFBRSxDQUFDQyxlQUFlLENBQUM7WUFDekJiLFNBQVNJLE9BQU8sQ0FBQ08sT0FBTyxHQUFHO1lBQzNCSjtRQUNGO0lBQ0Y7SUFDQSxPQUFPLFdBQVcsR0FBRTdCLGdEQUFtQixDQUFDQSwyQ0FBYyxFQUFFLE1BQU0sV0FBVyxHQUFFQSxnREFBbUIsQ0FBQyxzQkFBc0JELDhFQUFRQSxDQUFDO1FBQzVIMEMsTUFBTXRCLEtBQUt1QixLQUFLLEdBQUcsQ0FBQztRQUNwQkMsT0FBT3hCLEtBQUt1QixLQUFLLEdBQUc7UUFDcEJFLEtBQUt6QixLQUFLMEIsTUFBTSxHQUFHO1FBQ25CQyxRQUFRM0IsS0FBSzBCLE1BQU0sR0FBRyxDQUFDO1FBQ3ZCN0IsS0FBS2IsNERBQVNBLENBQUM7WUFBQ2lCO1lBQVdKO1NBQUk7SUFDakMsR0FBR0QsUUFBUSxDQUFDZ0IsY0FBY2xCLFdBQVcsV0FBVyxHQUFFYixnREFBbUIsQ0FBQyxTQUFTO1FBQzdFZ0IsS0FBS007SUFDUCxHQUFHUyxjQUFjbEIsU0FBU1UsSUFBSXdCLE9BQU87QUFDdkM7QUFFOEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aWJlLTNkLWNvZGUvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9PcnRob2dyYXBoaWNDYW1lcmEuanM/MDMyNCJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgX2V4dGVuZHMgZnJvbSAnQGJhYmVsL3J1bnRpbWUvaGVscGVycy9lc20vZXh0ZW5kcyc7XG5pbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgeyB1c2VUaHJlZSwgdXNlRnJhbWUgfSBmcm9tICdAcmVhY3QtdGhyZWUvZmliZXInO1xuaW1wb3J0IG1lcmdlUmVmcyBmcm9tICdyZWFjdC1tZXJnZS1yZWZzJztcbmltcG9ydCB7IHVzZUZCTyB9IGZyb20gJy4vdXNlRkJPLmpzJztcblxuY29uc3QgaXNGdW5jdGlvbiA9IG5vZGUgPT4gdHlwZW9mIG5vZGUgPT09ICdmdW5jdGlvbic7XG5cbmNvbnN0IE9ydGhvZ3JhcGhpY0NhbWVyYSA9IC8qI19fUFVSRV9fKi9SZWFjdC5mb3J3YXJkUmVmKCh7XG4gIGVudk1hcCxcbiAgcmVzb2x1dGlvbiA9IDI1NixcbiAgZnJhbWVzID0gSW5maW5pdHksXG4gIGNoaWxkcmVuLFxuICBtYWtlRGVmYXVsdCxcbiAgLi4ucHJvcHNcbn0sIHJlZikgPT4ge1xuICBjb25zdCBzZXQgPSB1c2VUaHJlZSgoe1xuICAgIHNldFxuICB9KSA9PiBzZXQpO1xuICBjb25zdCBjYW1lcmEgPSB1c2VUaHJlZSgoe1xuICAgIGNhbWVyYVxuICB9KSA9PiBjYW1lcmEpO1xuICBjb25zdCBzaXplID0gdXNlVGhyZWUoKHtcbiAgICBzaXplXG4gIH0pID0+IHNpemUpO1xuICBjb25zdCBjYW1lcmFSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IGdyb3VwUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBmYm8gPSB1c2VGQk8ocmVzb2x1dGlvbik7XG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKCFwcm9wcy5tYW51YWwpIHtcbiAgICAgIGNhbWVyYVJlZi5jdXJyZW50LnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgICB9XG4gIH0sIFtzaXplLCBwcm9wc10pO1xuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGNhbWVyYVJlZi5jdXJyZW50LnVwZGF0ZVByb2plY3Rpb25NYXRyaXgoKTtcbiAgfSk7XG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKG1ha2VEZWZhdWx0KSB7XG4gICAgICBjb25zdCBvbGRDYW0gPSBjYW1lcmE7XG4gICAgICBzZXQoKCkgPT4gKHtcbiAgICAgICAgY2FtZXJhOiBjYW1lcmFSZWYuY3VycmVudFxuICAgICAgfSkpO1xuICAgICAgcmV0dXJuICgpID0+IHNldCgoKSA9PiAoe1xuICAgICAgICBjYW1lcmE6IG9sZENhbVxuICAgICAgfSkpO1xuICAgIH0gLy8gVGhlIGNhbWVyYSBzaG91bGQgbm90IGJlIHBhcnQgb2YgdGhlIGRlcGVuZGVuY3kgbGlzdCBiZWNhdXNlIHRoaXMgY29tcG9uZW50cyBjYW1lcmEgaXMgYSBzdGFibGUgcmVmZXJlbmNlXG4gICAgLy8gdGhhdCBtdXN0IGV4Y2hhbmdlIHRoZSBkZWZhdWx0LCBhbmQgY2xlYW4gdXAgYWZ0ZXIgaXRzZWxmIG9uIHVubW91bnQuXG5cbiAgfSwgW2NhbWVyYVJlZiwgbWFrZURlZmF1bHQsIHNldF0pO1xuICBsZXQgY291bnQgPSAwO1xuICBsZXQgb2xkRW52TWFwID0gbnVsbDtcbiAgY29uc3QgZnVuY3Rpb25hbCA9IGlzRnVuY3Rpb24oY2hpbGRyZW4pO1xuICB1c2VGcmFtZShzdGF0ZSA9PiB7XG4gICAgaWYgKGZ1bmN0aW9uYWwgJiYgKGZyYW1lcyA9PT0gSW5maW5pdHkgfHwgY291bnQgPCBmcmFtZXMpKSB7XG4gICAgICBncm91cFJlZi5jdXJyZW50LnZpc2libGUgPSBmYWxzZTtcbiAgICAgIHN0YXRlLmdsLnNldFJlbmRlclRhcmdldChmYm8pO1xuICAgICAgb2xkRW52TWFwID0gc3RhdGUuc2NlbmUuYmFja2dyb3VuZDtcbiAgICAgIGlmIChlbnZNYXApIHN0YXRlLnNjZW5lLmJhY2tncm91bmQgPSBlbnZNYXA7XG4gICAgICBzdGF0ZS5nbC5yZW5kZXIoc3RhdGUuc2NlbmUsIGNhbWVyYVJlZi5jdXJyZW50KTtcbiAgICAgIHN0YXRlLnNjZW5lLmJhY2tncm91bmQgPSBvbGRFbnZNYXA7XG4gICAgICBzdGF0ZS5nbC5zZXRSZW5kZXJUYXJnZXQobnVsbCk7XG4gICAgICBncm91cFJlZi5jdXJyZW50LnZpc2libGUgPSB0cnVlO1xuICAgICAgY291bnQrKztcbiAgICB9XG4gIH0pO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwib3J0aG9ncmFwaGljQ2FtZXJhXCIsIF9leHRlbmRzKHtcbiAgICBsZWZ0OiBzaXplLndpZHRoIC8gLTIsXG4gICAgcmlnaHQ6IHNpemUud2lkdGggLyAyLFxuICAgIHRvcDogc2l6ZS5oZWlnaHQgLyAyLFxuICAgIGJvdHRvbTogc2l6ZS5oZWlnaHQgLyAtMixcbiAgICByZWY6IG1lcmdlUmVmcyhbY2FtZXJhUmVmLCByZWZdKVxuICB9LCBwcm9wcyksICFmdW5jdGlvbmFsICYmIGNoaWxkcmVuKSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJncm91cFwiLCB7XG4gICAgcmVmOiBncm91cFJlZlxuICB9LCBmdW5jdGlvbmFsICYmIGNoaWxkcmVuKGZiby50ZXh0dXJlKSkpO1xufSk7XG5cbmV4cG9ydCB7IE9ydGhvZ3JhcGhpY0NhbWVyYSB9O1xuIl0sIm5hbWVzIjpbIl9leHRlbmRzIiwiUmVhY3QiLCJ1c2VUaHJlZSIsInVzZUZyYW1lIiwibWVyZ2VSZWZzIiwidXNlRkJPIiwiaXNGdW5jdGlvbiIsIm5vZGUiLCJPcnRob2dyYXBoaWNDYW1lcmEiLCJmb3J3YXJkUmVmIiwiZW52TWFwIiwicmVzb2x1dGlvbiIsImZyYW1lcyIsIkluZmluaXR5IiwiY2hpbGRyZW4iLCJtYWtlRGVmYXVsdCIsInByb3BzIiwicmVmIiwic2V0IiwiY2FtZXJhIiwic2l6ZSIsImNhbWVyYVJlZiIsInVzZVJlZiIsImdyb3VwUmVmIiwiZmJvIiwidXNlTGF5b3V0RWZmZWN0IiwibWFudWFsIiwiY3VycmVudCIsInVwZGF0ZVByb2plY3Rpb25NYXRyaXgiLCJvbGRDYW0iLCJjb3VudCIsIm9sZEVudk1hcCIsImZ1bmN0aW9uYWwiLCJzdGF0ZSIsInZpc2libGUiLCJnbCIsInNldFJlbmRlclRhcmdldCIsInNjZW5lIiwiYmFja2dyb3VuZCIsInJlbmRlciIsImNyZWF0ZUVsZW1lbnQiLCJGcmFnbWVudCIsImxlZnQiLCJ3aWR0aCIsInJpZ2h0IiwidG9wIiwiaGVpZ2h0IiwiYm90dG9tIiwidGV4dHVyZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/OrthographicCamera.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/Sky.js":
/*!****************************************************!*\
  !*** ./node_modules/@react-three/drei/core/Sky.js ***!
  \****************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Sky: () => (/* binding */ Sky),\n/* harmony export */   calcPosFromAngles: () => (/* binding */ calcPosFromAngles)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/objects/Sky.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n\n\n\n\nfunction calcPosFromAngles(inclination, azimuth, vector = new three__WEBPACK_IMPORTED_MODULE_2__.Vector3()) {\n    const theta = Math.PI * (inclination - 0.5);\n    const phi = 2 * Math.PI * (azimuth - 0.5);\n    vector.x = Math.cos(phi);\n    vector.y = Math.sin(theta);\n    vector.z = Math.sin(phi);\n    return vector;\n}\nconst Sky = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({ inclination = 0.6, azimuth = 0.1, distance = 1000, mieCoefficient = 0.005, mieDirectionalG = 0.8, rayleigh = 0.5, turbidity = 10, sunPosition = calcPosFromAngles(inclination, azimuth), ...props }, ref)=>{\n    const scale = react__WEBPACK_IMPORTED_MODULE_1__.useMemo(()=>new three__WEBPACK_IMPORTED_MODULE_2__.Vector3().setScalar(distance), [\n        distance\n    ]);\n    const [sky] = react__WEBPACK_IMPORTED_MODULE_1__.useState(()=>new three_stdlib__WEBPACK_IMPORTED_MODULE_3__.Sky());\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"primitive\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        object: sky,\n        ref: ref,\n        \"material-uniforms-mieCoefficient-value\": mieCoefficient,\n        \"material-uniforms-mieDirectionalG-value\": mieDirectionalG,\n        \"material-uniforms-rayleigh-value\": rayleigh,\n        \"material-uniforms-sunPosition-value\": sunPosition,\n        \"material-uniforms-turbidity-value\": turbidity,\n        scale: scale\n    }, props));\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9Ta3kuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7OztBQUEwRDtBQUMzQjtBQUNhO0FBQ1o7QUFFaEMsU0FBU0ssa0JBQWtCQyxXQUFXLEVBQUVDLE9BQU8sRUFBRUMsU0FBUyxJQUFJSiwwQ0FBT0EsRUFBRTtJQUNyRSxNQUFNSyxRQUFRQyxLQUFLQyxFQUFFLEdBQUlMLENBQUFBLGNBQWMsR0FBRTtJQUN6QyxNQUFNTSxNQUFNLElBQUlGLEtBQUtDLEVBQUUsR0FBSUosQ0FBQUEsVUFBVSxHQUFFO0lBQ3ZDQyxPQUFPSyxDQUFDLEdBQUdILEtBQUtJLEdBQUcsQ0FBQ0Y7SUFDcEJKLE9BQU9PLENBQUMsR0FBR0wsS0FBS00sR0FBRyxDQUFDUDtJQUNwQkQsT0FBT1MsQ0FBQyxHQUFHUCxLQUFLTSxHQUFHLENBQUNKO0lBQ3BCLE9BQU9KO0FBQ1Q7QUFDQSxNQUFNTixNQUFNLFdBQVcsR0FBRUQsNkNBQWdCLENBQUMsQ0FBQyxFQUN6Q0ssY0FBYyxHQUFHLEVBQ2pCQyxVQUFVLEdBQUcsRUFDYlksV0FBVyxJQUFJLEVBQ2ZDLGlCQUFpQixLQUFLLEVBQ3RCQyxrQkFBa0IsR0FBRyxFQUNyQkMsV0FBVyxHQUFHLEVBQ2RDLFlBQVksRUFBRSxFQUNkQyxjQUFjbkIsa0JBQWtCQyxhQUFhQyxRQUFRLEVBQ3JELEdBQUdrQixPQUNKLEVBQUVDO0lBQ0QsTUFBTUMsUUFBUTFCLDBDQUFhLENBQUMsSUFBTSxJQUFJRywwQ0FBT0EsR0FBR3lCLFNBQVMsQ0FBQ1YsV0FBVztRQUFDQTtLQUFTO0lBQy9FLE1BQU0sQ0FBQ1csSUFBSSxHQUFHN0IsMkNBQWMsQ0FBQyxJQUFNLElBQUlFLDZDQUFLQTtJQUM1QyxPQUFPLFdBQVcsR0FBRUYsZ0RBQW1CLENBQUMsYUFBYUQsOEVBQVFBLENBQUM7UUFDNURpQyxRQUFRSDtRQUNSSixLQUFLQTtRQUNMLDBDQUEwQ047UUFDMUMsMkNBQTJDQztRQUMzQyxvQ0FBb0NDO1FBQ3BDLHVDQUF1Q0U7UUFDdkMscUNBQXFDRDtRQUNyQ0ksT0FBT0E7SUFDVCxHQUFHRjtBQUNMO0FBRWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmliZS0zZC1jb2RlLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL2NvcmUvU2t5LmpzPzJjMmIiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9leHRlbmRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgU2t5IGFzIFNreSQxIH0gZnJvbSAndGhyZWUtc3RkbGliJztcbmltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICd0aHJlZSc7XG5cbmZ1bmN0aW9uIGNhbGNQb3NGcm9tQW5nbGVzKGluY2xpbmF0aW9uLCBhemltdXRoLCB2ZWN0b3IgPSBuZXcgVmVjdG9yMygpKSB7XG4gIGNvbnN0IHRoZXRhID0gTWF0aC5QSSAqIChpbmNsaW5hdGlvbiAtIDAuNSk7XG4gIGNvbnN0IHBoaSA9IDIgKiBNYXRoLlBJICogKGF6aW11dGggLSAwLjUpO1xuICB2ZWN0b3IueCA9IE1hdGguY29zKHBoaSk7XG4gIHZlY3Rvci55ID0gTWF0aC5zaW4odGhldGEpO1xuICB2ZWN0b3IueiA9IE1hdGguc2luKHBoaSk7XG4gIHJldHVybiB2ZWN0b3I7XG59XG5jb25zdCBTa3kgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZigoe1xuICBpbmNsaW5hdGlvbiA9IDAuNixcbiAgYXppbXV0aCA9IDAuMSxcbiAgZGlzdGFuY2UgPSAxMDAwLFxuICBtaWVDb2VmZmljaWVudCA9IDAuMDA1LFxuICBtaWVEaXJlY3Rpb25hbEcgPSAwLjgsXG4gIHJheWxlaWdoID0gMC41LFxuICB0dXJiaWRpdHkgPSAxMCxcbiAgc3VuUG9zaXRpb24gPSBjYWxjUG9zRnJvbUFuZ2xlcyhpbmNsaW5hdGlvbiwgYXppbXV0aCksXG4gIC4uLnByb3BzXG59LCByZWYpID0+IHtcbiAgY29uc3Qgc2NhbGUgPSBSZWFjdC51c2VNZW1vKCgpID0+IG5ldyBWZWN0b3IzKCkuc2V0U2NhbGFyKGRpc3RhbmNlKSwgW2Rpc3RhbmNlXSk7XG4gIGNvbnN0IFtza3ldID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gbmV3IFNreSQxKCkpO1xuICByZXR1cm4gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoXCJwcmltaXRpdmVcIiwgX2V4dGVuZHMoe1xuICAgIG9iamVjdDogc2t5LFxuICAgIHJlZjogcmVmLFxuICAgIFwibWF0ZXJpYWwtdW5pZm9ybXMtbWllQ29lZmZpY2llbnQtdmFsdWVcIjogbWllQ29lZmZpY2llbnQsXG4gICAgXCJtYXRlcmlhbC11bmlmb3Jtcy1taWVEaXJlY3Rpb25hbEctdmFsdWVcIjogbWllRGlyZWN0aW9uYWxHLFxuICAgIFwibWF0ZXJpYWwtdW5pZm9ybXMtcmF5bGVpZ2gtdmFsdWVcIjogcmF5bGVpZ2gsXG4gICAgXCJtYXRlcmlhbC11bmlmb3Jtcy1zdW5Qb3NpdGlvbi12YWx1ZVwiOiBzdW5Qb3NpdGlvbixcbiAgICBcIm1hdGVyaWFsLXVuaWZvcm1zLXR1cmJpZGl0eS12YWx1ZVwiOiB0dXJiaWRpdHksXG4gICAgc2NhbGU6IHNjYWxlXG4gIH0sIHByb3BzKSk7XG59KTtcblxuZXhwb3J0IHsgU2t5LCBjYWxjUG9zRnJvbUFuZ2xlcyB9O1xuIl0sIm5hbWVzIjpbIl9leHRlbmRzIiwiUmVhY3QiLCJTa3kiLCJTa3kkMSIsIlZlY3RvcjMiLCJjYWxjUG9zRnJvbUFuZ2xlcyIsImluY2xpbmF0aW9uIiwiYXppbXV0aCIsInZlY3RvciIsInRoZXRhIiwiTWF0aCIsIlBJIiwicGhpIiwieCIsImNvcyIsInkiLCJzaW4iLCJ6IiwiZm9yd2FyZFJlZiIsImRpc3RhbmNlIiwibWllQ29lZmZpY2llbnQiLCJtaWVEaXJlY3Rpb25hbEciLCJyYXlsZWlnaCIsInR1cmJpZGl0eSIsInN1blBvc2l0aW9uIiwicHJvcHMiLCJyZWYiLCJzY2FsZSIsInVzZU1lbW8iLCJzZXRTY2FsYXIiLCJza3kiLCJ1c2VTdGF0ZSIsImNyZWF0ZUVsZW1lbnQiLCJvYmplY3QiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/Sky.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/TransformControls.js":
/*!******************************************************************!*\
  !*** ./node_modules/@react-three/drei/core/TransformControls.js ***!
  \******************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   TransformControls: () => (/* binding */ TransformControls)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/index-673ef987.esm.js\");\n/* harmony import */ var lodash_omit__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! lodash.omit */ \"(ssr)/./node_modules/lodash.omit/index.js\");\n/* harmony import */ var lodash_omit__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(lodash_omit__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var lodash_pick__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! lodash.pick */ \"(ssr)/./node_modules/lodash.pick/index.js\");\n/* harmony import */ var lodash_pick__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(lodash_pick__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_3___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_3__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var three_stdlib__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three-stdlib */ \"(ssr)/./node_modules/three-stdlib/controls/TransformControls.js\");\n\n\n\n\n\n\n\nconst TransformControls = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3__.forwardRef(({ children, domElement, onChange, onMouseDown, onMouseUp, onObjectChange, object, makeDefault, ...props }, ref)=>{\n    const transformOnlyPropNames = [\n        \"enabled\",\n        \"axis\",\n        \"mode\",\n        \"translationSnap\",\n        \"rotationSnap\",\n        \"scaleSnap\",\n        \"space\",\n        \"size\",\n        \"showX\",\n        \"showY\",\n        \"showZ\"\n    ];\n    const { camera, ...rest } = props;\n    const transformProps = lodash_pick__WEBPACK_IMPORTED_MODULE_2___default()(rest, transformOnlyPropNames);\n    const objectProps = lodash_omit__WEBPACK_IMPORTED_MODULE_1___default()(rest, transformOnlyPropNames); // @ts-expect-error new in @react-three/fiber@7.0.5\n    const defaultControls = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.z)((state)=>state.controls);\n    const gl = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.z)((state)=>state.gl);\n    const events = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.z)((state)=>state.events);\n    const defaultCamera = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.z)((state)=>state.camera);\n    const invalidate = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.z)((state)=>state.invalidate);\n    const get = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.z)((state)=>state.get);\n    const set = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.z)((state)=>state.set);\n    const explCamera = camera || defaultCamera;\n    const explDomElement = domElement || events.connected || gl.domElement;\n    const controls = react__WEBPACK_IMPORTED_MODULE_3__.useMemo(()=>new three_stdlib__WEBPACK_IMPORTED_MODULE_5__.TransformControls(explCamera, explDomElement), [\n        explCamera,\n        explDomElement\n    ]);\n    const group = react__WEBPACK_IMPORTED_MODULE_3__.useRef();\n    react__WEBPACK_IMPORTED_MODULE_3__.useLayoutEffect(()=>{\n        if (object) {\n            controls.attach(object instanceof three__WEBPACK_IMPORTED_MODULE_6__.Object3D ? object : object.current);\n        } else if (group.current instanceof three__WEBPACK_IMPORTED_MODULE_6__.Object3D) {\n            controls.attach(group.current);\n        }\n        return ()=>void controls.detach();\n    }, [\n        object,\n        children,\n        controls\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_3__.useEffect(()=>{\n        if (defaultControls) {\n            const callback = (event)=>defaultControls.enabled = !event.value;\n            controls.addEventListener(\"dragging-changed\", callback);\n            return ()=>controls.removeEventListener(\"dragging-changed\", callback);\n        }\n    }, [\n        controls,\n        defaultControls\n    ]);\n    const onChangeRef = react__WEBPACK_IMPORTED_MODULE_3__.useRef();\n    const onMouseDownRef = react__WEBPACK_IMPORTED_MODULE_3__.useRef();\n    const onMouseUpRef = react__WEBPACK_IMPORTED_MODULE_3__.useRef();\n    const onObjectChangeRef = react__WEBPACK_IMPORTED_MODULE_3__.useRef();\n    react__WEBPACK_IMPORTED_MODULE_3__.useLayoutEffect(()=>void (onChangeRef.current = onChange), [\n        onChange\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_3__.useLayoutEffect(()=>void (onMouseDownRef.current = onMouseDown), [\n        onMouseDown\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_3__.useLayoutEffect(()=>void (onMouseUpRef.current = onMouseUp), [\n        onMouseUp\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_3__.useLayoutEffect(()=>void (onObjectChangeRef.current = onObjectChange), [\n        onObjectChange\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_3__.useEffect(()=>{\n        const onChange = (e)=>{\n            invalidate();\n            onChangeRef.current == null ? void 0 : onChangeRef.current(e);\n        };\n        const onMouseDown = (e)=>onMouseDownRef.current == null ? void 0 : onMouseDownRef.current(e);\n        const onMouseUp = (e)=>onMouseUpRef.current == null ? void 0 : onMouseUpRef.current(e);\n        const onObjectChange = (e)=>onObjectChangeRef.current == null ? void 0 : onObjectChangeRef.current(e);\n        controls.addEventListener(\"change\", onChange);\n        controls.addEventListener(\"mouseDown\", onMouseDown);\n        controls.addEventListener(\"mouseUp\", onMouseUp);\n        controls.addEventListener(\"objectChange\", onObjectChange);\n        return ()=>{\n            controls.removeEventListener(\"change\", onChange);\n            controls.removeEventListener(\"mouseDown\", onMouseDown);\n            controls.removeEventListener(\"mouseUp\", onMouseUp);\n            controls.removeEventListener(\"objectChange\", onObjectChange);\n        };\n    }, [\n        invalidate,\n        controls\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_3__.useEffect(()=>{\n        if (makeDefault) {\n            const old = get().controls;\n            set({\n                controls\n            });\n            return ()=>set({\n                    controls: old\n                });\n        }\n    }, [\n        makeDefault,\n        controls\n    ]);\n    return controls ? /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3__.createElement(react__WEBPACK_IMPORTED_MODULE_3__.Fragment, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3__.createElement(\"primitive\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        ref: ref,\n        object: controls\n    }, transformProps)), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_3__.createElement(\"group\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        ref: group\n    }, objectProps), children)) : null;\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9UcmFuc2Zvcm1Db250cm9scy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7OztBQUEwRDtBQUNaO0FBQ2Y7QUFDQTtBQUNBO0FBQ0E7QUFDeUM7QUFFeEUsTUFBTU0sb0JBQW9CLFdBQVcsR0FBRUYsNkNBQWdCLENBQUMsQ0FBQyxFQUN2REssUUFBUSxFQUNSQyxVQUFVLEVBQ1ZDLFFBQVEsRUFDUkMsV0FBVyxFQUNYQyxTQUFTLEVBQ1RDLGNBQWMsRUFDZEMsTUFBTSxFQUNOQyxXQUFXLEVBQ1gsR0FBR0MsT0FDSixFQUFFQztJQUNELE1BQU1DLHlCQUF5QjtRQUFDO1FBQVc7UUFBUTtRQUFRO1FBQW1CO1FBQWdCO1FBQWE7UUFBUztRQUFRO1FBQVM7UUFBUztLQUFRO0lBQ3RKLE1BQU0sRUFDSkMsTUFBTSxFQUNOLEdBQUdDLE1BQ0osR0FBR0o7SUFDSixNQUFNSyxpQkFBaUJuQixrREFBSUEsQ0FBQ2tCLE1BQU1GO0lBQ2xDLE1BQU1JLGNBQWNyQixrREFBSUEsQ0FBQ21CLE1BQU1GLHlCQUF5QixtREFBbUQ7SUFFM0csTUFBTUssa0JBQWtCdkIscURBQVFBLENBQUN3QixDQUFBQSxRQUFTQSxNQUFNQyxRQUFRO0lBQ3hELE1BQU1DLEtBQUsxQixxREFBUUEsQ0FBQ3dCLENBQUFBLFFBQVNBLE1BQU1FLEVBQUU7SUFDckMsTUFBTUMsU0FBUzNCLHFEQUFRQSxDQUFDd0IsQ0FBQUEsUUFBU0EsTUFBTUcsTUFBTTtJQUM3QyxNQUFNQyxnQkFBZ0I1QixxREFBUUEsQ0FBQ3dCLENBQUFBLFFBQVNBLE1BQU1MLE1BQU07SUFDcEQsTUFBTVUsYUFBYTdCLHFEQUFRQSxDQUFDd0IsQ0FBQUEsUUFBU0EsTUFBTUssVUFBVTtJQUNyRCxNQUFNQyxNQUFNOUIscURBQVFBLENBQUN3QixDQUFBQSxRQUFTQSxNQUFNTSxHQUFHO0lBQ3ZDLE1BQU1DLE1BQU0vQixxREFBUUEsQ0FBQ3dCLENBQUFBLFFBQVNBLE1BQU1PLEdBQUc7SUFDdkMsTUFBTUMsYUFBYWIsVUFBVVM7SUFDN0IsTUFBTUssaUJBQWlCeEIsY0FBY2tCLE9BQU9PLFNBQVMsSUFBSVIsR0FBR2pCLFVBQVU7SUFDdEUsTUFBTWdCLFdBQVd0QiwwQ0FBYSxDQUFDLElBQU0sSUFBSUcsMkRBQW1CQSxDQUFDMEIsWUFBWUMsaUJBQWlCO1FBQUNEO1FBQVlDO0tBQWU7SUFDdEgsTUFBTUcsUUFBUWpDLHlDQUFZO0lBQzFCQSxrREFBcUIsQ0FBQztRQUNwQixJQUFJVyxRQUFRO1lBQ1ZXLFNBQVNjLE1BQU0sQ0FBQ3pCLGtCQUFrQlYsMkNBQWMsR0FBR1UsU0FBU0EsT0FBTzJCLE9BQU87UUFDNUUsT0FBTyxJQUFJTCxNQUFNSyxPQUFPLFlBQVlyQywyQ0FBYyxFQUFFO1lBQ2xEcUIsU0FBU2MsTUFBTSxDQUFDSCxNQUFNSyxPQUFPO1FBQy9CO1FBRUEsT0FBTyxJQUFNLEtBQUtoQixTQUFTaUIsTUFBTTtJQUNuQyxHQUFHO1FBQUM1QjtRQUFRTjtRQUFVaUI7S0FBUztJQUMvQnRCLDRDQUFlLENBQUM7UUFDZCxJQUFJb0IsaUJBQWlCO1lBQ25CLE1BQU1xQixXQUFXQyxDQUFBQSxRQUFTdEIsZ0JBQWdCdUIsT0FBTyxHQUFHLENBQUNELE1BQU1FLEtBQUs7WUFFaEV0QixTQUFTdUIsZ0JBQWdCLENBQUMsb0JBQW9CSjtZQUM5QyxPQUFPLElBQU1uQixTQUFTd0IsbUJBQW1CLENBQUMsb0JBQW9CTDtRQUNoRTtJQUNGLEdBQUc7UUFBQ25CO1FBQVVGO0tBQWdCO0lBQzlCLE1BQU0yQixjQUFjL0MseUNBQVk7SUFDaEMsTUFBTWdELGlCQUFpQmhELHlDQUFZO0lBQ25DLE1BQU1pRCxlQUFlakQseUNBQVk7SUFDakMsTUFBTWtELG9CQUFvQmxELHlDQUFZO0lBQ3RDQSxrREFBcUIsQ0FBQyxJQUFNLEtBQU0rQyxDQUFBQSxZQUFZVCxPQUFPLEdBQUcvQixRQUFPLEdBQUk7UUFBQ0E7S0FBUztJQUM3RVAsa0RBQXFCLENBQUMsSUFBTSxLQUFNZ0QsQ0FBQUEsZUFBZVYsT0FBTyxHQUFHOUIsV0FBVSxHQUFJO1FBQUNBO0tBQVk7SUFDdEZSLGtEQUFxQixDQUFDLElBQU0sS0FBTWlELENBQUFBLGFBQWFYLE9BQU8sR0FBRzdCLFNBQVEsR0FBSTtRQUFDQTtLQUFVO0lBQ2hGVCxrREFBcUIsQ0FBQyxJQUFNLEtBQU1rRCxDQUFBQSxrQkFBa0JaLE9BQU8sR0FBRzVCLGNBQWEsR0FBSTtRQUFDQTtLQUFlO0lBQy9GViw0Q0FBZSxDQUFDO1FBQ2QsTUFBTU8sV0FBVzRDLENBQUFBO1lBQ2Z6QjtZQUNBcUIsWUFBWVQsT0FBTyxJQUFJLE9BQU8sS0FBSyxJQUFJUyxZQUFZVCxPQUFPLENBQUNhO1FBQzdEO1FBRUEsTUFBTTNDLGNBQWMyQyxDQUFBQSxJQUFLSCxlQUFlVixPQUFPLElBQUksT0FBTyxLQUFLLElBQUlVLGVBQWVWLE9BQU8sQ0FBQ2E7UUFFMUYsTUFBTTFDLFlBQVkwQyxDQUFBQSxJQUFLRixhQUFhWCxPQUFPLElBQUksT0FBTyxLQUFLLElBQUlXLGFBQWFYLE9BQU8sQ0FBQ2E7UUFFcEYsTUFBTXpDLGlCQUFpQnlDLENBQUFBLElBQUtELGtCQUFrQlosT0FBTyxJQUFJLE9BQU8sS0FBSyxJQUFJWSxrQkFBa0JaLE9BQU8sQ0FBQ2E7UUFFbkc3QixTQUFTdUIsZ0JBQWdCLENBQUMsVUFBVXRDO1FBQ3BDZSxTQUFTdUIsZ0JBQWdCLENBQUMsYUFBYXJDO1FBQ3ZDYyxTQUFTdUIsZ0JBQWdCLENBQUMsV0FBV3BDO1FBQ3JDYSxTQUFTdUIsZ0JBQWdCLENBQUMsZ0JBQWdCbkM7UUFDMUMsT0FBTztZQUNMWSxTQUFTd0IsbUJBQW1CLENBQUMsVUFBVXZDO1lBQ3ZDZSxTQUFTd0IsbUJBQW1CLENBQUMsYUFBYXRDO1lBQzFDYyxTQUFTd0IsbUJBQW1CLENBQUMsV0FBV3JDO1lBQ3hDYSxTQUFTd0IsbUJBQW1CLENBQUMsZ0JBQWdCcEM7UUFDL0M7SUFDRixHQUFHO1FBQUNnQjtRQUFZSjtLQUFTO0lBQ3pCdEIsNENBQWUsQ0FBQztRQUNkLElBQUlZLGFBQWE7WUFDZixNQUFNd0MsTUFBTXpCLE1BQU1MLFFBQVE7WUFDMUJNLElBQUk7Z0JBQ0ZOO1lBQ0Y7WUFDQSxPQUFPLElBQU1NLElBQUk7b0JBQ2ZOLFVBQVU4QjtnQkFDWjtRQUNGO0lBQ0YsR0FBRztRQUFDeEM7UUFBYVU7S0FBUztJQUMxQixPQUFPQSxXQUFXLFdBQVcsR0FBRXRCLGdEQUFtQixDQUFDQSwyQ0FBYyxFQUFFLE1BQU0sV0FBVyxHQUFFQSxnREFBbUIsQ0FBQyxhQUFhSiw4RUFBUUEsQ0FBQztRQUM5SGtCLEtBQUtBO1FBQ0xILFFBQVFXO0lBQ1YsR0FBR0osa0JBQWtCLFdBQVcsR0FBRWxCLGdEQUFtQixDQUFDLFNBQVNKLDhFQUFRQSxDQUFDO1FBQ3RFa0IsS0FBS21CO0lBQ1AsR0FBR2QsY0FBY2QsYUFBYTtBQUNoQztBQUU2QiIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpYmUtM2QtY29kZS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9jb3JlL1RyYW5zZm9ybUNvbnRyb2xzLmpzPzFhZGQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9leHRlbmRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO1xuaW1wb3J0IHsgdXNlVGhyZWUgfSBmcm9tICdAcmVhY3QtdGhyZWUvZmliZXInO1xuaW1wb3J0IG9taXQgZnJvbSAnbG9kYXNoLm9taXQnO1xuaW1wb3J0IHBpY2sgZnJvbSAnbG9kYXNoLnBpY2snO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0ICogYXMgVEhSRUUgZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgVHJhbnNmb3JtQ29udHJvbHMgYXMgVHJhbnNmb3JtQ29udHJvbHMkMSB9IGZyb20gJ3RocmVlLXN0ZGxpYic7XG5cbmNvbnN0IFRyYW5zZm9ybUNvbnRyb2xzID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoKHtcbiAgY2hpbGRyZW4sXG4gIGRvbUVsZW1lbnQsXG4gIG9uQ2hhbmdlLFxuICBvbk1vdXNlRG93bixcbiAgb25Nb3VzZVVwLFxuICBvbk9iamVjdENoYW5nZSxcbiAgb2JqZWN0LFxuICBtYWtlRGVmYXVsdCxcbiAgLi4ucHJvcHNcbn0sIHJlZikgPT4ge1xuICBjb25zdCB0cmFuc2Zvcm1Pbmx5UHJvcE5hbWVzID0gWydlbmFibGVkJywgJ2F4aXMnLCAnbW9kZScsICd0cmFuc2xhdGlvblNuYXAnLCAncm90YXRpb25TbmFwJywgJ3NjYWxlU25hcCcsICdzcGFjZScsICdzaXplJywgJ3Nob3dYJywgJ3Nob3dZJywgJ3Nob3daJ107XG4gIGNvbnN0IHtcbiAgICBjYW1lcmEsXG4gICAgLi4ucmVzdFxuICB9ID0gcHJvcHM7XG4gIGNvbnN0IHRyYW5zZm9ybVByb3BzID0gcGljayhyZXN0LCB0cmFuc2Zvcm1Pbmx5UHJvcE5hbWVzKTtcbiAgY29uc3Qgb2JqZWN0UHJvcHMgPSBvbWl0KHJlc3QsIHRyYW5zZm9ybU9ubHlQcm9wTmFtZXMpOyAvLyBAdHMtZXhwZWN0LWVycm9yIG5ldyBpbiBAcmVhY3QtdGhyZWUvZmliZXJANy4wLjVcblxuICBjb25zdCBkZWZhdWx0Q29udHJvbHMgPSB1c2VUaHJlZShzdGF0ZSA9PiBzdGF0ZS5jb250cm9scyk7XG4gIGNvbnN0IGdsID0gdXNlVGhyZWUoc3RhdGUgPT4gc3RhdGUuZ2wpO1xuICBjb25zdCBldmVudHMgPSB1c2VUaHJlZShzdGF0ZSA9PiBzdGF0ZS5ldmVudHMpO1xuICBjb25zdCBkZWZhdWx0Q2FtZXJhID0gdXNlVGhyZWUoc3RhdGUgPT4gc3RhdGUuY2FtZXJhKTtcbiAgY29uc3QgaW52YWxpZGF0ZSA9IHVzZVRocmVlKHN0YXRlID0+IHN0YXRlLmludmFsaWRhdGUpO1xuICBjb25zdCBnZXQgPSB1c2VUaHJlZShzdGF0ZSA9PiBzdGF0ZS5nZXQpO1xuICBjb25zdCBzZXQgPSB1c2VUaHJlZShzdGF0ZSA9PiBzdGF0ZS5zZXQpO1xuICBjb25zdCBleHBsQ2FtZXJhID0gY2FtZXJhIHx8IGRlZmF1bHRDYW1lcmE7XG4gIGNvbnN0IGV4cGxEb21FbGVtZW50ID0gZG9tRWxlbWVudCB8fCBldmVudHMuY29ubmVjdGVkIHx8IGdsLmRvbUVsZW1lbnQ7XG4gIGNvbnN0IGNvbnRyb2xzID0gUmVhY3QudXNlTWVtbygoKSA9PiBuZXcgVHJhbnNmb3JtQ29udHJvbHMkMShleHBsQ2FtZXJhLCBleHBsRG9tRWxlbWVudCksIFtleHBsQ2FtZXJhLCBleHBsRG9tRWxlbWVudF0pO1xuICBjb25zdCBncm91cCA9IFJlYWN0LnVzZVJlZigpO1xuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIGlmIChvYmplY3QpIHtcbiAgICAgIGNvbnRyb2xzLmF0dGFjaChvYmplY3QgaW5zdGFuY2VvZiBUSFJFRS5PYmplY3QzRCA/IG9iamVjdCA6IG9iamVjdC5jdXJyZW50KTtcbiAgICB9IGVsc2UgaWYgKGdyb3VwLmN1cnJlbnQgaW5zdGFuY2VvZiBUSFJFRS5PYmplY3QzRCkge1xuICAgICAgY29udHJvbHMuYXR0YWNoKGdyb3VwLmN1cnJlbnQpO1xuICAgIH1cblxuICAgIHJldHVybiAoKSA9PiB2b2lkIGNvbnRyb2xzLmRldGFjaCgpO1xuICB9LCBbb2JqZWN0LCBjaGlsZHJlbiwgY29udHJvbHNdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZGVmYXVsdENvbnRyb2xzKSB7XG4gICAgICBjb25zdCBjYWxsYmFjayA9IGV2ZW50ID0+IGRlZmF1bHRDb250cm9scy5lbmFibGVkID0gIWV2ZW50LnZhbHVlO1xuXG4gICAgICBjb250cm9scy5hZGRFdmVudExpc3RlbmVyKCdkcmFnZ2luZy1jaGFuZ2VkJywgY2FsbGJhY2spO1xuICAgICAgcmV0dXJuICgpID0+IGNvbnRyb2xzLnJlbW92ZUV2ZW50TGlzdGVuZXIoJ2RyYWdnaW5nLWNoYW5nZWQnLCBjYWxsYmFjayk7XG4gICAgfVxuICB9LCBbY29udHJvbHMsIGRlZmF1bHRDb250cm9sc10pO1xuICBjb25zdCBvbkNoYW5nZVJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICBjb25zdCBvbk1vdXNlRG93blJlZiA9IFJlYWN0LnVzZVJlZigpO1xuICBjb25zdCBvbk1vdXNlVXBSZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgY29uc3Qgb25PYmplY3RDaGFuZ2VSZWYgPSBSZWFjdC51c2VSZWYoKTtcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHZvaWQgKG9uQ2hhbmdlUmVmLmN1cnJlbnQgPSBvbkNoYW5nZSksIFtvbkNoYW5nZV0pO1xuICBSZWFjdC51c2VMYXlvdXRFZmZlY3QoKCkgPT4gdm9pZCAob25Nb3VzZURvd25SZWYuY3VycmVudCA9IG9uTW91c2VEb3duKSwgW29uTW91c2VEb3duXSk7XG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB2b2lkIChvbk1vdXNlVXBSZWYuY3VycmVudCA9IG9uTW91c2VVcCksIFtvbk1vdXNlVXBdKTtcbiAgUmVhY3QudXNlTGF5b3V0RWZmZWN0KCgpID0+IHZvaWQgKG9uT2JqZWN0Q2hhbmdlUmVmLmN1cnJlbnQgPSBvbk9iamVjdENoYW5nZSksIFtvbk9iamVjdENoYW5nZV0pO1xuICBSZWFjdC51c2VFZmZlY3QoKCkgPT4ge1xuICAgIGNvbnN0IG9uQ2hhbmdlID0gZSA9PiB7XG4gICAgICBpbnZhbGlkYXRlKCk7XG4gICAgICBvbkNoYW5nZVJlZi5jdXJyZW50ID09IG51bGwgPyB2b2lkIDAgOiBvbkNoYW5nZVJlZi5jdXJyZW50KGUpO1xuICAgIH07XG5cbiAgICBjb25zdCBvbk1vdXNlRG93biA9IGUgPT4gb25Nb3VzZURvd25SZWYuY3VycmVudCA9PSBudWxsID8gdm9pZCAwIDogb25Nb3VzZURvd25SZWYuY3VycmVudChlKTtcblxuICAgIGNvbnN0IG9uTW91c2VVcCA9IGUgPT4gb25Nb3VzZVVwUmVmLmN1cnJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uTW91c2VVcFJlZi5jdXJyZW50KGUpO1xuXG4gICAgY29uc3Qgb25PYmplY3RDaGFuZ2UgPSBlID0+IG9uT2JqZWN0Q2hhbmdlUmVmLmN1cnJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IG9uT2JqZWN0Q2hhbmdlUmVmLmN1cnJlbnQoZSk7XG5cbiAgICBjb250cm9scy5hZGRFdmVudExpc3RlbmVyKCdjaGFuZ2UnLCBvbkNoYW5nZSk7XG4gICAgY29udHJvbHMuYWRkRXZlbnRMaXN0ZW5lcignbW91c2VEb3duJywgb25Nb3VzZURvd24pO1xuICAgIGNvbnRyb2xzLmFkZEV2ZW50TGlzdGVuZXIoJ21vdXNlVXAnLCBvbk1vdXNlVXApO1xuICAgIGNvbnRyb2xzLmFkZEV2ZW50TGlzdGVuZXIoJ29iamVjdENoYW5nZScsIG9uT2JqZWN0Q2hhbmdlKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgY29udHJvbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcignY2hhbmdlJywgb25DaGFuZ2UpO1xuICAgICAgY29udHJvbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VEb3duJywgb25Nb3VzZURvd24pO1xuICAgICAgY29udHJvbHMucmVtb3ZlRXZlbnRMaXN0ZW5lcignbW91c2VVcCcsIG9uTW91c2VVcCk7XG4gICAgICBjb250cm9scy5yZW1vdmVFdmVudExpc3RlbmVyKCdvYmplY3RDaGFuZ2UnLCBvbk9iamVjdENoYW5nZSk7XG4gICAgfTtcbiAgfSwgW2ludmFsaWRhdGUsIGNvbnRyb2xzXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgaWYgKG1ha2VEZWZhdWx0KSB7XG4gICAgICBjb25zdCBvbGQgPSBnZXQoKS5jb250cm9scztcbiAgICAgIHNldCh7XG4gICAgICAgIGNvbnRyb2xzXG4gICAgICB9KTtcbiAgICAgIHJldHVybiAoKSA9PiBzZXQoe1xuICAgICAgICBjb250cm9sczogb2xkXG4gICAgICB9KTtcbiAgICB9XG4gIH0sIFttYWtlRGVmYXVsdCwgY29udHJvbHNdKTtcbiAgcmV0dXJuIGNvbnRyb2xzID8gLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuRnJhZ21lbnQsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwicHJpbWl0aXZlXCIsIF9leHRlbmRzKHtcbiAgICByZWY6IHJlZixcbiAgICBvYmplY3Q6IGNvbnRyb2xzXG4gIH0sIHRyYW5zZm9ybVByb3BzKSksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZ3JvdXBcIiwgX2V4dGVuZHMoe1xuICAgIHJlZjogZ3JvdXBcbiAgfSwgb2JqZWN0UHJvcHMpLCBjaGlsZHJlbikpIDogbnVsbDtcbn0pO1xuXG5leHBvcnQgeyBUcmFuc2Zvcm1Db250cm9scyB9O1xuIl0sIm5hbWVzIjpbIl9leHRlbmRzIiwidXNlVGhyZWUiLCJvbWl0IiwicGljayIsIlJlYWN0IiwiVEhSRUUiLCJUcmFuc2Zvcm1Db250cm9scyIsIlRyYW5zZm9ybUNvbnRyb2xzJDEiLCJmb3J3YXJkUmVmIiwiY2hpbGRyZW4iLCJkb21FbGVtZW50Iiwib25DaGFuZ2UiLCJvbk1vdXNlRG93biIsIm9uTW91c2VVcCIsIm9uT2JqZWN0Q2hhbmdlIiwib2JqZWN0IiwibWFrZURlZmF1bHQiLCJwcm9wcyIsInJlZiIsInRyYW5zZm9ybU9ubHlQcm9wTmFtZXMiLCJjYW1lcmEiLCJyZXN0IiwidHJhbnNmb3JtUHJvcHMiLCJvYmplY3RQcm9wcyIsImRlZmF1bHRDb250cm9scyIsInN0YXRlIiwiY29udHJvbHMiLCJnbCIsImV2ZW50cyIsImRlZmF1bHRDYW1lcmEiLCJpbnZhbGlkYXRlIiwiZ2V0Iiwic2V0IiwiZXhwbENhbWVyYSIsImV4cGxEb21FbGVtZW50IiwiY29ubmVjdGVkIiwidXNlTWVtbyIsImdyb3VwIiwidXNlUmVmIiwidXNlTGF5b3V0RWZmZWN0IiwiYXR0YWNoIiwiT2JqZWN0M0QiLCJjdXJyZW50IiwiZGV0YWNoIiwidXNlRWZmZWN0IiwiY2FsbGJhY2siLCJldmVudCIsImVuYWJsZWQiLCJ2YWx1ZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJyZW1vdmVFdmVudExpc3RlbmVyIiwib25DaGFuZ2VSZWYiLCJvbk1vdXNlRG93blJlZiIsIm9uTW91c2VVcFJlZiIsIm9uT2JqZWN0Q2hhbmdlUmVmIiwiZSIsIm9sZCIsImNyZWF0ZUVsZW1lbnQiLCJGcmFnbWVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/TransformControls.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/shaderMaterial.js":
/*!***************************************************************!*\
  !*** ./node_modules/@react-three/drei/core/shaderMaterial.js ***!
  \***************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   shaderMaterial: () => (/* binding */ shaderMaterial)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n\nfunction shaderMaterial(uniforms, vertexShader, fragmentShader, onInit) {\n    const material = class material extends three__WEBPACK_IMPORTED_MODULE_0__.ShaderMaterial {\n        constructor(parameters = {}){\n            const entries = Object.entries(uniforms); // Create unforms and shaders\n            super({\n                uniforms: entries.reduce((acc, [name, value])=>{\n                    const uniform = three__WEBPACK_IMPORTED_MODULE_0__.UniformsUtils.clone({\n                        [name]: {\n                            value\n                        }\n                    });\n                    return {\n                        ...acc,\n                        ...uniform\n                    };\n                }, {}),\n                vertexShader,\n                fragmentShader\n            }); // Create getter/setters\n            this.key = \"\";\n            entries.forEach(([name])=>Object.defineProperty(this, name, {\n                    get: ()=>this.uniforms[name].value,\n                    set: (v)=>this.uniforms[name].value = v\n                })); // Assign parameters, this might include uniforms\n            Object.assign(this, parameters); // Call onInit\n            if (onInit) onInit(this);\n        }\n    };\n    material.key = three__WEBPACK_IMPORTED_MODULE_0__.MathUtils.generateUUID();\n    return material;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS9zaGFkZXJNYXRlcmlhbC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUErQjtBQUUvQixTQUFTQyxlQUFlQyxRQUFRLEVBQUVDLFlBQVksRUFBRUMsY0FBYyxFQUFFQyxNQUFNO0lBQ3BFLE1BQU1DLFdBQVcsTUFBTUEsaUJBQWlCTixpREFBb0I7UUFDMURRLFlBQVlDLGFBQWEsQ0FBQyxDQUFDLENBQUU7WUFDM0IsTUFBTUMsVUFBVUMsT0FBT0QsT0FBTyxDQUFDUixXQUFXLDZCQUE2QjtZQUV2RSxLQUFLLENBQUM7Z0JBQ0pBLFVBQVVRLFFBQVFFLE1BQU0sQ0FBQyxDQUFDQyxLQUFLLENBQUNDLE1BQU1DLE1BQU07b0JBQzFDLE1BQU1DLFVBQVVoQixnREFBbUIsQ0FBQ2tCLEtBQUssQ0FBQzt3QkFDeEMsQ0FBQ0osS0FBSyxFQUFFOzRCQUNOQzt3QkFDRjtvQkFDRjtvQkFDQSxPQUFPO3dCQUFFLEdBQUdGLEdBQUc7d0JBQ2IsR0FBR0csT0FBTztvQkFDWjtnQkFDRixHQUFHLENBQUM7Z0JBQ0piO2dCQUNBQztZQUNGLElBQUksd0JBQXdCO1lBRTVCLElBQUksQ0FBQ2UsR0FBRyxHQUFHO1lBQ1hULFFBQVFVLE9BQU8sQ0FBQyxDQUFDLENBQUNOLEtBQUssR0FBS0gsT0FBT1UsY0FBYyxDQUFDLElBQUksRUFBRVAsTUFBTTtvQkFDNURRLEtBQUssSUFBTSxJQUFJLENBQUNwQixRQUFRLENBQUNZLEtBQUssQ0FBQ0MsS0FBSztvQkFDcENRLEtBQUtDLENBQUFBLElBQUssSUFBSSxDQUFDdEIsUUFBUSxDQUFDWSxLQUFLLENBQUNDLEtBQUssR0FBR1M7Z0JBQ3hDLEtBQUssaURBQWlEO1lBRXREYixPQUFPYyxNQUFNLENBQUMsSUFBSSxFQUFFaEIsYUFBYSxjQUFjO1lBRS9DLElBQUlKLFFBQVFBLE9BQU8sSUFBSTtRQUN6QjtJQUVGO0lBQ0FDLFNBQVNhLEdBQUcsR0FBR25CLDRDQUFlLENBQUMyQixZQUFZO0lBQzNDLE9BQU9yQjtBQUNUO0FBRTBCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmliZS0zZC1jb2RlLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL2NvcmUvc2hhZGVyTWF0ZXJpYWwuanM/Nzc4MyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5cbmZ1bmN0aW9uIHNoYWRlck1hdGVyaWFsKHVuaWZvcm1zLCB2ZXJ0ZXhTaGFkZXIsIGZyYWdtZW50U2hhZGVyLCBvbkluaXQpIHtcbiAgY29uc3QgbWF0ZXJpYWwgPSBjbGFzcyBtYXRlcmlhbCBleHRlbmRzIFRIUkVFLlNoYWRlck1hdGVyaWFsIHtcbiAgICBjb25zdHJ1Y3RvcihwYXJhbWV0ZXJzID0ge30pIHtcbiAgICAgIGNvbnN0IGVudHJpZXMgPSBPYmplY3QuZW50cmllcyh1bmlmb3Jtcyk7IC8vIENyZWF0ZSB1bmZvcm1zIGFuZCBzaGFkZXJzXG5cbiAgICAgIHN1cGVyKHtcbiAgICAgICAgdW5pZm9ybXM6IGVudHJpZXMucmVkdWNlKChhY2MsIFtuYW1lLCB2YWx1ZV0pID0+IHtcbiAgICAgICAgICBjb25zdCB1bmlmb3JtID0gVEhSRUUuVW5pZm9ybXNVdGlscy5jbG9uZSh7XG4gICAgICAgICAgICBbbmFtZV06IHtcbiAgICAgICAgICAgICAgdmFsdWVcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9KTtcbiAgICAgICAgICByZXR1cm4geyAuLi5hY2MsXG4gICAgICAgICAgICAuLi51bmlmb3JtXG4gICAgICAgICAgfTtcbiAgICAgICAgfSwge30pLFxuICAgICAgICB2ZXJ0ZXhTaGFkZXIsXG4gICAgICAgIGZyYWdtZW50U2hhZGVyXG4gICAgICB9KTsgLy8gQ3JlYXRlIGdldHRlci9zZXR0ZXJzXG5cbiAgICAgIHRoaXMua2V5ID0gJyc7XG4gICAgICBlbnRyaWVzLmZvckVhY2goKFtuYW1lXSkgPT4gT2JqZWN0LmRlZmluZVByb3BlcnR5KHRoaXMsIG5hbWUsIHtcbiAgICAgICAgZ2V0OiAoKSA9PiB0aGlzLnVuaWZvcm1zW25hbWVdLnZhbHVlLFxuICAgICAgICBzZXQ6IHYgPT4gdGhpcy51bmlmb3Jtc1tuYW1lXS52YWx1ZSA9IHZcbiAgICAgIH0pKTsgLy8gQXNzaWduIHBhcmFtZXRlcnMsIHRoaXMgbWlnaHQgaW5jbHVkZSB1bmlmb3Jtc1xuXG4gICAgICBPYmplY3QuYXNzaWduKHRoaXMsIHBhcmFtZXRlcnMpOyAvLyBDYWxsIG9uSW5pdFxuXG4gICAgICBpZiAob25Jbml0KSBvbkluaXQodGhpcyk7XG4gICAgfVxuXG4gIH07XG4gIG1hdGVyaWFsLmtleSA9IFRIUkVFLk1hdGhVdGlscy5nZW5lcmF0ZVVVSUQoKTtcbiAgcmV0dXJuIG1hdGVyaWFsO1xufVxuXG5leHBvcnQgeyBzaGFkZXJNYXRlcmlhbCB9O1xuIl0sIm5hbWVzIjpbIlRIUkVFIiwic2hhZGVyTWF0ZXJpYWwiLCJ1bmlmb3JtcyIsInZlcnRleFNoYWRlciIsImZyYWdtZW50U2hhZGVyIiwib25Jbml0IiwibWF0ZXJpYWwiLCJTaGFkZXJNYXRlcmlhbCIsImNvbnN0cnVjdG9yIiwicGFyYW1ldGVycyIsImVudHJpZXMiLCJPYmplY3QiLCJyZWR1Y2UiLCJhY2MiLCJuYW1lIiwidmFsdWUiLCJ1bmlmb3JtIiwiVW5pZm9ybXNVdGlscyIsImNsb25lIiwia2V5IiwiZm9yRWFjaCIsImRlZmluZVByb3BlcnR5IiwiZ2V0Iiwic2V0IiwidiIsImFzc2lnbiIsIk1hdGhVdGlscyIsImdlbmVyYXRlVVVJRCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/shaderMaterial.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/useBVH.js":
/*!*******************************************************!*\
  !*** ./node_modules/@react-three/drei/core/useBVH.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Bvh: () => (/* binding */ Bvh),\n/* harmony export */   useBVH: () => (/* binding */ useBVH)\n/* harmony export */ });\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/index-673ef987.esm.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var three_mesh_bvh__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three-mesh-bvh */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/Constants.js\");\n/* harmony import */ var three_mesh_bvh__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! three-mesh-bvh */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/ExtensionUtilities.js\");\n\n\n\n\n\nconst isMesh = (child)=>child.isMesh;\n/**\n * @deprecated Use the Bvh component instead\n */ function useBVH(mesh, options) {\n    options = {\n        strategy: three_mesh_bvh__WEBPACK_IMPORTED_MODULE_2__.SAH,\n        verbose: false,\n        setBoundingBox: true,\n        maxDepth: 40,\n        maxLeafTris: 10,\n        ...options\n    };\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        if (mesh.current) {\n            mesh.current.raycast = three_mesh_bvh__WEBPACK_IMPORTED_MODULE_3__.acceleratedRaycast;\n            const geometry = mesh.current.geometry;\n            geometry.computeBoundsTree = three_mesh_bvh__WEBPACK_IMPORTED_MODULE_3__.computeBoundsTree;\n            geometry.disposeBoundsTree = three_mesh_bvh__WEBPACK_IMPORTED_MODULE_3__.disposeBoundsTree;\n            geometry.computeBoundsTree(options);\n            return ()=>{\n                if (geometry.boundsTree) {\n                    geometry.disposeBoundsTree();\n                }\n            };\n        }\n    }, [\n        mesh,\n        JSON.stringify(options)\n    ]);\n}\nconst Bvh = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.forwardRef(({ enabled = true, firstHitOnly = false, children, strategy = three_mesh_bvh__WEBPACK_IMPORTED_MODULE_2__.SAH, verbose = false, setBoundingBox = true, maxDepth = 40, maxLeafTris = 10, ...props }, fref)=>{\n    const ref = react__WEBPACK_IMPORTED_MODULE_1__.useRef(null);\n    const raycaster = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_4__.z)((state)=>state.raycaster);\n    react__WEBPACK_IMPORTED_MODULE_1__.useImperativeHandle(fref, ()=>ref.current, []);\n    react__WEBPACK_IMPORTED_MODULE_1__.useEffect(()=>{\n        if (enabled) {\n            const options = {\n                strategy,\n                verbose,\n                setBoundingBox,\n                maxDepth,\n                maxLeafTris\n            };\n            const group = ref.current; // This can only safely work if the component is used once, but there is no alternative.\n            // Hijacking the raycast method to do it for individual meshes is not an option as it would\n            // cost too much memory ...\n            raycaster.firstHitOnly = firstHitOnly;\n            group.traverse((child)=>{\n                // Only include meshes that do not yet have a boundsTree and whose raycast is standard issue\n                if (isMesh(child) && !child.geometry.boundsTree && child.raycast === three__WEBPACK_IMPORTED_MODULE_5__.Mesh.prototype.raycast) {\n                    child.raycast = three_mesh_bvh__WEBPACK_IMPORTED_MODULE_3__.acceleratedRaycast;\n                    child.geometry.computeBoundsTree = three_mesh_bvh__WEBPACK_IMPORTED_MODULE_3__.computeBoundsTree;\n                    child.geometry.disposeBoundsTree = three_mesh_bvh__WEBPACK_IMPORTED_MODULE_3__.disposeBoundsTree;\n                    child.geometry.computeBoundsTree(options);\n                }\n            });\n            return ()=>{\n                delete raycaster.firstHitOnly;\n                group.traverse((child)=>{\n                    if (isMesh(child) && child.geometry.boundsTree) {\n                        child.geometry.disposeBoundsTree();\n                        child.raycast = three__WEBPACK_IMPORTED_MODULE_5__.Mesh.prototype.raycast;\n                    }\n                });\n            };\n        }\n    });\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_1__.createElement(\"group\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_0__[\"default\"])({\n        ref: ref\n    }, props), children);\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS91c2VCVkguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7O0FBQTBEO0FBQ1o7QUFDZjtBQUNGO0FBQ2tFO0FBRS9GLE1BQU1RLFNBQVNDLENBQUFBLFFBQVNBLE1BQU1ELE1BQU07QUFDcEM7O0NBRUMsR0FHRCxTQUFTRSxPQUFPQyxJQUFJLEVBQUVDLE9BQU87SUFDM0JBLFVBQVU7UUFDUkMsVUFBVVQsK0NBQUdBO1FBQ2JVLFNBQVM7UUFDVEMsZ0JBQWdCO1FBQ2hCQyxVQUFVO1FBQ1ZDLGFBQWE7UUFDYixHQUFHTCxPQUFPO0lBQ1o7SUFDQVYsNENBQWUsQ0FBQztRQUNkLElBQUlTLEtBQUtRLE9BQU8sRUFBRTtZQUNoQlIsS0FBS1EsT0FBTyxDQUFDQyxPQUFPLEdBQUdmLDhEQUFrQkE7WUFDekMsTUFBTWdCLFdBQVdWLEtBQUtRLE9BQU8sQ0FBQ0UsUUFBUTtZQUN0Q0EsU0FBU2YsaUJBQWlCLEdBQUdBLDZEQUFpQkE7WUFDOUNlLFNBQVNkLGlCQUFpQixHQUFHQSw2REFBaUJBO1lBQzlDYyxTQUFTZixpQkFBaUIsQ0FBQ007WUFDM0IsT0FBTztnQkFDTCxJQUFJUyxTQUFTQyxVQUFVLEVBQUU7b0JBQ3ZCRCxTQUFTZCxpQkFBaUI7Z0JBQzVCO1lBQ0Y7UUFDRjtJQUNGLEdBQUc7UUFBQ0k7UUFBTVksS0FBS0MsU0FBUyxDQUFDWjtLQUFTO0FBQ3BDO0FBQ0EsTUFBTWEsTUFBTSxXQUFXLEdBQUV2Qiw2Q0FBZ0IsQ0FBQyxDQUFDLEVBQ3pDeUIsVUFBVSxJQUFJLEVBQ2RDLGVBQWUsS0FBSyxFQUNwQkMsUUFBUSxFQUNSaEIsV0FBV1QsK0NBQUcsRUFDZFUsVUFBVSxLQUFLLEVBQ2ZDLGlCQUFpQixJQUFJLEVBQ3JCQyxXQUFXLEVBQUUsRUFDYkMsY0FBYyxFQUFFLEVBQ2hCLEdBQUdhLE9BQ0osRUFBRUM7SUFDRCxNQUFNQyxNQUFNOUIseUNBQVksQ0FBQztJQUN6QixNQUFNZ0MsWUFBWWpDLHFEQUFRQSxDQUFDa0MsQ0FBQUEsUUFBU0EsTUFBTUQsU0FBUztJQUNuRGhDLHNEQUF5QixDQUFDNkIsTUFBTSxJQUFNQyxJQUFJYixPQUFPLEVBQUUsRUFBRTtJQUNyRGpCLDRDQUFlLENBQUM7UUFDZCxJQUFJeUIsU0FBUztZQUNYLE1BQU1mLFVBQVU7Z0JBQ2RDO2dCQUNBQztnQkFDQUM7Z0JBQ0FDO2dCQUNBQztZQUNGO1lBQ0EsTUFBTW9CLFFBQVFMLElBQUliLE9BQU8sRUFBRSx3RkFBd0Y7WUFDbkgsMkZBQTJGO1lBQzNGLDJCQUEyQjtZQUUzQmUsVUFBVU4sWUFBWSxHQUFHQTtZQUN6QlMsTUFBTUMsUUFBUSxDQUFDN0IsQ0FBQUE7Z0JBQ2IsNEZBQTRGO2dCQUM1RixJQUFJRCxPQUFPQyxVQUFVLENBQUNBLE1BQU1ZLFFBQVEsQ0FBQ0MsVUFBVSxJQUFJYixNQUFNVyxPQUFPLEtBQUtqQix1Q0FBSUEsQ0FBQ29DLFNBQVMsQ0FBQ25CLE9BQU8sRUFBRTtvQkFDM0ZYLE1BQU1XLE9BQU8sR0FBR2YsOERBQWtCQTtvQkFDbENJLE1BQU1ZLFFBQVEsQ0FBQ2YsaUJBQWlCLEdBQUdBLDZEQUFpQkE7b0JBQ3BERyxNQUFNWSxRQUFRLENBQUNkLGlCQUFpQixHQUFHQSw2REFBaUJBO29CQUNwREUsTUFBTVksUUFBUSxDQUFDZixpQkFBaUIsQ0FBQ007Z0JBQ25DO1lBQ0Y7WUFDQSxPQUFPO2dCQUNMLE9BQU9zQixVQUFVTixZQUFZO2dCQUM3QlMsTUFBTUMsUUFBUSxDQUFDN0IsQ0FBQUE7b0JBQ2IsSUFBSUQsT0FBT0MsVUFBVUEsTUFBTVksUUFBUSxDQUFDQyxVQUFVLEVBQUU7d0JBQzlDYixNQUFNWSxRQUFRLENBQUNkLGlCQUFpQjt3QkFDaENFLE1BQU1XLE9BQU8sR0FBR2pCLHVDQUFJQSxDQUFDb0MsU0FBUyxDQUFDbkIsT0FBTztvQkFDeEM7Z0JBQ0Y7WUFDRjtRQUNGO0lBQ0Y7SUFDQSxPQUFPLFdBQVcsR0FBRWxCLGdEQUFtQixDQUFDLFNBQVNGLDhFQUFRQSxDQUFDO1FBQ3hEZ0MsS0FBS0E7SUFDUCxHQUFHRixRQUFRRDtBQUNiO0FBRXVCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmliZS0zZC1jb2RlLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL2NvcmUvdXNlQlZILmpzPzc4YTMiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IF9leHRlbmRzIGZyb20gJ0BiYWJlbC9ydW50aW1lL2hlbHBlcnMvZXNtL2V4dGVuZHMnO1xuaW1wb3J0IHsgdXNlVGhyZWUgfSBmcm9tICdAcmVhY3QtdGhyZWUvZmliZXInO1xuaW1wb3J0ICogYXMgUmVhY3QgZnJvbSAncmVhY3QnO1xuaW1wb3J0IHsgTWVzaCB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IFNBSCwgYWNjZWxlcmF0ZWRSYXljYXN0LCBjb21wdXRlQm91bmRzVHJlZSwgZGlzcG9zZUJvdW5kc1RyZWUgfSBmcm9tICd0aHJlZS1tZXNoLWJ2aCc7XG5cbmNvbnN0IGlzTWVzaCA9IGNoaWxkID0+IGNoaWxkLmlzTWVzaDtcbi8qKlxuICogQGRlcHJlY2F0ZWQgVXNlIHRoZSBCdmggY29tcG9uZW50IGluc3RlYWRcbiAqL1xuXG5cbmZ1bmN0aW9uIHVzZUJWSChtZXNoLCBvcHRpb25zKSB7XG4gIG9wdGlvbnMgPSB7XG4gICAgc3RyYXRlZ3k6IFNBSCxcbiAgICB2ZXJib3NlOiBmYWxzZSxcbiAgICBzZXRCb3VuZGluZ0JveDogdHJ1ZSxcbiAgICBtYXhEZXB0aDogNDAsXG4gICAgbWF4TGVhZlRyaXM6IDEwLFxuICAgIC4uLm9wdGlvbnNcbiAgfTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAobWVzaC5jdXJyZW50KSB7XG4gICAgICBtZXNoLmN1cnJlbnQucmF5Y2FzdCA9IGFjY2VsZXJhdGVkUmF5Y2FzdDtcbiAgICAgIGNvbnN0IGdlb21ldHJ5ID0gbWVzaC5jdXJyZW50Lmdlb21ldHJ5O1xuICAgICAgZ2VvbWV0cnkuY29tcHV0ZUJvdW5kc1RyZWUgPSBjb21wdXRlQm91bmRzVHJlZTtcbiAgICAgIGdlb21ldHJ5LmRpc3Bvc2VCb3VuZHNUcmVlID0gZGlzcG9zZUJvdW5kc1RyZWU7XG4gICAgICBnZW9tZXRyeS5jb21wdXRlQm91bmRzVHJlZShvcHRpb25zKTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGlmIChnZW9tZXRyeS5ib3VuZHNUcmVlKSB7XG4gICAgICAgICAgZ2VvbWV0cnkuZGlzcG9zZUJvdW5kc1RyZWUoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICB9XG4gIH0sIFttZXNoLCBKU09OLnN0cmluZ2lmeShvcHRpb25zKV0pO1xufVxuY29uc3QgQnZoID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoKHtcbiAgZW5hYmxlZCA9IHRydWUsXG4gIGZpcnN0SGl0T25seSA9IGZhbHNlLFxuICBjaGlsZHJlbixcbiAgc3RyYXRlZ3kgPSBTQUgsXG4gIHZlcmJvc2UgPSBmYWxzZSxcbiAgc2V0Qm91bmRpbmdCb3ggPSB0cnVlLFxuICBtYXhEZXB0aCA9IDQwLFxuICBtYXhMZWFmVHJpcyA9IDEwLFxuICAuLi5wcm9wc1xufSwgZnJlZikgPT4ge1xuICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIGNvbnN0IHJheWNhc3RlciA9IHVzZVRocmVlKHN0YXRlID0+IHN0YXRlLnJheWNhc3Rlcik7XG4gIFJlYWN0LnVzZUltcGVyYXRpdmVIYW5kbGUoZnJlZiwgKCkgPT4gcmVmLmN1cnJlbnQsIFtdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICBpZiAoZW5hYmxlZCkge1xuICAgICAgY29uc3Qgb3B0aW9ucyA9IHtcbiAgICAgICAgc3RyYXRlZ3ksXG4gICAgICAgIHZlcmJvc2UsXG4gICAgICAgIHNldEJvdW5kaW5nQm94LFxuICAgICAgICBtYXhEZXB0aCxcbiAgICAgICAgbWF4TGVhZlRyaXNcbiAgICAgIH07XG4gICAgICBjb25zdCBncm91cCA9IHJlZi5jdXJyZW50OyAvLyBUaGlzIGNhbiBvbmx5IHNhZmVseSB3b3JrIGlmIHRoZSBjb21wb25lbnQgaXMgdXNlZCBvbmNlLCBidXQgdGhlcmUgaXMgbm8gYWx0ZXJuYXRpdmUuXG4gICAgICAvLyBIaWphY2tpbmcgdGhlIHJheWNhc3QgbWV0aG9kIHRvIGRvIGl0IGZvciBpbmRpdmlkdWFsIG1lc2hlcyBpcyBub3QgYW4gb3B0aW9uIGFzIGl0IHdvdWxkXG4gICAgICAvLyBjb3N0IHRvbyBtdWNoIG1lbW9yeSAuLi5cblxuICAgICAgcmF5Y2FzdGVyLmZpcnN0SGl0T25seSA9IGZpcnN0SGl0T25seTtcbiAgICAgIGdyb3VwLnRyYXZlcnNlKGNoaWxkID0+IHtcbiAgICAgICAgLy8gT25seSBpbmNsdWRlIG1lc2hlcyB0aGF0IGRvIG5vdCB5ZXQgaGF2ZSBhIGJvdW5kc1RyZWUgYW5kIHdob3NlIHJheWNhc3QgaXMgc3RhbmRhcmQgaXNzdWVcbiAgICAgICAgaWYgKGlzTWVzaChjaGlsZCkgJiYgIWNoaWxkLmdlb21ldHJ5LmJvdW5kc1RyZWUgJiYgY2hpbGQucmF5Y2FzdCA9PT0gTWVzaC5wcm90b3R5cGUucmF5Y2FzdCkge1xuICAgICAgICAgIGNoaWxkLnJheWNhc3QgPSBhY2NlbGVyYXRlZFJheWNhc3Q7XG4gICAgICAgICAgY2hpbGQuZ2VvbWV0cnkuY29tcHV0ZUJvdW5kc1RyZWUgPSBjb21wdXRlQm91bmRzVHJlZTtcbiAgICAgICAgICBjaGlsZC5nZW9tZXRyeS5kaXNwb3NlQm91bmRzVHJlZSA9IGRpc3Bvc2VCb3VuZHNUcmVlO1xuICAgICAgICAgIGNoaWxkLmdlb21ldHJ5LmNvbXB1dGVCb3VuZHNUcmVlKG9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICB9KTtcbiAgICAgIHJldHVybiAoKSA9PiB7XG4gICAgICAgIGRlbGV0ZSByYXljYXN0ZXIuZmlyc3RIaXRPbmx5O1xuICAgICAgICBncm91cC50cmF2ZXJzZShjaGlsZCA9PiB7XG4gICAgICAgICAgaWYgKGlzTWVzaChjaGlsZCkgJiYgY2hpbGQuZ2VvbWV0cnkuYm91bmRzVHJlZSkge1xuICAgICAgICAgICAgY2hpbGQuZ2VvbWV0cnkuZGlzcG9zZUJvdW5kc1RyZWUoKTtcbiAgICAgICAgICAgIGNoaWxkLnJheWNhc3QgPSBNZXNoLnByb3RvdHlwZS5yYXljYXN0O1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9O1xuICAgIH1cbiAgfSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImdyb3VwXCIsIF9leHRlbmRzKHtcbiAgICByZWY6IHJlZlxuICB9LCBwcm9wcyksIGNoaWxkcmVuKTtcbn0pO1xuXG5leHBvcnQgeyBCdmgsIHVzZUJWSCB9O1xuIl0sIm5hbWVzIjpbIl9leHRlbmRzIiwidXNlVGhyZWUiLCJSZWFjdCIsIk1lc2giLCJTQUgiLCJhY2NlbGVyYXRlZFJheWNhc3QiLCJjb21wdXRlQm91bmRzVHJlZSIsImRpc3Bvc2VCb3VuZHNUcmVlIiwiaXNNZXNoIiwiY2hpbGQiLCJ1c2VCVkgiLCJtZXNoIiwib3B0aW9ucyIsInN0cmF0ZWd5IiwidmVyYm9zZSIsInNldEJvdW5kaW5nQm94IiwibWF4RGVwdGgiLCJtYXhMZWFmVHJpcyIsInVzZUVmZmVjdCIsImN1cnJlbnQiLCJyYXljYXN0IiwiZ2VvbWV0cnkiLCJib3VuZHNUcmVlIiwiSlNPTiIsInN0cmluZ2lmeSIsIkJ2aCIsImZvcndhcmRSZWYiLCJlbmFibGVkIiwiZmlyc3RIaXRPbmx5IiwiY2hpbGRyZW4iLCJwcm9wcyIsImZyZWYiLCJyZWYiLCJ1c2VSZWYiLCJyYXljYXN0ZXIiLCJzdGF0ZSIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJncm91cCIsInRyYXZlcnNlIiwicHJvdG90eXBlIiwiY3JlYXRlRWxlbWVudCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/useBVH.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/core/useFBO.js":
/*!*******************************************************!*\
  !*** ./node_modules/@react-three/drei/core/useFBO.js ***!
  \*******************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   useFBO: () => (/* binding */ useFBO)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var _react_three_fiber__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @react-three/fiber */ \"(ssr)/./node_modules/@react-three/fiber/dist/index-673ef987.esm.js\");\n\n\n\n// 👇 uncomment when TS version supports function overloads\n// export function useFBO(settings?: FBOSettings)\nfunction useFBO(/** Width in pixels, or settings (will render fullscreen by default) */ width, /** Height in pixels */ height, /**Settings */ settings) {\n    const size = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_1__.z)((state)=>state.size);\n    const viewport = (0,_react_three_fiber__WEBPACK_IMPORTED_MODULE_1__.z)((state)=>state.viewport);\n    const _width = typeof width === \"number\" ? width : size.width * viewport.dpr;\n    const _height = typeof height === \"number\" ? height : size.height * viewport.dpr;\n    const _settings = (typeof width === \"number\" ? settings : width) || {};\n    const { samples = 0, depth, ...targetSettings } = _settings;\n    const target = react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>{\n        const target = new three__WEBPACK_IMPORTED_MODULE_2__.WebGLRenderTarget(_width, _height, {\n            minFilter: three__WEBPACK_IMPORTED_MODULE_2__.LinearFilter,\n            magFilter: three__WEBPACK_IMPORTED_MODULE_2__.LinearFilter,\n            type: three__WEBPACK_IMPORTED_MODULE_2__.HalfFloatType,\n            ...targetSettings\n        });\n        if (depth) {\n            target.depthTexture = new three__WEBPACK_IMPORTED_MODULE_2__.DepthTexture(_width, _height, three__WEBPACK_IMPORTED_MODULE_2__.FloatType);\n        }\n        target.samples = samples;\n        return target;\n    }, []);\n    react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect(()=>{\n        target.setSize(_width, _height);\n        if (samples) target.samples = samples;\n    }, [\n        samples,\n        target,\n        _width,\n        _height\n    ]);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        return ()=>target.dispose();\n    }, []);\n    return target;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS91c2VGQk8uanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7QUFBK0I7QUFDQTtBQUNlO0FBRTlDLDJEQUEyRDtBQUMzRCxpREFBaUQ7QUFDakQsU0FBU0csT0FDVCxxRUFBcUUsR0FDckVDLEtBQUssRUFDTCxxQkFBcUIsR0FDckJDLE1BQU0sRUFDTixZQUFZLEdBQ1pDLFFBQVE7SUFDTixNQUFNQyxPQUFPTCxxREFBUUEsQ0FBQ00sQ0FBQUEsUUFBU0EsTUFBTUQsSUFBSTtJQUN6QyxNQUFNRSxXQUFXUCxxREFBUUEsQ0FBQ00sQ0FBQUEsUUFBU0EsTUFBTUMsUUFBUTtJQUVqRCxNQUFNQyxTQUFTLE9BQU9OLFVBQVUsV0FBV0EsUUFBUUcsS0FBS0gsS0FBSyxHQUFHSyxTQUFTRSxHQUFHO0lBRTVFLE1BQU1DLFVBQVUsT0FBT1AsV0FBVyxXQUFXQSxTQUFTRSxLQUFLRixNQUFNLEdBQUdJLFNBQVNFLEdBQUc7SUFFaEYsTUFBTUUsWUFBWSxDQUFDLE9BQU9ULFVBQVUsV0FBV0UsV0FBV0YsS0FBSSxLQUFNLENBQUM7SUFFckUsTUFBTSxFQUNKVSxVQUFVLENBQUMsRUFDWEMsS0FBSyxFQUNMLEdBQUdDLGdCQUNKLEdBQUdIO0lBQ0osTUFBTUksU0FBU2pCLDBDQUFhLENBQUM7UUFDM0IsTUFBTWlCLFNBQVMsSUFBSWhCLG9EQUF1QixDQUFDUyxRQUFRRSxTQUFTO1lBQzFEUSxXQUFXbkIsK0NBQWtCO1lBQzdCcUIsV0FBV3JCLCtDQUFrQjtZQUM3QnNCLE1BQU10QixnREFBbUI7WUFDekIsR0FBR2UsY0FBYztRQUNuQjtRQUVBLElBQUlELE9BQU87WUFDVEUsT0FBT1EsWUFBWSxHQUFHLElBQUl4QiwrQ0FBa0IsQ0FBQ1MsUUFBUUUsU0FBU1gsNENBQWU7UUFDL0U7UUFFQWdCLE9BQU9ILE9BQU8sR0FBR0E7UUFDakIsT0FBT0c7SUFDVCxHQUFHLEVBQUU7SUFDTGpCLGtEQUFxQixDQUFDO1FBQ3BCaUIsT0FBT1ksT0FBTyxDQUFDbkIsUUFBUUU7UUFDdkIsSUFBSUUsU0FBU0csT0FBT0gsT0FBTyxHQUFHQTtJQUNoQyxHQUFHO1FBQUNBO1FBQVNHO1FBQVFQO1FBQVFFO0tBQVE7SUFDckNaLDRDQUFlLENBQUM7UUFDZCxPQUFPLElBQU1pQixPQUFPYyxPQUFPO0lBQzdCLEdBQUcsRUFBRTtJQUNMLE9BQU9kO0FBQ1Q7QUFFa0IiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aWJlLTNkLWNvZGUvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvY29yZS91c2VGQk8uanM/ZjllNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgKiBhcyBSZWFjdCBmcm9tICdyZWFjdCc7XG5pbXBvcnQgKiBhcyBUSFJFRSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyB1c2VUaHJlZSB9IGZyb20gJ0ByZWFjdC10aHJlZS9maWJlcic7XG5cbi8vIPCfkYcgdW5jb21tZW50IHdoZW4gVFMgdmVyc2lvbiBzdXBwb3J0cyBmdW5jdGlvbiBvdmVybG9hZHNcbi8vIGV4cG9ydCBmdW5jdGlvbiB1c2VGQk8oc2V0dGluZ3M/OiBGQk9TZXR0aW5ncylcbmZ1bmN0aW9uIHVzZUZCTyhcbi8qKiBXaWR0aCBpbiBwaXhlbHMsIG9yIHNldHRpbmdzICh3aWxsIHJlbmRlciBmdWxsc2NyZWVuIGJ5IGRlZmF1bHQpICovXG53aWR0aCxcbi8qKiBIZWlnaHQgaW4gcGl4ZWxzICovXG5oZWlnaHQsXG4vKipTZXR0aW5ncyAqL1xuc2V0dGluZ3MpIHtcbiAgY29uc3Qgc2l6ZSA9IHVzZVRocmVlKHN0YXRlID0+IHN0YXRlLnNpemUpO1xuICBjb25zdCB2aWV3cG9ydCA9IHVzZVRocmVlKHN0YXRlID0+IHN0YXRlLnZpZXdwb3J0KTtcblxuICBjb25zdCBfd2lkdGggPSB0eXBlb2Ygd2lkdGggPT09ICdudW1iZXInID8gd2lkdGggOiBzaXplLndpZHRoICogdmlld3BvcnQuZHByO1xuXG4gIGNvbnN0IF9oZWlnaHQgPSB0eXBlb2YgaGVpZ2h0ID09PSAnbnVtYmVyJyA/IGhlaWdodCA6IHNpemUuaGVpZ2h0ICogdmlld3BvcnQuZHByO1xuXG4gIGNvbnN0IF9zZXR0aW5ncyA9ICh0eXBlb2Ygd2lkdGggPT09ICdudW1iZXInID8gc2V0dGluZ3MgOiB3aWR0aCkgfHwge307XG5cbiAgY29uc3Qge1xuICAgIHNhbXBsZXMgPSAwLFxuICAgIGRlcHRoLFxuICAgIC4uLnRhcmdldFNldHRpbmdzXG4gIH0gPSBfc2V0dGluZ3M7XG4gIGNvbnN0IHRhcmdldCA9IFJlYWN0LnVzZU1lbW8oKCkgPT4ge1xuICAgIGNvbnN0IHRhcmdldCA9IG5ldyBUSFJFRS5XZWJHTFJlbmRlclRhcmdldChfd2lkdGgsIF9oZWlnaHQsIHtcbiAgICAgIG1pbkZpbHRlcjogVEhSRUUuTGluZWFyRmlsdGVyLFxuICAgICAgbWFnRmlsdGVyOiBUSFJFRS5MaW5lYXJGaWx0ZXIsXG4gICAgICB0eXBlOiBUSFJFRS5IYWxmRmxvYXRUeXBlLFxuICAgICAgLi4udGFyZ2V0U2V0dGluZ3NcbiAgICB9KTtcblxuICAgIGlmIChkZXB0aCkge1xuICAgICAgdGFyZ2V0LmRlcHRoVGV4dHVyZSA9IG5ldyBUSFJFRS5EZXB0aFRleHR1cmUoX3dpZHRoLCBfaGVpZ2h0LCBUSFJFRS5GbG9hdFR5cGUpO1xuICAgIH1cblxuICAgIHRhcmdldC5zYW1wbGVzID0gc2FtcGxlcztcbiAgICByZXR1cm4gdGFyZ2V0O1xuICB9LCBbXSk7XG4gIFJlYWN0LnVzZUxheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgdGFyZ2V0LnNldFNpemUoX3dpZHRoLCBfaGVpZ2h0KTtcbiAgICBpZiAoc2FtcGxlcykgdGFyZ2V0LnNhbXBsZXMgPSBzYW1wbGVzO1xuICB9LCBbc2FtcGxlcywgdGFyZ2V0LCBfd2lkdGgsIF9oZWlnaHRdKTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICByZXR1cm4gKCkgPT4gdGFyZ2V0LmRpc3Bvc2UoKTtcbiAgfSwgW10pO1xuICByZXR1cm4gdGFyZ2V0O1xufVxuXG5leHBvcnQgeyB1c2VGQk8gfTtcbiJdLCJuYW1lcyI6WyJSZWFjdCIsIlRIUkVFIiwidXNlVGhyZWUiLCJ1c2VGQk8iLCJ3aWR0aCIsImhlaWdodCIsInNldHRpbmdzIiwic2l6ZSIsInN0YXRlIiwidmlld3BvcnQiLCJfd2lkdGgiLCJkcHIiLCJfaGVpZ2h0IiwiX3NldHRpbmdzIiwic2FtcGxlcyIsImRlcHRoIiwidGFyZ2V0U2V0dGluZ3MiLCJ0YXJnZXQiLCJ1c2VNZW1vIiwiV2ViR0xSZW5kZXJUYXJnZXQiLCJtaW5GaWx0ZXIiLCJMaW5lYXJGaWx0ZXIiLCJtYWdGaWx0ZXIiLCJ0eXBlIiwiSGFsZkZsb2F0VHlwZSIsImRlcHRoVGV4dHVyZSIsIkRlcHRoVGV4dHVyZSIsIkZsb2F0VHlwZSIsInVzZUxheW91dEVmZmVjdCIsInNldFNpemUiLCJ1c2VFZmZlY3QiLCJkaXNwb3NlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/core/useFBO.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/dist/index-673ef987.esm.js":
/*!********************************************************************!*\
  !*** ./node_modules/@react-three/fiber/dist/index-673ef987.esm.js ***!
  \********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   A: () => (/* binding */ useFrame),\n/* harmony export */   B: () => (/* binding */ Block),\n/* harmony export */   C: () => (/* binding */ useGraph),\n/* harmony export */   D: () => (/* binding */ useLoader),\n/* harmony export */   E: () => (/* binding */ ErrorBoundary),\n/* harmony export */   a: () => (/* binding */ useIsomorphicLayoutEffect),\n/* harmony export */   b: () => (/* binding */ createRoot),\n/* harmony export */   c: () => (/* binding */ createEvents),\n/* harmony export */   d: () => (/* binding */ unmountComponentAtNode),\n/* harmony export */   e: () => (/* binding */ extend),\n/* harmony export */   f: () => (/* binding */ context),\n/* harmony export */   g: () => (/* binding */ createPortal),\n/* harmony export */   h: () => (/* binding */ reconciler),\n/* harmony export */   i: () => (/* binding */ isRef),\n/* harmony export */   j: () => (/* binding */ applyProps),\n/* harmony export */   k: () => (/* binding */ dispose),\n/* harmony export */   l: () => (/* binding */ invalidate),\n/* harmony export */   m: () => (/* binding */ advance),\n/* harmony export */   n: () => (/* binding */ addEffect),\n/* harmony export */   o: () => (/* binding */ addAfterEffect),\n/* harmony export */   p: () => (/* binding */ addTail),\n/* harmony export */   q: () => (/* binding */ flushGlobalEffects),\n/* harmony export */   r: () => (/* binding */ render),\n/* harmony export */   s: () => (/* binding */ getRootState),\n/* harmony export */   t: () => (/* binding */ threeTypes),\n/* harmony export */   u: () => (/* binding */ useMutableCallback),\n/* harmony export */   v: () => (/* binding */ act),\n/* harmony export */   w: () => (/* binding */ roots),\n/* harmony export */   x: () => (/* binding */ useInstanceHandle),\n/* harmony export */   y: () => (/* binding */ useStore),\n/* harmony export */   z: () => (/* binding */ useThree)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n/* harmony import */ var react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react-reconciler/constants */ \"(ssr)/./node_modules/react-reconciler/constants.js\");\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! zustand */ \"(ssr)/./node_modules/@react-three/fiber/node_modules/zustand/esm/index.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react-reconciler */ \"(ssr)/./node_modules/react-reconciler/index.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react_reconciler__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var scheduler__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! scheduler */ \"(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/index.js\");\n/* harmony import */ var suspend_react__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! suspend-react */ \"(ssr)/./node_modules/suspend-react/index.js\");\n\n\n\n\n\n\n\nvar threeTypes = /*#__PURE__*/ Object.freeze({\n    __proto__: null\n});\nconst catalogue = {};\nconst extend = (objects)=>void Object.assign(catalogue, objects);\nfunction createRenderer(_roots, _getEventPriority) {\n    function createInstance(type, { args = [], attach, ...props }, root) {\n        let name = `${type[0].toUpperCase()}${type.slice(1)}`;\n        let instance;\n        if (type === \"primitive\") {\n            if (props.object === undefined) throw new Error(\"R3F: Primitives without 'object' are invalid!\");\n            const object = props.object;\n            instance = prepare(object, {\n                type,\n                root,\n                attach,\n                primitive: true\n            });\n        } else {\n            const target = catalogue[name];\n            if (!target) {\n                throw new Error(`R3F: ${name} is not part of the THREE namespace! Did you forget to extend? See: https://docs.pmnd.rs/react-three-fiber/api/objects#using-3rd-party-objects-declaratively`);\n            }\n            // Throw if an object or literal was passed for args\n            if (!Array.isArray(args)) throw new Error(\"R3F: The args prop must be an array!\");\n            // Instanciate new object, link it to the root\n            // Append memoized props with args so it's not forgotten\n            instance = prepare(new target(...args), {\n                type,\n                root,\n                attach,\n                // Save args in case we need to reconstruct later for HMR\n                memoizedProps: {\n                    args\n                }\n            });\n        }\n        // Auto-attach geometries and materials\n        if (instance.__r3f.attach === undefined) {\n            if (instance instanceof three__WEBPACK_IMPORTED_MODULE_4__.BufferGeometry) instance.__r3f.attach = \"geometry\";\n            else if (instance instanceof three__WEBPACK_IMPORTED_MODULE_4__.Material) instance.__r3f.attach = \"material\";\n        }\n        // It should NOT call onUpdate on object instanciation, because it hasn't been added to the\n        // view yet. If the callback relies on references for instance, they won't be ready yet, this is\n        // why it passes \"true\" here\n        // There is no reason to apply props to injects\n        if (name !== \"inject\") applyProps$1(instance, props);\n        return instance;\n    }\n    function appendChild(parentInstance, child) {\n        let added = false;\n        if (child) {\n            var _child$__r3f, _parentInstance$__r3f;\n            // The attach attribute implies that the object attaches itself on the parent\n            if ((_child$__r3f = child.__r3f) != null && _child$__r3f.attach) {\n                attach(parentInstance, child, child.__r3f.attach);\n            } else if (child.isObject3D && parentInstance.isObject3D) {\n                // add in the usual parent-child way\n                parentInstance.add(child);\n                added = true;\n            }\n            // This is for anything that used attach, and for non-Object3Ds that don't get attached to props;\n            // that is, anything that's a child in React but not a child in the scenegraph.\n            if (!added) (_parentInstance$__r3f = parentInstance.__r3f) == null ? void 0 : _parentInstance$__r3f.objects.push(child);\n            if (!child.__r3f) prepare(child, {});\n            child.__r3f.parent = parentInstance;\n            updateInstance(child);\n            invalidateInstance(child);\n        }\n    }\n    function insertBefore(parentInstance, child, beforeChild) {\n        let added = false;\n        if (child) {\n            var _child$__r3f2, _parentInstance$__r3f2;\n            if ((_child$__r3f2 = child.__r3f) != null && _child$__r3f2.attach) {\n                attach(parentInstance, child, child.__r3f.attach);\n            } else if (child.isObject3D && parentInstance.isObject3D) {\n                child.parent = parentInstance;\n                child.dispatchEvent({\n                    type: \"added\"\n                });\n                const restSiblings = parentInstance.children.filter((sibling)=>sibling !== child);\n                const index = restSiblings.indexOf(beforeChild);\n                parentInstance.children = [\n                    ...restSiblings.slice(0, index),\n                    child,\n                    ...restSiblings.slice(index)\n                ];\n                added = true;\n            }\n            if (!added) (_parentInstance$__r3f2 = parentInstance.__r3f) == null ? void 0 : _parentInstance$__r3f2.objects.push(child);\n            if (!child.__r3f) prepare(child, {});\n            child.__r3f.parent = parentInstance;\n            updateInstance(child);\n            invalidateInstance(child);\n        }\n    }\n    function removeRecursive(array, parent, dispose = false) {\n        if (array) [\n            ...array\n        ].forEach((child)=>removeChild(parent, child, dispose));\n    }\n    function removeChild(parentInstance, child, dispose) {\n        if (child) {\n            var _parentInstance$__r3f3, _child$__r3f3, _child$__r3f5;\n            // Clear the parent reference\n            if (child.__r3f) child.__r3f.parent = null;\n            // Remove child from the parents objects\n            if ((_parentInstance$__r3f3 = parentInstance.__r3f) != null && _parentInstance$__r3f3.objects) parentInstance.__r3f.objects = parentInstance.__r3f.objects.filter((x)=>x !== child);\n            // Remove attachment\n            if ((_child$__r3f3 = child.__r3f) != null && _child$__r3f3.attach) {\n                detach(parentInstance, child, child.__r3f.attach);\n            } else if (child.isObject3D && parentInstance.isObject3D) {\n                var _child$__r3f4;\n                parentInstance.remove(child);\n                // Remove interactivity\n                if ((_child$__r3f4 = child.__r3f) != null && _child$__r3f4.root) {\n                    removeInteractivity(child.__r3f.root, child);\n                }\n            }\n            // Allow objects to bail out of recursive dispose altogether by passing dispose={null}\n            // Never dispose of primitives because their state may be kept outside of React!\n            // In order for an object to be able to dispose it has to have\n            //   - a dispose method,\n            //   - it cannot be a <primitive object={...} />\n            //   - it cannot be a THREE.Scene, because three has broken it's own api\n            //\n            // Since disposal is recursive, we can check the optional dispose arg, which will be undefined\n            // when the reconciler calls it, but then carry our own check recursively\n            const isPrimitive = (_child$__r3f5 = child.__r3f) == null ? void 0 : _child$__r3f5.primitive;\n            const shouldDispose = dispose === undefined ? child.dispose !== null && !isPrimitive : dispose;\n            // Remove nested child objects. Primitives should not have objects and children that are\n            // attached to them declaratively ...\n            if (!isPrimitive) {\n                var _child$__r3f6;\n                removeRecursive((_child$__r3f6 = child.__r3f) == null ? void 0 : _child$__r3f6.objects, child, shouldDispose);\n                removeRecursive(child.children, child, shouldDispose);\n            }\n            // Remove references\n            delete child.__r3f;\n            // Dispose item whenever the reconciler feels like it\n            if (shouldDispose && child.dispose && child.type !== \"Scene\") {\n                (0,scheduler__WEBPACK_IMPORTED_MODULE_3__.unstable_scheduleCallback)(scheduler__WEBPACK_IMPORTED_MODULE_3__.unstable_IdlePriority, ()=>{\n                    try {\n                        child.dispose();\n                    } catch (e) {\n                    /* ... */ }\n                });\n            }\n            invalidateInstance(parentInstance);\n        }\n    }\n    function switchInstance(instance, type, newProps, fiber) {\n        var _instance$__r3f;\n        const parent = (_instance$__r3f = instance.__r3f) == null ? void 0 : _instance$__r3f.parent;\n        if (!parent) return;\n        const newInstance = createInstance(type, newProps, instance.__r3f.root);\n        // https://github.com/pmndrs/react-three-fiber/issues/1348\n        // When args change the instance has to be re-constructed, which then\n        // forces r3f to re-parent the children and non-scene objects\n        if (instance.children) {\n            for (const child of instance.children){\n                if (child.__r3f) appendChild(newInstance, child);\n            }\n            instance.children = instance.children.filter((child)=>!child.__r3f);\n        }\n        instance.__r3f.objects.forEach((child)=>appendChild(newInstance, child));\n        instance.__r3f.objects = [];\n        if (!instance.__r3f.autoRemovedBeforeAppend) {\n            removeChild(parent, instance);\n        }\n        if (newInstance.parent) {\n            newInstance.__r3f.autoRemovedBeforeAppend = true;\n        }\n        appendChild(parent, newInstance);\n        // Re-bind event handlers\n        if (newInstance.raycast && newInstance.__r3f.eventCount) {\n            const rootState = newInstance.__r3f.root.getState();\n            rootState.internal.interaction.push(newInstance);\n        }\n        [\n            fiber,\n            fiber.alternate\n        ].forEach((fiber)=>{\n            if (fiber !== null) {\n                fiber.stateNode = newInstance;\n                if (fiber.ref) {\n                    if (typeof fiber.ref === \"function\") fiber.ref(newInstance);\n                    else fiber.ref.current = newInstance;\n                }\n            }\n        });\n    }\n    // Don't handle text instances, warn on undefined behavior\n    const handleTextInstance = ()=>console.warn(\"Text is not allowed in the R3F tree! This could be stray whitespace or characters.\");\n    const reconciler = react_reconciler__WEBPACK_IMPORTED_MODULE_2___default()({\n        createInstance,\n        removeChild,\n        appendChild,\n        appendInitialChild: appendChild,\n        insertBefore,\n        supportsMutation: true,\n        isPrimaryRenderer: false,\n        supportsPersistence: false,\n        supportsHydration: false,\n        noTimeout: -1,\n        appendChildToContainer: (container, child)=>{\n            if (!child) return;\n            // Don't append to unmounted container\n            const scene = container.getState().scene;\n            if (!scene.__r3f) return;\n            // Link current root to the default scene\n            scene.__r3f.root = container;\n            appendChild(scene, child);\n        },\n        removeChildFromContainer: (container, child)=>{\n            if (!child) return;\n            removeChild(container.getState().scene, child);\n        },\n        insertInContainerBefore: (container, child, beforeChild)=>{\n            if (!child || !beforeChild) return;\n            // Don't append to unmounted container\n            const scene = container.getState().scene;\n            if (!scene.__r3f) return;\n            insertBefore(scene, child, beforeChild);\n        },\n        getRootHostContext: ()=>null,\n        getChildHostContext: (parentHostContext)=>parentHostContext,\n        finalizeInitialChildren (instance) {\n            var _instance$__r3f2;\n            const localState = (_instance$__r3f2 = instance == null ? void 0 : instance.__r3f) != null ? _instance$__r3f2 : {};\n            // https://github.com/facebook/react/issues/20271\n            // Returning true will trigger commitMount\n            return Boolean(localState.handlers);\n        },\n        prepareUpdate (instance, _type, oldProps, newProps) {\n            var _instance$__r3f3;\n            const localState = (_instance$__r3f3 = instance == null ? void 0 : instance.__r3f) != null ? _instance$__r3f3 : {};\n            // Create diff-sets\n            if (localState.primitive && newProps.object && newProps.object !== instance) {\n                return [\n                    true\n                ];\n            } else {\n                // This is a data object, let's extract critical information about it\n                const { args: argsNew = [], children: cN, ...restNew } = newProps;\n                const { args: argsOld = [], children: cO, ...restOld } = oldProps;\n                // Throw if an object or literal was passed for args\n                if (!Array.isArray(argsNew)) throw new Error(\"R3F: the args prop must be an array!\");\n                // If it has new props or arguments, then it needs to be re-instantiated\n                if (argsNew.some((value, index)=>value !== argsOld[index])) return [\n                    true\n                ];\n                // Create a diff-set, flag if there are any changes\n                const diff = diffProps(instance, restNew, restOld, true);\n                if (diff.changes.length) return [\n                    false,\n                    diff\n                ];\n                // Otherwise do not touch the instance\n                return null;\n            }\n        },\n        commitUpdate (instance, [reconstruct, diff], type, _oldProps, newProps, fiber) {\n            // Reconstruct when args or <primitive object={...} have changes\n            if (reconstruct) switchInstance(instance, type, newProps, fiber);\n            else applyProps$1(instance, diff);\n        },\n        commitMount (instance, _type, _props, _int) {\n            var _instance$__r3f4;\n            // https://github.com/facebook/react/issues/20271\n            // This will make sure events are only added once to the central container\n            const localState = (_instance$__r3f4 = instance.__r3f) != null ? _instance$__r3f4 : {};\n            if (instance.raycast && localState.handlers && localState.eventCount) {\n                instance.__r3f.root.getState().internal.interaction.push(instance);\n            }\n        },\n        getPublicInstance: (instance)=>instance,\n        prepareForCommit: ()=>null,\n        preparePortalMount: (container)=>prepare(container.getState().scene),\n        resetAfterCommit: ()=>{},\n        shouldSetTextContent: ()=>false,\n        clearContainer: ()=>false,\n        hideInstance (instance) {\n            var _instance$__r3f5;\n            // Detach while the instance is hidden\n            const { attach: type, parent } = (_instance$__r3f5 = instance.__r3f) != null ? _instance$__r3f5 : {};\n            if (type && parent) detach(parent, instance, type);\n            if (instance.isObject3D) instance.visible = false;\n            invalidateInstance(instance);\n        },\n        unhideInstance (instance, props) {\n            var _instance$__r3f6;\n            // Re-attach when the instance is unhidden\n            const { attach: type, parent } = (_instance$__r3f6 = instance.__r3f) != null ? _instance$__r3f6 : {};\n            if (type && parent) attach(parent, instance, type);\n            if (instance.isObject3D && props.visible == null || props.visible) instance.visible = true;\n            invalidateInstance(instance);\n        },\n        createTextInstance: handleTextInstance,\n        hideTextInstance: handleTextInstance,\n        unhideTextInstance: handleTextInstance,\n        // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r916356874\n        // @ts-ignore\n        getCurrentEventPriority: ()=>_getEventPriority ? _getEventPriority() : react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DefaultEventPriority,\n        beforeActiveInstanceBlur: ()=>{},\n        afterActiveInstanceBlur: ()=>{},\n        detachDeletedInstance: ()=>{},\n        now: typeof performance !== \"undefined\" && is.fun(performance.now) ? performance.now : is.fun(Date.now) ? Date.now : ()=>0,\n        // https://github.com/pmndrs/react-three-fiber/pull/2360#discussion_r920883503\n        scheduleTimeout: is.fun(setTimeout) ? setTimeout : undefined,\n        cancelTimeout: is.fun(clearTimeout) ? clearTimeout : undefined\n    });\n    return {\n        reconciler,\n        applyProps: applyProps$1\n    };\n}\nvar _window$document, _window$navigator;\n/**\n * Returns `true` with correct TS type inference if an object has a configurable color space (since r152).\n */ const hasColorSpace = (object)=>\"colorSpace\" in object || \"outputColorSpace\" in object;\n/**\n * The current THREE.ColorManagement instance, if present.\n */ const getColorManagement = ()=>{\n    var _ColorManagement;\n    return (_ColorManagement = catalogue.ColorManagement) != null ? _ColorManagement : null;\n};\nconst isOrthographicCamera = (def)=>def && def.isOrthographicCamera;\nconst isRef = (obj)=>obj && obj.hasOwnProperty(\"current\");\n/**\n * An SSR-friendly useLayoutEffect.\n *\n * React currently throws a warning when using useLayoutEffect on the server.\n * To get around it, we can conditionally useEffect on the server (no-op) and\n * useLayoutEffect elsewhere.\n *\n * @see https://github.com/facebook/react/issues/14927\n */ const useIsomorphicLayoutEffect =  false ? 0 : react__WEBPACK_IMPORTED_MODULE_0__.useEffect;\nfunction useMutableCallback(fn) {\n    const ref = react__WEBPACK_IMPORTED_MODULE_0__.useRef(fn);\n    useIsomorphicLayoutEffect(()=>void (ref.current = fn), [\n        fn\n    ]);\n    return ref;\n}\nfunction Block({ set }) {\n    useIsomorphicLayoutEffect(()=>{\n        set(new Promise(()=>null));\n        return ()=>set(false);\n    }, [\n        set\n    ]);\n    return null;\n}\nclass ErrorBoundary extends react__WEBPACK_IMPORTED_MODULE_0__.Component {\n    constructor(...args){\n        super(...args);\n        this.state = {\n            error: false\n        };\n    }\n    componentDidCatch(err) {\n        this.props.set(err);\n    }\n    render() {\n        return this.state.error ? null : this.props.children;\n    }\n}\nErrorBoundary.getDerivedStateFromError = ()=>({\n        error: true\n    });\nconst DEFAULT = \"__default\";\nconst DEFAULTS = new Map();\nconst isDiffSet = (def)=>def && !!def.memoized && !!def.changes;\nfunction calculateDpr(dpr) {\n    var _window$devicePixelRa;\n    // Err on the side of progress by assuming 2x dpr if we can't detect it\n    // This will happen in workers where window is defined but dpr isn't.\n    const target =  false ? 0 : 1;\n    return Array.isArray(dpr) ? Math.min(Math.max(dpr[0], target), dpr[1]) : dpr;\n}\n/**\n * Returns instance root state\n */ const getRootState = (obj)=>{\n    var _r3f;\n    return (_r3f = obj.__r3f) == null ? void 0 : _r3f.root.getState();\n};\n// A collection of compare functions\nconst is = {\n    obj: (a)=>a === Object(a) && !is.arr(a) && typeof a !== \"function\",\n    fun: (a)=>typeof a === \"function\",\n    str: (a)=>typeof a === \"string\",\n    num: (a)=>typeof a === \"number\",\n    boo: (a)=>typeof a === \"boolean\",\n    und: (a)=>a === void 0,\n    arr: (a)=>Array.isArray(a),\n    equ (a, b, { arrays = \"shallow\", objects = \"reference\", strict = true } = {}) {\n        // Wrong type or one of the two undefined, doesn't match\n        if (typeof a !== typeof b || !!a !== !!b) return false;\n        // Atomic, just compare a against b\n        if (is.str(a) || is.num(a)) return a === b;\n        const isObj = is.obj(a);\n        if (isObj && objects === \"reference\") return a === b;\n        const isArr = is.arr(a);\n        if (isArr && arrays === \"reference\") return a === b;\n        // Array or Object, shallow compare first to see if it's a match\n        if ((isArr || isObj) && a === b) return true;\n        // Last resort, go through keys\n        let i;\n        // Check if a has all the keys of b\n        for(i in a)if (!(i in b)) return false;\n        // Check if values between keys match\n        if (isObj && arrays === \"shallow\" && objects === \"shallow\") {\n            for(i in strict ? b : a)if (!is.equ(a[i], b[i], {\n                strict,\n                objects: \"reference\"\n            })) return false;\n        } else {\n            for(i in strict ? b : a)if (a[i] !== b[i]) return false;\n        }\n        // If i is undefined\n        if (is.und(i)) {\n            // If both arrays are empty we consider them equal\n            if (isArr && a.length === 0 && b.length === 0) return true;\n            // If both objects are empty we consider them equal\n            if (isObj && Object.keys(a).length === 0 && Object.keys(b).length === 0) return true;\n            // Otherwise match them by value\n            if (a !== b) return false;\n        }\n        return true;\n    }\n};\n// Collects nodes and materials from a THREE.Object3D\nfunction buildGraph(object) {\n    const data = {\n        nodes: {},\n        materials: {}\n    };\n    if (object) {\n        object.traverse((obj)=>{\n            if (obj.name) data.nodes[obj.name] = obj;\n            if (obj.material && !data.materials[obj.material.name]) data.materials[obj.material.name] = obj.material;\n        });\n    }\n    return data;\n}\n// Disposes an object and all its properties\nfunction dispose(obj) {\n    if (obj.dispose && obj.type !== \"Scene\") obj.dispose();\n    for(const p in obj){\n        p.dispose == null ? void 0 : p.dispose();\n        delete obj[p];\n    }\n}\n// Each object in the scene carries a small LocalState descriptor\nfunction prepare(object, state) {\n    const instance = object;\n    instance.__r3f = {\n        type: \"\",\n        root: null,\n        previousAttach: null,\n        memoizedProps: {},\n        eventCount: 0,\n        handlers: {},\n        objects: [],\n        parent: null,\n        ...state\n    };\n    return object;\n}\nfunction resolve(instance, key) {\n    let target = instance;\n    if (key.includes(\"-\")) {\n        const entries = key.split(\"-\");\n        const last = entries.pop();\n        target = entries.reduce((acc, key)=>acc[key], instance);\n        return {\n            target,\n            key: last\n        };\n    } else return {\n        target,\n        key\n    };\n}\n// Checks if a dash-cased string ends with an integer\nconst INDEX_REGEX = /-\\d+$/;\nfunction attach(parent, child, type) {\n    if (is.str(type)) {\n        // If attaching into an array (foo-0), create one\n        if (INDEX_REGEX.test(type)) {\n            const root = type.replace(INDEX_REGEX, \"\");\n            const { target, key } = resolve(parent, root);\n            if (!Array.isArray(target[key])) target[key] = [];\n        }\n        const { target, key } = resolve(parent, type);\n        child.__r3f.previousAttach = target[key];\n        target[key] = child;\n    } else child.__r3f.previousAttach = type(parent, child);\n}\nfunction detach(parent, child, type) {\n    var _child$__r3f, _child$__r3f2;\n    if (is.str(type)) {\n        const { target, key } = resolve(parent, type);\n        const previous = child.__r3f.previousAttach;\n        // When the previous value was undefined, it means the value was never set to begin with\n        if (previous === undefined) delete target[key];\n        else target[key] = previous;\n    } else (_child$__r3f = child.__r3f) == null ? void 0 : _child$__r3f.previousAttach == null ? void 0 : _child$__r3f.previousAttach(parent, child);\n    (_child$__r3f2 = child.__r3f) == null ? true : delete _child$__r3f2.previousAttach;\n}\n// This function prepares a set of changes to be applied to the instance\nfunction diffProps(instance, { children: cN, key: kN, ref: rN, ...props }, { children: cP, key: kP, ref: rP, ...previous } = {}, remove = false) {\n    var _instance$__r3f;\n    const localState = (_instance$__r3f = instance == null ? void 0 : instance.__r3f) != null ? _instance$__r3f : {};\n    const entries = Object.entries(props);\n    const changes = [];\n    // Catch removed props, prepend them so they can be reset or removed\n    if (remove) {\n        const previousKeys = Object.keys(previous);\n        for(let i = 0; i < previousKeys.length; i++){\n            if (!props.hasOwnProperty(previousKeys[i])) entries.unshift([\n                previousKeys[i],\n                DEFAULT + \"remove\"\n            ]);\n        }\n    }\n    entries.forEach(([key, value])=>{\n        var _instance$__r3f2;\n        // Bail out on primitive object\n        if ((_instance$__r3f2 = instance.__r3f) != null && _instance$__r3f2.primitive && key === \"object\") return;\n        // When props match bail out\n        if (is.equ(value, previous[key])) return;\n        // Collect handlers and bail out\n        if (/^on(Pointer|Click|DoubleClick|ContextMenu|Wheel)/.test(key)) return changes.push([\n            key,\n            value,\n            true,\n            []\n        ]);\n        // Split dashed props\n        let entries = [];\n        if (key.includes(\"-\")) entries = key.split(\"-\");\n        changes.push([\n            key,\n            value,\n            false,\n            entries\n        ]);\n        // Reset pierced props\n        for(const prop in props){\n            const value = props[prop];\n            if (prop.startsWith(`${key}-`)) changes.push([\n                prop,\n                value,\n                false,\n                prop.split(\"-\")\n            ]);\n        }\n    });\n    const memoized = {\n        ...props\n    };\n    if (localState.memoizedProps && localState.memoizedProps.args) memoized.args = localState.memoizedProps.args;\n    if (localState.memoizedProps && localState.memoizedProps.attach) memoized.attach = localState.memoizedProps.attach;\n    return {\n        memoized,\n        changes\n    };\n}\n// This function applies a set of changes to the instance\nfunction applyProps$1(instance, data) {\n    var _instance$__r3f3, _root$getState, _instance$__r3f4;\n    // Filter equals, events and reserved props\n    const localState = (_instance$__r3f3 = instance.__r3f) != null ? _instance$__r3f3 : {};\n    const root = localState.root;\n    const rootState = (_root$getState = root == null ? void 0 : root.getState == null ? void 0 : root.getState()) != null ? _root$getState : {};\n    const { memoized, changes } = isDiffSet(data) ? data : diffProps(instance, data);\n    const prevHandlers = localState.eventCount;\n    // Prepare memoized props\n    if (instance.__r3f) instance.__r3f.memoizedProps = memoized;\n    for(let i = 0; i < changes.length; i++){\n        let [key, value, isEvent, keys] = changes[i];\n        // Alias (output)encoding => (output)colorSpace (since r152)\n        // https://github.com/pmndrs/react-three-fiber/pull/2829\n        if (hasColorSpace(instance)) {\n            const sRGBEncoding = 3001;\n            const SRGBColorSpace = \"srgb\";\n            const LinearSRGBColorSpace = \"srgb-linear\";\n            if (key === \"encoding\") {\n                key = \"colorSpace\";\n                value = value === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;\n            } else if (key === \"outputEncoding\") {\n                key = \"outputColorSpace\";\n                value = value === sRGBEncoding ? SRGBColorSpace : LinearSRGBColorSpace;\n            }\n        }\n        let currentInstance = instance;\n        let targetProp = currentInstance[key];\n        // Revolve dashed props\n        if (keys.length) {\n            targetProp = keys.reduce((acc, key)=>acc[key], instance);\n            // If the target is atomic, it forces us to switch the root\n            if (!(targetProp && targetProp.set)) {\n                const [name, ...reverseEntries] = keys.reverse();\n                currentInstance = reverseEntries.reverse().reduce((acc, key)=>acc[key], instance);\n                key = name;\n            }\n        }\n        // https://github.com/mrdoob/three.js/issues/21209\n        // HMR/fast-refresh relies on the ability to cancel out props, but threejs\n        // has no means to do this. Hence we curate a small collection of value-classes\n        // with their respective constructor/set arguments\n        // For removed props, try to set default values, if possible\n        if (value === DEFAULT + \"remove\") {\n            if (currentInstance.constructor) {\n                // create a blank slate of the instance and copy the particular parameter.\n                let ctor = DEFAULTS.get(currentInstance.constructor);\n                if (!ctor) {\n                    // @ts-ignore\n                    ctor = new currentInstance.constructor();\n                    DEFAULTS.set(currentInstance.constructor, ctor);\n                }\n                value = ctor[key];\n            } else {\n                // instance does not have constructor, just set it to 0\n                value = 0;\n            }\n        }\n        // Deal with pointer events ...\n        if (isEvent) {\n            if (value) localState.handlers[key] = value;\n            else delete localState.handlers[key];\n            localState.eventCount = Object.keys(localState.handlers).length;\n        } else if (targetProp && targetProp.set && (targetProp.copy || targetProp instanceof three__WEBPACK_IMPORTED_MODULE_4__.Layers)) {\n            // If value is an array\n            if (Array.isArray(value)) {\n                if (targetProp.fromArray) targetProp.fromArray(value);\n                else targetProp.set(...value);\n            } else if (targetProp.copy && value && value.constructor && targetProp.constructor === value.constructor) {\n                targetProp.copy(value);\n            } else if (value !== undefined) {\n                const isColor = targetProp instanceof three__WEBPACK_IMPORTED_MODULE_4__.Color;\n                // Allow setting array scalars\n                if (!isColor && targetProp.setScalar) targetProp.setScalar(value);\n                else if (targetProp instanceof three__WEBPACK_IMPORTED_MODULE_4__.Layers && value instanceof three__WEBPACK_IMPORTED_MODULE_4__.Layers) targetProp.mask = value.mask;\n                else targetProp.set(value);\n                // For versions of three which don't support THREE.ColorManagement,\n                // Auto-convert sRGB colors\n                // https://github.com/pmndrs/react-three-fiber/issues/344\n                if (!getColorManagement() && !rootState.linear && isColor) targetProp.convertSRGBToLinear();\n            }\n        // Else, just overwrite the value\n        } else {\n            currentInstance[key] = value;\n            // Auto-convert sRGB textures, for now ...\n            // https://github.com/pmndrs/react-three-fiber/issues/344\n            if (currentInstance[key] instanceof three__WEBPACK_IMPORTED_MODULE_4__.Texture && // sRGB textures must be RGBA8 since r137 https://github.com/mrdoob/three.js/pull/23129\n            currentInstance[key].format === three__WEBPACK_IMPORTED_MODULE_4__.RGBAFormat && currentInstance[key].type === three__WEBPACK_IMPORTED_MODULE_4__.UnsignedByteType) {\n                const texture = currentInstance[key];\n                if (hasColorSpace(texture) && hasColorSpace(rootState.gl)) texture.colorSpace = rootState.gl.outputColorSpace;\n                else texture.encoding = rootState.gl.outputEncoding;\n            }\n        }\n        invalidateInstance(instance);\n    }\n    if (localState.parent && rootState.internal && instance.raycast && prevHandlers !== localState.eventCount) {\n        // Pre-emptively remove the instance from the interaction manager\n        const index = rootState.internal.interaction.indexOf(instance);\n        if (index > -1) rootState.internal.interaction.splice(index, 1);\n        // Add the instance to the interaction manager only when it has handlers\n        if (localState.eventCount) rootState.internal.interaction.push(instance);\n    }\n    // Call the update lifecycle when it is being updated, but only when it is part of the scene.\n    // Skip updates to the `onUpdate` prop itself\n    const isCircular = changes.length === 1 && changes[0][0] === \"onUpdate\";\n    if (!isCircular && changes.length && (_instance$__r3f4 = instance.__r3f) != null && _instance$__r3f4.parent) updateInstance(instance);\n    return instance;\n}\nfunction invalidateInstance(instance) {\n    var _instance$__r3f5, _instance$__r3f5$root;\n    const state = (_instance$__r3f5 = instance.__r3f) == null ? void 0 : (_instance$__r3f5$root = _instance$__r3f5.root) == null ? void 0 : _instance$__r3f5$root.getState == null ? void 0 : _instance$__r3f5$root.getState();\n    if (state && state.internal.frames === 0) state.invalidate();\n}\nfunction updateInstance(instance) {\n    instance.onUpdate == null ? void 0 : instance.onUpdate(instance);\n}\nfunction updateCamera(camera, size) {\n    // https://github.com/pmndrs/react-three-fiber/issues/92\n    // Do not mess with the camera if it belongs to the user\n    if (!camera.manual) {\n        if (isOrthographicCamera(camera)) {\n            camera.left = size.width / -2;\n            camera.right = size.width / 2;\n            camera.top = size.height / 2;\n            camera.bottom = size.height / -2;\n        } else {\n            camera.aspect = size.width / size.height;\n        }\n        camera.updateProjectionMatrix();\n        // https://github.com/pmndrs/react-three-fiber/issues/178\n        // Update matrix world since the renderer is a frame late\n        camera.updateMatrixWorld();\n    }\n}\nfunction makeId(event) {\n    return (event.eventObject || event.object).uuid + \"/\" + event.index + event.instanceId;\n}\n// https://github.com/facebook/react/tree/main/packages/react-reconciler#getcurrenteventpriority\n// Gives React a clue as to how import the current interaction is\nfunction getEventPriority() {\n    var _globalScope$event;\n    // Get a handle to the current global scope in window and worker contexts if able\n    // https://github.com/pmndrs/react-three-fiber/pull/2493\n    const globalScope = typeof self !== \"undefined\" && self ||  false && 0;\n    if (!globalScope) return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DefaultEventPriority;\n    const name = (_globalScope$event = globalScope.event) == null ? void 0 : _globalScope$event.type;\n    switch(name){\n        case \"click\":\n        case \"contextmenu\":\n        case \"dblclick\":\n        case \"pointercancel\":\n        case \"pointerdown\":\n        case \"pointerup\":\n            return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DiscreteEventPriority;\n        case \"pointermove\":\n        case \"pointerout\":\n        case \"pointerover\":\n        case \"pointerenter\":\n        case \"pointerleave\":\n        case \"wheel\":\n            return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.ContinuousEventPriority;\n        default:\n            return react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.DefaultEventPriority;\n    }\n}\n/**\n * Release pointer captures.\n * This is called by releasePointerCapture in the API, and when an object is removed.\n */ function releaseInternalPointerCapture(capturedMap, obj, captures, pointerId) {\n    const captureData = captures.get(obj);\n    if (captureData) {\n        captures.delete(obj);\n        // If this was the last capturing object for this pointer\n        if (captures.size === 0) {\n            capturedMap.delete(pointerId);\n            captureData.target.releasePointerCapture(pointerId);\n        }\n    }\n}\nfunction removeInteractivity(store, object) {\n    const { internal } = store.getState();\n    // Removes every trace of an object from the data store\n    internal.interaction = internal.interaction.filter((o)=>o !== object);\n    internal.initialHits = internal.initialHits.filter((o)=>o !== object);\n    internal.hovered.forEach((value, key)=>{\n        if (value.eventObject === object || value.object === object) {\n            // Clear out intersects, they are outdated by now\n            internal.hovered.delete(key);\n        }\n    });\n    internal.capturedMap.forEach((captures, pointerId)=>{\n        releaseInternalPointerCapture(internal.capturedMap, object, captures, pointerId);\n    });\n}\nfunction createEvents(store) {\n    /** Calculates delta */ function calculateDistance(event) {\n        const { internal } = store.getState();\n        const dx = event.offsetX - internal.initialClick[0];\n        const dy = event.offsetY - internal.initialClick[1];\n        return Math.round(Math.sqrt(dx * dx + dy * dy));\n    }\n    /** Returns true if an instance has a valid pointer-event registered, this excludes scroll, clicks etc */ function filterPointerEvents(objects) {\n        return objects.filter((obj)=>[\n                \"Move\",\n                \"Over\",\n                \"Enter\",\n                \"Out\",\n                \"Leave\"\n            ].some((name)=>{\n                var _r3f;\n                return (_r3f = obj.__r3f) == null ? void 0 : _r3f.handlers[\"onPointer\" + name];\n            }));\n    }\n    function intersect(event, filter) {\n        const state = store.getState();\n        const duplicates = new Set();\n        const intersections = [];\n        // Allow callers to eliminate event objects\n        const eventsObjects = filter ? filter(state.internal.interaction) : state.internal.interaction;\n        // Reset all raycaster cameras to undefined\n        for(let i = 0; i < eventsObjects.length; i++){\n            const state = getRootState(eventsObjects[i]);\n            if (state) {\n                state.raycaster.camera = undefined;\n            }\n        }\n        if (!state.previousRoot) {\n            // Make sure root-level pointer and ray are set up\n            state.events.compute == null ? void 0 : state.events.compute(event, state);\n        }\n        function handleRaycast(obj) {\n            const state = getRootState(obj);\n            // Skip event handling when noEvents is set, or when the raycasters camera is null\n            if (!state || !state.events.enabled || state.raycaster.camera === null) return [];\n            // When the camera is undefined we have to call the event layers update function\n            if (state.raycaster.camera === undefined) {\n                var _state$previousRoot;\n                state.events.compute == null ? void 0 : state.events.compute(event, state, (_state$previousRoot = state.previousRoot) == null ? void 0 : _state$previousRoot.getState());\n                // If the camera is still undefined we have to skip this layer entirely\n                if (state.raycaster.camera === undefined) state.raycaster.camera = null;\n            }\n            // Intersect object by object\n            return state.raycaster.camera ? state.raycaster.intersectObject(obj, true) : [];\n        }\n        // Collect events\n        let hits = eventsObjects// Intersect objects\n        .flatMap(handleRaycast)// Sort by event priority and distance\n        .sort((a, b)=>{\n            const aState = getRootState(a.object);\n            const bState = getRootState(b.object);\n            if (!aState || !bState) return a.distance - b.distance;\n            return bState.events.priority - aState.events.priority || a.distance - b.distance;\n        })// Filter out duplicates\n        .filter((item)=>{\n            const id = makeId(item);\n            if (duplicates.has(id)) return false;\n            duplicates.add(id);\n            return true;\n        });\n        // https://github.com/mrdoob/three.js/issues/16031\n        // Allow custom userland intersect sort order, this likely only makes sense on the root filter\n        if (state.events.filter) hits = state.events.filter(hits, state);\n        // Bubble up the events, find the event source (eventObject)\n        for (const hit of hits){\n            let eventObject = hit.object;\n            // Bubble event up\n            while(eventObject){\n                var _r3f2;\n                if ((_r3f2 = eventObject.__r3f) != null && _r3f2.eventCount) intersections.push({\n                    ...hit,\n                    eventObject\n                });\n                eventObject = eventObject.parent;\n            }\n        }\n        // If the interaction is captured, make all capturing targets part of the intersect.\n        if (\"pointerId\" in event && state.internal.capturedMap.has(event.pointerId)) {\n            for (let captureData of state.internal.capturedMap.get(event.pointerId).values()){\n                if (!duplicates.has(makeId(captureData.intersection))) intersections.push(captureData.intersection);\n            }\n        }\n        return intersections;\n    }\n    /**  Handles intersections by forwarding them to handlers */ function handleIntersects(intersections, event, delta, callback) {\n        const rootState = store.getState();\n        // If anything has been found, forward it to the event listeners\n        if (intersections.length) {\n            const localState = {\n                stopped: false\n            };\n            for (const hit of intersections){\n                const state = getRootState(hit.object) || rootState;\n                const { raycaster, pointer, camera, internal } = state;\n                const unprojectedPoint = new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(pointer.x, pointer.y, 0).unproject(camera);\n                const hasPointerCapture = (id)=>{\n                    var _internal$capturedMap, _internal$capturedMap2;\n                    return (_internal$capturedMap = (_internal$capturedMap2 = internal.capturedMap.get(id)) == null ? void 0 : _internal$capturedMap2.has(hit.eventObject)) != null ? _internal$capturedMap : false;\n                };\n                const setPointerCapture = (id)=>{\n                    const captureData = {\n                        intersection: hit,\n                        target: event.target\n                    };\n                    if (internal.capturedMap.has(id)) {\n                        // if the pointerId was previously captured, we add the hit to the\n                        // event capturedMap.\n                        internal.capturedMap.get(id).set(hit.eventObject, captureData);\n                    } else {\n                        // if the pointerId was not previously captured, we create a map\n                        // containing the hitObject, and the hit. hitObject is used for\n                        // faster access.\n                        internal.capturedMap.set(id, new Map([\n                            [\n                                hit.eventObject,\n                                captureData\n                            ]\n                        ]));\n                    }\n                    event.target.setPointerCapture(id);\n                };\n                const releasePointerCapture = (id)=>{\n                    const captures = internal.capturedMap.get(id);\n                    if (captures) {\n                        releaseInternalPointerCapture(internal.capturedMap, hit.eventObject, captures, id);\n                    }\n                };\n                // Add native event props\n                let extractEventProps = {};\n                // This iterates over the event's properties including the inherited ones. Native PointerEvents have most of their props as getters which are inherited, but polyfilled PointerEvents have them all as their own properties (i.e. not inherited). We can't use Object.keys() or Object.entries() as they only return \"own\" properties; nor Object.getPrototypeOf(event) as that *doesn't* return \"own\" properties, only inherited ones.\n                for(let prop in event){\n                    let property = event[prop];\n                    // Only copy over atomics, leave functions alone as these should be\n                    // called as event.nativeEvent.fn()\n                    if (typeof property !== \"function\") extractEventProps[prop] = property;\n                }\n                let raycastEvent = {\n                    ...hit,\n                    ...extractEventProps,\n                    pointer,\n                    intersections,\n                    stopped: localState.stopped,\n                    delta,\n                    unprojectedPoint,\n                    ray: raycaster.ray,\n                    camera: camera,\n                    // Hijack stopPropagation, which just sets a flag\n                    stopPropagation () {\n                        // https://github.com/pmndrs/react-three-fiber/issues/596\n                        // Events are not allowed to stop propagation if the pointer has been captured\n                        const capturesForPointer = \"pointerId\" in event && internal.capturedMap.get(event.pointerId);\n                        // We only authorize stopPropagation...\n                        if (// ...if this pointer hasn't been captured\n                        !capturesForPointer || // ... or if the hit object is capturing the pointer\n                        capturesForPointer.has(hit.eventObject)) {\n                            raycastEvent.stopped = localState.stopped = true;\n                            // Propagation is stopped, remove all other hover records\n                            // An event handler is only allowed to flush other handlers if it is hovered itself\n                            if (internal.hovered.size && Array.from(internal.hovered.values()).find((i)=>i.eventObject === hit.eventObject)) {\n                                // Objects cannot flush out higher up objects that have already caught the event\n                                const higher = intersections.slice(0, intersections.indexOf(hit));\n                                cancelPointer([\n                                    ...higher,\n                                    hit\n                                ]);\n                            }\n                        }\n                    },\n                    // there should be a distinction between target and currentTarget\n                    target: {\n                        hasPointerCapture,\n                        setPointerCapture,\n                        releasePointerCapture\n                    },\n                    currentTarget: {\n                        hasPointerCapture,\n                        setPointerCapture,\n                        releasePointerCapture\n                    },\n                    nativeEvent: event\n                };\n                // Call subscribers\n                callback(raycastEvent);\n                // Event bubbling may be interrupted by stopPropagation\n                if (localState.stopped === true) break;\n            }\n        }\n        return intersections;\n    }\n    function cancelPointer(intersections) {\n        const { internal } = store.getState();\n        for (const hoveredObj of internal.hovered.values()){\n            // When no objects were hit or the the hovered object wasn't found underneath the cursor\n            // we call onPointerOut and delete the object from the hovered-elements map\n            if (!intersections.length || !intersections.find((hit)=>hit.object === hoveredObj.object && hit.index === hoveredObj.index && hit.instanceId === hoveredObj.instanceId)) {\n                const eventObject = hoveredObj.eventObject;\n                const instance = eventObject.__r3f;\n                const handlers = instance == null ? void 0 : instance.handlers;\n                internal.hovered.delete(makeId(hoveredObj));\n                if (instance != null && instance.eventCount) {\n                    // Clear out intersects, they are outdated by now\n                    const data = {\n                        ...hoveredObj,\n                        intersections\n                    };\n                    handlers.onPointerOut == null ? void 0 : handlers.onPointerOut(data);\n                    handlers.onPointerLeave == null ? void 0 : handlers.onPointerLeave(data);\n                }\n            }\n        }\n    }\n    function pointerMissed(event, objects) {\n        for(let i = 0; i < objects.length; i++){\n            const instance = objects[i].__r3f;\n            instance == null ? void 0 : instance.handlers.onPointerMissed == null ? void 0 : instance.handlers.onPointerMissed(event);\n        }\n    }\n    function handlePointer(name) {\n        // Deal with cancelation\n        switch(name){\n            case \"onPointerLeave\":\n            case \"onPointerCancel\":\n                return ()=>cancelPointer([]);\n            case \"onLostPointerCapture\":\n                return (event)=>{\n                    const { internal } = store.getState();\n                    if (\"pointerId\" in event && internal.capturedMap.has(event.pointerId)) {\n                        // If the object event interface had onLostPointerCapture, we'd call it here on every\n                        // object that's getting removed. We call it on the next frame because onLostPointerCapture\n                        // fires before onPointerUp. Otherwise pointerUp would never be called if the event didn't\n                        // happen in the object it originated from, leaving components in a in-between state.\n                        requestAnimationFrame(()=>{\n                            // Only release if pointer-up didn't do it already\n                            if (internal.capturedMap.has(event.pointerId)) {\n                                internal.capturedMap.delete(event.pointerId);\n                                cancelPointer([]);\n                            }\n                        });\n                    }\n                };\n        }\n        // Any other pointer goes here ...\n        return function handleEvent(event) {\n            const { onPointerMissed, internal } = store.getState();\n            // prepareRay(event)\n            internal.lastEvent.current = event;\n            // Get fresh intersects\n            const isPointerMove = name === \"onPointerMove\";\n            const isClickEvent = name === \"onClick\" || name === \"onContextMenu\" || name === \"onDoubleClick\";\n            const filter = isPointerMove ? filterPointerEvents : undefined;\n            const hits = intersect(event, filter);\n            const delta = isClickEvent ? calculateDistance(event) : 0;\n            // Save initial coordinates on pointer-down\n            if (name === \"onPointerDown\") {\n                internal.initialClick = [\n                    event.offsetX,\n                    event.offsetY\n                ];\n                internal.initialHits = hits.map((hit)=>hit.eventObject);\n            }\n            // If a click yields no results, pass it back to the user as a miss\n            // Missed events have to come first in order to establish user-land side-effect clean up\n            if (isClickEvent && !hits.length) {\n                if (delta <= 2) {\n                    pointerMissed(event, internal.interaction);\n                    if (onPointerMissed) onPointerMissed(event);\n                }\n            }\n            // Take care of unhover\n            if (isPointerMove) cancelPointer(hits);\n            function onIntersect(data) {\n                const eventObject = data.eventObject;\n                const instance = eventObject.__r3f;\n                const handlers = instance == null ? void 0 : instance.handlers;\n                // Check presence of handlers\n                if (!(instance != null && instance.eventCount)) return;\n                /*\n        MAYBE TODO, DELETE IF NOT: \n          Check if the object is captured, captured events should not have intersects running in parallel\n          But wouldn't it be better to just replace capturedMap with a single entry?\n          Also, are we OK with straight up making picking up multiple objects impossible?\n          \n        const pointerId = (data as ThreeEvent<PointerEvent>).pointerId        \n        if (pointerId !== undefined) {\n          const capturedMeshSet = internal.capturedMap.get(pointerId)\n          if (capturedMeshSet) {\n            const captured = capturedMeshSet.get(eventObject)\n            if (captured && captured.localState.stopped) return\n          }\n        }*/ if (isPointerMove) {\n                    // Move event ...\n                    if (handlers.onPointerOver || handlers.onPointerEnter || handlers.onPointerOut || handlers.onPointerLeave) {\n                        // When enter or out is present take care of hover-state\n                        const id = makeId(data);\n                        const hoveredItem = internal.hovered.get(id);\n                        if (!hoveredItem) {\n                            // If the object wasn't previously hovered, book it and call its handler\n                            internal.hovered.set(id, data);\n                            handlers.onPointerOver == null ? void 0 : handlers.onPointerOver(data);\n                            handlers.onPointerEnter == null ? void 0 : handlers.onPointerEnter(data);\n                        } else if (hoveredItem.stopped) {\n                            // If the object was previously hovered and stopped, we shouldn't allow other items to proceed\n                            data.stopPropagation();\n                        }\n                    }\n                    // Call mouse move\n                    handlers.onPointerMove == null ? void 0 : handlers.onPointerMove(data);\n                } else {\n                    // All other events ...\n                    const handler = handlers[name];\n                    if (handler) {\n                        // Forward all events back to their respective handlers with the exception of click events,\n                        // which must use the initial target\n                        if (!isClickEvent || internal.initialHits.includes(eventObject)) {\n                            // Missed events have to come first\n                            pointerMissed(event, internal.interaction.filter((object)=>!internal.initialHits.includes(object)));\n                            // Now call the handler\n                            handler(data);\n                        }\n                    } else {\n                        // Trigger onPointerMissed on all elements that have pointer over/out handlers, but not click and weren't hit\n                        if (isClickEvent && internal.initialHits.includes(eventObject)) {\n                            pointerMissed(event, internal.interaction.filter((object)=>!internal.initialHits.includes(object)));\n                        }\n                    }\n                }\n            }\n            handleIntersects(hits, event, delta, onIntersect);\n        };\n    }\n    return {\n        handlePointer\n    };\n}\n// Keys that shouldn't be copied between R3F stores\nconst privateKeys = [\n    \"set\",\n    \"get\",\n    \"setSize\",\n    \"setFrameloop\",\n    \"setDpr\",\n    \"events\",\n    \"invalidate\",\n    \"advance\",\n    \"size\",\n    \"viewport\"\n];\nconst isRenderer = (def)=>!!(def != null && def.render);\nconst context = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createContext(null);\nconst createStore = (invalidate, advance)=>{\n    const rootState = (0,zustand__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((set, get)=>{\n        const position = new three__WEBPACK_IMPORTED_MODULE_4__.Vector3();\n        const defaultTarget = new three__WEBPACK_IMPORTED_MODULE_4__.Vector3();\n        const tempTarget = new three__WEBPACK_IMPORTED_MODULE_4__.Vector3();\n        function getCurrentViewport(camera = get().camera, target = defaultTarget, size = get().size) {\n            const { width, height, top, left } = size;\n            const aspect = width / height;\n            if (target instanceof three__WEBPACK_IMPORTED_MODULE_4__.Vector3) tempTarget.copy(target);\n            else tempTarget.set(...target);\n            const distance = camera.getWorldPosition(position).distanceTo(tempTarget);\n            if (isOrthographicCamera(camera)) {\n                return {\n                    width: width / camera.zoom,\n                    height: height / camera.zoom,\n                    top,\n                    left,\n                    factor: 1,\n                    distance,\n                    aspect\n                };\n            } else {\n                const fov = camera.fov * Math.PI / 180; // convert vertical fov to radians\n                const h = 2 * Math.tan(fov / 2) * distance; // visible height\n                const w = h * (width / height);\n                return {\n                    width: w,\n                    height: h,\n                    top,\n                    left,\n                    factor: width / w,\n                    distance,\n                    aspect\n                };\n            }\n        }\n        let performanceTimeout = undefined;\n        const setPerformanceCurrent = (current)=>set((state)=>({\n                    performance: {\n                        ...state.performance,\n                        current\n                    }\n                }));\n        const pointer = new three__WEBPACK_IMPORTED_MODULE_4__.Vector2();\n        const rootState = {\n            set,\n            get,\n            // Mock objects that have to be configured\n            gl: null,\n            camera: null,\n            raycaster: null,\n            events: {\n                priority: 1,\n                enabled: true,\n                connected: false\n            },\n            xr: null,\n            scene: null,\n            invalidate: (frames = 1)=>invalidate(get(), frames),\n            advance: (timestamp, runGlobalEffects)=>advance(timestamp, runGlobalEffects, get()),\n            legacy: false,\n            linear: false,\n            flat: false,\n            controls: null,\n            clock: new three__WEBPACK_IMPORTED_MODULE_4__.Clock(),\n            pointer,\n            mouse: pointer,\n            frameloop: \"always\",\n            onPointerMissed: undefined,\n            performance: {\n                current: 1,\n                min: 0.5,\n                max: 1,\n                debounce: 200,\n                regress: ()=>{\n                    const state = get();\n                    // Clear timeout\n                    if (performanceTimeout) clearTimeout(performanceTimeout);\n                    // Set lower bound performance\n                    if (state.performance.current !== state.performance.min) setPerformanceCurrent(state.performance.min);\n                    // Go back to upper bound performance after a while unless something regresses meanwhile\n                    performanceTimeout = setTimeout(()=>setPerformanceCurrent(get().performance.max), state.performance.debounce);\n                }\n            },\n            size: {\n                width: 0,\n                height: 0,\n                top: 0,\n                left: 0,\n                updateStyle: false\n            },\n            viewport: {\n                initialDpr: 0,\n                dpr: 0,\n                width: 0,\n                height: 0,\n                top: 0,\n                left: 0,\n                aspect: 0,\n                distance: 0,\n                factor: 0,\n                getCurrentViewport\n            },\n            setEvents: (events)=>set((state)=>({\n                        ...state,\n                        events: {\n                            ...state.events,\n                            ...events\n                        }\n                    })),\n            setSize: (width, height, updateStyle, top, left)=>{\n                const camera = get().camera;\n                const size = {\n                    width,\n                    height,\n                    top: top || 0,\n                    left: left || 0,\n                    updateStyle\n                };\n                set((state)=>({\n                        size,\n                        viewport: {\n                            ...state.viewport,\n                            ...getCurrentViewport(camera, defaultTarget, size)\n                        }\n                    }));\n            },\n            setDpr: (dpr)=>set((state)=>{\n                    const resolved = calculateDpr(dpr);\n                    return {\n                        viewport: {\n                            ...state.viewport,\n                            dpr: resolved,\n                            initialDpr: state.viewport.initialDpr || resolved\n                        }\n                    };\n                }),\n            setFrameloop: (frameloop = \"always\")=>{\n                const clock = get().clock;\n                // if frameloop === \"never\" clock.elapsedTime is updated using advance(timestamp)\n                clock.stop();\n                clock.elapsedTime = 0;\n                if (frameloop !== \"never\") {\n                    clock.start();\n                    clock.elapsedTime = 0;\n                }\n                set(()=>({\n                        frameloop\n                    }));\n            },\n            previousRoot: undefined,\n            internal: {\n                active: false,\n                priority: 0,\n                frames: 0,\n                lastEvent: /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createRef(),\n                interaction: [],\n                hovered: new Map(),\n                subscribers: [],\n                initialClick: [\n                    0,\n                    0\n                ],\n                initialHits: [],\n                capturedMap: new Map(),\n                subscribe: (ref, priority, store)=>{\n                    const internal = get().internal;\n                    // If this subscription was given a priority, it takes rendering into its own hands\n                    // For that reason we switch off automatic rendering and increase the manual flag\n                    // As long as this flag is positive there can be no internal rendering at all\n                    // because there could be multiple render subscriptions\n                    internal.priority = internal.priority + (priority > 0 ? 1 : 0);\n                    internal.subscribers.push({\n                        ref,\n                        priority,\n                        store\n                    });\n                    // Register subscriber and sort layers from lowest to highest, meaning,\n                    // highest priority renders last (on top of the other frames)\n                    internal.subscribers = internal.subscribers.sort((a, b)=>a.priority - b.priority);\n                    return ()=>{\n                        const internal = get().internal;\n                        if (internal != null && internal.subscribers) {\n                            // Decrease manual flag if this subscription had a priority\n                            internal.priority = internal.priority - (priority > 0 ? 1 : 0);\n                            // Remove subscriber from list\n                            internal.subscribers = internal.subscribers.filter((s)=>s.ref !== ref);\n                        }\n                    };\n                }\n            }\n        };\n        return rootState;\n    });\n    const state = rootState.getState();\n    let oldSize = state.size;\n    let oldDpr = state.viewport.dpr;\n    let oldCamera = state.camera;\n    rootState.subscribe(()=>{\n        const { camera, size, viewport, gl, set } = rootState.getState();\n        // Resize camera and renderer on changes to size and pixelratio\n        if (size !== oldSize || viewport.dpr !== oldDpr) {\n            var _size$updateStyle;\n            oldSize = size;\n            oldDpr = viewport.dpr;\n            // Update camera & renderer\n            updateCamera(camera, size);\n            gl.setPixelRatio(viewport.dpr);\n            const updateStyle = (_size$updateStyle = size.updateStyle) != null ? _size$updateStyle : typeof HTMLCanvasElement !== \"undefined\" && gl.domElement instanceof HTMLCanvasElement;\n            gl.setSize(size.width, size.height, updateStyle);\n        }\n        // Update viewport once the camera changes\n        if (camera !== oldCamera) {\n            oldCamera = camera;\n            // Update viewport\n            set((state)=>({\n                    viewport: {\n                        ...state.viewport,\n                        ...state.viewport.getCurrentViewport(camera)\n                    }\n                }));\n        }\n    });\n    // Invalidate on any change\n    rootState.subscribe((state)=>invalidate(state));\n    // Return root state\n    return rootState;\n};\nfunction createSubs(callback, subs) {\n    const sub = {\n        callback\n    };\n    subs.add(sub);\n    return ()=>void subs.delete(sub);\n}\nlet i;\nlet globalEffects = new Set();\nlet globalAfterEffects = new Set();\nlet globalTailEffects = new Set();\n/**\n * Adds a global render callback which is called each frame.\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addEffect\n */ const addEffect = (callback)=>createSubs(callback, globalEffects);\n/**\n * Adds a global after-render callback which is called each frame.\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addAfterEffect\n */ const addAfterEffect = (callback)=>createSubs(callback, globalAfterEffects);\n/**\n * Adds a global callback which is called when rendering stops.\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#addTail\n */ const addTail = (callback)=>createSubs(callback, globalTailEffects);\nfunction run(effects, timestamp) {\n    if (!effects.size) return;\n    for (const { callback } of effects.values()){\n        callback(timestamp);\n    }\n}\nfunction flushGlobalEffects(type, timestamp) {\n    switch(type){\n        case \"before\":\n            return run(globalEffects, timestamp);\n        case \"after\":\n            return run(globalAfterEffects, timestamp);\n        case \"tail\":\n            return run(globalTailEffects, timestamp);\n    }\n}\nlet subscribers;\nlet subscription;\nfunction render$1(timestamp, state, frame) {\n    // Run local effects\n    let delta = state.clock.getDelta();\n    // In frameloop='never' mode, clock times are updated using the provided timestamp\n    if (state.frameloop === \"never\" && typeof timestamp === \"number\") {\n        delta = timestamp - state.clock.elapsedTime;\n        state.clock.oldTime = state.clock.elapsedTime;\n        state.clock.elapsedTime = timestamp;\n    }\n    // Call subscribers (useFrame)\n    subscribers = state.internal.subscribers;\n    for(i = 0; i < subscribers.length; i++){\n        subscription = subscribers[i];\n        subscription.ref.current(subscription.store.getState(), delta, frame);\n    }\n    // Render content\n    if (!state.internal.priority && state.gl.render) state.gl.render(state.scene, state.camera);\n    // Decrease frame count\n    state.internal.frames = Math.max(0, state.internal.frames - 1);\n    return state.frameloop === \"always\" ? 1 : state.internal.frames;\n}\nfunction createLoop(roots) {\n    let running = false;\n    let repeat;\n    let frame;\n    let state;\n    function loop(timestamp) {\n        frame = requestAnimationFrame(loop);\n        running = true;\n        repeat = 0;\n        // Run effects\n        flushGlobalEffects(\"before\", timestamp);\n        // Render all roots\n        for (const root of roots.values()){\n            var _state$gl$xr;\n            state = root.store.getState();\n            // If the frameloop is invalidated, do not run another frame\n            if (state.internal.active && (state.frameloop === \"always\" || state.internal.frames > 0) && !((_state$gl$xr = state.gl.xr) != null && _state$gl$xr.isPresenting)) {\n                repeat += render$1(timestamp, state);\n            }\n        }\n        // Run after-effects\n        flushGlobalEffects(\"after\", timestamp);\n        // Stop the loop if nothing invalidates it\n        if (repeat === 0) {\n            // Tail call effects, they are called when rendering stops\n            flushGlobalEffects(\"tail\", timestamp);\n            // Flag end of operation\n            running = false;\n            return cancelAnimationFrame(frame);\n        }\n    }\n    function invalidate(state, frames = 1) {\n        var _state$gl$xr2;\n        if (!state) return roots.forEach((root)=>invalidate(root.store.getState()), frames);\n        if ((_state$gl$xr2 = state.gl.xr) != null && _state$gl$xr2.isPresenting || !state.internal.active || state.frameloop === \"never\") return;\n        // Increase frames, do not go higher than 60\n        state.internal.frames = Math.min(60, state.internal.frames + frames);\n        // If the render-loop isn't active, start it\n        if (!running) {\n            running = true;\n            requestAnimationFrame(loop);\n        }\n    }\n    function advance(timestamp, runGlobalEffects = true, state, frame) {\n        if (runGlobalEffects) flushGlobalEffects(\"before\", timestamp);\n        if (!state) for (const root of roots.values())render$1(timestamp, root.store.getState());\n        else render$1(timestamp, state, frame);\n        if (runGlobalEffects) flushGlobalEffects(\"after\", timestamp);\n    }\n    return {\n        loop,\n        /**\n     * Invalidates the view, requesting a frame to be rendered. Will globally invalidate unless passed a root's state.\n     * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#invalidate\n     */ invalidate,\n        /**\n     * Advances the frameloop and runs render effects, useful for when manually rendering via `frameloop=\"never\"`.\n     * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#advance\n     */ advance\n    };\n}\n/**\n * Exposes an object's {@link LocalState}.\n * @see https://docs.pmnd.rs/react-three-fiber/api/additional-exports#useInstanceHandle\n *\n * **Note**: this is an escape hatch to react-internal fields. Expect this to change significantly between versions.\n */ function useInstanceHandle(ref) {\n    const instance = react__WEBPACK_IMPORTED_MODULE_0__.useRef(null);\n    useIsomorphicLayoutEffect(()=>void (instance.current = ref.current.__r3f), [\n        ref\n    ]);\n    return instance;\n}\nfunction useStore() {\n    const store = react__WEBPACK_IMPORTED_MODULE_0__.useContext(context);\n    if (!store) throw new Error(\"R3F: Hooks can only be used within the Canvas component!\");\n    return store;\n}\n/**\n * Accesses R3F's internal state, containing renderer, canvas, scene, etc.\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#usethree\n */ function useThree(selector = (state)=>state, equalityFn) {\n    return useStore()(selector, equalityFn);\n}\n/**\n * Executes a callback before render in a shared frame loop.\n * Can order effects with render priority or manually render with a positive priority.\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#useframe\n */ function useFrame(callback, renderPriority = 0) {\n    const store = useStore();\n    const subscribe = store.getState().internal.subscribe;\n    // Memoize ref\n    const ref = useMutableCallback(callback);\n    // Subscribe on mount, unsubscribe on unmount\n    useIsomorphicLayoutEffect(()=>subscribe(ref, renderPriority, store), [\n        renderPriority,\n        subscribe,\n        store\n    ]);\n    return null;\n}\n/**\n * Returns a node graph of an object with named nodes & materials.\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#usegraph\n */ function useGraph(object) {\n    return react__WEBPACK_IMPORTED_MODULE_0__.useMemo(()=>buildGraph(object), [\n        object\n    ]);\n}\nfunction loadingFn(extensions, onProgress) {\n    return function(Proto, ...input) {\n        // Construct new loader and run extensions\n        const loader = new Proto();\n        if (extensions) extensions(loader);\n        // Go through the urls and load them\n        return Promise.all(input.map((input)=>new Promise((res, reject)=>loader.load(input, (data)=>{\n                    if (data.scene) Object.assign(data, buildGraph(data.scene));\n                    res(data);\n                }, onProgress, (error)=>reject(new Error(`Could not load ${input}: ${error.message}`))))));\n    };\n}\n/**\n * Synchronously loads and caches assets with a three loader.\n *\n * Note: this hook's caller must be wrapped with `React.Suspense`\n * @see https://docs.pmnd.rs/react-three-fiber/api/hooks#useloader\n */ function useLoader(Proto, input, extensions, onProgress) {\n    // Use suspense to load async assets\n    const keys = Array.isArray(input) ? input : [\n        input\n    ];\n    const results = (0,suspend_react__WEBPACK_IMPORTED_MODULE_6__.suspend)(loadingFn(extensions, onProgress), [\n        Proto,\n        ...keys\n    ], {\n        equal: is.equ\n    });\n    // Return the object/s\n    return Array.isArray(input) ? results : results[0];\n}\n/**\n * Preloads an asset into cache as a side-effect.\n */ useLoader.preload = function(Proto, input, extensions) {\n    const keys = Array.isArray(input) ? input : [\n        input\n    ];\n    return (0,suspend_react__WEBPACK_IMPORTED_MODULE_6__.preload)(loadingFn(extensions), [\n        Proto,\n        ...keys\n    ]);\n};\n/**\n * Removes a loaded asset from cache.\n */ useLoader.clear = function(Proto, input) {\n    const keys = Array.isArray(input) ? input : [\n        input\n    ];\n    return (0,suspend_react__WEBPACK_IMPORTED_MODULE_6__.clear)([\n        Proto,\n        ...keys\n    ]);\n};\nconst roots = new Map();\nconst { invalidate, advance } = createLoop(roots);\nconst { reconciler, applyProps } = createRenderer(roots, getEventPriority);\nconst shallowLoose = {\n    objects: \"shallow\",\n    strict: false\n};\nconst createRendererInstance = (gl, canvas)=>{\n    const customRenderer = typeof gl === \"function\" ? gl(canvas) : gl;\n    if (isRenderer(customRenderer)) return customRenderer;\n    else return new three__WEBPACK_IMPORTED_MODULE_7__.WebGLRenderer({\n        powerPreference: \"high-performance\",\n        canvas: canvas,\n        antialias: true,\n        alpha: true,\n        ...gl\n    });\n};\nfunction computeInitialSize(canvas, defaultSize) {\n    if (defaultSize) return defaultSize;\n    if (typeof HTMLCanvasElement !== \"undefined\" && canvas instanceof HTMLCanvasElement && canvas.parentElement) {\n        const { width, height, top, left } = canvas.parentElement.getBoundingClientRect();\n        return {\n            width,\n            height,\n            top,\n            left\n        };\n    } else if (typeof OffscreenCanvas !== \"undefined\" && canvas instanceof OffscreenCanvas) {\n        return {\n            width: canvas.width,\n            height: canvas.height,\n            top: 0,\n            left: 0\n        };\n    }\n    return {\n        width: 0,\n        height: 0,\n        top: 0,\n        left: 0\n    };\n}\nfunction createRoot(canvas) {\n    // Check against mistaken use of createRoot\n    const prevRoot = roots.get(canvas);\n    const prevFiber = prevRoot == null ? void 0 : prevRoot.fiber;\n    const prevStore = prevRoot == null ? void 0 : prevRoot.store;\n    if (prevRoot) console.warn(\"R3F.createRoot should only be called once!\");\n    // Report when an error was detected in a previous render\n    // https://github.com/pmndrs/react-three-fiber/pull/2261\n    const logRecoverableError = typeof reportError === \"function\" ? // In modern browsers, reportError will dispatch an error event,\n    // emulating an uncaught JavaScript error.\n    reportError : // In older browsers and test environments, fallback to console.error.\n    console.error;\n    // Create store\n    const store = prevStore || createStore(invalidate, advance);\n    // Create renderer\n    const fiber = prevFiber || reconciler.createContainer(store, react_reconciler_constants__WEBPACK_IMPORTED_MODULE_1__.ConcurrentRoot, null, false, null, \"\", logRecoverableError, null);\n    // Map it\n    if (!prevRoot) roots.set(canvas, {\n        fiber,\n        store\n    });\n    // Locals\n    let onCreated;\n    let configured = false;\n    let lastCamera;\n    return {\n        configure (props = {}) {\n            let { gl: glConfig, size: propsSize, scene: sceneOptions, events, onCreated: onCreatedCallback, shadows = false, linear = false, flat = false, legacy = false, orthographic = false, frameloop = \"always\", dpr = [\n                1,\n                2\n            ], performance: performance1, raycaster: raycastOptions, camera: cameraOptions, onPointerMissed } = props;\n            let state = store.getState();\n            // Set up renderer (one time only!)\n            let gl = state.gl;\n            if (!state.gl) state.set({\n                gl: gl = createRendererInstance(glConfig, canvas)\n            });\n            // Set up raycaster (one time only!)\n            let raycaster = state.raycaster;\n            if (!raycaster) state.set({\n                raycaster: raycaster = new three__WEBPACK_IMPORTED_MODULE_4__.Raycaster()\n            });\n            // Set raycaster options\n            const { params, ...options } = raycastOptions || {};\n            if (!is.equ(options, raycaster, shallowLoose)) applyProps(raycaster, {\n                ...options\n            });\n            if (!is.equ(params, raycaster.params, shallowLoose)) applyProps(raycaster, {\n                params: {\n                    ...raycaster.params,\n                    ...params\n                }\n            });\n            // Create default camera, don't overwrite any user-set state\n            if (!state.camera || state.camera === lastCamera && !is.equ(lastCamera, cameraOptions, shallowLoose)) {\n                lastCamera = cameraOptions;\n                const isCamera = cameraOptions instanceof three__WEBPACK_IMPORTED_MODULE_4__.Camera;\n                const camera = isCamera ? cameraOptions : orthographic ? new three__WEBPACK_IMPORTED_MODULE_4__.OrthographicCamera(0, 0, 0, 0, 0.1, 1000) : new three__WEBPACK_IMPORTED_MODULE_4__.PerspectiveCamera(75, 0, 0.1, 1000);\n                if (!isCamera) {\n                    camera.position.z = 5;\n                    if (cameraOptions) applyProps(camera, cameraOptions);\n                    // Always look at center by default\n                    if (!state.camera && !(cameraOptions != null && cameraOptions.rotation)) camera.lookAt(0, 0, 0);\n                }\n                state.set({\n                    camera\n                });\n            }\n            // Set up scene (one time only!)\n            if (!state.scene) {\n                let scene;\n                if (sceneOptions instanceof three__WEBPACK_IMPORTED_MODULE_4__.Scene) {\n                    scene = sceneOptions;\n                } else {\n                    scene = new three__WEBPACK_IMPORTED_MODULE_4__.Scene();\n                    if (sceneOptions) applyProps(scene, sceneOptions);\n                }\n                state.set({\n                    scene: prepare(scene)\n                });\n            }\n            // Set up XR (one time only!)\n            if (!state.xr) {\n                var _gl$xr;\n                // Handle frame behavior in WebXR\n                const handleXRFrame = (timestamp, frame)=>{\n                    const state = store.getState();\n                    if (state.frameloop === \"never\") return;\n                    advance(timestamp, true, state, frame);\n                };\n                // Toggle render switching on session\n                const handleSessionChange = ()=>{\n                    const state = store.getState();\n                    state.gl.xr.enabled = state.gl.xr.isPresenting;\n                    state.gl.xr.setAnimationLoop(state.gl.xr.isPresenting ? handleXRFrame : null);\n                    if (!state.gl.xr.isPresenting) invalidate(state);\n                };\n                // WebXR session manager\n                const xr = {\n                    connect () {\n                        const gl = store.getState().gl;\n                        gl.xr.addEventListener(\"sessionstart\", handleSessionChange);\n                        gl.xr.addEventListener(\"sessionend\", handleSessionChange);\n                    },\n                    disconnect () {\n                        const gl = store.getState().gl;\n                        gl.xr.removeEventListener(\"sessionstart\", handleSessionChange);\n                        gl.xr.removeEventListener(\"sessionend\", handleSessionChange);\n                    }\n                };\n                // Subscribe to WebXR session events\n                if (typeof ((_gl$xr = gl.xr) == null ? void 0 : _gl$xr.addEventListener) === \"function\") xr.connect();\n                state.set({\n                    xr\n                });\n            }\n            // Set shadowmap\n            if (gl.shadowMap) {\n                const oldEnabled = gl.shadowMap.enabled;\n                const oldType = gl.shadowMap.type;\n                gl.shadowMap.enabled = !!shadows;\n                if (is.boo(shadows)) {\n                    gl.shadowMap.type = three__WEBPACK_IMPORTED_MODULE_4__.PCFSoftShadowMap;\n                } else if (is.str(shadows)) {\n                    var _types$shadows;\n                    const types = {\n                        basic: three__WEBPACK_IMPORTED_MODULE_4__.BasicShadowMap,\n                        percentage: three__WEBPACK_IMPORTED_MODULE_4__.PCFShadowMap,\n                        soft: three__WEBPACK_IMPORTED_MODULE_4__.PCFSoftShadowMap,\n                        variance: three__WEBPACK_IMPORTED_MODULE_4__.VSMShadowMap\n                    };\n                    gl.shadowMap.type = (_types$shadows = types[shadows]) != null ? _types$shadows : three__WEBPACK_IMPORTED_MODULE_4__.PCFSoftShadowMap;\n                } else if (is.obj(shadows)) {\n                    Object.assign(gl.shadowMap, shadows);\n                }\n                if (oldEnabled !== gl.shadowMap.enabled || oldType !== gl.shadowMap.type) gl.shadowMap.needsUpdate = true;\n            }\n            // Safely set color management if available.\n            // Avoid accessing THREE.ColorManagement to play nice with older versions\n            const ColorManagement = getColorManagement();\n            if (ColorManagement) {\n                if (\"enabled\" in ColorManagement) ColorManagement.enabled = !legacy;\n                else if (\"legacyMode\" in ColorManagement) ColorManagement.legacyMode = legacy;\n            }\n            // Set color space and tonemapping preferences\n            const LinearEncoding = 3000;\n            const sRGBEncoding = 3001;\n            applyProps(gl, {\n                outputEncoding: linear ? LinearEncoding : sRGBEncoding,\n                toneMapping: flat ? three__WEBPACK_IMPORTED_MODULE_4__.NoToneMapping : three__WEBPACK_IMPORTED_MODULE_4__.ACESFilmicToneMapping\n            });\n            // Update color management state\n            if (state.legacy !== legacy) state.set(()=>({\n                    legacy\n                }));\n            if (state.linear !== linear) state.set(()=>({\n                    linear\n                }));\n            if (state.flat !== flat) state.set(()=>({\n                    flat\n                }));\n            // Set gl props\n            if (glConfig && !is.fun(glConfig) && !isRenderer(glConfig) && !is.equ(glConfig, gl, shallowLoose)) applyProps(gl, glConfig);\n            // Store events internally\n            if (events && !state.events.handlers) state.set({\n                events: events(store)\n            });\n            // Check size, allow it to take on container bounds initially\n            const size = computeInitialSize(canvas, propsSize);\n            if (!is.equ(size, state.size, shallowLoose)) {\n                state.setSize(size.width, size.height, size.updateStyle, size.top, size.left);\n            }\n            // Check pixelratio\n            if (dpr && state.viewport.dpr !== calculateDpr(dpr)) state.setDpr(dpr);\n            // Check frameloop\n            if (state.frameloop !== frameloop) state.setFrameloop(frameloop);\n            // Check pointer missed\n            if (!state.onPointerMissed) state.set({\n                onPointerMissed\n            });\n            // Check performance\n            if (performance1 && !is.equ(performance1, state.performance, shallowLoose)) state.set((state)=>({\n                    performance: {\n                        ...state.performance,\n                        ...performance1\n                    }\n                }));\n            // Set locals\n            onCreated = onCreatedCallback;\n            configured = true;\n            return this;\n        },\n        render (children) {\n            // The root has to be configured before it can be rendered\n            if (!configured) this.configure();\n            reconciler.updateContainer(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Provider, {\n                store: store,\n                children: children,\n                onCreated: onCreated,\n                rootElement: canvas\n            }), fiber, null, ()=>undefined);\n            return store;\n        },\n        unmount () {\n            unmountComponentAtNode(canvas);\n        }\n    };\n}\nfunction render(children, canvas, config) {\n    console.warn(\"R3F.render is no longer supported in React 18. Use createRoot instead!\");\n    const root = createRoot(canvas);\n    root.configure(config);\n    return root.render(children);\n}\nfunction Provider({ store, children, onCreated, rootElement }) {\n    useIsomorphicLayoutEffect(()=>{\n        const state = store.getState();\n        // Flag the canvas active, rendering will now begin\n        state.set((state)=>({\n                internal: {\n                    ...state.internal,\n                    active: true\n                }\n            }));\n        // Notifiy that init is completed, the scene graph exists, but nothing has yet rendered\n        if (onCreated) onCreated(state);\n        // Connect events to the targets parent, this is done to ensure events are registered on\n        // a shared target, and not on the canvas itself\n        if (!store.getState().events.connected) state.events.connect == null ? void 0 : state.events.connect(rootElement);\n    // eslint-disable-next-line react-hooks/exhaustive-deps\n    }, []);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(context.Provider, {\n        value: store\n    }, children);\n}\nfunction unmountComponentAtNode(canvas, callback) {\n    const root = roots.get(canvas);\n    const fiber = root == null ? void 0 : root.fiber;\n    if (fiber) {\n        const state = root == null ? void 0 : root.store.getState();\n        if (state) state.internal.active = false;\n        reconciler.updateContainer(null, fiber, null, ()=>{\n            if (state) {\n                setTimeout(()=>{\n                    try {\n                        var _state$gl, _state$gl$renderLists, _state$gl2, _state$gl3;\n                        state.events.disconnect == null ? void 0 : state.events.disconnect();\n                        (_state$gl = state.gl) == null ? void 0 : (_state$gl$renderLists = _state$gl.renderLists) == null ? void 0 : _state$gl$renderLists.dispose == null ? void 0 : _state$gl$renderLists.dispose();\n                        (_state$gl2 = state.gl) == null ? void 0 : _state$gl2.forceContextLoss == null ? void 0 : _state$gl2.forceContextLoss();\n                        if ((_state$gl3 = state.gl) != null && _state$gl3.xr) state.xr.disconnect();\n                        dispose(state);\n                        roots.delete(canvas);\n                        if (callback) callback(canvas);\n                    } catch (e) {\n                    /* ... */ }\n                }, 500);\n            }\n        });\n    }\n}\nfunction createPortal(children, container, state) {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(Portal, {\n        key: container.uuid,\n        children: children,\n        container: container,\n        state: state\n    });\n}\nfunction Portal({ state = {}, children, container }) {\n    /** This has to be a component because it would not be able to call useThree/useStore otherwise since\n   *  if this is our environment, then we are not in r3f's renderer but in react-dom, it would trigger\n   *  the \"R3F hooks can only be used within the Canvas component!\" warning:\n   *  <Canvas>\n   *    {createPortal(...)} */ const { events, size, ...rest } = state;\n    const previousRoot = useStore();\n    const [raycaster] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>new three__WEBPACK_IMPORTED_MODULE_4__.Raycaster());\n    const [pointer] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>new three__WEBPACK_IMPORTED_MODULE_4__.Vector2());\n    const inject = react__WEBPACK_IMPORTED_MODULE_0__.useCallback((rootState, injectState)=>{\n        const intersect = {\n            ...rootState\n        }; // all prev state props\n        // Only the fields of \"rootState\" that do not differ from injectState\n        // Some props should be off-limits\n        // Otherwise filter out the props that are different and let the inject layer take precedence\n        Object.keys(rootState).forEach((key)=>{\n            if (// Some props should be off-limits\n            privateKeys.includes(key) || // Otherwise filter out the props that are different and let the inject layer take precedence\n            // Unless the inject layer props is undefined, then we keep the root layer\n            rootState[key] !== injectState[key] && injectState[key]) {\n                delete intersect[key];\n            }\n        });\n        let viewport = undefined;\n        if (injectState && size) {\n            const camera = injectState.camera;\n            // Calculate the override viewport, if present\n            viewport = rootState.viewport.getCurrentViewport(camera, new three__WEBPACK_IMPORTED_MODULE_4__.Vector3(), size);\n            // Update the portal camera, if it differs from the previous layer\n            if (camera !== rootState.camera) updateCamera(camera, size);\n        }\n        return {\n            // The intersect consists of the previous root state\n            ...intersect,\n            // Portals have their own scene, which forms the root, a raycaster and a pointer\n            scene: container,\n            raycaster,\n            pointer,\n            mouse: pointer,\n            // Their previous root is the layer before it\n            previousRoot,\n            // Events, size and viewport can be overridden by the inject layer\n            events: {\n                ...rootState.events,\n                ...injectState == null ? void 0 : injectState.events,\n                ...events\n            },\n            size: {\n                ...rootState.size,\n                ...size\n            },\n            viewport: {\n                ...rootState.viewport,\n                ...viewport\n            },\n            ...rest\n        };\n    }, [\n        state\n    ]);\n    const [usePortalStore] = react__WEBPACK_IMPORTED_MODULE_0__.useState(()=>{\n        // Create a mirrored store, based on the previous root with a few overrides ...\n        const previousState = previousRoot.getState();\n        const store = (0,zustand__WEBPACK_IMPORTED_MODULE_5__[\"default\"])((set, get)=>({\n                ...previousState,\n                scene: container,\n                raycaster,\n                pointer,\n                mouse: pointer,\n                previousRoot,\n                events: {\n                    ...previousState.events,\n                    ...events\n                },\n                size: {\n                    ...previousState.size,\n                    ...size\n                },\n                ...rest,\n                // Set and get refer to this root-state\n                set,\n                get,\n                // Layers are allowed to override events\n                setEvents: (events)=>set((state)=>({\n                            ...state,\n                            events: {\n                                ...state.events,\n                                ...events\n                            }\n                        }))\n            }));\n        return store;\n    });\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        // Subscribe to previous root-state and copy changes over to the mirrored portal-state\n        const unsub = previousRoot.subscribe((prev)=>usePortalStore.setState((state)=>inject(prev, state)));\n        return ()=>{\n            unsub();\n            usePortalStore.destroy();\n        };\n    }, []);\n    react__WEBPACK_IMPORTED_MODULE_0__.useEffect(()=>{\n        usePortalStore.setState((injectState)=>inject(previousRoot.getState(), injectState));\n    }, [\n        inject\n    ]);\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(react__WEBPACK_IMPORTED_MODULE_0__.Fragment, null, reconciler.createPortal(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_0__.createElement(context.Provider, {\n        value: usePortalStore\n    }, children), usePortalStore, null));\n}\nreconciler.injectIntoDevTools({\n    bundleType:  false ? 0 : 1,\n    rendererPackageName: \"@react-three/fiber\",\n    version: react__WEBPACK_IMPORTED_MODULE_0__.version\n});\nconst act = react__WEBPACK_IMPORTED_MODULE_0__.unstable_act;\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL2Rpc3QvaW5kZXgtNjczZWY5ODcuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQStCO0FBQ0E7QUFDbUc7QUFDckc7QUFDYTtBQUNtQztBQUNyQjtBQUV4RCxJQUFJYSxhQUFhLFdBQVcsR0FBRUMsT0FBT0MsTUFBTSxDQUFDO0lBQzFDQyxXQUFXO0FBQ2I7QUFFQSxNQUFNQyxZQUFZLENBQUM7QUFDbkIsTUFBTUMsU0FBU0MsQ0FBQUEsVUFBVyxLQUFLTCxPQUFPTSxNQUFNLENBQUNILFdBQVdFO0FBQ3hELFNBQVNFLGVBQWVDLE1BQU0sRUFBRUMsaUJBQWlCO0lBQy9DLFNBQVNDLGVBQWVDLElBQUksRUFBRSxFQUM1QkMsT0FBTyxFQUFFLEVBQ1RDLE1BQU0sRUFDTixHQUFHQyxPQUNKLEVBQUVDLElBQUk7UUFDTCxJQUFJQyxPQUFPLENBQUMsRUFBRUwsSUFBSSxDQUFDLEVBQUUsQ0FBQ00sV0FBVyxHQUFHLEVBQUVOLEtBQUtPLEtBQUssQ0FBQyxHQUFHLENBQUM7UUFDckQsSUFBSUM7UUFDSixJQUFJUixTQUFTLGFBQWE7WUFDeEIsSUFBSUcsTUFBTU0sTUFBTSxLQUFLQyxXQUFXLE1BQU0sSUFBSUMsTUFBTTtZQUNoRCxNQUFNRixTQUFTTixNQUFNTSxNQUFNO1lBQzNCRCxXQUFXSSxRQUFRSCxRQUFRO2dCQUN6QlQ7Z0JBQ0FJO2dCQUNBRjtnQkFDQVcsV0FBVztZQUNiO1FBQ0YsT0FBTztZQUNMLE1BQU1DLFNBQVN0QixTQUFTLENBQUNhLEtBQUs7WUFDOUIsSUFBSSxDQUFDUyxRQUFRO2dCQUNYLE1BQU0sSUFBSUgsTUFBTSxDQUFDLEtBQUssRUFBRU4sS0FBSyw0SkFBNEosQ0FBQztZQUM1TDtZQUVBLG9EQUFvRDtZQUNwRCxJQUFJLENBQUNVLE1BQU1DLE9BQU8sQ0FBQ2YsT0FBTyxNQUFNLElBQUlVLE1B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QVcsR0FBRXBtQixnREFBbUIsQ0FBQ0EsMkNBQWMsRUFBRSxNQUFNeUcsV0FBV3VmLFlBQVksQ0FBRSxXQUFXLEdBQUVobUIsZ0RBQW1CLENBQUNvYSxRQUFRaUwsUUFBUSxFQUFFO1FBQ3hJN2MsT0FBTytkO0lBQ1QsR0FBR3ZpQixXQUFXdWlCLGdCQUFnQjtBQUNoQztBQUNBOWYsV0FBV3FnQixrQkFBa0IsQ0FBQztJQUM1QkMsWUFBWUMsTUFBeUIsR0FBZSxDQUFDLEdBQUc7SUFDeERDLHFCQUFxQjtJQUNyQkMsU0FBU2xuQiwwQ0FBYTtBQUN4QjtBQUNBLE1BQU1tbkIsTUFBTW5uQiwrQ0FBa0I7QUFFc2dCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmliZS0zZC1jb2RlLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9maWJlci9kaXN0L2luZGV4LTY3M2VmOTg3LmVzbS5qcz9lNWFmIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCB7IERlZmF1bHRFdmVudFByaW9yaXR5LCBDb250aW51b3VzRXZlbnRQcmlvcml0eSwgRGlzY3JldGVFdmVudFByaW9yaXR5LCBDb25jdXJyZW50Um9vdCB9IGZyb20gJ3JlYWN0LXJlY29uY2lsZXIvY29uc3RhbnRzJztcbmltcG9ydCBjcmVhdGUgZnJvbSAnenVzdGFuZCc7XG5pbXBvcnQgUmVjb25jaWxlciBmcm9tICdyZWFjdC1yZWNvbmNpbGVyJztcbmltcG9ydCB7IHVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2ssIHVuc3RhYmxlX0lkbGVQcmlvcml0eSB9IGZyb20gJ3NjaGVkdWxlcic7XG5pbXBvcnQgeyBzdXNwZW5kLCBwcmVsb2FkLCBjbGVhciB9IGZyb20gJ3N1c3BlbmQtcmVhY3QnO1xuXG52YXIgdGhyZWVUeXBlcyA9IC8qI19fUFVSRV9fKi9PYmplY3QuZnJlZXplKHtcbiAgX19wcm90b19fOiBudWxsXG59KTtcblxuY29uc3QgY2F0YWxvZ3VlID0ge307XG5jb25zdCBleHRlbmQgPSBvYmplY3RzID0+IHZvaWQgT2JqZWN0LmFzc2lnbihjYXRhbG9ndWUsIG9iamVjdHMpO1xuZnVuY3Rpb24gY3JlYXRlUmVuZGVyZXIoX3Jvb3RzLCBfZ2V0RXZlbnRQcmlvcml0eSkge1xuICBmdW5jdGlvbiBjcmVhdGVJbnN0YW5jZSh0eXBlLCB7XG4gICAgYXJncyA9IFtdLFxuICAgIGF0dGFjaCxcbiAgICAuLi5wcm9wc1xuICB9LCByb290KSB7XG4gICAgbGV0IG5hbWUgPSBgJHt0eXBlWzBdLnRvVXBwZXJDYXNlKCl9JHt0eXBlLnNsaWNlKDEpfWA7XG4gICAgbGV0IGluc3RhbmNlO1xuICAgIGlmICh0eXBlID09PSAncHJpbWl0aXZlJykge1xuICAgICAgaWYgKHByb3BzLm9iamVjdCA9PT0gdW5kZWZpbmVkKSB0aHJvdyBuZXcgRXJyb3IoXCJSM0Y6IFByaW1pdGl2ZXMgd2l0aG91dCAnb2JqZWN0JyBhcmUgaW52YWxpZCFcIik7XG4gICAgICBjb25zdCBvYmplY3QgPSBwcm9wcy5vYmplY3Q7XG4gICAgICBpbnN0YW5jZSA9IHByZXBhcmUob2JqZWN0LCB7XG4gICAgICAgIHR5cGUsXG4gICAgICAgIHJvb3QsXG4gICAgICAgIGF0dGFjaCxcbiAgICAgICAgcHJpbWl0aXZlOiB0cnVlXG4gICAgICB9KTtcbiAgICB9IGVsc2Uge1xuICAgICAgY29uc3QgdGFyZ2V0ID0gY2F0YWxvZ3VlW25hbWVdO1xuICAgICAgaWYgKCF0YXJnZXQpIHtcbiAgICAgICAgdGhyb3cgbmV3IEVycm9yKGBSM0Y6ICR7bmFtZX0gaXMgbm90IHBhcnQgb2YgdGhlIFRIUkVFIG5hbWVzcGFjZSEgRGlkIHlvdSBmb3JnZXQgdG8gZXh0ZW5kPyBTZWU6IGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9vYmplY3RzI3VzaW5nLTNyZC1wYXJ0eS1vYmplY3RzLWRlY2xhcmF0aXZlbHlgKTtcbiAgICAgIH1cblxuICAgICAgLy8gVGhyb3cgaWYgYW4gb2JqZWN0IG9yIGxpdGVyYWwgd2FzIHBhc3NlZCBmb3IgYXJnc1xuICAgICAgaWYgKCFBcnJheS5pc0FycmF5KGFyZ3MpKSB0aHJvdyBuZXcgRXJyb3IoJ1IzRjogVGhlIGFyZ3MgcHJvcCBtdXN0IGJlIGFuIGFycmF5IScpO1xuXG4gICAgICAvLyBJbnN0YW5jaWF0ZSBuZXcgb2JqZWN0LCBsaW5rIGl0IHRvIHRoZSByb290XG4gICAgICAvLyBBcHBlbmQgbWVtb2l6ZWQgcHJvcHMgd2l0aCBhcmdzIHNvIGl0J3Mgbm90IGZvcmdvdHRlblxuICAgICAgaW5zdGFuY2UgPSBwcmVwYXJlKG5ldyB0YXJnZXQoLi4uYXJncyksIHtcbiAgICAgICAgdHlwZSxcbiAgICAgICAgcm9vdCxcbiAgICAgICAgYXR0YWNoLFxuICAgICAgICAvLyBTYXZlIGFyZ3MgaW4gY2FzZSB3ZSBuZWVkIHRvIHJlY29uc3RydWN0IGxhdGVyIGZvciBITVJcbiAgICAgICAgbWVtb2l6ZWRQcm9wczoge1xuICAgICAgICAgIGFyZ3NcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgfVxuXG4gICAgLy8gQXV0by1hdHRhY2ggZ2VvbWV0cmllcyBhbmQgbWF0ZXJpYWxzXG4gICAgaWYgKGluc3RhbmNlLl9fcjNmLmF0dGFjaCA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICBpZiAoaW5zdGFuY2UgaW5zdGFuY2VvZiBUSFJFRS5CdWZmZXJHZW9tZXRyeSkgaW5zdGFuY2UuX19yM2YuYXR0YWNoID0gJ2dlb21ldHJ5JztlbHNlIGlmIChpbnN0YW5jZSBpbnN0YW5jZW9mIFRIUkVFLk1hdGVyaWFsKSBpbnN0YW5jZS5fX3IzZi5hdHRhY2ggPSAnbWF0ZXJpYWwnO1xuICAgIH1cblxuICAgIC8vIEl0IHNob3VsZCBOT1QgY2FsbCBvblVwZGF0ZSBvbiBvYmplY3QgaW5zdGFuY2lhdGlvbiwgYmVjYXVzZSBpdCBoYXNuJ3QgYmVlbiBhZGRlZCB0byB0aGVcbiAgICAvLyB2aWV3IHlldC4gSWYgdGhlIGNhbGxiYWNrIHJlbGllcyBvbiByZWZlcmVuY2VzIGZvciBpbnN0YW5jZSwgdGhleSB3b24ndCBiZSByZWFkeSB5ZXQsIHRoaXMgaXNcbiAgICAvLyB3aHkgaXQgcGFzc2VzIFwidHJ1ZVwiIGhlcmVcbiAgICAvLyBUaGVyZSBpcyBubyByZWFzb24gdG8gYXBwbHkgcHJvcHMgdG8gaW5qZWN0c1xuICAgIGlmIChuYW1lICE9PSAnaW5qZWN0JykgYXBwbHlQcm9wcyQxKGluc3RhbmNlLCBwcm9wcyk7XG4gICAgcmV0dXJuIGluc3RhbmNlO1xuICB9XG4gIGZ1bmN0aW9uIGFwcGVuZENoaWxkKHBhcmVudEluc3RhbmNlLCBjaGlsZCkge1xuICAgIGxldCBhZGRlZCA9IGZhbHNlO1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgdmFyIF9jaGlsZCRfX3IzZiwgX3BhcmVudEluc3RhbmNlJF9fcjNmO1xuICAgICAgLy8gVGhlIGF0dGFjaCBhdHRyaWJ1dGUgaW1wbGllcyB0aGF0IHRoZSBvYmplY3QgYXR0YWNoZXMgaXRzZWxmIG9uIHRoZSBwYXJlbnRcbiAgICAgIGlmICgoX2NoaWxkJF9fcjNmID0gY2hpbGQuX19yM2YpICE9IG51bGwgJiYgX2NoaWxkJF9fcjNmLmF0dGFjaCkge1xuICAgICAgICBhdHRhY2gocGFyZW50SW5zdGFuY2UsIGNoaWxkLCBjaGlsZC5fX3IzZi5hdHRhY2gpO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZC5pc09iamVjdDNEICYmIHBhcmVudEluc3RhbmNlLmlzT2JqZWN0M0QpIHtcbiAgICAgICAgLy8gYWRkIGluIHRoZSB1c3VhbCBwYXJlbnQtY2hpbGQgd2F5XG4gICAgICAgIHBhcmVudEluc3RhbmNlLmFkZChjaGlsZCk7XG4gICAgICAgIGFkZGVkID0gdHJ1ZTtcbiAgICAgIH1cbiAgICAgIC8vIFRoaXMgaXMgZm9yIGFueXRoaW5nIHRoYXQgdXNlZCBhdHRhY2gsIGFuZCBmb3Igbm9uLU9iamVjdDNEcyB0aGF0IGRvbid0IGdldCBhdHRhY2hlZCB0byBwcm9wcztcbiAgICAgIC8vIHRoYXQgaXMsIGFueXRoaW5nIHRoYXQncyBhIGNoaWxkIGluIFJlYWN0IGJ1dCBub3QgYSBjaGlsZCBpbiB0aGUgc2NlbmVncmFwaC5cbiAgICAgIGlmICghYWRkZWQpIChfcGFyZW50SW5zdGFuY2UkX19yM2YgPSBwYXJlbnRJbnN0YW5jZS5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9wYXJlbnRJbnN0YW5jZSRfX3IzZi5vYmplY3RzLnB1c2goY2hpbGQpO1xuICAgICAgaWYgKCFjaGlsZC5fX3IzZikgcHJlcGFyZShjaGlsZCwge30pO1xuICAgICAgY2hpbGQuX19yM2YucGFyZW50ID0gcGFyZW50SW5zdGFuY2U7XG4gICAgICB1cGRhdGVJbnN0YW5jZShjaGlsZCk7XG4gICAgICBpbnZhbGlkYXRlSW5zdGFuY2UoY2hpbGQpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBpbnNlcnRCZWZvcmUocGFyZW50SW5zdGFuY2UsIGNoaWxkLCBiZWZvcmVDaGlsZCkge1xuICAgIGxldCBhZGRlZCA9IGZhbHNlO1xuICAgIGlmIChjaGlsZCkge1xuICAgICAgdmFyIF9jaGlsZCRfX3IzZjIsIF9wYXJlbnRJbnN0YW5jZSRfX3IzZjI7XG4gICAgICBpZiAoKF9jaGlsZCRfX3IzZjIgPSBjaGlsZC5fX3IzZikgIT0gbnVsbCAmJiBfY2hpbGQkX19yM2YyLmF0dGFjaCkge1xuICAgICAgICBhdHRhY2gocGFyZW50SW5zdGFuY2UsIGNoaWxkLCBjaGlsZC5fX3IzZi5hdHRhY2gpO1xuICAgICAgfSBlbHNlIGlmIChjaGlsZC5pc09iamVjdDNEICYmIHBhcmVudEluc3RhbmNlLmlzT2JqZWN0M0QpIHtcbiAgICAgICAgY2hpbGQucGFyZW50ID0gcGFyZW50SW5zdGFuY2U7XG4gICAgICAgIGNoaWxkLmRpc3BhdGNoRXZlbnQoe1xuICAgICAgICAgIHR5cGU6ICdhZGRlZCdcbiAgICAgICAgfSk7XG4gICAgICAgIGNvbnN0IHJlc3RTaWJsaW5ncyA9IHBhcmVudEluc3RhbmNlLmNoaWxkcmVuLmZpbHRlcihzaWJsaW5nID0+IHNpYmxpbmcgIT09IGNoaWxkKTtcbiAgICAgICAgY29uc3QgaW5kZXggPSByZXN0U2libGluZ3MuaW5kZXhPZihiZWZvcmVDaGlsZCk7XG4gICAgICAgIHBhcmVudEluc3RhbmNlLmNoaWxkcmVuID0gWy4uLnJlc3RTaWJsaW5ncy5zbGljZSgwLCBpbmRleCksIGNoaWxkLCAuLi5yZXN0U2libGluZ3Muc2xpY2UoaW5kZXgpXTtcbiAgICAgICAgYWRkZWQgPSB0cnVlO1xuICAgICAgfVxuICAgICAgaWYgKCFhZGRlZCkgKF9wYXJlbnRJbnN0YW5jZSRfX3IzZjIgPSBwYXJlbnRJbnN0YW5jZS5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9wYXJlbnRJbnN0YW5jZSRfX3IzZjIub2JqZWN0cy5wdXNoKGNoaWxkKTtcbiAgICAgIGlmICghY2hpbGQuX19yM2YpIHByZXBhcmUoY2hpbGQsIHt9KTtcbiAgICAgIGNoaWxkLl9fcjNmLnBhcmVudCA9IHBhcmVudEluc3RhbmNlO1xuICAgICAgdXBkYXRlSW5zdGFuY2UoY2hpbGQpO1xuICAgICAgaW52YWxpZGF0ZUluc3RhbmNlKGNoaWxkKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gcmVtb3ZlUmVjdXJzaXZlKGFycmF5LCBwYXJlbnQsIGRpc3Bvc2UgPSBmYWxzZSkge1xuICAgIGlmIChhcnJheSkgWy4uLmFycmF5XS5mb3JFYWNoKGNoaWxkID0+IHJlbW92ZUNoaWxkKHBhcmVudCwgY2hpbGQsIGRpc3Bvc2UpKTtcbiAgfVxuICBmdW5jdGlvbiByZW1vdmVDaGlsZChwYXJlbnRJbnN0YW5jZSwgY2hpbGQsIGRpc3Bvc2UpIHtcbiAgICBpZiAoY2hpbGQpIHtcbiAgICAgIHZhciBfcGFyZW50SW5zdGFuY2UkX19yM2YzLCBfY2hpbGQkX19yM2YzLCBfY2hpbGQkX19yM2Y1O1xuICAgICAgLy8gQ2xlYXIgdGhlIHBhcmVudCByZWZlcmVuY2VcbiAgICAgIGlmIChjaGlsZC5fX3IzZikgY2hpbGQuX19yM2YucGFyZW50ID0gbnVsbDtcbiAgICAgIC8vIFJlbW92ZSBjaGlsZCBmcm9tIHRoZSBwYXJlbnRzIG9iamVjdHNcbiAgICAgIGlmICgoX3BhcmVudEluc3RhbmNlJF9fcjNmMyA9IHBhcmVudEluc3RhbmNlLl9fcjNmKSAhPSBudWxsICYmIF9wYXJlbnRJbnN0YW5jZSRfX3IzZjMub2JqZWN0cykgcGFyZW50SW5zdGFuY2UuX19yM2Yub2JqZWN0cyA9IHBhcmVudEluc3RhbmNlLl9fcjNmLm9iamVjdHMuZmlsdGVyKHggPT4geCAhPT0gY2hpbGQpO1xuICAgICAgLy8gUmVtb3ZlIGF0dGFjaG1lbnRcbiAgICAgIGlmICgoX2NoaWxkJF9fcjNmMyA9IGNoaWxkLl9fcjNmKSAhPSBudWxsICYmIF9jaGlsZCRfX3IzZjMuYXR0YWNoKSB7XG4gICAgICAgIGRldGFjaChwYXJlbnRJbnN0YW5jZSwgY2hpbGQsIGNoaWxkLl9fcjNmLmF0dGFjaCk7XG4gICAgICB9IGVsc2UgaWYgKGNoaWxkLmlzT2JqZWN0M0QgJiYgcGFyZW50SW5zdGFuY2UuaXNPYmplY3QzRCkge1xuICAgICAgICB2YXIgX2NoaWxkJF9fcjNmNDtcbiAgICAgICAgcGFyZW50SW5zdGFuY2UucmVtb3ZlKGNoaWxkKTtcbiAgICAgICAgLy8gUmVtb3ZlIGludGVyYWN0aXZpdHlcbiAgICAgICAgaWYgKChfY2hpbGQkX19yM2Y0ID0gY2hpbGQuX19yM2YpICE9IG51bGwgJiYgX2NoaWxkJF9fcjNmNC5yb290KSB7XG4gICAgICAgICAgcmVtb3ZlSW50ZXJhY3Rpdml0eShjaGlsZC5fX3IzZi5yb290LCBjaGlsZCk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgLy8gQWxsb3cgb2JqZWN0cyB0byBiYWlsIG91dCBvZiByZWN1cnNpdmUgZGlzcG9zZSBhbHRvZ2V0aGVyIGJ5IHBhc3NpbmcgZGlzcG9zZT17bnVsbH1cbiAgICAgIC8vIE5ldmVyIGRpc3Bvc2Ugb2YgcHJpbWl0aXZlcyBiZWNhdXNlIHRoZWlyIHN0YXRlIG1heSBiZSBrZXB0IG91dHNpZGUgb2YgUmVhY3QhXG4gICAgICAvLyBJbiBvcmRlciBmb3IgYW4gb2JqZWN0IHRvIGJlIGFibGUgdG8gZGlzcG9zZSBpdCBoYXMgdG8gaGF2ZVxuICAgICAgLy8gICAtIGEgZGlzcG9zZSBtZXRob2QsXG4gICAgICAvLyAgIC0gaXQgY2Fubm90IGJlIGEgPHByaW1pdGl2ZSBvYmplY3Q9ey4uLn0gLz5cbiAgICAgIC8vICAgLSBpdCBjYW5ub3QgYmUgYSBUSFJFRS5TY2VuZSwgYmVjYXVzZSB0aHJlZSBoYXMgYnJva2VuIGl0J3Mgb3duIGFwaVxuICAgICAgLy9cbiAgICAgIC8vIFNpbmNlIGRpc3Bvc2FsIGlzIHJlY3Vyc2l2ZSwgd2UgY2FuIGNoZWNrIHRoZSBvcHRpb25hbCBkaXNwb3NlIGFyZywgd2hpY2ggd2lsbCBiZSB1bmRlZmluZWRcbiAgICAgIC8vIHdoZW4gdGhlIHJlY29uY2lsZXIgY2FsbHMgaXQsIGJ1dCB0aGVuIGNhcnJ5IG91ciBvd24gY2hlY2sgcmVjdXJzaXZlbHlcbiAgICAgIGNvbnN0IGlzUHJpbWl0aXZlID0gKF9jaGlsZCRfX3IzZjUgPSBjaGlsZC5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jaGlsZCRfX3IzZjUucHJpbWl0aXZlO1xuICAgICAgY29uc3Qgc2hvdWxkRGlzcG9zZSA9IGRpc3Bvc2UgPT09IHVuZGVmaW5lZCA/IGNoaWxkLmRpc3Bvc2UgIT09IG51bGwgJiYgIWlzUHJpbWl0aXZlIDogZGlzcG9zZTtcblxuICAgICAgLy8gUmVtb3ZlIG5lc3RlZCBjaGlsZCBvYmplY3RzLiBQcmltaXRpdmVzIHNob3VsZCBub3QgaGF2ZSBvYmplY3RzIGFuZCBjaGlsZHJlbiB0aGF0IGFyZVxuICAgICAgLy8gYXR0YWNoZWQgdG8gdGhlbSBkZWNsYXJhdGl2ZWx5IC4uLlxuICAgICAgaWYgKCFpc1ByaW1pdGl2ZSkge1xuICAgICAgICB2YXIgX2NoaWxkJF9fcjNmNjtcbiAgICAgICAgcmVtb3ZlUmVjdXJzaXZlKChfY2hpbGQkX19yM2Y2ID0gY2hpbGQuX19yM2YpID09IG51bGwgPyB2b2lkIDAgOiBfY2hpbGQkX19yM2Y2Lm9iamVjdHMsIGNoaWxkLCBzaG91bGREaXNwb3NlKTtcbiAgICAgICAgcmVtb3ZlUmVjdXJzaXZlKGNoaWxkLmNoaWxkcmVuLCBjaGlsZCwgc2hvdWxkRGlzcG9zZSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFJlbW92ZSByZWZlcmVuY2VzXG4gICAgICBkZWxldGUgY2hpbGQuX19yM2Y7XG5cbiAgICAgIC8vIERpc3Bvc2UgaXRlbSB3aGVuZXZlciB0aGUgcmVjb25jaWxlciBmZWVscyBsaWtlIGl0XG4gICAgICBpZiAoc2hvdWxkRGlzcG9zZSAmJiBjaGlsZC5kaXNwb3NlICYmIGNoaWxkLnR5cGUgIT09ICdTY2VuZScpIHtcbiAgICAgICAgdW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayh1bnN0YWJsZV9JZGxlUHJpb3JpdHksICgpID0+IHtcbiAgICAgICAgICB0cnkge1xuICAgICAgICAgICAgY2hpbGQuZGlzcG9zZSgpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8qIC4uLiAqL1xuICAgICAgICAgIH1cbiAgICAgICAgfSk7XG4gICAgICB9XG4gICAgICBpbnZhbGlkYXRlSW5zdGFuY2UocGFyZW50SW5zdGFuY2UpO1xuICAgIH1cbiAgfVxuICBmdW5jdGlvbiBzd2l0Y2hJbnN0YW5jZShpbnN0YW5jZSwgdHlwZSwgbmV3UHJvcHMsIGZpYmVyKSB7XG4gICAgdmFyIF9pbnN0YW5jZSRfX3IzZjtcbiAgICBjb25zdCBwYXJlbnQgPSAoX2luc3RhbmNlJF9fcjNmID0gaW5zdGFuY2UuX19yM2YpID09IG51bGwgPyB2b2lkIDAgOiBfaW5zdGFuY2UkX19yM2YucGFyZW50O1xuICAgIGlmICghcGFyZW50KSByZXR1cm47XG4gICAgY29uc3QgbmV3SW5zdGFuY2UgPSBjcmVhdGVJbnN0YW5jZSh0eXBlLCBuZXdQcm9wcywgaW5zdGFuY2UuX19yM2Yucm9vdCk7XG5cbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy8xMzQ4XG4gICAgLy8gV2hlbiBhcmdzIGNoYW5nZSB0aGUgaW5zdGFuY2UgaGFzIHRvIGJlIHJlLWNvbnN0cnVjdGVkLCB3aGljaCB0aGVuXG4gICAgLy8gZm9yY2VzIHIzZiB0byByZS1wYXJlbnQgdGhlIGNoaWxkcmVuIGFuZCBub24tc2NlbmUgb2JqZWN0c1xuICAgIGlmIChpbnN0YW5jZS5jaGlsZHJlbikge1xuICAgICAgZm9yIChjb25zdCBjaGlsZCBvZiBpbnN0YW5jZS5jaGlsZHJlbikge1xuICAgICAgICBpZiAoY2hpbGQuX19yM2YpIGFwcGVuZENoaWxkKG5ld0luc3RhbmNlLCBjaGlsZCk7XG4gICAgICB9XG4gICAgICBpbnN0YW5jZS5jaGlsZHJlbiA9IGluc3RhbmNlLmNoaWxkcmVuLmZpbHRlcihjaGlsZCA9PiAhY2hpbGQuX19yM2YpO1xuICAgIH1cbiAgICBpbnN0YW5jZS5fX3IzZi5vYmplY3RzLmZvckVhY2goY2hpbGQgPT4gYXBwZW5kQ2hpbGQobmV3SW5zdGFuY2UsIGNoaWxkKSk7XG4gICAgaW5zdGFuY2UuX19yM2Yub2JqZWN0cyA9IFtdO1xuICAgIGlmICghaW5zdGFuY2UuX19yM2YuYXV0b1JlbW92ZWRCZWZvcmVBcHBlbmQpIHtcbiAgICAgIHJlbW92ZUNoaWxkKHBhcmVudCwgaW5zdGFuY2UpO1xuICAgIH1cbiAgICBpZiAobmV3SW5zdGFuY2UucGFyZW50KSB7XG4gICAgICBuZXdJbnN0YW5jZS5fX3IzZi5hdXRvUmVtb3ZlZEJlZm9yZUFwcGVuZCA9IHRydWU7XG4gICAgfVxuICAgIGFwcGVuZENoaWxkKHBhcmVudCwgbmV3SW5zdGFuY2UpO1xuXG4gICAgLy8gUmUtYmluZCBldmVudCBoYW5kbGVyc1xuICAgIGlmIChuZXdJbnN0YW5jZS5yYXljYXN0ICYmIG5ld0luc3RhbmNlLl9fcjNmLmV2ZW50Q291bnQpIHtcbiAgICAgIGNvbnN0IHJvb3RTdGF0ZSA9IG5ld0luc3RhbmNlLl9fcjNmLnJvb3QuZ2V0U3RhdGUoKTtcbiAgICAgIHJvb3RTdGF0ZS5pbnRlcm5hbC5pbnRlcmFjdGlvbi5wdXNoKG5ld0luc3RhbmNlKTtcbiAgICB9XG4gICAgW2ZpYmVyLCBmaWJlci5hbHRlcm5hdGVdLmZvckVhY2goZmliZXIgPT4ge1xuICAgICAgaWYgKGZpYmVyICE9PSBudWxsKSB7XG4gICAgICAgIGZpYmVyLnN0YXRlTm9kZSA9IG5ld0luc3RhbmNlO1xuICAgICAgICBpZiAoZmliZXIucmVmKSB7XG4gICAgICAgICAgaWYgKHR5cGVvZiBmaWJlci5yZWYgPT09ICdmdW5jdGlvbicpIGZpYmVyLnJlZihuZXdJbnN0YW5jZSk7ZWxzZSBmaWJlci5yZWYuY3VycmVudCA9IG5ld0luc3RhbmNlO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfSk7XG4gIH1cblxuICAvLyBEb24ndCBoYW5kbGUgdGV4dCBpbnN0YW5jZXMsIHdhcm4gb24gdW5kZWZpbmVkIGJlaGF2aW9yXG4gIGNvbnN0IGhhbmRsZVRleHRJbnN0YW5jZSA9ICgpID0+IGNvbnNvbGUud2FybignVGV4dCBpcyBub3QgYWxsb3dlZCBpbiB0aGUgUjNGIHRyZWUhIFRoaXMgY291bGQgYmUgc3RyYXkgd2hpdGVzcGFjZSBvciBjaGFyYWN0ZXJzLicpO1xuICBjb25zdCByZWNvbmNpbGVyID0gUmVjb25jaWxlcih7XG4gICAgY3JlYXRlSW5zdGFuY2UsXG4gICAgcmVtb3ZlQ2hpbGQsXG4gICAgYXBwZW5kQ2hpbGQsXG4gICAgYXBwZW5kSW5pdGlhbENoaWxkOiBhcHBlbmRDaGlsZCxcbiAgICBpbnNlcnRCZWZvcmUsXG4gICAgc3VwcG9ydHNNdXRhdGlvbjogdHJ1ZSxcbiAgICBpc1ByaW1hcnlSZW5kZXJlcjogZmFsc2UsXG4gICAgc3VwcG9ydHNQZXJzaXN0ZW5jZTogZmFsc2UsXG4gICAgc3VwcG9ydHNIeWRyYXRpb246IGZhbHNlLFxuICAgIG5vVGltZW91dDogLTEsXG4gICAgYXBwZW5kQ2hpbGRUb0NvbnRhaW5lcjogKGNvbnRhaW5lciwgY2hpbGQpID0+IHtcbiAgICAgIGlmICghY2hpbGQpIHJldHVybjtcblxuICAgICAgLy8gRG9uJ3QgYXBwZW5kIHRvIHVubW91bnRlZCBjb250YWluZXJcbiAgICAgIGNvbnN0IHNjZW5lID0gY29udGFpbmVyLmdldFN0YXRlKCkuc2NlbmU7XG4gICAgICBpZiAoIXNjZW5lLl9fcjNmKSByZXR1cm47XG5cbiAgICAgIC8vIExpbmsgY3VycmVudCByb290IHRvIHRoZSBkZWZhdWx0IHNjZW5lXG4gICAgICBzY2VuZS5fX3IzZi5yb290ID0gY29udGFpbmVyO1xuICAgICAgYXBwZW5kQ2hpbGQoc2NlbmUsIGNoaWxkKTtcbiAgICB9LFxuICAgIHJlbW92ZUNoaWxkRnJvbUNvbnRhaW5lcjogKGNvbnRhaW5lciwgY2hpbGQpID0+IHtcbiAgICAgIGlmICghY2hpbGQpIHJldHVybjtcbiAgICAgIHJlbW92ZUNoaWxkKGNvbnRhaW5lci5nZXRTdGF0ZSgpLnNjZW5lLCBjaGlsZCk7XG4gICAgfSxcbiAgICBpbnNlcnRJbkNvbnRhaW5lckJlZm9yZTogKGNvbnRhaW5lciwgY2hpbGQsIGJlZm9yZUNoaWxkKSA9PiB7XG4gICAgICBpZiAoIWNoaWxkIHx8ICFiZWZvcmVDaGlsZCkgcmV0dXJuO1xuXG4gICAgICAvLyBEb24ndCBhcHBlbmQgdG8gdW5tb3VudGVkIGNvbnRhaW5lclxuICAgICAgY29uc3Qgc2NlbmUgPSBjb250YWluZXIuZ2V0U3RhdGUoKS5zY2VuZTtcbiAgICAgIGlmICghc2NlbmUuX19yM2YpIHJldHVybjtcbiAgICAgIGluc2VydEJlZm9yZShzY2VuZSwgY2hpbGQsIGJlZm9yZUNoaWxkKTtcbiAgICB9LFxuICAgIGdldFJvb3RIb3N0Q29udGV4dDogKCkgPT4gbnVsbCxcbiAgICBnZXRDaGlsZEhvc3RDb250ZXh0OiBwYXJlbnRIb3N0Q29udGV4dCA9PiBwYXJlbnRIb3N0Q29udGV4dCxcbiAgICBmaW5hbGl6ZUluaXRpYWxDaGlsZHJlbihpbnN0YW5jZSkge1xuICAgICAgdmFyIF9pbnN0YW5jZSRfX3IzZjI7XG4gICAgICBjb25zdCBsb2NhbFN0YXRlID0gKF9pbnN0YW5jZSRfX3IzZjIgPSBpbnN0YW5jZSA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2UuX19yM2YpICE9IG51bGwgPyBfaW5zdGFuY2UkX19yM2YyIDoge307XG4gICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvaXNzdWVzLzIwMjcxXG4gICAgICAvLyBSZXR1cm5pbmcgdHJ1ZSB3aWxsIHRyaWdnZXIgY29tbWl0TW91bnRcbiAgICAgIHJldHVybiBCb29sZWFuKGxvY2FsU3RhdGUuaGFuZGxlcnMpO1xuICAgIH0sXG4gICAgcHJlcGFyZVVwZGF0ZShpbnN0YW5jZSwgX3R5cGUsIG9sZFByb3BzLCBuZXdQcm9wcykge1xuICAgICAgdmFyIF9pbnN0YW5jZSRfX3IzZjM7XG4gICAgICBjb25zdCBsb2NhbFN0YXRlID0gKF9pbnN0YW5jZSRfX3IzZjMgPSBpbnN0YW5jZSA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2UuX19yM2YpICE9IG51bGwgPyBfaW5zdGFuY2UkX19yM2YzIDoge307XG5cbiAgICAgIC8vIENyZWF0ZSBkaWZmLXNldHNcbiAgICAgIGlmIChsb2NhbFN0YXRlLnByaW1pdGl2ZSAmJiBuZXdQcm9wcy5vYmplY3QgJiYgbmV3UHJvcHMub2JqZWN0ICE9PSBpbnN0YW5jZSkge1xuICAgICAgICByZXR1cm4gW3RydWVdO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgLy8gVGhpcyBpcyBhIGRhdGEgb2JqZWN0LCBsZXQncyBleHRyYWN0IGNyaXRpY2FsIGluZm9ybWF0aW9uIGFib3V0IGl0XG4gICAgICAgIGNvbnN0IHtcbiAgICAgICAgICBhcmdzOiBhcmdzTmV3ID0gW10sXG4gICAgICAgICAgY2hpbGRyZW46IGNOLFxuICAgICAgICAgIC4uLnJlc3ROZXdcbiAgICAgICAgfSA9IG5ld1Byb3BzO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgYXJnczogYXJnc09sZCA9IFtdLFxuICAgICAgICAgIGNoaWxkcmVuOiBjTyxcbiAgICAgICAgICAuLi5yZXN0T2xkXG4gICAgICAgIH0gPSBvbGRQcm9wcztcblxuICAgICAgICAvLyBUaHJvdyBpZiBhbiBvYmplY3Qgb3IgbGl0ZXJhbCB3YXMgcGFzc2VkIGZvciBhcmdzXG4gICAgICAgIGlmICghQXJyYXkuaXNBcnJheShhcmdzTmV3KSkgdGhyb3cgbmV3IEVycm9yKCdSM0Y6IHRoZSBhcmdzIHByb3AgbXVzdCBiZSBhbiBhcnJheSEnKTtcblxuICAgICAgICAvLyBJZiBpdCBoYXMgbmV3IHByb3BzIG9yIGFyZ3VtZW50cywgdGhlbiBpdCBuZWVkcyB0byBiZSByZS1pbnN0YW50aWF0ZWRcbiAgICAgICAgaWYgKGFyZ3NOZXcuc29tZSgodmFsdWUsIGluZGV4KSA9PiB2YWx1ZSAhPT0gYXJnc09sZFtpbmRleF0pKSByZXR1cm4gW3RydWVdO1xuICAgICAgICAvLyBDcmVhdGUgYSBkaWZmLXNldCwgZmxhZyBpZiB0aGVyZSBhcmUgYW55IGNoYW5nZXNcbiAgICAgICAgY29uc3QgZGlmZiA9IGRpZmZQcm9wcyhpbnN0YW5jZSwgcmVzdE5ldywgcmVzdE9sZCwgdHJ1ZSk7XG4gICAgICAgIGlmIChkaWZmLmNoYW5nZXMubGVuZ3RoKSByZXR1cm4gW2ZhbHNlLCBkaWZmXTtcblxuICAgICAgICAvLyBPdGhlcndpc2UgZG8gbm90IHRvdWNoIHRoZSBpbnN0YW5jZVxuICAgICAgICByZXR1cm4gbnVsbDtcbiAgICAgIH1cbiAgICB9LFxuICAgIGNvbW1pdFVwZGF0ZShpbnN0YW5jZSwgW3JlY29uc3RydWN0LCBkaWZmXSwgdHlwZSwgX29sZFByb3BzLCBuZXdQcm9wcywgZmliZXIpIHtcbiAgICAgIC8vIFJlY29uc3RydWN0IHdoZW4gYXJncyBvciA8cHJpbWl0aXZlIG9iamVjdD17Li4ufSBoYXZlIGNoYW5nZXNcbiAgICAgIGlmIChyZWNvbnN0cnVjdCkgc3dpdGNoSW5zdGFuY2UoaW5zdGFuY2UsIHR5cGUsIG5ld1Byb3BzLCBmaWJlcik7XG4gICAgICAvLyBPdGhlcndpc2UganVzdCBvdmVyd3JpdGUgcHJvcHNcbiAgICAgIGVsc2UgYXBwbHlQcm9wcyQxKGluc3RhbmNlLCBkaWZmKTtcbiAgICB9LFxuICAgIGNvbW1pdE1vdW50KGluc3RhbmNlLCBfdHlwZSwgX3Byb3BzLCBfaW50KSB7XG4gICAgICB2YXIgX2luc3RhbmNlJF9fcjNmNDtcbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9mYWNlYm9vay9yZWFjdC9pc3N1ZXMvMjAyNzFcbiAgICAgIC8vIFRoaXMgd2lsbCBtYWtlIHN1cmUgZXZlbnRzIGFyZSBvbmx5IGFkZGVkIG9uY2UgdG8gdGhlIGNlbnRyYWwgY29udGFpbmVyXG4gICAgICBjb25zdCBsb2NhbFN0YXRlID0gKF9pbnN0YW5jZSRfX3IzZjQgPSBpbnN0YW5jZS5fX3IzZikgIT0gbnVsbCA/IF9pbnN0YW5jZSRfX3IzZjQgOiB7fTtcbiAgICAgIGlmIChpbnN0YW5jZS5yYXljYXN0ICYmIGxvY2FsU3RhdGUuaGFuZGxlcnMgJiYgbG9jYWxTdGF0ZS5ldmVudENvdW50KSB7XG4gICAgICAgIGluc3RhbmNlLl9fcjNmLnJvb3QuZ2V0U3RhdGUoKS5pbnRlcm5hbC5pbnRlcmFjdGlvbi5wdXNoKGluc3RhbmNlKTtcbiAgICAgIH1cbiAgICB9LFxuICAgIGdldFB1YmxpY0luc3RhbmNlOiBpbnN0YW5jZSA9PiBpbnN0YW5jZSxcbiAgICBwcmVwYXJlRm9yQ29tbWl0OiAoKSA9PiBudWxsLFxuICAgIHByZXBhcmVQb3J0YWxNb3VudDogY29udGFpbmVyID0+IHByZXBhcmUoY29udGFpbmVyLmdldFN0YXRlKCkuc2NlbmUpLFxuICAgIHJlc2V0QWZ0ZXJDb21taXQ6ICgpID0+IHt9LFxuICAgIHNob3VsZFNldFRleHRDb250ZW50OiAoKSA9PiBmYWxzZSxcbiAgICBjbGVhckNvbnRhaW5lcjogKCkgPT4gZmFsc2UsXG4gICAgaGlkZUluc3RhbmNlKGluc3RhbmNlKSB7XG4gICAgICB2YXIgX2luc3RhbmNlJF9fcjNmNTtcbiAgICAgIC8vIERldGFjaCB3aGlsZSB0aGUgaW5zdGFuY2UgaXMgaGlkZGVuXG4gICAgICBjb25zdCB7XG4gICAgICAgIGF0dGFjaDogdHlwZSxcbiAgICAgICAgcGFyZW50XG4gICAgICB9ID0gKF9pbnN0YW5jZSRfX3IzZjUgPSBpbnN0YW5jZS5fX3IzZikgIT0gbnVsbCA/IF9pbnN0YW5jZSRfX3IzZjUgOiB7fTtcbiAgICAgIGlmICh0eXBlICYmIHBhcmVudCkgZGV0YWNoKHBhcmVudCwgaW5zdGFuY2UsIHR5cGUpO1xuICAgICAgaWYgKGluc3RhbmNlLmlzT2JqZWN0M0QpIGluc3RhbmNlLnZpc2libGUgPSBmYWxzZTtcbiAgICAgIGludmFsaWRhdGVJbnN0YW5jZShpbnN0YW5jZSk7XG4gICAgfSxcbiAgICB1bmhpZGVJbnN0YW5jZShpbnN0YW5jZSwgcHJvcHMpIHtcbiAgICAgIHZhciBfaW5zdGFuY2UkX19yM2Y2O1xuICAgICAgLy8gUmUtYXR0YWNoIHdoZW4gdGhlIGluc3RhbmNlIGlzIHVuaGlkZGVuXG4gICAgICBjb25zdCB7XG4gICAgICAgIGF0dGFjaDogdHlwZSxcbiAgICAgICAgcGFyZW50XG4gICAgICB9ID0gKF9pbnN0YW5jZSRfX3IzZjYgPSBpbnN0YW5jZS5fX3IzZikgIT0gbnVsbCA/IF9pbnN0YW5jZSRfX3IzZjYgOiB7fTtcbiAgICAgIGlmICh0eXBlICYmIHBhcmVudCkgYXR0YWNoKHBhcmVudCwgaW5zdGFuY2UsIHR5cGUpO1xuICAgICAgaWYgKGluc3RhbmNlLmlzT2JqZWN0M0QgJiYgcHJvcHMudmlzaWJsZSA9PSBudWxsIHx8IHByb3BzLnZpc2libGUpIGluc3RhbmNlLnZpc2libGUgPSB0cnVlO1xuICAgICAgaW52YWxpZGF0ZUluc3RhbmNlKGluc3RhbmNlKTtcbiAgICB9LFxuICAgIGNyZWF0ZVRleHRJbnN0YW5jZTogaGFuZGxlVGV4dEluc3RhbmNlLFxuICAgIGhpZGVUZXh0SW5zdGFuY2U6IGhhbmRsZVRleHRJbnN0YW5jZSxcbiAgICB1bmhpZGVUZXh0SW5zdGFuY2U6IGhhbmRsZVRleHRJbnN0YW5jZSxcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL3B1bGwvMjM2MCNkaXNjdXNzaW9uX3I5MTYzNTY4NzRcbiAgICAvLyBAdHMtaWdub3JlXG4gICAgZ2V0Q3VycmVudEV2ZW50UHJpb3JpdHk6ICgpID0+IF9nZXRFdmVudFByaW9yaXR5ID8gX2dldEV2ZW50UHJpb3JpdHkoKSA6IERlZmF1bHRFdmVudFByaW9yaXR5LFxuICAgIGJlZm9yZUFjdGl2ZUluc3RhbmNlQmx1cjogKCkgPT4ge30sXG4gICAgYWZ0ZXJBY3RpdmVJbnN0YW5jZUJsdXI6ICgpID0+IHt9LFxuICAgIGRldGFjaERlbGV0ZWRJbnN0YW5jZTogKCkgPT4ge30sXG4gICAgbm93OiB0eXBlb2YgcGVyZm9ybWFuY2UgIT09ICd1bmRlZmluZWQnICYmIGlzLmZ1bihwZXJmb3JtYW5jZS5ub3cpID8gcGVyZm9ybWFuY2Uubm93IDogaXMuZnVuKERhdGUubm93KSA/IERhdGUubm93IDogKCkgPT4gMCxcbiAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL3B1bGwvMjM2MCNkaXNjdXNzaW9uX3I5MjA4ODM1MDNcbiAgICBzY2hlZHVsZVRpbWVvdXQ6IGlzLmZ1bihzZXRUaW1lb3V0KSA/IHNldFRpbWVvdXQgOiB1bmRlZmluZWQsXG4gICAgY2FuY2VsVGltZW91dDogaXMuZnVuKGNsZWFyVGltZW91dCkgPyBjbGVhclRpbWVvdXQgOiB1bmRlZmluZWRcbiAgfSk7XG4gIHJldHVybiB7XG4gICAgcmVjb25jaWxlcixcbiAgICBhcHBseVByb3BzOiBhcHBseVByb3BzJDFcbiAgfTtcbn1cblxudmFyIF93aW5kb3ckZG9jdW1lbnQsIF93aW5kb3ckbmF2aWdhdG9yO1xuLyoqXG4gKiBSZXR1cm5zIGB0cnVlYCB3aXRoIGNvcnJlY3QgVFMgdHlwZSBpbmZlcmVuY2UgaWYgYW4gb2JqZWN0IGhhcyBhIGNvbmZpZ3VyYWJsZSBjb2xvciBzcGFjZSAoc2luY2UgcjE1MikuXG4gKi9cbmNvbnN0IGhhc0NvbG9yU3BhY2UgPSBvYmplY3QgPT4gJ2NvbG9yU3BhY2UnIGluIG9iamVjdCB8fCAnb3V0cHV0Q29sb3JTcGFjZScgaW4gb2JqZWN0O1xuLyoqXG4gKiBUaGUgY3VycmVudCBUSFJFRS5Db2xvck1hbmFnZW1lbnQgaW5zdGFuY2UsIGlmIHByZXNlbnQuXG4gKi9cbmNvbnN0IGdldENvbG9yTWFuYWdlbWVudCA9ICgpID0+IHtcbiAgdmFyIF9Db2xvck1hbmFnZW1lbnQ7XG4gIHJldHVybiAoX0NvbG9yTWFuYWdlbWVudCA9IGNhdGFsb2d1ZS5Db2xvck1hbmFnZW1lbnQpICE9IG51bGwgPyBfQ29sb3JNYW5hZ2VtZW50IDogbnVsbDtcbn07XG5jb25zdCBpc09ydGhvZ3JhcGhpY0NhbWVyYSA9IGRlZiA9PiBkZWYgJiYgZGVmLmlzT3J0aG9ncmFwaGljQ2FtZXJhO1xuY29uc3QgaXNSZWYgPSBvYmogPT4gb2JqICYmIG9iai5oYXNPd25Qcm9wZXJ0eSgnY3VycmVudCcpO1xuXG4vKipcbiAqIEFuIFNTUi1mcmllbmRseSB1c2VMYXlvdXRFZmZlY3QuXG4gKlxuICogUmVhY3QgY3VycmVudGx5IHRocm93cyBhIHdhcm5pbmcgd2hlbiB1c2luZyB1c2VMYXlvdXRFZmZlY3Qgb24gdGhlIHNlcnZlci5cbiAqIFRvIGdldCBhcm91bmQgaXQsIHdlIGNhbiBjb25kaXRpb25hbGx5IHVzZUVmZmVjdCBvbiB0aGUgc2VydmVyIChuby1vcCkgYW5kXG4gKiB1c2VMYXlvdXRFZmZlY3QgZWxzZXdoZXJlLlxuICpcbiAqIEBzZWUgaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8xNDkyN1xuICovXG5jb25zdCB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0ID0gdHlwZW9mIHdpbmRvdyAhPT0gJ3VuZGVmaW5lZCcgJiYgKChfd2luZG93JGRvY3VtZW50ID0gd2luZG93LmRvY3VtZW50KSAhPSBudWxsICYmIF93aW5kb3ckZG9jdW1lbnQuY3JlYXRlRWxlbWVudCB8fCAoKF93aW5kb3ckbmF2aWdhdG9yID0gd2luZG93Lm5hdmlnYXRvcikgPT0gbnVsbCA/IHZvaWQgMCA6IF93aW5kb3ckbmF2aWdhdG9yLnByb2R1Y3QpID09PSAnUmVhY3ROYXRpdmUnKSA/IFJlYWN0LnVzZUxheW91dEVmZmVjdCA6IFJlYWN0LnVzZUVmZmVjdDtcbmZ1bmN0aW9uIHVzZU11dGFibGVDYWxsYmFjayhmbikge1xuICBjb25zdCByZWYgPSBSZWFjdC51c2VSZWYoZm4pO1xuICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHZvaWQgKHJlZi5jdXJyZW50ID0gZm4pLCBbZm5dKTtcbiAgcmV0dXJuIHJlZjtcbn1cbmZ1bmN0aW9uIEJsb2NrKHtcbiAgc2V0XG59KSB7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4ge1xuICAgIHNldChuZXcgUHJvbWlzZSgoKSA9PiBudWxsKSk7XG4gICAgcmV0dXJuICgpID0+IHNldChmYWxzZSk7XG4gIH0sIFtzZXRdKTtcbiAgcmV0dXJuIG51bGw7XG59XG5jbGFzcyBFcnJvckJvdW5kYXJ5IGV4dGVuZHMgUmVhY3QuQ29tcG9uZW50IHtcbiAgY29uc3RydWN0b3IoLi4uYXJncykge1xuICAgIHN1cGVyKC4uLmFyZ3MpO1xuICAgIHRoaXMuc3RhdGUgPSB7XG4gICAgICBlcnJvcjogZmFsc2VcbiAgICB9O1xuICB9XG4gIGNvbXBvbmVudERpZENhdGNoKGVycikge1xuICAgIHRoaXMucHJvcHMuc2V0KGVycik7XG4gIH1cbiAgcmVuZGVyKCkge1xuICAgIHJldHVybiB0aGlzLnN0YXRlLmVycm9yID8gbnVsbCA6IHRoaXMucHJvcHMuY2hpbGRyZW47XG4gIH1cbn1cbkVycm9yQm91bmRhcnkuZ2V0RGVyaXZlZFN0YXRlRnJvbUVycm9yID0gKCkgPT4gKHtcbiAgZXJyb3I6IHRydWVcbn0pO1xuY29uc3QgREVGQVVMVCA9ICdfX2RlZmF1bHQnO1xuY29uc3QgREVGQVVMVFMgPSBuZXcgTWFwKCk7XG5jb25zdCBpc0RpZmZTZXQgPSBkZWYgPT4gZGVmICYmICEhZGVmLm1lbW9pemVkICYmICEhZGVmLmNoYW5nZXM7XG5mdW5jdGlvbiBjYWxjdWxhdGVEcHIoZHByKSB7XG4gIHZhciBfd2luZG93JGRldmljZVBpeGVsUmE7XG4gIC8vIEVyciBvbiB0aGUgc2lkZSBvZiBwcm9ncmVzcyBieSBhc3N1bWluZyAyeCBkcHIgaWYgd2UgY2FuJ3QgZGV0ZWN0IGl0XG4gIC8vIFRoaXMgd2lsbCBoYXBwZW4gaW4gd29ya2VycyB3aGVyZSB3aW5kb3cgaXMgZGVmaW5lZCBidXQgZHByIGlzbid0LlxuICBjb25zdCB0YXJnZXQgPSB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyA/IChfd2luZG93JGRldmljZVBpeGVsUmEgPSB3aW5kb3cuZGV2aWNlUGl4ZWxSYXRpbykgIT0gbnVsbCA/IF93aW5kb3ckZGV2aWNlUGl4ZWxSYSA6IDIgOiAxO1xuICByZXR1cm4gQXJyYXkuaXNBcnJheShkcHIpID8gTWF0aC5taW4oTWF0aC5tYXgoZHByWzBdLCB0YXJnZXQpLCBkcHJbMV0pIDogZHByO1xufVxuXG4vKipcbiAqIFJldHVybnMgaW5zdGFuY2Ugcm9vdCBzdGF0ZVxuICovXG5jb25zdCBnZXRSb290U3RhdGUgPSBvYmogPT4ge1xuICB2YXIgX3IzZjtcbiAgcmV0dXJuIChfcjNmID0gb2JqLl9fcjNmKSA9PSBudWxsID8gdm9pZCAwIDogX3IzZi5yb290LmdldFN0YXRlKCk7XG59O1xuLy8gQSBjb2xsZWN0aW9uIG9mIGNvbXBhcmUgZnVuY3Rpb25zXG5jb25zdCBpcyA9IHtcbiAgb2JqOiBhID0+IGEgPT09IE9iamVjdChhKSAmJiAhaXMuYXJyKGEpICYmIHR5cGVvZiBhICE9PSAnZnVuY3Rpb24nLFxuICBmdW46IGEgPT4gdHlwZW9mIGEgPT09ICdmdW5jdGlvbicsXG4gIHN0cjogYSA9PiB0eXBlb2YgYSA9PT0gJ3N0cmluZycsXG4gIG51bTogYSA9PiB0eXBlb2YgYSA9PT0gJ251bWJlcicsXG4gIGJvbzogYSA9PiB0eXBlb2YgYSA9PT0gJ2Jvb2xlYW4nLFxuICB1bmQ6IGEgPT4gYSA9PT0gdm9pZCAwLFxuICBhcnI6IGEgPT4gQXJyYXkuaXNBcnJheShhKSxcbiAgZXF1KGEsIGIsIHtcbiAgICBhcnJheXMgPSAnc2hhbGxvdycsXG4gICAgb2JqZWN0cyA9ICdyZWZlcmVuY2UnLFxuICAgIHN0cmljdCA9IHRydWVcbiAgfSA9IHt9KSB7XG4gICAgLy8gV3JvbmcgdHlwZSBvciBvbmUgb2YgdGhlIHR3byB1bmRlZmluZWQsIGRvZXNuJ3QgbWF0Y2hcbiAgICBpZiAodHlwZW9mIGEgIT09IHR5cGVvZiBiIHx8ICEhYSAhPT0gISFiKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gQXRvbWljLCBqdXN0IGNvbXBhcmUgYSBhZ2FpbnN0IGJcbiAgICBpZiAoaXMuc3RyKGEpIHx8IGlzLm51bShhKSkgcmV0dXJuIGEgPT09IGI7XG4gICAgY29uc3QgaXNPYmogPSBpcy5vYmooYSk7XG4gICAgaWYgKGlzT2JqICYmIG9iamVjdHMgPT09ICdyZWZlcmVuY2UnKSByZXR1cm4gYSA9PT0gYjtcbiAgICBjb25zdCBpc0FyciA9IGlzLmFycihhKTtcbiAgICBpZiAoaXNBcnIgJiYgYXJyYXlzID09PSAncmVmZXJlbmNlJykgcmV0dXJuIGEgPT09IGI7XG4gICAgLy8gQXJyYXkgb3IgT2JqZWN0LCBzaGFsbG93IGNvbXBhcmUgZmlyc3QgdG8gc2VlIGlmIGl0J3MgYSBtYXRjaFxuICAgIGlmICgoaXNBcnIgfHwgaXNPYmopICYmIGEgPT09IGIpIHJldHVybiB0cnVlO1xuICAgIC8vIExhc3QgcmVzb3J0LCBnbyB0aHJvdWdoIGtleXNcbiAgICBsZXQgaTtcbiAgICAvLyBDaGVjayBpZiBhIGhhcyBhbGwgdGhlIGtleXMgb2YgYlxuICAgIGZvciAoaSBpbiBhKSBpZiAoIShpIGluIGIpKSByZXR1cm4gZmFsc2U7XG4gICAgLy8gQ2hlY2sgaWYgdmFsdWVzIGJldHdlZW4ga2V5cyBtYXRjaFxuICAgIGlmIChpc09iaiAmJiBhcnJheXMgPT09ICdzaGFsbG93JyAmJiBvYmplY3RzID09PSAnc2hhbGxvdycpIHtcbiAgICAgIGZvciAoaSBpbiBzdHJpY3QgPyBiIDogYSkgaWYgKCFpcy5lcXUoYVtpXSwgYltpXSwge1xuICAgICAgICBzdHJpY3QsXG4gICAgICAgIG9iamVjdHM6ICdyZWZlcmVuY2UnXG4gICAgICB9KSkgcmV0dXJuIGZhbHNlO1xuICAgIH0gZWxzZSB7XG4gICAgICBmb3IgKGkgaW4gc3RyaWN0ID8gYiA6IGEpIGlmIChhW2ldICE9PSBiW2ldKSByZXR1cm4gZmFsc2U7XG4gICAgfVxuICAgIC8vIElmIGkgaXMgdW5kZWZpbmVkXG4gICAgaWYgKGlzLnVuZChpKSkge1xuICAgICAgLy8gSWYgYm90aCBhcnJheXMgYXJlIGVtcHR5IHdlIGNvbnNpZGVyIHRoZW0gZXF1YWxcbiAgICAgIGlmIChpc0FyciAmJiBhLmxlbmd0aCA9PT0gMCAmJiBiLmxlbmd0aCA9PT0gMCkgcmV0dXJuIHRydWU7XG4gICAgICAvLyBJZiBib3RoIG9iamVjdHMgYXJlIGVtcHR5IHdlIGNvbnNpZGVyIHRoZW0gZXF1YWxcbiAgICAgIGlmIChpc09iaiAmJiBPYmplY3Qua2V5cyhhKS5sZW5ndGggPT09IDAgJiYgT2JqZWN0LmtleXMoYikubGVuZ3RoID09PSAwKSByZXR1cm4gdHJ1ZTtcbiAgICAgIC8vIE90aGVyd2lzZSBtYXRjaCB0aGVtIGJ5IHZhbHVlXG4gICAgICBpZiAoYSAhPT0gYikgcmV0dXJuIGZhbHNlO1xuICAgIH1cbiAgICByZXR1cm4gdHJ1ZTtcbiAgfVxufTtcblxuLy8gQ29sbGVjdHMgbm9kZXMgYW5kIG1hdGVyaWFscyBmcm9tIGEgVEhSRUUuT2JqZWN0M0RcbmZ1bmN0aW9uIGJ1aWxkR3JhcGgob2JqZWN0KSB7XG4gIGNvbnN0IGRhdGEgPSB7XG4gICAgbm9kZXM6IHt9LFxuICAgIG1hdGVyaWFsczoge31cbiAgfTtcbiAgaWYgKG9iamVjdCkge1xuICAgIG9iamVjdC50cmF2ZXJzZShvYmogPT4ge1xuICAgICAgaWYgKG9iai5uYW1lKSBkYXRhLm5vZGVzW29iai5uYW1lXSA9IG9iajtcbiAgICAgIGlmIChvYmoubWF0ZXJpYWwgJiYgIWRhdGEubWF0ZXJpYWxzW29iai5tYXRlcmlhbC5uYW1lXSkgZGF0YS5tYXRlcmlhbHNbb2JqLm1hdGVyaWFsLm5hbWVdID0gb2JqLm1hdGVyaWFsO1xuICAgIH0pO1xuICB9XG4gIHJldHVybiBkYXRhO1xufVxuXG4vLyBEaXNwb3NlcyBhbiBvYmplY3QgYW5kIGFsbCBpdHMgcHJvcGVydGllc1xuZnVuY3Rpb24gZGlzcG9zZShvYmopIHtcbiAgaWYgKG9iai5kaXNwb3NlICYmIG9iai50eXBlICE9PSAnU2NlbmUnKSBvYmouZGlzcG9zZSgpO1xuICBmb3IgKGNvbnN0IHAgaW4gb2JqKSB7XG4gICAgcC5kaXNwb3NlID09IG51bGwgPyB2b2lkIDAgOiBwLmRpc3Bvc2UoKTtcbiAgICBkZWxldGUgb2JqW3BdO1xuICB9XG59XG5cbi8vIEVhY2ggb2JqZWN0IGluIHRoZSBzY2VuZSBjYXJyaWVzIGEgc21hbGwgTG9jYWxTdGF0ZSBkZXNjcmlwdG9yXG5mdW5jdGlvbiBwcmVwYXJlKG9iamVjdCwgc3RhdGUpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBvYmplY3Q7XG4gIGluc3RhbmNlLl9fcjNmID0ge1xuICAgIHR5cGU6ICcnLFxuICAgIHJvb3Q6IG51bGwsXG4gICAgcHJldmlvdXNBdHRhY2g6IG51bGwsXG4gICAgbWVtb2l6ZWRQcm9wczoge30sXG4gICAgZXZlbnRDb3VudDogMCxcbiAgICBoYW5kbGVyczoge30sXG4gICAgb2JqZWN0czogW10sXG4gICAgcGFyZW50OiBudWxsLFxuICAgIC4uLnN0YXRlXG4gIH07XG4gIHJldHVybiBvYmplY3Q7XG59XG5mdW5jdGlvbiByZXNvbHZlKGluc3RhbmNlLCBrZXkpIHtcbiAgbGV0IHRhcmdldCA9IGluc3RhbmNlO1xuICBpZiAoa2V5LmluY2x1ZGVzKCctJykpIHtcbiAgICBjb25zdCBlbnRyaWVzID0ga2V5LnNwbGl0KCctJyk7XG4gICAgY29uc3QgbGFzdCA9IGVudHJpZXMucG9wKCk7XG4gICAgdGFyZ2V0ID0gZW50cmllcy5yZWR1Y2UoKGFjYywga2V5KSA9PiBhY2Nba2V5XSwgaW5zdGFuY2UpO1xuICAgIHJldHVybiB7XG4gICAgICB0YXJnZXQsXG4gICAgICBrZXk6IGxhc3RcbiAgICB9O1xuICB9IGVsc2UgcmV0dXJuIHtcbiAgICB0YXJnZXQsXG4gICAga2V5XG4gIH07XG59XG5cbi8vIENoZWNrcyBpZiBhIGRhc2gtY2FzZWQgc3RyaW5nIGVuZHMgd2l0aCBhbiBpbnRlZ2VyXG5jb25zdCBJTkRFWF9SRUdFWCA9IC8tXFxkKyQvO1xuZnVuY3Rpb24gYXR0YWNoKHBhcmVudCwgY2hpbGQsIHR5cGUpIHtcbiAgaWYgKGlzLnN0cih0eXBlKSkge1xuICAgIC8vIElmIGF0dGFjaGluZyBpbnRvIGFuIGFycmF5IChmb28tMCksIGNyZWF0ZSBvbmVcbiAgICBpZiAoSU5ERVhfUkVHRVgudGVzdCh0eXBlKSkge1xuICAgICAgY29uc3Qgcm9vdCA9IHR5cGUucmVwbGFjZShJTkRFWF9SRUdFWCwgJycpO1xuICAgICAgY29uc3Qge1xuICAgICAgICB0YXJnZXQsXG4gICAgICAgIGtleVxuICAgICAgfSA9IHJlc29sdmUocGFyZW50LCByb290KTtcbiAgICAgIGlmICghQXJyYXkuaXNBcnJheSh0YXJnZXRba2V5XSkpIHRhcmdldFtrZXldID0gW107XG4gICAgfVxuICAgIGNvbnN0IHtcbiAgICAgIHRhcmdldCxcbiAgICAgIGtleVxuICAgIH0gPSByZXNvbHZlKHBhcmVudCwgdHlwZSk7XG4gICAgY2hpbGQuX19yM2YucHJldmlvdXNBdHRhY2ggPSB0YXJnZXRba2V5XTtcbiAgICB0YXJnZXRba2V5XSA9IGNoaWxkO1xuICB9IGVsc2UgY2hpbGQuX19yM2YucHJldmlvdXNBdHRhY2ggPSB0eXBlKHBhcmVudCwgY2hpbGQpO1xufVxuZnVuY3Rpb24gZGV0YWNoKHBhcmVudCwgY2hpbGQsIHR5cGUpIHtcbiAgdmFyIF9jaGlsZCRfX3IzZiwgX2NoaWxkJF9fcjNmMjtcbiAgaWYgKGlzLnN0cih0eXBlKSkge1xuICAgIGNvbnN0IHtcbiAgICAgIHRhcmdldCxcbiAgICAgIGtleVxuICAgIH0gPSByZXNvbHZlKHBhcmVudCwgdHlwZSk7XG4gICAgY29uc3QgcHJldmlvdXMgPSBjaGlsZC5fX3IzZi5wcmV2aW91c0F0dGFjaDtcbiAgICAvLyBXaGVuIHRoZSBwcmV2aW91cyB2YWx1ZSB3YXMgdW5kZWZpbmVkLCBpdCBtZWFucyB0aGUgdmFsdWUgd2FzIG5ldmVyIHNldCB0byBiZWdpbiB3aXRoXG4gICAgaWYgKHByZXZpb3VzID09PSB1bmRlZmluZWQpIGRlbGV0ZSB0YXJnZXRba2V5XTtcbiAgICAvLyBPdGhlcndpc2Ugc2V0IHRoZSBwcmV2aW91cyB2YWx1ZVxuICAgIGVsc2UgdGFyZ2V0W2tleV0gPSBwcmV2aW91cztcbiAgfSBlbHNlIChfY2hpbGQkX19yM2YgPSBjaGlsZC5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9jaGlsZCRfX3IzZi5wcmV2aW91c0F0dGFjaCA9PSBudWxsID8gdm9pZCAwIDogX2NoaWxkJF9fcjNmLnByZXZpb3VzQXR0YWNoKHBhcmVudCwgY2hpbGQpO1xuICAoX2NoaWxkJF9fcjNmMiA9IGNoaWxkLl9fcjNmKSA9PSBudWxsID8gdHJ1ZSA6IGRlbGV0ZSBfY2hpbGQkX19yM2YyLnByZXZpb3VzQXR0YWNoO1xufVxuXG4vLyBUaGlzIGZ1bmN0aW9uIHByZXBhcmVzIGEgc2V0IG9mIGNoYW5nZXMgdG8gYmUgYXBwbGllZCB0byB0aGUgaW5zdGFuY2VcbmZ1bmN0aW9uIGRpZmZQcm9wcyhpbnN0YW5jZSwge1xuICBjaGlsZHJlbjogY04sXG4gIGtleToga04sXG4gIHJlZjogck4sXG4gIC4uLnByb3BzXG59LCB7XG4gIGNoaWxkcmVuOiBjUCxcbiAga2V5OiBrUCxcbiAgcmVmOiByUCxcbiAgLi4ucHJldmlvdXNcbn0gPSB7fSwgcmVtb3ZlID0gZmFsc2UpIHtcbiAgdmFyIF9pbnN0YW5jZSRfX3IzZjtcbiAgY29uc3QgbG9jYWxTdGF0ZSA9IChfaW5zdGFuY2UkX19yM2YgPSBpbnN0YW5jZSA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2UuX19yM2YpICE9IG51bGwgPyBfaW5zdGFuY2UkX19yM2YgOiB7fTtcbiAgY29uc3QgZW50cmllcyA9IE9iamVjdC5lbnRyaWVzKHByb3BzKTtcbiAgY29uc3QgY2hhbmdlcyA9IFtdO1xuXG4gIC8vIENhdGNoIHJlbW92ZWQgcHJvcHMsIHByZXBlbmQgdGhlbSBzbyB0aGV5IGNhbiBiZSByZXNldCBvciByZW1vdmVkXG4gIGlmIChyZW1vdmUpIHtcbiAgICBjb25zdCBwcmV2aW91c0tleXMgPSBPYmplY3Qua2V5cyhwcmV2aW91cyk7XG4gICAgZm9yIChsZXQgaSA9IDA7IGkgPCBwcmV2aW91c0tleXMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGlmICghcHJvcHMuaGFzT3duUHJvcGVydHkocHJldmlvdXNLZXlzW2ldKSkgZW50cmllcy51bnNoaWZ0KFtwcmV2aW91c0tleXNbaV0sIERFRkFVTFQgKyAncmVtb3ZlJ10pO1xuICAgIH1cbiAgfVxuICBlbnRyaWVzLmZvckVhY2goKFtrZXksIHZhbHVlXSkgPT4ge1xuICAgIHZhciBfaW5zdGFuY2UkX19yM2YyO1xuICAgIC8vIEJhaWwgb3V0IG9uIHByaW1pdGl2ZSBvYmplY3RcbiAgICBpZiAoKF9pbnN0YW5jZSRfX3IzZjIgPSBpbnN0YW5jZS5fX3IzZikgIT0gbnVsbCAmJiBfaW5zdGFuY2UkX19yM2YyLnByaW1pdGl2ZSAmJiBrZXkgPT09ICdvYmplY3QnKSByZXR1cm47XG4gICAgLy8gV2hlbiBwcm9wcyBtYXRjaCBiYWlsIG91dFxuICAgIGlmIChpcy5lcXUodmFsdWUsIHByZXZpb3VzW2tleV0pKSByZXR1cm47XG4gICAgLy8gQ29sbGVjdCBoYW5kbGVycyBhbmQgYmFpbCBvdXRcbiAgICBpZiAoL15vbihQb2ludGVyfENsaWNrfERvdWJsZUNsaWNrfENvbnRleHRNZW51fFdoZWVsKS8udGVzdChrZXkpKSByZXR1cm4gY2hhbmdlcy5wdXNoKFtrZXksIHZhbHVlLCB0cnVlLCBbXV0pO1xuICAgIC8vIFNwbGl0IGRhc2hlZCBwcm9wc1xuICAgIGxldCBlbnRyaWVzID0gW107XG4gICAgaWYgKGtleS5pbmNsdWRlcygnLScpKSBlbnRyaWVzID0ga2V5LnNwbGl0KCctJyk7XG4gICAgY2hhbmdlcy5wdXNoKFtrZXksIHZhbHVlLCBmYWxzZSwgZW50cmllc10pO1xuXG4gICAgLy8gUmVzZXQgcGllcmNlZCBwcm9wc1xuICAgIGZvciAoY29uc3QgcHJvcCBpbiBwcm9wcykge1xuICAgICAgY29uc3QgdmFsdWUgPSBwcm9wc1twcm9wXTtcbiAgICAgIGlmIChwcm9wLnN0YXJ0c1dpdGgoYCR7a2V5fS1gKSkgY2hhbmdlcy5wdXNoKFtwcm9wLCB2YWx1ZSwgZmFsc2UsIHByb3Auc3BsaXQoJy0nKV0pO1xuICAgIH1cbiAgfSk7XG4gIGNvbnN0IG1lbW9pemVkID0ge1xuICAgIC4uLnByb3BzXG4gIH07XG4gIGlmIChsb2NhbFN0YXRlLm1lbW9pemVkUHJvcHMgJiYgbG9jYWxTdGF0ZS5tZW1vaXplZFByb3BzLmFyZ3MpIG1lbW9pemVkLmFyZ3MgPSBsb2NhbFN0YXRlLm1lbW9pemVkUHJvcHMuYXJncztcbiAgaWYgKGxvY2FsU3RhdGUubWVtb2l6ZWRQcm9wcyAmJiBsb2NhbFN0YXRlLm1lbW9pemVkUHJvcHMuYXR0YWNoKSBtZW1vaXplZC5hdHRhY2ggPSBsb2NhbFN0YXRlLm1lbW9pemVkUHJvcHMuYXR0YWNoO1xuICByZXR1cm4ge1xuICAgIG1lbW9pemVkLFxuICAgIGNoYW5nZXNcbiAgfTtcbn1cblxuLy8gVGhpcyBmdW5jdGlvbiBhcHBsaWVzIGEgc2V0IG9mIGNoYW5nZXMgdG8gdGhlIGluc3RhbmNlXG5mdW5jdGlvbiBhcHBseVByb3BzJDEoaW5zdGFuY2UsIGRhdGEpIHtcbiAgdmFyIF9pbnN0YW5jZSRfX3IzZjMsIF9yb290JGdldFN0YXRlLCBfaW5zdGFuY2UkX19yM2Y0O1xuICAvLyBGaWx0ZXIgZXF1YWxzLCBldmVudHMgYW5kIHJlc2VydmVkIHByb3BzXG4gIGNvbnN0IGxvY2FsU3RhdGUgPSAoX2luc3RhbmNlJF9fcjNmMyA9IGluc3RhbmNlLl9fcjNmKSAhPSBudWxsID8gX2luc3RhbmNlJF9fcjNmMyA6IHt9O1xuICBjb25zdCByb290ID0gbG9jYWxTdGF0ZS5yb290O1xuICBjb25zdCByb290U3RhdGUgPSAoX3Jvb3QkZ2V0U3RhdGUgPSByb290ID09IG51bGwgPyB2b2lkIDAgOiByb290LmdldFN0YXRlID09IG51bGwgPyB2b2lkIDAgOiByb290LmdldFN0YXRlKCkpICE9IG51bGwgPyBfcm9vdCRnZXRTdGF0ZSA6IHt9O1xuICBjb25zdCB7XG4gICAgbWVtb2l6ZWQsXG4gICAgY2hhbmdlc1xuICB9ID0gaXNEaWZmU2V0KGRhdGEpID8gZGF0YSA6IGRpZmZQcm9wcyhpbnN0YW5jZSwgZGF0YSk7XG4gIGNvbnN0IHByZXZIYW5kbGVycyA9IGxvY2FsU3RhdGUuZXZlbnRDb3VudDtcblxuICAvLyBQcmVwYXJlIG1lbW9pemVkIHByb3BzXG4gIGlmIChpbnN0YW5jZS5fX3IzZikgaW5zdGFuY2UuX19yM2YubWVtb2l6ZWRQcm9wcyA9IG1lbW9pemVkO1xuICBmb3IgKGxldCBpID0gMDsgaSA8IGNoYW5nZXMubGVuZ3RoOyBpKyspIHtcbiAgICBsZXQgW2tleSwgdmFsdWUsIGlzRXZlbnQsIGtleXNdID0gY2hhbmdlc1tpXTtcblxuICAgIC8vIEFsaWFzIChvdXRwdXQpZW5jb2RpbmcgPT4gKG91dHB1dCljb2xvclNwYWNlIChzaW5jZSByMTUyKVxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvcHVsbC8yODI5XG4gICAgaWYgKGhhc0NvbG9yU3BhY2UoaW5zdGFuY2UpKSB7XG4gICAgICBjb25zdCBzUkdCRW5jb2RpbmcgPSAzMDAxO1xuICAgICAgY29uc3QgU1JHQkNvbG9yU3BhY2UgPSAnc3JnYic7XG4gICAgICBjb25zdCBMaW5lYXJTUkdCQ29sb3JTcGFjZSA9ICdzcmdiLWxpbmVhcic7XG4gICAgICBpZiAoa2V5ID09PSAnZW5jb2RpbmcnKSB7XG4gICAgICAgIGtleSA9ICdjb2xvclNwYWNlJztcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gc1JHQkVuY29kaW5nID8gU1JHQkNvbG9yU3BhY2UgOiBMaW5lYXJTUkdCQ29sb3JTcGFjZTtcbiAgICAgIH0gZWxzZSBpZiAoa2V5ID09PSAnb3V0cHV0RW5jb2RpbmcnKSB7XG4gICAgICAgIGtleSA9ICdvdXRwdXRDb2xvclNwYWNlJztcbiAgICAgICAgdmFsdWUgPSB2YWx1ZSA9PT0gc1JHQkVuY29kaW5nID8gU1JHQkNvbG9yU3BhY2UgOiBMaW5lYXJTUkdCQ29sb3JTcGFjZTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IGN1cnJlbnRJbnN0YW5jZSA9IGluc3RhbmNlO1xuICAgIGxldCB0YXJnZXRQcm9wID0gY3VycmVudEluc3RhbmNlW2tleV07XG5cbiAgICAvLyBSZXZvbHZlIGRhc2hlZCBwcm9wc1xuICAgIGlmIChrZXlzLmxlbmd0aCkge1xuICAgICAgdGFyZ2V0UHJvcCA9IGtleXMucmVkdWNlKChhY2MsIGtleSkgPT4gYWNjW2tleV0sIGluc3RhbmNlKTtcbiAgICAgIC8vIElmIHRoZSB0YXJnZXQgaXMgYXRvbWljLCBpdCBmb3JjZXMgdXMgdG8gc3dpdGNoIHRoZSByb290XG4gICAgICBpZiAoISh0YXJnZXRQcm9wICYmIHRhcmdldFByb3Auc2V0KSkge1xuICAgICAgICBjb25zdCBbbmFtZSwgLi4ucmV2ZXJzZUVudHJpZXNdID0ga2V5cy5yZXZlcnNlKCk7XG4gICAgICAgIGN1cnJlbnRJbnN0YW5jZSA9IHJldmVyc2VFbnRyaWVzLnJldmVyc2UoKS5yZWR1Y2UoKGFjYywga2V5KSA9PiBhY2Nba2V5XSwgaW5zdGFuY2UpO1xuICAgICAgICBrZXkgPSBuYW1lO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9tcmRvb2IvdGhyZWUuanMvaXNzdWVzLzIxMjA5XG4gICAgLy8gSE1SL2Zhc3QtcmVmcmVzaCByZWxpZXMgb24gdGhlIGFiaWxpdHkgdG8gY2FuY2VsIG91dCBwcm9wcywgYnV0IHRocmVlanNcbiAgICAvLyBoYXMgbm8gbWVhbnMgdG8gZG8gdGhpcy4gSGVuY2Ugd2UgY3VyYXRlIGEgc21hbGwgY29sbGVjdGlvbiBvZiB2YWx1ZS1jbGFzc2VzXG4gICAgLy8gd2l0aCB0aGVpciByZXNwZWN0aXZlIGNvbnN0cnVjdG9yL3NldCBhcmd1bWVudHNcbiAgICAvLyBGb3IgcmVtb3ZlZCBwcm9wcywgdHJ5IHRvIHNldCBkZWZhdWx0IHZhbHVlcywgaWYgcG9zc2libGVcbiAgICBpZiAodmFsdWUgPT09IERFRkFVTFQgKyAncmVtb3ZlJykge1xuICAgICAgaWYgKGN1cnJlbnRJbnN0YW5jZS5jb25zdHJ1Y3Rvcikge1xuICAgICAgICAvLyBjcmVhdGUgYSBibGFuayBzbGF0ZSBvZiB0aGUgaW5zdGFuY2UgYW5kIGNvcHkgdGhlIHBhcnRpY3VsYXIgcGFyYW1ldGVyLlxuICAgICAgICBsZXQgY3RvciA9IERFRkFVTFRTLmdldChjdXJyZW50SW5zdGFuY2UuY29uc3RydWN0b3IpO1xuICAgICAgICBpZiAoIWN0b3IpIHtcbiAgICAgICAgICAvLyBAdHMtaWdub3JlXG4gICAgICAgICAgY3RvciA9IG5ldyBjdXJyZW50SW5zdGFuY2UuY29uc3RydWN0b3IoKTtcbiAgICAgICAgICBERUZBVUxUUy5zZXQoY3VycmVudEluc3RhbmNlLmNvbnN0cnVjdG9yLCBjdG9yKTtcbiAgICAgICAgfVxuICAgICAgICB2YWx1ZSA9IGN0b3Jba2V5XTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIC8vIGluc3RhbmNlIGRvZXMgbm90IGhhdmUgY29uc3RydWN0b3IsIGp1c3Qgc2V0IGl0IHRvIDBcbiAgICAgICAgdmFsdWUgPSAwO1xuICAgICAgfVxuICAgIH1cblxuICAgIC8vIERlYWwgd2l0aCBwb2ludGVyIGV2ZW50cyAuLi5cbiAgICBpZiAoaXNFdmVudCkge1xuICAgICAgaWYgKHZhbHVlKSBsb2NhbFN0YXRlLmhhbmRsZXJzW2tleV0gPSB2YWx1ZTtlbHNlIGRlbGV0ZSBsb2NhbFN0YXRlLmhhbmRsZXJzW2tleV07XG4gICAgICBsb2NhbFN0YXRlLmV2ZW50Q291bnQgPSBPYmplY3Qua2V5cyhsb2NhbFN0YXRlLmhhbmRsZXJzKS5sZW5ndGg7XG4gICAgfVxuICAgIC8vIFNwZWNpYWwgdHJlYXRtZW50IGZvciBvYmplY3RzIHdpdGggc3VwcG9ydCBmb3Igc2V0L2NvcHksIGFuZCBsYXllcnNcbiAgICBlbHNlIGlmICh0YXJnZXRQcm9wICYmIHRhcmdldFByb3Auc2V0ICYmICh0YXJnZXRQcm9wLmNvcHkgfHwgdGFyZ2V0UHJvcCBpbnN0YW5jZW9mIFRIUkVFLkxheWVycykpIHtcbiAgICAgIC8vIElmIHZhbHVlIGlzIGFuIGFycmF5XG4gICAgICBpZiAoQXJyYXkuaXNBcnJheSh2YWx1ZSkpIHtcbiAgICAgICAgaWYgKHRhcmdldFByb3AuZnJvbUFycmF5KSB0YXJnZXRQcm9wLmZyb21BcnJheSh2YWx1ZSk7ZWxzZSB0YXJnZXRQcm9wLnNldCguLi52YWx1ZSk7XG4gICAgICB9XG4gICAgICAvLyBUZXN0IGFnYWluIHRhcmdldC5jb3B5KGNsYXNzKSBuZXh0IC4uLlxuICAgICAgZWxzZSBpZiAodGFyZ2V0UHJvcC5jb3B5ICYmIHZhbHVlICYmIHZhbHVlLmNvbnN0cnVjdG9yICYmIHRhcmdldFByb3AuY29uc3RydWN0b3IgPT09IHZhbHVlLmNvbnN0cnVjdG9yKSB7XG4gICAgICAgIHRhcmdldFByb3AuY29weSh2YWx1ZSk7XG4gICAgICB9XG4gICAgICAvLyBJZiBub3RoaW5nIGVsc2UgZml0cywganVzdCBzZXQgdGhlIHNpbmdsZSB2YWx1ZSwgaWdub3JlIHVuZGVmaW5lZFxuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9pc3N1ZXMvMjc0XG4gICAgICBlbHNlIGlmICh2YWx1ZSAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIGNvbnN0IGlzQ29sb3IgPSB0YXJnZXRQcm9wIGluc3RhbmNlb2YgVEhSRUUuQ29sb3I7XG4gICAgICAgIC8vIEFsbG93IHNldHRpbmcgYXJyYXkgc2NhbGFyc1xuICAgICAgICBpZiAoIWlzQ29sb3IgJiYgdGFyZ2V0UHJvcC5zZXRTY2FsYXIpIHRhcmdldFByb3Auc2V0U2NhbGFyKHZhbHVlKTtcbiAgICAgICAgLy8gTGF5ZXJzIGhhdmUgbm8gY29weSBmdW5jdGlvbiwgd2UgbXVzdCB0aGVyZWZvcmUgY29weSB0aGUgbWFzayBwcm9wZXJ0eVxuICAgICAgICBlbHNlIGlmICh0YXJnZXRQcm9wIGluc3RhbmNlb2YgVEhSRUUuTGF5ZXJzICYmIHZhbHVlIGluc3RhbmNlb2YgVEhSRUUuTGF5ZXJzKSB0YXJnZXRQcm9wLm1hc2sgPSB2YWx1ZS5tYXNrO1xuICAgICAgICAvLyBPdGhlcndpc2UganVzdCBzZXQgLi4uXG4gICAgICAgIGVsc2UgdGFyZ2V0UHJvcC5zZXQodmFsdWUpO1xuICAgICAgICAvLyBGb3IgdmVyc2lvbnMgb2YgdGhyZWUgd2hpY2ggZG9uJ3Qgc3VwcG9ydCBUSFJFRS5Db2xvck1hbmFnZW1lbnQsXG4gICAgICAgIC8vIEF1dG8tY29udmVydCBzUkdCIGNvbG9yc1xuICAgICAgICAvLyBodHRwczovL2dpdGh1Yi5jb20vcG1uZHJzL3JlYWN0LXRocmVlLWZpYmVyL2lzc3Vlcy8zNDRcbiAgICAgICAgaWYgKCFnZXRDb2xvck1hbmFnZW1lbnQoKSAmJiAhcm9vdFN0YXRlLmxpbmVhciAmJiBpc0NvbG9yKSB0YXJnZXRQcm9wLmNvbnZlcnRTUkdCVG9MaW5lYXIoKTtcbiAgICAgIH1cbiAgICAgIC8vIEVsc2UsIGp1c3Qgb3ZlcndyaXRlIHRoZSB2YWx1ZVxuICAgIH0gZWxzZSB7XG4gICAgICBjdXJyZW50SW5zdGFuY2Vba2V5XSA9IHZhbHVlO1xuXG4gICAgICAvLyBBdXRvLWNvbnZlcnQgc1JHQiB0ZXh0dXJlcywgZm9yIG5vdyAuLi5cbiAgICAgIC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9wbW5kcnMvcmVhY3QtdGhyZWUtZmliZXIvaXNzdWVzLzM0NFxuICAgICAgaWYgKGN1cnJlbnRJbnN0YW5jZVtrZXldIGluc3RhbmNlb2YgVEhSRUUuVGV4dHVyZSAmJlxuICAgICAgLy8gc1JHQiB0ZXh0dXJlcyBtdXN0IGJlIFJHQkE4IHNpbmNlIHIxMzcgaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9wdWxsLzIzMTI5XG4gICAgICBjdXJyZW50SW5zdGFuY2Vba2V5XS5mb3JtYXQgPT09IFRIUkVFLlJHQkFGb3JtYXQgJiYgY3VycmVudEluc3RhbmNlW2tleV0udHlwZSA9PT0gVEhSRUUuVW5zaWduZWRCeXRlVHlwZSkge1xuICAgICAgICBjb25zdCB0ZXh0dXJlID0gY3VycmVudEluc3RhbmNlW2tleV07XG4gICAgICAgIGlmIChoYXNDb2xvclNwYWNlKHRleHR1cmUpICYmIGhhc0NvbG9yU3BhY2Uocm9vdFN0YXRlLmdsKSkgdGV4dHVyZS5jb2xvclNwYWNlID0gcm9vdFN0YXRlLmdsLm91dHB1dENvbG9yU3BhY2U7ZWxzZSB0ZXh0dXJlLmVuY29kaW5nID0gcm9vdFN0YXRlLmdsLm91dHB1dEVuY29kaW5nO1xuICAgICAgfVxuICAgIH1cbiAgICBpbnZhbGlkYXRlSW5zdGFuY2UoaW5zdGFuY2UpO1xuICB9XG4gIGlmIChsb2NhbFN0YXRlLnBhcmVudCAmJiByb290U3RhdGUuaW50ZXJuYWwgJiYgaW5zdGFuY2UucmF5Y2FzdCAmJiBwcmV2SGFuZGxlcnMgIT09IGxvY2FsU3RhdGUuZXZlbnRDb3VudCkge1xuICAgIC8vIFByZS1lbXB0aXZlbHkgcmVtb3ZlIHRoZSBpbnN0YW5jZSBmcm9tIHRoZSBpbnRlcmFjdGlvbiBtYW5hZ2VyXG4gICAgY29uc3QgaW5kZXggPSByb290U3RhdGUuaW50ZXJuYWwuaW50ZXJhY3Rpb24uaW5kZXhPZihpbnN0YW5jZSk7XG4gICAgaWYgKGluZGV4ID4gLTEpIHJvb3RTdGF0ZS5pbnRlcm5hbC5pbnRlcmFjdGlvbi5zcGxpY2UoaW5kZXgsIDEpO1xuICAgIC8vIEFkZCB0aGUgaW5zdGFuY2UgdG8gdGhlIGludGVyYWN0aW9uIG1hbmFnZXIgb25seSB3aGVuIGl0IGhhcyBoYW5kbGVyc1xuICAgIGlmIChsb2NhbFN0YXRlLmV2ZW50Q291bnQpIHJvb3RTdGF0ZS5pbnRlcm5hbC5pbnRlcmFjdGlvbi5wdXNoKGluc3RhbmNlKTtcbiAgfVxuXG4gIC8vIENhbGwgdGhlIHVwZGF0ZSBsaWZlY3ljbGUgd2hlbiBpdCBpcyBiZWluZyB1cGRhdGVkLCBidXQgb25seSB3aGVuIGl0IGlzIHBhcnQgb2YgdGhlIHNjZW5lLlxuICAvLyBTa2lwIHVwZGF0ZXMgdG8gdGhlIGBvblVwZGF0ZWAgcHJvcCBpdHNlbGZcbiAgY29uc3QgaXNDaXJjdWxhciA9IGNoYW5nZXMubGVuZ3RoID09PSAxICYmIGNoYW5nZXNbMF1bMF0gPT09ICdvblVwZGF0ZSc7XG4gIGlmICghaXNDaXJjdWxhciAmJiBjaGFuZ2VzLmxlbmd0aCAmJiAoX2luc3RhbmNlJF9fcjNmNCA9IGluc3RhbmNlLl9fcjNmKSAhPSBudWxsICYmIF9pbnN0YW5jZSRfX3IzZjQucGFyZW50KSB1cGRhdGVJbnN0YW5jZShpbnN0YW5jZSk7XG4gIHJldHVybiBpbnN0YW5jZTtcbn1cbmZ1bmN0aW9uIGludmFsaWRhdGVJbnN0YW5jZShpbnN0YW5jZSkge1xuICB2YXIgX2luc3RhbmNlJF9fcjNmNSwgX2luc3RhbmNlJF9fcjNmNSRyb290O1xuICBjb25zdCBzdGF0ZSA9IChfaW5zdGFuY2UkX19yM2Y1ID0gaW5zdGFuY2UuX19yM2YpID09IG51bGwgPyB2b2lkIDAgOiAoX2luc3RhbmNlJF9fcjNmNSRyb290ID0gX2luc3RhbmNlJF9fcjNmNS5yb290KSA9PSBudWxsID8gdm9pZCAwIDogX2luc3RhbmNlJF9fcjNmNSRyb290LmdldFN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBfaW5zdGFuY2UkX19yM2Y1JHJvb3QuZ2V0U3RhdGUoKTtcbiAgaWYgKHN0YXRlICYmIHN0YXRlLmludGVybmFsLmZyYW1lcyA9PT0gMCkgc3RhdGUuaW52YWxpZGF0ZSgpO1xufVxuZnVuY3Rpb24gdXBkYXRlSW5zdGFuY2UoaW5zdGFuY2UpIHtcbiAgaW5zdGFuY2Uub25VcGRhdGUgPT0gbnVsbCA/IHZvaWQgMCA6IGluc3RhbmNlLm9uVXBkYXRlKGluc3RhbmNlKTtcbn1cbmZ1bmN0aW9uIHVwZGF0ZUNhbWVyYShjYW1lcmEsIHNpemUpIHtcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9pc3N1ZXMvOTJcbiAgLy8gRG8gbm90IG1lc3Mgd2l0aCB0aGUgY2FtZXJhIGlmIGl0IGJlbG9uZ3MgdG8gdGhlIHVzZXJcbiAgaWYgKCFjYW1lcmEubWFudWFsKSB7XG4gICAgaWYgKGlzT3J0aG9ncmFwaGljQ2FtZXJhKGNhbWVyYSkpIHtcbiAgICAgIGNhbWVyYS5sZWZ0ID0gc2l6ZS53aWR0aCAvIC0yO1xuICAgICAgY2FtZXJhLnJpZ2h0ID0gc2l6ZS53aWR0aCAvIDI7XG4gICAgICBjYW1lcmEudG9wID0gc2l6ZS5oZWlnaHQgLyAyO1xuICAgICAgY2FtZXJhLmJvdHRvbSA9IHNpemUuaGVpZ2h0IC8gLTI7XG4gICAgfSBlbHNlIHtcbiAgICAgIGNhbWVyYS5hc3BlY3QgPSBzaXplLndpZHRoIC8gc2l6ZS5oZWlnaHQ7XG4gICAgfVxuICAgIGNhbWVyYS51cGRhdGVQcm9qZWN0aW9uTWF0cml4KCk7XG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9pc3N1ZXMvMTc4XG4gICAgLy8gVXBkYXRlIG1hdHJpeCB3b3JsZCBzaW5jZSB0aGUgcmVuZGVyZXIgaXMgYSBmcmFtZSBsYXRlXG4gICAgY2FtZXJhLnVwZGF0ZU1hdHJpeFdvcmxkKCk7XG4gIH1cbn1cblxuZnVuY3Rpb24gbWFrZUlkKGV2ZW50KSB7XG4gIHJldHVybiAoZXZlbnQuZXZlbnRPYmplY3QgfHwgZXZlbnQub2JqZWN0KS51dWlkICsgJy8nICsgZXZlbnQuaW5kZXggKyBldmVudC5pbnN0YW5jZUlkO1xufVxuXG4vLyBodHRwczovL2dpdGh1Yi5jb20vZmFjZWJvb2svcmVhY3QvdHJlZS9tYWluL3BhY2thZ2VzL3JlYWN0LXJlY29uY2lsZXIjZ2V0Y3VycmVudGV2ZW50cHJpb3JpdHlcbi8vIEdpdmVzIFJlYWN0IGEgY2x1ZSBhcyB0byBob3cgaW1wb3J0IHRoZSBjdXJyZW50IGludGVyYWN0aW9uIGlzXG5mdW5jdGlvbiBnZXRFdmVudFByaW9yaXR5KCkge1xuICB2YXIgX2dsb2JhbFNjb3BlJGV2ZW50O1xuICAvLyBHZXQgYSBoYW5kbGUgdG8gdGhlIGN1cnJlbnQgZ2xvYmFsIHNjb3BlIGluIHdpbmRvdyBhbmQgd29ya2VyIGNvbnRleHRzIGlmIGFibGVcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9wdWxsLzI0OTNcbiAgY29uc3QgZ2xvYmFsU2NvcGUgPSB0eXBlb2Ygc2VsZiAhPT0gJ3VuZGVmaW5lZCcgJiYgc2VsZiB8fCB0eXBlb2Ygd2luZG93ICE9PSAndW5kZWZpbmVkJyAmJiB3aW5kb3c7XG4gIGlmICghZ2xvYmFsU2NvcGUpIHJldHVybiBEZWZhdWx0RXZlbnRQcmlvcml0eTtcbiAgY29uc3QgbmFtZSA9IChfZ2xvYmFsU2NvcGUkZXZlbnQgPSBnbG9iYWxTY29wZS5ldmVudCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9nbG9iYWxTY29wZSRldmVudC50eXBlO1xuICBzd2l0Y2ggKG5hbWUpIHtcbiAgICBjYXNlICdjbGljayc6XG4gICAgY2FzZSAnY29udGV4dG1lbnUnOlxuICAgIGNhc2UgJ2RibGNsaWNrJzpcbiAgICBjYXNlICdwb2ludGVyY2FuY2VsJzpcbiAgICBjYXNlICdwb2ludGVyZG93bic6XG4gICAgY2FzZSAncG9pbnRlcnVwJzpcbiAgICAgIHJldHVybiBEaXNjcmV0ZUV2ZW50UHJpb3JpdHk7XG4gICAgY2FzZSAncG9pbnRlcm1vdmUnOlxuICAgIGNhc2UgJ3BvaW50ZXJvdXQnOlxuICAgIGNhc2UgJ3BvaW50ZXJvdmVyJzpcbiAgICBjYXNlICdwb2ludGVyZW50ZXInOlxuICAgIGNhc2UgJ3BvaW50ZXJsZWF2ZSc6XG4gICAgY2FzZSAnd2hlZWwnOlxuICAgICAgcmV0dXJuIENvbnRpbnVvdXNFdmVudFByaW9yaXR5O1xuICAgIGRlZmF1bHQ6XG4gICAgICByZXR1cm4gRGVmYXVsdEV2ZW50UHJpb3JpdHk7XG4gIH1cbn1cblxuLyoqXG4gKiBSZWxlYXNlIHBvaW50ZXIgY2FwdHVyZXMuXG4gKiBUaGlzIGlzIGNhbGxlZCBieSByZWxlYXNlUG9pbnRlckNhcHR1cmUgaW4gdGhlIEFQSSwgYW5kIHdoZW4gYW4gb2JqZWN0IGlzIHJlbW92ZWQuXG4gKi9cbmZ1bmN0aW9uIHJlbGVhc2VJbnRlcm5hbFBvaW50ZXJDYXB0dXJlKGNhcHR1cmVkTWFwLCBvYmosIGNhcHR1cmVzLCBwb2ludGVySWQpIHtcbiAgY29uc3QgY2FwdHVyZURhdGEgPSBjYXB0dXJlcy5nZXQob2JqKTtcbiAgaWYgKGNhcHR1cmVEYXRhKSB7XG4gICAgY2FwdHVyZXMuZGVsZXRlKG9iaik7XG4gICAgLy8gSWYgdGhpcyB3YXMgdGhlIGxhc3QgY2FwdHVyaW5nIG9iamVjdCBmb3IgdGhpcyBwb2ludGVyXG4gICAgaWYgKGNhcHR1cmVzLnNpemUgPT09IDApIHtcbiAgICAgIGNhcHR1cmVkTWFwLmRlbGV0ZShwb2ludGVySWQpO1xuICAgICAgY2FwdHVyZURhdGEudGFyZ2V0LnJlbGVhc2VQb2ludGVyQ2FwdHVyZShwb2ludGVySWQpO1xuICAgIH1cbiAgfVxufVxuZnVuY3Rpb24gcmVtb3ZlSW50ZXJhY3Rpdml0eShzdG9yZSwgb2JqZWN0KSB7XG4gIGNvbnN0IHtcbiAgICBpbnRlcm5hbFxuICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgLy8gUmVtb3ZlcyBldmVyeSB0cmFjZSBvZiBhbiBvYmplY3QgZnJvbSB0aGUgZGF0YSBzdG9yZVxuICBpbnRlcm5hbC5pbnRlcmFjdGlvbiA9IGludGVybmFsLmludGVyYWN0aW9uLmZpbHRlcihvID0+IG8gIT09IG9iamVjdCk7XG4gIGludGVybmFsLmluaXRpYWxIaXRzID0gaW50ZXJuYWwuaW5pdGlhbEhpdHMuZmlsdGVyKG8gPT4gbyAhPT0gb2JqZWN0KTtcbiAgaW50ZXJuYWwuaG92ZXJlZC5mb3JFYWNoKCh2YWx1ZSwga2V5KSA9PiB7XG4gICAgaWYgKHZhbHVlLmV2ZW50T2JqZWN0ID09PSBvYmplY3QgfHwgdmFsdWUub2JqZWN0ID09PSBvYmplY3QpIHtcbiAgICAgIC8vIENsZWFyIG91dCBpbnRlcnNlY3RzLCB0aGV5IGFyZSBvdXRkYXRlZCBieSBub3dcbiAgICAgIGludGVybmFsLmhvdmVyZWQuZGVsZXRlKGtleSk7XG4gICAgfVxuICB9KTtcbiAgaW50ZXJuYWwuY2FwdHVyZWRNYXAuZm9yRWFjaCgoY2FwdHVyZXMsIHBvaW50ZXJJZCkgPT4ge1xuICAgIHJlbGVhc2VJbnRlcm5hbFBvaW50ZXJDYXB0dXJlKGludGVybmFsLmNhcHR1cmVkTWFwLCBvYmplY3QsIGNhcHR1cmVzLCBwb2ludGVySWQpO1xuICB9KTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZUV2ZW50cyhzdG9yZSkge1xuICAvKiogQ2FsY3VsYXRlcyBkZWx0YSAqL1xuICBmdW5jdGlvbiBjYWxjdWxhdGVEaXN0YW5jZShldmVudCkge1xuICAgIGNvbnN0IHtcbiAgICAgIGludGVybmFsXG4gICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgY29uc3QgZHggPSBldmVudC5vZmZzZXRYIC0gaW50ZXJuYWwuaW5pdGlhbENsaWNrWzBdO1xuICAgIGNvbnN0IGR5ID0gZXZlbnQub2Zmc2V0WSAtIGludGVybmFsLmluaXRpYWxDbGlja1sxXTtcbiAgICByZXR1cm4gTWF0aC5yb3VuZChNYXRoLnNxcnQoZHggKiBkeCArIGR5ICogZHkpKTtcbiAgfVxuXG4gIC8qKiBSZXR1cm5zIHRydWUgaWYgYW4gaW5zdGFuY2UgaGFzIGEgdmFsaWQgcG9pbnRlci1ldmVudCByZWdpc3RlcmVkLCB0aGlzIGV4Y2x1ZGVzIHNjcm9sbCwgY2xpY2tzIGV0YyAqL1xuICBmdW5jdGlvbiBmaWx0ZXJQb2ludGVyRXZlbnRzKG9iamVjdHMpIHtcbiAgICByZXR1cm4gb2JqZWN0cy5maWx0ZXIob2JqID0+IFsnTW92ZScsICdPdmVyJywgJ0VudGVyJywgJ091dCcsICdMZWF2ZSddLnNvbWUobmFtZSA9PiB7XG4gICAgICB2YXIgX3IzZjtcbiAgICAgIHJldHVybiAoX3IzZiA9IG9iai5fX3IzZikgPT0gbnVsbCA/IHZvaWQgMCA6IF9yM2YuaGFuZGxlcnNbJ29uUG9pbnRlcicgKyBuYW1lXTtcbiAgICB9KSk7XG4gIH1cbiAgZnVuY3Rpb24gaW50ZXJzZWN0KGV2ZW50LCBmaWx0ZXIpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgY29uc3QgZHVwbGljYXRlcyA9IG5ldyBTZXQoKTtcbiAgICBjb25zdCBpbnRlcnNlY3Rpb25zID0gW107XG4gICAgLy8gQWxsb3cgY2FsbGVycyB0byBlbGltaW5hdGUgZXZlbnQgb2JqZWN0c1xuICAgIGNvbnN0IGV2ZW50c09iamVjdHMgPSBmaWx0ZXIgPyBmaWx0ZXIoc3RhdGUuaW50ZXJuYWwuaW50ZXJhY3Rpb24pIDogc3RhdGUuaW50ZXJuYWwuaW50ZXJhY3Rpb247XG4gICAgLy8gUmVzZXQgYWxsIHJheWNhc3RlciBjYW1lcmFzIHRvIHVuZGVmaW5lZFxuICAgIGZvciAobGV0IGkgPSAwOyBpIDwgZXZlbnRzT2JqZWN0cy5sZW5ndGg7IGkrKykge1xuICAgICAgY29uc3Qgc3RhdGUgPSBnZXRSb290U3RhdGUoZXZlbnRzT2JqZWN0c1tpXSk7XG4gICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgc3RhdGUucmF5Y2FzdGVyLmNhbWVyYSA9IHVuZGVmaW5lZDtcbiAgICAgIH1cbiAgICB9XG4gICAgaWYgKCFzdGF0ZS5wcmV2aW91c1Jvb3QpIHtcbiAgICAgIC8vIE1ha2Ugc3VyZSByb290LWxldmVsIHBvaW50ZXIgYW5kIHJheSBhcmUgc2V0IHVwXG4gICAgICBzdGF0ZS5ldmVudHMuY29tcHV0ZSA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUuZXZlbnRzLmNvbXB1dGUoZXZlbnQsIHN0YXRlKTtcbiAgICB9XG4gICAgZnVuY3Rpb24gaGFuZGxlUmF5Y2FzdChvYmopIHtcbiAgICAgIGNvbnN0IHN0YXRlID0gZ2V0Um9vdFN0YXRlKG9iaik7XG4gICAgICAvLyBTa2lwIGV2ZW50IGhhbmRsaW5nIHdoZW4gbm9FdmVudHMgaXMgc2V0LCBvciB3aGVuIHRoZSByYXljYXN0ZXJzIGNhbWVyYSBpcyBudWxsXG4gICAgICBpZiAoIXN0YXRlIHx8ICFzdGF0ZS5ldmVudHMuZW5hYmxlZCB8fCBzdGF0ZS5yYXljYXN0ZXIuY2FtZXJhID09PSBudWxsKSByZXR1cm4gW107XG5cbiAgICAgIC8vIFdoZW4gdGhlIGNhbWVyYSBpcyB1bmRlZmluZWQgd2UgaGF2ZSB0byBjYWxsIHRoZSBldmVudCBsYXllcnMgdXBkYXRlIGZ1bmN0aW9uXG4gICAgICBpZiAoc3RhdGUucmF5Y2FzdGVyLmNhbWVyYSA9PT0gdW5kZWZpbmVkKSB7XG4gICAgICAgIHZhciBfc3RhdGUkcHJldmlvdXNSb290O1xuICAgICAgICBzdGF0ZS5ldmVudHMuY29tcHV0ZSA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUuZXZlbnRzLmNvbXB1dGUoZXZlbnQsIHN0YXRlLCAoX3N0YXRlJHByZXZpb3VzUm9vdCA9IHN0YXRlLnByZXZpb3VzUm9vdCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9zdGF0ZSRwcmV2aW91c1Jvb3QuZ2V0U3RhdGUoKSk7XG4gICAgICAgIC8vIElmIHRoZSBjYW1lcmEgaXMgc3RpbGwgdW5kZWZpbmVkIHdlIGhhdmUgdG8gc2tpcCB0aGlzIGxheWVyIGVudGlyZWx5XG4gICAgICAgIGlmIChzdGF0ZS5yYXljYXN0ZXIuY2FtZXJhID09PSB1bmRlZmluZWQpIHN0YXRlLnJheWNhc3Rlci5jYW1lcmEgPSBudWxsO1xuICAgICAgfVxuXG4gICAgICAvLyBJbnRlcnNlY3Qgb2JqZWN0IGJ5IG9iamVjdFxuICAgICAgcmV0dXJuIHN0YXRlLnJheWNhc3Rlci5jYW1lcmEgPyBzdGF0ZS5yYXljYXN0ZXIuaW50ZXJzZWN0T2JqZWN0KG9iaiwgdHJ1ZSkgOiBbXTtcbiAgICB9XG5cbiAgICAvLyBDb2xsZWN0IGV2ZW50c1xuICAgIGxldCBoaXRzID0gZXZlbnRzT2JqZWN0c1xuICAgIC8vIEludGVyc2VjdCBvYmplY3RzXG4gICAgLmZsYXRNYXAoaGFuZGxlUmF5Y2FzdClcbiAgICAvLyBTb3J0IGJ5IGV2ZW50IHByaW9yaXR5IGFuZCBkaXN0YW5jZVxuICAgIC5zb3J0KChhLCBiKSA9PiB7XG4gICAgICBjb25zdCBhU3RhdGUgPSBnZXRSb290U3RhdGUoYS5vYmplY3QpO1xuICAgICAgY29uc3QgYlN0YXRlID0gZ2V0Um9vdFN0YXRlKGIub2JqZWN0KTtcbiAgICAgIGlmICghYVN0YXRlIHx8ICFiU3RhdGUpIHJldHVybiBhLmRpc3RhbmNlIC0gYi5kaXN0YW5jZTtcbiAgICAgIHJldHVybiBiU3RhdGUuZXZlbnRzLnByaW9yaXR5IC0gYVN0YXRlLmV2ZW50cy5wcmlvcml0eSB8fCBhLmRpc3RhbmNlIC0gYi5kaXN0YW5jZTtcbiAgICB9KVxuICAgIC8vIEZpbHRlciBvdXQgZHVwbGljYXRlc1xuICAgIC5maWx0ZXIoaXRlbSA9PiB7XG4gICAgICBjb25zdCBpZCA9IG1ha2VJZChpdGVtKTtcbiAgICAgIGlmIChkdXBsaWNhdGVzLmhhcyhpZCkpIHJldHVybiBmYWxzZTtcbiAgICAgIGR1cGxpY2F0ZXMuYWRkKGlkKTtcbiAgICAgIHJldHVybiB0cnVlO1xuICAgIH0pO1xuXG4gICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9pc3N1ZXMvMTYwMzFcbiAgICAvLyBBbGxvdyBjdXN0b20gdXNlcmxhbmQgaW50ZXJzZWN0IHNvcnQgb3JkZXIsIHRoaXMgbGlrZWx5IG9ubHkgbWFrZXMgc2Vuc2Ugb24gdGhlIHJvb3QgZmlsdGVyXG4gICAgaWYgKHN0YXRlLmV2ZW50cy5maWx0ZXIpIGhpdHMgPSBzdGF0ZS5ldmVudHMuZmlsdGVyKGhpdHMsIHN0YXRlKTtcblxuICAgIC8vIEJ1YmJsZSB1cCB0aGUgZXZlbnRzLCBmaW5kIHRoZSBldmVudCBzb3VyY2UgKGV2ZW50T2JqZWN0KVxuICAgIGZvciAoY29uc3QgaGl0IG9mIGhpdHMpIHtcbiAgICAgIGxldCBldmVudE9iamVjdCA9IGhpdC5vYmplY3Q7XG4gICAgICAvLyBCdWJibGUgZXZlbnQgdXBcbiAgICAgIHdoaWxlIChldmVudE9iamVjdCkge1xuICAgICAgICB2YXIgX3IzZjI7XG4gICAgICAgIGlmICgoX3IzZjIgPSBldmVudE9iamVjdC5fX3IzZikgIT0gbnVsbCAmJiBfcjNmMi5ldmVudENvdW50KSBpbnRlcnNlY3Rpb25zLnB1c2goe1xuICAgICAgICAgIC4uLmhpdCxcbiAgICAgICAgICBldmVudE9iamVjdFxuICAgICAgICB9KTtcbiAgICAgICAgZXZlbnRPYmplY3QgPSBldmVudE9iamVjdC5wYXJlbnQ7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gSWYgdGhlIGludGVyYWN0aW9uIGlzIGNhcHR1cmVkLCBtYWtlIGFsbCBjYXB0dXJpbmcgdGFyZ2V0cyBwYXJ0IG9mIHRoZSBpbnRlcnNlY3QuXG4gICAgaWYgKCdwb2ludGVySWQnIGluIGV2ZW50ICYmIHN0YXRlLmludGVybmFsLmNhcHR1cmVkTWFwLmhhcyhldmVudC5wb2ludGVySWQpKSB7XG4gICAgICBmb3IgKGxldCBjYXB0dXJlRGF0YSBvZiBzdGF0ZS5pbnRlcm5hbC5jYXB0dXJlZE1hcC5nZXQoZXZlbnQucG9pbnRlcklkKS52YWx1ZXMoKSkge1xuICAgICAgICBpZiAoIWR1cGxpY2F0ZXMuaGFzKG1ha2VJZChjYXB0dXJlRGF0YS5pbnRlcnNlY3Rpb24pKSkgaW50ZXJzZWN0aW9ucy5wdXNoKGNhcHR1cmVEYXRhLmludGVyc2VjdGlvbik7XG4gICAgICB9XG4gICAgfVxuICAgIHJldHVybiBpbnRlcnNlY3Rpb25zO1xuICB9XG5cbiAgLyoqICBIYW5kbGVzIGludGVyc2VjdGlvbnMgYnkgZm9yd2FyZGluZyB0aGVtIHRvIGhhbmRsZXJzICovXG4gIGZ1bmN0aW9uIGhhbmRsZUludGVyc2VjdHMoaW50ZXJzZWN0aW9ucywgZXZlbnQsIGRlbHRhLCBjYWxsYmFjaykge1xuICAgIGNvbnN0IHJvb3RTdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICAvLyBJZiBhbnl0aGluZyBoYXMgYmVlbiBmb3VuZCwgZm9yd2FyZCBpdCB0byB0aGUgZXZlbnQgbGlzdGVuZXJzXG4gICAgaWYgKGludGVyc2VjdGlvbnMubGVuZ3RoKSB7XG4gICAgICBjb25zdCBsb2NhbFN0YXRlID0ge1xuICAgICAgICBzdG9wcGVkOiBmYWxzZVxuICAgICAgfTtcbiAgICAgIGZvciAoY29uc3QgaGl0IG9mIGludGVyc2VjdGlvbnMpIHtcbiAgICAgICAgY29uc3Qgc3RhdGUgPSBnZXRSb290U3RhdGUoaGl0Lm9iamVjdCkgfHwgcm9vdFN0YXRlO1xuICAgICAgICBjb25zdCB7XG4gICAgICAgICAgcmF5Y2FzdGVyLFxuICAgICAgICAgIHBvaW50ZXIsXG4gICAgICAgICAgY2FtZXJhLFxuICAgICAgICAgIGludGVybmFsXG4gICAgICAgIH0gPSBzdGF0ZTtcbiAgICAgICAgY29uc3QgdW5wcm9qZWN0ZWRQb2ludCA9IG5ldyBUSFJFRS5WZWN0b3IzKHBvaW50ZXIueCwgcG9pbnRlci55LCAwKS51bnByb2plY3QoY2FtZXJhKTtcbiAgICAgICAgY29uc3QgaGFzUG9pbnRlckNhcHR1cmUgPSBpZCA9PiB7XG4gICAgICAgICAgdmFyIF9pbnRlcm5hbCRjYXB0dXJlZE1hcCwgX2ludGVybmFsJGNhcHR1cmVkTWFwMjtcbiAgICAgICAgICByZXR1cm4gKF9pbnRlcm5hbCRjYXB0dXJlZE1hcCA9IChfaW50ZXJuYWwkY2FwdHVyZWRNYXAyID0gaW50ZXJuYWwuY2FwdHVyZWRNYXAuZ2V0KGlkKSkgPT0gbnVsbCA/IHZvaWQgMCA6IF9pbnRlcm5hbCRjYXB0dXJlZE1hcDIuaGFzKGhpdC5ldmVudE9iamVjdCkpICE9IG51bGwgPyBfaW50ZXJuYWwkY2FwdHVyZWRNYXAgOiBmYWxzZTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3Qgc2V0UG9pbnRlckNhcHR1cmUgPSBpZCA9PiB7XG4gICAgICAgICAgY29uc3QgY2FwdHVyZURhdGEgPSB7XG4gICAgICAgICAgICBpbnRlcnNlY3Rpb246IGhpdCxcbiAgICAgICAgICAgIHRhcmdldDogZXZlbnQudGFyZ2V0XG4gICAgICAgICAgfTtcbiAgICAgICAgICBpZiAoaW50ZXJuYWwuY2FwdHVyZWRNYXAuaGFzKGlkKSkge1xuICAgICAgICAgICAgLy8gaWYgdGhlIHBvaW50ZXJJZCB3YXMgcHJldmlvdXNseSBjYXB0dXJlZCwgd2UgYWRkIHRoZSBoaXQgdG8gdGhlXG4gICAgICAgICAgICAvLyBldmVudCBjYXB0dXJlZE1hcC5cbiAgICAgICAgICAgIGludGVybmFsLmNhcHR1cmVkTWFwLmdldChpZCkuc2V0KGhpdC5ldmVudE9iamVjdCwgY2FwdHVyZURhdGEpO1xuICAgICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgICAvLyBpZiB0aGUgcG9pbnRlcklkIHdhcyBub3QgcHJldmlvdXNseSBjYXB0dXJlZCwgd2UgY3JlYXRlIGEgbWFwXG4gICAgICAgICAgICAvLyBjb250YWluaW5nIHRoZSBoaXRPYmplY3QsIGFuZCB0aGUgaGl0LiBoaXRPYmplY3QgaXMgdXNlZCBmb3JcbiAgICAgICAgICAgIC8vIGZhc3RlciBhY2Nlc3MuXG4gICAgICAgICAgICBpbnRlcm5hbC5jYXB0dXJlZE1hcC5zZXQoaWQsIG5ldyBNYXAoW1toaXQuZXZlbnRPYmplY3QsIGNhcHR1cmVEYXRhXV0pKTtcbiAgICAgICAgICB9XG4gICAgICAgICAgZXZlbnQudGFyZ2V0LnNldFBvaW50ZXJDYXB0dXJlKGlkKTtcbiAgICAgICAgfTtcbiAgICAgICAgY29uc3QgcmVsZWFzZVBvaW50ZXJDYXB0dXJlID0gaWQgPT4ge1xuICAgICAgICAgIGNvbnN0IGNhcHR1cmVzID0gaW50ZXJuYWwuY2FwdHVyZWRNYXAuZ2V0KGlkKTtcbiAgICAgICAgICBpZiAoY2FwdHVyZXMpIHtcbiAgICAgICAgICAgIHJlbGVhc2VJbnRlcm5hbFBvaW50ZXJDYXB0dXJlKGludGVybmFsLmNhcHR1cmVkTWFwLCBoaXQuZXZlbnRPYmplY3QsIGNhcHR1cmVzLCBpZCk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIEFkZCBuYXRpdmUgZXZlbnQgcHJvcHNcbiAgICAgICAgbGV0IGV4dHJhY3RFdmVudFByb3BzID0ge307XG4gICAgICAgIC8vIFRoaXMgaXRlcmF0ZXMgb3ZlciB0aGUgZXZlbnQncyBwcm9wZXJ0aWVzIGluY2x1ZGluZyB0aGUgaW5oZXJpdGVkIG9uZXMuIE5hdGl2ZSBQb2ludGVyRXZlbnRzIGhhdmUgbW9zdCBvZiB0aGVpciBwcm9wcyBhcyBnZXR0ZXJzIHdoaWNoIGFyZSBpbmhlcml0ZWQsIGJ1dCBwb2x5ZmlsbGVkIFBvaW50ZXJFdmVudHMgaGF2ZSB0aGVtIGFsbCBhcyB0aGVpciBvd24gcHJvcGVydGllcyAoaS5lLiBub3QgaW5oZXJpdGVkKS4gV2UgY2FuJ3QgdXNlIE9iamVjdC5rZXlzKCkgb3IgT2JqZWN0LmVudHJpZXMoKSBhcyB0aGV5IG9ubHkgcmV0dXJuIFwib3duXCIgcHJvcGVydGllczsgbm9yIE9iamVjdC5nZXRQcm90b3R5cGVPZihldmVudCkgYXMgdGhhdCAqZG9lc24ndCogcmV0dXJuIFwib3duXCIgcHJvcGVydGllcywgb25seSBpbmhlcml0ZWQgb25lcy5cbiAgICAgICAgZm9yIChsZXQgcHJvcCBpbiBldmVudCkge1xuICAgICAgICAgIGxldCBwcm9wZXJ0eSA9IGV2ZW50W3Byb3BdO1xuICAgICAgICAgIC8vIE9ubHkgY29weSBvdmVyIGF0b21pY3MsIGxlYXZlIGZ1bmN0aW9ucyBhbG9uZSBhcyB0aGVzZSBzaG91bGQgYmVcbiAgICAgICAgICAvLyBjYWxsZWQgYXMgZXZlbnQubmF0aXZlRXZlbnQuZm4oKVxuICAgICAgICAgIGlmICh0eXBlb2YgcHJvcGVydHkgIT09ICdmdW5jdGlvbicpIGV4dHJhY3RFdmVudFByb3BzW3Byb3BdID0gcHJvcGVydHk7XG4gICAgICAgIH1cbiAgICAgICAgbGV0IHJheWNhc3RFdmVudCA9IHtcbiAgICAgICAgICAuLi5oaXQsXG4gICAgICAgICAgLi4uZXh0cmFjdEV2ZW50UHJvcHMsXG4gICAgICAgICAgcG9pbnRlcixcbiAgICAgICAgICBpbnRlcnNlY3Rpb25zLFxuICAgICAgICAgIHN0b3BwZWQ6IGxvY2FsU3RhdGUuc3RvcHBlZCxcbiAgICAgICAgICBkZWx0YSxcbiAgICAgICAgICB1bnByb2plY3RlZFBvaW50LFxuICAgICAgICAgIHJheTogcmF5Y2FzdGVyLnJheSxcbiAgICAgICAgICBjYW1lcmE6IGNhbWVyYSxcbiAgICAgICAgICAvLyBIaWphY2sgc3RvcFByb3BhZ2F0aW9uLCB3aGljaCBqdXN0IHNldHMgYSBmbGFnXG4gICAgICAgICAgc3RvcFByb3BhZ2F0aW9uKCkge1xuICAgICAgICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9pc3N1ZXMvNTk2XG4gICAgICAgICAgICAvLyBFdmVudHMgYXJlIG5vdCBhbGxvd2VkIHRvIHN0b3AgcHJvcGFnYXRpb24gaWYgdGhlIHBvaW50ZXIgaGFzIGJlZW4gY2FwdHVyZWRcbiAgICAgICAgICAgIGNvbnN0IGNhcHR1cmVzRm9yUG9pbnRlciA9ICdwb2ludGVySWQnIGluIGV2ZW50ICYmIGludGVybmFsLmNhcHR1cmVkTWFwLmdldChldmVudC5wb2ludGVySWQpO1xuXG4gICAgICAgICAgICAvLyBXZSBvbmx5IGF1dGhvcml6ZSBzdG9wUHJvcGFnYXRpb24uLi5cbiAgICAgICAgICAgIGlmIChcbiAgICAgICAgICAgIC8vIC4uLmlmIHRoaXMgcG9pbnRlciBoYXNuJ3QgYmVlbiBjYXB0dXJlZFxuICAgICAgICAgICAgIWNhcHR1cmVzRm9yUG9pbnRlciB8fFxuICAgICAgICAgICAgLy8gLi4uIG9yIGlmIHRoZSBoaXQgb2JqZWN0IGlzIGNhcHR1cmluZyB0aGUgcG9pbnRlclxuICAgICAgICAgICAgY2FwdHVyZXNGb3JQb2ludGVyLmhhcyhoaXQuZXZlbnRPYmplY3QpKSB7XG4gICAgICAgICAgICAgIHJheWNhc3RFdmVudC5zdG9wcGVkID0gbG9jYWxTdGF0ZS5zdG9wcGVkID0gdHJ1ZTtcbiAgICAgICAgICAgICAgLy8gUHJvcGFnYXRpb24gaXMgc3RvcHBlZCwgcmVtb3ZlIGFsbCBvdGhlciBob3ZlciByZWNvcmRzXG4gICAgICAgICAgICAgIC8vIEFuIGV2ZW50IGhhbmRsZXIgaXMgb25seSBhbGxvd2VkIHRvIGZsdXNoIG90aGVyIGhhbmRsZXJzIGlmIGl0IGlzIGhvdmVyZWQgaXRzZWxmXG4gICAgICAgICAgICAgIGlmIChpbnRlcm5hbC5ob3ZlcmVkLnNpemUgJiYgQXJyYXkuZnJvbShpbnRlcm5hbC5ob3ZlcmVkLnZhbHVlcygpKS5maW5kKGkgPT4gaS5ldmVudE9iamVjdCA9PT0gaGl0LmV2ZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgICAgIC8vIE9iamVjdHMgY2Fubm90IGZsdXNoIG91dCBoaWdoZXIgdXAgb2JqZWN0cyB0aGF0IGhhdmUgYWxyZWFkeSBjYXVnaHQgdGhlIGV2ZW50XG4gICAgICAgICAgICAgICAgY29uc3QgaGlnaGVyID0gaW50ZXJzZWN0aW9ucy5zbGljZSgwLCBpbnRlcnNlY3Rpb25zLmluZGV4T2YoaGl0KSk7XG4gICAgICAgICAgICAgICAgY2FuY2VsUG9pbnRlcihbLi4uaGlnaGVyLCBoaXRdKTtcbiAgICAgICAgICAgICAgfVxuICAgICAgICAgICAgfVxuICAgICAgICAgIH0sXG4gICAgICAgICAgLy8gdGhlcmUgc2hvdWxkIGJlIGEgZGlzdGluY3Rpb24gYmV0d2VlbiB0YXJnZXQgYW5kIGN1cnJlbnRUYXJnZXRcbiAgICAgICAgICB0YXJnZXQ6IHtcbiAgICAgICAgICAgIGhhc1BvaW50ZXJDYXB0dXJlLFxuICAgICAgICAgICAgc2V0UG9pbnRlckNhcHR1cmUsXG4gICAgICAgICAgICByZWxlYXNlUG9pbnRlckNhcHR1cmVcbiAgICAgICAgICB9LFxuICAgICAgICAgIGN1cnJlbnRUYXJnZXQ6IHtcbiAgICAgICAgICAgIGhhc1BvaW50ZXJDYXB0dXJlLFxuICAgICAgICAgICAgc2V0UG9pbnRlckNhcHR1cmUsXG4gICAgICAgICAgICByZWxlYXNlUG9pbnRlckNhcHR1cmVcbiAgICAgICAgICB9LFxuICAgICAgICAgIG5hdGl2ZUV2ZW50OiBldmVudFxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIENhbGwgc3Vic2NyaWJlcnNcbiAgICAgICAgY2FsbGJhY2socmF5Y2FzdEV2ZW50KTtcbiAgICAgICAgLy8gRXZlbnQgYnViYmxpbmcgbWF5IGJlIGludGVycnVwdGVkIGJ5IHN0b3BQcm9wYWdhdGlvblxuICAgICAgICBpZiAobG9jYWxTdGF0ZS5zdG9wcGVkID09PSB0cnVlKSBicmVhaztcbiAgICAgIH1cbiAgICB9XG4gICAgcmV0dXJuIGludGVyc2VjdGlvbnM7XG4gIH1cbiAgZnVuY3Rpb24gY2FuY2VsUG9pbnRlcihpbnRlcnNlY3Rpb25zKSB7XG4gICAgY29uc3Qge1xuICAgICAgaW50ZXJuYWxcbiAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBmb3IgKGNvbnN0IGhvdmVyZWRPYmogb2YgaW50ZXJuYWwuaG92ZXJlZC52YWx1ZXMoKSkge1xuICAgICAgLy8gV2hlbiBubyBvYmplY3RzIHdlcmUgaGl0IG9yIHRoZSB0aGUgaG92ZXJlZCBvYmplY3Qgd2Fzbid0IGZvdW5kIHVuZGVybmVhdGggdGhlIGN1cnNvclxuICAgICAgLy8gd2UgY2FsbCBvblBvaW50ZXJPdXQgYW5kIGRlbGV0ZSB0aGUgb2JqZWN0IGZyb20gdGhlIGhvdmVyZWQtZWxlbWVudHMgbWFwXG4gICAgICBpZiAoIWludGVyc2VjdGlvbnMubGVuZ3RoIHx8ICFpbnRlcnNlY3Rpb25zLmZpbmQoaGl0ID0+IGhpdC5vYmplY3QgPT09IGhvdmVyZWRPYmoub2JqZWN0ICYmIGhpdC5pbmRleCA9PT0gaG92ZXJlZE9iai5pbmRleCAmJiBoaXQuaW5zdGFuY2VJZCA9PT0gaG92ZXJlZE9iai5pbnN0YW5jZUlkKSkge1xuICAgICAgICBjb25zdCBldmVudE9iamVjdCA9IGhvdmVyZWRPYmouZXZlbnRPYmplY3Q7XG4gICAgICAgIGNvbnN0IGluc3RhbmNlID0gZXZlbnRPYmplY3QuX19yM2Y7XG4gICAgICAgIGNvbnN0IGhhbmRsZXJzID0gaW5zdGFuY2UgPT0gbnVsbCA/IHZvaWQgMCA6IGluc3RhbmNlLmhhbmRsZXJzO1xuICAgICAgICBpbnRlcm5hbC5ob3ZlcmVkLmRlbGV0ZShtYWtlSWQoaG92ZXJlZE9iaikpO1xuICAgICAgICBpZiAoaW5zdGFuY2UgIT0gbnVsbCAmJiBpbnN0YW5jZS5ldmVudENvdW50KSB7XG4gICAgICAgICAgLy8gQ2xlYXIgb3V0IGludGVyc2VjdHMsIHRoZXkgYXJlIG91dGRhdGVkIGJ5IG5vd1xuICAgICAgICAgIGNvbnN0IGRhdGEgPSB7XG4gICAgICAgICAgICAuLi5ob3ZlcmVkT2JqLFxuICAgICAgICAgICAgaW50ZXJzZWN0aW9uc1xuICAgICAgICAgIH07XG4gICAgICAgICAgaGFuZGxlcnMub25Qb2ludGVyT3V0ID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVycy5vblBvaW50ZXJPdXQoZGF0YSk7XG4gICAgICAgICAgaGFuZGxlcnMub25Qb2ludGVyTGVhdmUgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZXJzLm9uUG9pbnRlckxlYXZlKGRhdGEpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIHBvaW50ZXJNaXNzZWQoZXZlbnQsIG9iamVjdHMpIHtcbiAgICBmb3IgKGxldCBpID0gMDsgaSA8IG9iamVjdHMubGVuZ3RoOyBpKyspIHtcbiAgICAgIGNvbnN0IGluc3RhbmNlID0gb2JqZWN0c1tpXS5fX3IzZjtcbiAgICAgIGluc3RhbmNlID09IG51bGwgPyB2b2lkIDAgOiBpbnN0YW5jZS5oYW5kbGVycy5vblBvaW50ZXJNaXNzZWQgPT0gbnVsbCA/IHZvaWQgMCA6IGluc3RhbmNlLmhhbmRsZXJzLm9uUG9pbnRlck1pc3NlZChldmVudCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGhhbmRsZVBvaW50ZXIobmFtZSkge1xuICAgIC8vIERlYWwgd2l0aCBjYW5jZWxhdGlvblxuICAgIHN3aXRjaCAobmFtZSkge1xuICAgICAgY2FzZSAnb25Qb2ludGVyTGVhdmUnOlxuICAgICAgY2FzZSAnb25Qb2ludGVyQ2FuY2VsJzpcbiAgICAgICAgcmV0dXJuICgpID0+IGNhbmNlbFBvaW50ZXIoW10pO1xuICAgICAgY2FzZSAnb25Mb3N0UG9pbnRlckNhcHR1cmUnOlxuICAgICAgICByZXR1cm4gZXZlbnQgPT4ge1xuICAgICAgICAgIGNvbnN0IHtcbiAgICAgICAgICAgIGludGVybmFsXG4gICAgICAgICAgfSA9IHN0b3JlLmdldFN0YXRlKCk7XG4gICAgICAgICAgaWYgKCdwb2ludGVySWQnIGluIGV2ZW50ICYmIGludGVybmFsLmNhcHR1cmVkTWFwLmhhcyhldmVudC5wb2ludGVySWQpKSB7XG4gICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IGV2ZW50IGludGVyZmFjZSBoYWQgb25Mb3N0UG9pbnRlckNhcHR1cmUsIHdlJ2QgY2FsbCBpdCBoZXJlIG9uIGV2ZXJ5XG4gICAgICAgICAgICAvLyBvYmplY3QgdGhhdCdzIGdldHRpbmcgcmVtb3ZlZC4gV2UgY2FsbCBpdCBvbiB0aGUgbmV4dCBmcmFtZSBiZWNhdXNlIG9uTG9zdFBvaW50ZXJDYXB0dXJlXG4gICAgICAgICAgICAvLyBmaXJlcyBiZWZvcmUgb25Qb2ludGVyVXAuIE90aGVyd2lzZSBwb2ludGVyVXAgd291bGQgbmV2ZXIgYmUgY2FsbGVkIGlmIHRoZSBldmVudCBkaWRuJ3RcbiAgICAgICAgICAgIC8vIGhhcHBlbiBpbiB0aGUgb2JqZWN0IGl0IG9yaWdpbmF0ZWQgZnJvbSwgbGVhdmluZyBjb21wb25lbnRzIGluIGEgaW4tYmV0d2VlbiBzdGF0ZS5cbiAgICAgICAgICAgIHJlcXVlc3RBbmltYXRpb25GcmFtZSgoKSA9PiB7XG4gICAgICAgICAgICAgIC8vIE9ubHkgcmVsZWFzZSBpZiBwb2ludGVyLXVwIGRpZG4ndCBkbyBpdCBhbHJlYWR5XG4gICAgICAgICAgICAgIGlmIChpbnRlcm5hbC5jYXB0dXJlZE1hcC5oYXMoZXZlbnQucG9pbnRlcklkKSkge1xuICAgICAgICAgICAgICAgIGludGVybmFsLmNhcHR1cmVkTWFwLmRlbGV0ZShldmVudC5wb2ludGVySWQpO1xuICAgICAgICAgICAgICAgIGNhbmNlbFBvaW50ZXIoW10pO1xuICAgICAgICAgICAgICB9XG4gICAgICAgICAgICB9KTtcbiAgICAgICAgICB9XG4gICAgICAgIH07XG4gICAgfVxuXG4gICAgLy8gQW55IG90aGVyIHBvaW50ZXIgZ29lcyBoZXJlIC4uLlxuICAgIHJldHVybiBmdW5jdGlvbiBoYW5kbGVFdmVudChldmVudCkge1xuICAgICAgY29uc3Qge1xuICAgICAgICBvblBvaW50ZXJNaXNzZWQsXG4gICAgICAgIGludGVybmFsXG4gICAgICB9ID0gc3RvcmUuZ2V0U3RhdGUoKTtcblxuICAgICAgLy8gcHJlcGFyZVJheShldmVudClcbiAgICAgIGludGVybmFsLmxhc3RFdmVudC5jdXJyZW50ID0gZXZlbnQ7XG5cbiAgICAgIC8vIEdldCBmcmVzaCBpbnRlcnNlY3RzXG4gICAgICBjb25zdCBpc1BvaW50ZXJNb3ZlID0gbmFtZSA9PT0gJ29uUG9pbnRlck1vdmUnO1xuICAgICAgY29uc3QgaXNDbGlja0V2ZW50ID0gbmFtZSA9PT0gJ29uQ2xpY2snIHx8IG5hbWUgPT09ICdvbkNvbnRleHRNZW51JyB8fCBuYW1lID09PSAnb25Eb3VibGVDbGljayc7XG4gICAgICBjb25zdCBmaWx0ZXIgPSBpc1BvaW50ZXJNb3ZlID8gZmlsdGVyUG9pbnRlckV2ZW50cyA6IHVuZGVmaW5lZDtcbiAgICAgIGNvbnN0IGhpdHMgPSBpbnRlcnNlY3QoZXZlbnQsIGZpbHRlcik7XG4gICAgICBjb25zdCBkZWx0YSA9IGlzQ2xpY2tFdmVudCA/IGNhbGN1bGF0ZURpc3RhbmNlKGV2ZW50KSA6IDA7XG5cbiAgICAgIC8vIFNhdmUgaW5pdGlhbCBjb29yZGluYXRlcyBvbiBwb2ludGVyLWRvd25cbiAgICAgIGlmIChuYW1lID09PSAnb25Qb2ludGVyRG93bicpIHtcbiAgICAgICAgaW50ZXJuYWwuaW5pdGlhbENsaWNrID0gW2V2ZW50Lm9mZnNldFgsIGV2ZW50Lm9mZnNldFldO1xuICAgICAgICBpbnRlcm5hbC5pbml0aWFsSGl0cyA9IGhpdHMubWFwKGhpdCA9PiBoaXQuZXZlbnRPYmplY3QpO1xuICAgICAgfVxuXG4gICAgICAvLyBJZiBhIGNsaWNrIHlpZWxkcyBubyByZXN1bHRzLCBwYXNzIGl0IGJhY2sgdG8gdGhlIHVzZXIgYXMgYSBtaXNzXG4gICAgICAvLyBNaXNzZWQgZXZlbnRzIGhhdmUgdG8gY29tZSBmaXJzdCBpbiBvcmRlciB0byBlc3RhYmxpc2ggdXNlci1sYW5kIHNpZGUtZWZmZWN0IGNsZWFuIHVwXG4gICAgICBpZiAoaXNDbGlja0V2ZW50ICYmICFoaXRzLmxlbmd0aCkge1xuICAgICAgICBpZiAoZGVsdGEgPD0gMikge1xuICAgICAgICAgIHBvaW50ZXJNaXNzZWQoZXZlbnQsIGludGVybmFsLmludGVyYWN0aW9uKTtcbiAgICAgICAgICBpZiAob25Qb2ludGVyTWlzc2VkKSBvblBvaW50ZXJNaXNzZWQoZXZlbnQpO1xuICAgICAgICB9XG4gICAgICB9XG4gICAgICAvLyBUYWtlIGNhcmUgb2YgdW5ob3ZlclxuICAgICAgaWYgKGlzUG9pbnRlck1vdmUpIGNhbmNlbFBvaW50ZXIoaGl0cyk7XG4gICAgICBmdW5jdGlvbiBvbkludGVyc2VjdChkYXRhKSB7XG4gICAgICAgIGNvbnN0IGV2ZW50T2JqZWN0ID0gZGF0YS5ldmVudE9iamVjdDtcbiAgICAgICAgY29uc3QgaW5zdGFuY2UgPSBldmVudE9iamVjdC5fX3IzZjtcbiAgICAgICAgY29uc3QgaGFuZGxlcnMgPSBpbnN0YW5jZSA9PSBudWxsID8gdm9pZCAwIDogaW5zdGFuY2UuaGFuZGxlcnM7XG5cbiAgICAgICAgLy8gQ2hlY2sgcHJlc2VuY2Ugb2YgaGFuZGxlcnNcbiAgICAgICAgaWYgKCEoaW5zdGFuY2UgIT0gbnVsbCAmJiBpbnN0YW5jZS5ldmVudENvdW50KSkgcmV0dXJuO1xuXG4gICAgICAgIC8qXG4gICAgICAgIE1BWUJFIFRPRE8sIERFTEVURSBJRiBOT1Q6IFxuICAgICAgICAgIENoZWNrIGlmIHRoZSBvYmplY3QgaXMgY2FwdHVyZWQsIGNhcHR1cmVkIGV2ZW50cyBzaG91bGQgbm90IGhhdmUgaW50ZXJzZWN0cyBydW5uaW5nIGluIHBhcmFsbGVsXG4gICAgICAgICAgQnV0IHdvdWxkbid0IGl0IGJlIGJldHRlciB0byBqdXN0IHJlcGxhY2UgY2FwdHVyZWRNYXAgd2l0aCBhIHNpbmdsZSBlbnRyeT9cbiAgICAgICAgICBBbHNvLCBhcmUgd2UgT0sgd2l0aCBzdHJhaWdodCB1cCBtYWtpbmcgcGlja2luZyB1cCBtdWx0aXBsZSBvYmplY3RzIGltcG9zc2libGU/XG4gICAgICAgICAgXG4gICAgICAgIGNvbnN0IHBvaW50ZXJJZCA9IChkYXRhIGFzIFRocmVlRXZlbnQ8UG9pbnRlckV2ZW50PikucG9pbnRlcklkICAgICAgICBcbiAgICAgICAgaWYgKHBvaW50ZXJJZCAhPT0gdW5kZWZpbmVkKSB7XG4gICAgICAgICAgY29uc3QgY2FwdHVyZWRNZXNoU2V0ID0gaW50ZXJuYWwuY2FwdHVyZWRNYXAuZ2V0KHBvaW50ZXJJZClcbiAgICAgICAgICBpZiAoY2FwdHVyZWRNZXNoU2V0KSB7XG4gICAgICAgICAgICBjb25zdCBjYXB0dXJlZCA9IGNhcHR1cmVkTWVzaFNldC5nZXQoZXZlbnRPYmplY3QpXG4gICAgICAgICAgICBpZiAoY2FwdHVyZWQgJiYgY2FwdHVyZWQubG9jYWxTdGF0ZS5zdG9wcGVkKSByZXR1cm5cbiAgICAgICAgICB9XG4gICAgICAgIH0qL1xuXG4gICAgICAgIGlmIChpc1BvaW50ZXJNb3ZlKSB7XG4gICAgICAgICAgLy8gTW92ZSBldmVudCAuLi5cbiAgICAgICAgICBpZiAoaGFuZGxlcnMub25Qb2ludGVyT3ZlciB8fCBoYW5kbGVycy5vblBvaW50ZXJFbnRlciB8fCBoYW5kbGVycy5vblBvaW50ZXJPdXQgfHwgaGFuZGxlcnMub25Qb2ludGVyTGVhdmUpIHtcbiAgICAgICAgICAgIC8vIFdoZW4gZW50ZXIgb3Igb3V0IGlzIHByZXNlbnQgdGFrZSBjYXJlIG9mIGhvdmVyLXN0YXRlXG4gICAgICAgICAgICBjb25zdCBpZCA9IG1ha2VJZChkYXRhKTtcbiAgICAgICAgICAgIGNvbnN0IGhvdmVyZWRJdGVtID0gaW50ZXJuYWwuaG92ZXJlZC5nZXQoaWQpO1xuICAgICAgICAgICAgaWYgKCFob3ZlcmVkSXRlbSkge1xuICAgICAgICAgICAgICAvLyBJZiB0aGUgb2JqZWN0IHdhc24ndCBwcmV2aW91c2x5IGhvdmVyZWQsIGJvb2sgaXQgYW5kIGNhbGwgaXRzIGhhbmRsZXJcbiAgICAgICAgICAgICAgaW50ZXJuYWwuaG92ZXJlZC5zZXQoaWQsIGRhdGEpO1xuICAgICAgICAgICAgICBoYW5kbGVycy5vblBvaW50ZXJPdmVyID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVycy5vblBvaW50ZXJPdmVyKGRhdGEpO1xuICAgICAgICAgICAgICBoYW5kbGVycy5vblBvaW50ZXJFbnRlciA9PSBudWxsID8gdm9pZCAwIDogaGFuZGxlcnMub25Qb2ludGVyRW50ZXIoZGF0YSk7XG4gICAgICAgICAgICB9IGVsc2UgaWYgKGhvdmVyZWRJdGVtLnN0b3BwZWQpIHtcbiAgICAgICAgICAgICAgLy8gSWYgdGhlIG9iamVjdCB3YXMgcHJldmlvdXNseSBob3ZlcmVkIGFuZCBzdG9wcGVkLCB3ZSBzaG91bGRuJ3QgYWxsb3cgb3RoZXIgaXRlbXMgdG8gcHJvY2VlZFxuICAgICAgICAgICAgICBkYXRhLnN0b3BQcm9wYWdhdGlvbigpO1xuICAgICAgICAgICAgfVxuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBDYWxsIG1vdXNlIG1vdmVcbiAgICAgICAgICBoYW5kbGVycy5vblBvaW50ZXJNb3ZlID09IG51bGwgPyB2b2lkIDAgOiBoYW5kbGVycy5vblBvaW50ZXJNb3ZlKGRhdGEpO1xuICAgICAgICB9IGVsc2Uge1xuICAgICAgICAgIC8vIEFsbCBvdGhlciBldmVudHMgLi4uXG4gICAgICAgICAgY29uc3QgaGFuZGxlciA9IGhhbmRsZXJzW25hbWVdO1xuICAgICAgICAgIGlmIChoYW5kbGVyKSB7XG4gICAgICAgICAgICAvLyBGb3J3YXJkIGFsbCBldmVudHMgYmFjayB0byB0aGVpciByZXNwZWN0aXZlIGhhbmRsZXJzIHdpdGggdGhlIGV4Y2VwdGlvbiBvZiBjbGljayBldmVudHMsXG4gICAgICAgICAgICAvLyB3aGljaCBtdXN0IHVzZSB0aGUgaW5pdGlhbCB0YXJnZXRcbiAgICAgICAgICAgIGlmICghaXNDbGlja0V2ZW50IHx8IGludGVybmFsLmluaXRpYWxIaXRzLmluY2x1ZGVzKGV2ZW50T2JqZWN0KSkge1xuICAgICAgICAgICAgICAvLyBNaXNzZWQgZXZlbnRzIGhhdmUgdG8gY29tZSBmaXJzdFxuICAgICAgICAgICAgICBwb2ludGVyTWlzc2VkKGV2ZW50LCBpbnRlcm5hbC5pbnRlcmFjdGlvbi5maWx0ZXIob2JqZWN0ID0+ICFpbnRlcm5hbC5pbml0aWFsSGl0cy5pbmNsdWRlcyhvYmplY3QpKSk7XG4gICAgICAgICAgICAgIC8vIE5vdyBjYWxsIHRoZSBoYW5kbGVyXG4gICAgICAgICAgICAgIGhhbmRsZXIoZGF0YSk7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfSBlbHNlIHtcbiAgICAgICAgICAgIC8vIFRyaWdnZXIgb25Qb2ludGVyTWlzc2VkIG9uIGFsbCBlbGVtZW50cyB0aGF0IGhhdmUgcG9pbnRlciBvdmVyL291dCBoYW5kbGVycywgYnV0IG5vdCBjbGljayBhbmQgd2VyZW4ndCBoaXRcbiAgICAgICAgICAgIGlmIChpc0NsaWNrRXZlbnQgJiYgaW50ZXJuYWwuaW5pdGlhbEhpdHMuaW5jbHVkZXMoZXZlbnRPYmplY3QpKSB7XG4gICAgICAgICAgICAgIHBvaW50ZXJNaXNzZWQoZXZlbnQsIGludGVybmFsLmludGVyYWN0aW9uLmZpbHRlcihvYmplY3QgPT4gIWludGVybmFsLmluaXRpYWxIaXRzLmluY2x1ZGVzKG9iamVjdCkpKTtcbiAgICAgICAgICAgIH1cbiAgICAgICAgICB9XG4gICAgICAgIH1cbiAgICAgIH1cbiAgICAgIGhhbmRsZUludGVyc2VjdHMoaGl0cywgZXZlbnQsIGRlbHRhLCBvbkludGVyc2VjdCk7XG4gICAgfTtcbiAgfVxuICByZXR1cm4ge1xuICAgIGhhbmRsZVBvaW50ZXJcbiAgfTtcbn1cblxuLy8gS2V5cyB0aGF0IHNob3VsZG4ndCBiZSBjb3BpZWQgYmV0d2VlbiBSM0Ygc3RvcmVzXG5jb25zdCBwcml2YXRlS2V5cyA9IFsnc2V0JywgJ2dldCcsICdzZXRTaXplJywgJ3NldEZyYW1lbG9vcCcsICdzZXREcHInLCAnZXZlbnRzJywgJ2ludmFsaWRhdGUnLCAnYWR2YW5jZScsICdzaXplJywgJ3ZpZXdwb3J0J107XG5jb25zdCBpc1JlbmRlcmVyID0gZGVmID0+ICEhKGRlZiAhPSBudWxsICYmIGRlZi5yZW5kZXIpO1xuY29uc3QgY29udGV4dCA9IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVDb250ZXh0KG51bGwpO1xuY29uc3QgY3JlYXRlU3RvcmUgPSAoaW52YWxpZGF0ZSwgYWR2YW5jZSkgPT4ge1xuICBjb25zdCByb290U3RhdGUgPSBjcmVhdGUoKHNldCwgZ2V0KSA9PiB7XG4gICAgY29uc3QgcG9zaXRpb24gPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIGNvbnN0IGRlZmF1bHRUYXJnZXQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIGNvbnN0IHRlbXBUYXJnZXQgPSBuZXcgVEhSRUUuVmVjdG9yMygpO1xuICAgIGZ1bmN0aW9uIGdldEN1cnJlbnRWaWV3cG9ydChjYW1lcmEgPSBnZXQoKS5jYW1lcmEsIHRhcmdldCA9IGRlZmF1bHRUYXJnZXQsIHNpemUgPSBnZXQoKS5zaXplKSB7XG4gICAgICBjb25zdCB7XG4gICAgICAgIHdpZHRoLFxuICAgICAgICBoZWlnaHQsXG4gICAgICAgIHRvcCxcbiAgICAgICAgbGVmdFxuICAgICAgfSA9IHNpemU7XG4gICAgICBjb25zdCBhc3BlY3QgPSB3aWR0aCAvIGhlaWdodDtcbiAgICAgIGlmICh0YXJnZXQgaW5zdGFuY2VvZiBUSFJFRS5WZWN0b3IzKSB0ZW1wVGFyZ2V0LmNvcHkodGFyZ2V0KTtlbHNlIHRlbXBUYXJnZXQuc2V0KC4uLnRhcmdldCk7XG4gICAgICBjb25zdCBkaXN0YW5jZSA9IGNhbWVyYS5nZXRXb3JsZFBvc2l0aW9uKHBvc2l0aW9uKS5kaXN0YW5jZVRvKHRlbXBUYXJnZXQpO1xuICAgICAgaWYgKGlzT3J0aG9ncmFwaGljQ2FtZXJhKGNhbWVyYSkpIHtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB3aWR0aDogd2lkdGggLyBjYW1lcmEuem9vbSxcbiAgICAgICAgICBoZWlnaHQ6IGhlaWdodCAvIGNhbWVyYS56b29tLFxuICAgICAgICAgIHRvcCxcbiAgICAgICAgICBsZWZ0LFxuICAgICAgICAgIGZhY3RvcjogMSxcbiAgICAgICAgICBkaXN0YW5jZSxcbiAgICAgICAgICBhc3BlY3RcbiAgICAgICAgfTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGNvbnN0IGZvdiA9IGNhbWVyYS5mb3YgKiBNYXRoLlBJIC8gMTgwOyAvLyBjb252ZXJ0IHZlcnRpY2FsIGZvdiB0byByYWRpYW5zXG4gICAgICAgIGNvbnN0IGggPSAyICogTWF0aC50YW4oZm92IC8gMikgKiBkaXN0YW5jZTsgLy8gdmlzaWJsZSBoZWlnaHRcbiAgICAgICAgY29uc3QgdyA9IGggKiAod2lkdGggLyBoZWlnaHQpO1xuICAgICAgICByZXR1cm4ge1xuICAgICAgICAgIHdpZHRoOiB3LFxuICAgICAgICAgIGhlaWdodDogaCxcbiAgICAgICAgICB0b3AsXG4gICAgICAgICAgbGVmdCxcbiAgICAgICAgICBmYWN0b3I6IHdpZHRoIC8gdyxcbiAgICAgICAgICBkaXN0YW5jZSxcbiAgICAgICAgICBhc3BlY3RcbiAgICAgICAgfTtcbiAgICAgIH1cbiAgICB9XG4gICAgbGV0IHBlcmZvcm1hbmNlVGltZW91dCA9IHVuZGVmaW5lZDtcbiAgICBjb25zdCBzZXRQZXJmb3JtYW5jZUN1cnJlbnQgPSBjdXJyZW50ID0+IHNldChzdGF0ZSA9PiAoe1xuICAgICAgcGVyZm9ybWFuY2U6IHtcbiAgICAgICAgLi4uc3RhdGUucGVyZm9ybWFuY2UsXG4gICAgICAgIGN1cnJlbnRcbiAgICAgIH1cbiAgICB9KSk7XG4gICAgY29uc3QgcG9pbnRlciA9IG5ldyBUSFJFRS5WZWN0b3IyKCk7XG4gICAgY29uc3Qgcm9vdFN0YXRlID0ge1xuICAgICAgc2V0LFxuICAgICAgZ2V0LFxuICAgICAgLy8gTW9jayBvYmplY3RzIHRoYXQgaGF2ZSB0byBiZSBjb25maWd1cmVkXG4gICAgICBnbDogbnVsbCxcbiAgICAgIGNhbWVyYTogbnVsbCxcbiAgICAgIHJheWNhc3RlcjogbnVsbCxcbiAgICAgIGV2ZW50czoge1xuICAgICAgICBwcmlvcml0eTogMSxcbiAgICAgICAgZW5hYmxlZDogdHJ1ZSxcbiAgICAgICAgY29ubmVjdGVkOiBmYWxzZVxuICAgICAgfSxcbiAgICAgIHhyOiBudWxsLFxuICAgICAgc2NlbmU6IG51bGwsXG4gICAgICBpbnZhbGlkYXRlOiAoZnJhbWVzID0gMSkgPT4gaW52YWxpZGF0ZShnZXQoKSwgZnJhbWVzKSxcbiAgICAgIGFkdmFuY2U6ICh0aW1lc3RhbXAsIHJ1bkdsb2JhbEVmZmVjdHMpID0+IGFkdmFuY2UodGltZXN0YW1wLCBydW5HbG9iYWxFZmZlY3RzLCBnZXQoKSksXG4gICAgICBsZWdhY3k6IGZhbHNlLFxuICAgICAgbGluZWFyOiBmYWxzZSxcbiAgICAgIGZsYXQ6IGZhbHNlLFxuICAgICAgY29udHJvbHM6IG51bGwsXG4gICAgICBjbG9jazogbmV3IFRIUkVFLkNsb2NrKCksXG4gICAgICBwb2ludGVyLFxuICAgICAgbW91c2U6IHBvaW50ZXIsXG4gICAgICBmcmFtZWxvb3A6ICdhbHdheXMnLFxuICAgICAgb25Qb2ludGVyTWlzc2VkOiB1bmRlZmluZWQsXG4gICAgICBwZXJmb3JtYW5jZToge1xuICAgICAgICBjdXJyZW50OiAxLFxuICAgICAgICBtaW46IDAuNSxcbiAgICAgICAgbWF4OiAxLFxuICAgICAgICBkZWJvdW5jZTogMjAwLFxuICAgICAgICByZWdyZXNzOiAoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3RhdGUgPSBnZXQoKTtcbiAgICAgICAgICAvLyBDbGVhciB0aW1lb3V0XG4gICAgICAgICAgaWYgKHBlcmZvcm1hbmNlVGltZW91dCkgY2xlYXJUaW1lb3V0KHBlcmZvcm1hbmNlVGltZW91dCk7XG4gICAgICAgICAgLy8gU2V0IGxvd2VyIGJvdW5kIHBlcmZvcm1hbmNlXG4gICAgICAgICAgaWYgKHN0YXRlLnBlcmZvcm1hbmNlLmN1cnJlbnQgIT09IHN0YXRlLnBlcmZvcm1hbmNlLm1pbikgc2V0UGVyZm9ybWFuY2VDdXJyZW50KHN0YXRlLnBlcmZvcm1hbmNlLm1pbik7XG4gICAgICAgICAgLy8gR28gYmFjayB0byB1cHBlciBib3VuZCBwZXJmb3JtYW5jZSBhZnRlciBhIHdoaWxlIHVubGVzcyBzb21ldGhpbmcgcmVncmVzc2VzIG1lYW53aGlsZVxuICAgICAgICAgIHBlcmZvcm1hbmNlVGltZW91dCA9IHNldFRpbWVvdXQoKCkgPT4gc2V0UGVyZm9ybWFuY2VDdXJyZW50KGdldCgpLnBlcmZvcm1hbmNlLm1heCksIHN0YXRlLnBlcmZvcm1hbmNlLmRlYm91bmNlKTtcbiAgICAgICAgfVxuICAgICAgfSxcbiAgICAgIHNpemU6IHtcbiAgICAgICAgd2lkdGg6IDAsXG4gICAgICAgIGhlaWdodDogMCxcbiAgICAgICAgdG9wOiAwLFxuICAgICAgICBsZWZ0OiAwLFxuICAgICAgICB1cGRhdGVTdHlsZTogZmFsc2VcbiAgICAgIH0sXG4gICAgICB2aWV3cG9ydDoge1xuICAgICAgICBpbml0aWFsRHByOiAwLFxuICAgICAgICBkcHI6IDAsXG4gICAgICAgIHdpZHRoOiAwLFxuICAgICAgICBoZWlnaHQ6IDAsXG4gICAgICAgIHRvcDogMCxcbiAgICAgICAgbGVmdDogMCxcbiAgICAgICAgYXNwZWN0OiAwLFxuICAgICAgICBkaXN0YW5jZTogMCxcbiAgICAgICAgZmFjdG9yOiAwLFxuICAgICAgICBnZXRDdXJyZW50Vmlld3BvcnRcbiAgICAgIH0sXG4gICAgICBzZXRFdmVudHM6IGV2ZW50cyA9PiBzZXQoc3RhdGUgPT4gKHtcbiAgICAgICAgLi4uc3RhdGUsXG4gICAgICAgIGV2ZW50czoge1xuICAgICAgICAgIC4uLnN0YXRlLmV2ZW50cyxcbiAgICAgICAgICAuLi5ldmVudHNcbiAgICAgICAgfVxuICAgICAgfSkpLFxuICAgICAgc2V0U2l6ZTogKHdpZHRoLCBoZWlnaHQsIHVwZGF0ZVN0eWxlLCB0b3AsIGxlZnQpID0+IHtcbiAgICAgICAgY29uc3QgY2FtZXJhID0gZ2V0KCkuY2FtZXJhO1xuICAgICAgICBjb25zdCBzaXplID0ge1xuICAgICAgICAgIHdpZHRoLFxuICAgICAgICAgIGhlaWdodCxcbiAgICAgICAgICB0b3A6IHRvcCB8fCAwLFxuICAgICAgICAgIGxlZnQ6IGxlZnQgfHwgMCxcbiAgICAgICAgICB1cGRhdGVTdHlsZVxuICAgICAgICB9O1xuICAgICAgICBzZXQoc3RhdGUgPT4gKHtcbiAgICAgICAgICBzaXplLFxuICAgICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgICAuLi5zdGF0ZS52aWV3cG9ydCxcbiAgICAgICAgICAgIC4uLmdldEN1cnJlbnRWaWV3cG9ydChjYW1lcmEsIGRlZmF1bHRUYXJnZXQsIHNpemUpXG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICB9LFxuICAgICAgc2V0RHByOiBkcHIgPT4gc2V0KHN0YXRlID0+IHtcbiAgICAgICAgY29uc3QgcmVzb2x2ZWQgPSBjYWxjdWxhdGVEcHIoZHByKTtcbiAgICAgICAgcmV0dXJuIHtcbiAgICAgICAgICB2aWV3cG9ydDoge1xuICAgICAgICAgICAgLi4uc3RhdGUudmlld3BvcnQsXG4gICAgICAgICAgICBkcHI6IHJlc29sdmVkLFxuICAgICAgICAgICAgaW5pdGlhbERwcjogc3RhdGUudmlld3BvcnQuaW5pdGlhbERwciB8fCByZXNvbHZlZFxuICAgICAgICAgIH1cbiAgICAgICAgfTtcbiAgICAgIH0pLFxuICAgICAgc2V0RnJhbWVsb29wOiAoZnJhbWVsb29wID0gJ2Fsd2F5cycpID0+IHtcbiAgICAgICAgY29uc3QgY2xvY2sgPSBnZXQoKS5jbG9jaztcblxuICAgICAgICAvLyBpZiBmcmFtZWxvb3AgPT09IFwibmV2ZXJcIiBjbG9jay5lbGFwc2VkVGltZSBpcyB1cGRhdGVkIHVzaW5nIGFkdmFuY2UodGltZXN0YW1wKVxuICAgICAgICBjbG9jay5zdG9wKCk7XG4gICAgICAgIGNsb2NrLmVsYXBzZWRUaW1lID0gMDtcbiAgICAgICAgaWYgKGZyYW1lbG9vcCAhPT0gJ25ldmVyJykge1xuICAgICAgICAgIGNsb2NrLnN0YXJ0KCk7XG4gICAgICAgICAgY2xvY2suZWxhcHNlZFRpbWUgPSAwO1xuICAgICAgICB9XG4gICAgICAgIHNldCgoKSA9PiAoe1xuICAgICAgICAgIGZyYW1lbG9vcFxuICAgICAgICB9KSk7XG4gICAgICB9LFxuICAgICAgcHJldmlvdXNSb290OiB1bmRlZmluZWQsXG4gICAgICBpbnRlcm5hbDoge1xuICAgICAgICBhY3RpdmU6IGZhbHNlLFxuICAgICAgICBwcmlvcml0eTogMCxcbiAgICAgICAgZnJhbWVzOiAwLFxuICAgICAgICBsYXN0RXZlbnQ6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVSZWYoKSxcbiAgICAgICAgaW50ZXJhY3Rpb246IFtdLFxuICAgICAgICBob3ZlcmVkOiBuZXcgTWFwKCksXG4gICAgICAgIHN1YnNjcmliZXJzOiBbXSxcbiAgICAgICAgaW5pdGlhbENsaWNrOiBbMCwgMF0sXG4gICAgICAgIGluaXRpYWxIaXRzOiBbXSxcbiAgICAgICAgY2FwdHVyZWRNYXA6IG5ldyBNYXAoKSxcbiAgICAgICAgc3Vic2NyaWJlOiAocmVmLCBwcmlvcml0eSwgc3RvcmUpID0+IHtcbiAgICAgICAgICBjb25zdCBpbnRlcm5hbCA9IGdldCgpLmludGVybmFsO1xuICAgICAgICAgIC8vIElmIHRoaXMgc3Vic2NyaXB0aW9uIHdhcyBnaXZlbiBhIHByaW9yaXR5LCBpdCB0YWtlcyByZW5kZXJpbmcgaW50byBpdHMgb3duIGhhbmRzXG4gICAgICAgICAgLy8gRm9yIHRoYXQgcmVhc29uIHdlIHN3aXRjaCBvZmYgYXV0b21hdGljIHJlbmRlcmluZyBhbmQgaW5jcmVhc2UgdGhlIG1hbnVhbCBmbGFnXG4gICAgICAgICAgLy8gQXMgbG9uZyBhcyB0aGlzIGZsYWcgaXMgcG9zaXRpdmUgdGhlcmUgY2FuIGJlIG5vIGludGVybmFsIHJlbmRlcmluZyBhdCBhbGxcbiAgICAgICAgICAvLyBiZWNhdXNlIHRoZXJlIGNvdWxkIGJlIG11bHRpcGxlIHJlbmRlciBzdWJzY3JpcHRpb25zXG4gICAgICAgICAgaW50ZXJuYWwucHJpb3JpdHkgPSBpbnRlcm5hbC5wcmlvcml0eSArIChwcmlvcml0eSA+IDAgPyAxIDogMCk7XG4gICAgICAgICAgaW50ZXJuYWwuc3Vic2NyaWJlcnMucHVzaCh7XG4gICAgICAgICAgICByZWYsXG4gICAgICAgICAgICBwcmlvcml0eSxcbiAgICAgICAgICAgIHN0b3JlXG4gICAgICAgICAgfSk7XG4gICAgICAgICAgLy8gUmVnaXN0ZXIgc3Vic2NyaWJlciBhbmQgc29ydCBsYXllcnMgZnJvbSBsb3dlc3QgdG8gaGlnaGVzdCwgbWVhbmluZyxcbiAgICAgICAgICAvLyBoaWdoZXN0IHByaW9yaXR5IHJlbmRlcnMgbGFzdCAob24gdG9wIG9mIHRoZSBvdGhlciBmcmFtZXMpXG4gICAgICAgICAgaW50ZXJuYWwuc3Vic2NyaWJlcnMgPSBpbnRlcm5hbC5zdWJzY3JpYmVycy5zb3J0KChhLCBiKSA9PiBhLnByaW9yaXR5IC0gYi5wcmlvcml0eSk7XG4gICAgICAgICAgcmV0dXJuICgpID0+IHtcbiAgICAgICAgICAgIGNvbnN0IGludGVybmFsID0gZ2V0KCkuaW50ZXJuYWw7XG4gICAgICAgICAgICBpZiAoaW50ZXJuYWwgIT0gbnVsbCAmJiBpbnRlcm5hbC5zdWJzY3JpYmVycykge1xuICAgICAgICAgICAgICAvLyBEZWNyZWFzZSBtYW51YWwgZmxhZyBpZiB0aGlzIHN1YnNjcmlwdGlvbiBoYWQgYSBwcmlvcml0eVxuICAgICAgICAgICAgICBpbnRlcm5hbC5wcmlvcml0eSA9IGludGVybmFsLnByaW9yaXR5IC0gKHByaW9yaXR5ID4gMCA/IDEgOiAwKTtcbiAgICAgICAgICAgICAgLy8gUmVtb3ZlIHN1YnNjcmliZXIgZnJvbSBsaXN0XG4gICAgICAgICAgICAgIGludGVybmFsLnN1YnNjcmliZXJzID0gaW50ZXJuYWwuc3Vic2NyaWJlcnMuZmlsdGVyKHMgPT4gcy5yZWYgIT09IHJlZik7XG4gICAgICAgICAgICB9XG4gICAgICAgICAgfTtcbiAgICAgICAgfVxuICAgICAgfVxuICAgIH07XG4gICAgcmV0dXJuIHJvb3RTdGF0ZTtcbiAgfSk7XG4gIGNvbnN0IHN0YXRlID0gcm9vdFN0YXRlLmdldFN0YXRlKCk7XG4gIGxldCBvbGRTaXplID0gc3RhdGUuc2l6ZTtcbiAgbGV0IG9sZERwciA9IHN0YXRlLnZpZXdwb3J0LmRwcjtcbiAgbGV0IG9sZENhbWVyYSA9IHN0YXRlLmNhbWVyYTtcbiAgcm9vdFN0YXRlLnN1YnNjcmliZSgoKSA9PiB7XG4gICAgY29uc3Qge1xuICAgICAgY2FtZXJhLFxuICAgICAgc2l6ZSxcbiAgICAgIHZpZXdwb3J0LFxuICAgICAgZ2wsXG4gICAgICBzZXRcbiAgICB9ID0gcm9vdFN0YXRlLmdldFN0YXRlKCk7XG5cbiAgICAvLyBSZXNpemUgY2FtZXJhIGFuZCByZW5kZXJlciBvbiBjaGFuZ2VzIHRvIHNpemUgYW5kIHBpeGVscmF0aW9cbiAgICBpZiAoc2l6ZSAhPT0gb2xkU2l6ZSB8fCB2aWV3cG9ydC5kcHIgIT09IG9sZERwcikge1xuICAgICAgdmFyIF9zaXplJHVwZGF0ZVN0eWxlO1xuICAgICAgb2xkU2l6ZSA9IHNpemU7XG4gICAgICBvbGREcHIgPSB2aWV3cG9ydC5kcHI7XG4gICAgICAvLyBVcGRhdGUgY2FtZXJhICYgcmVuZGVyZXJcbiAgICAgIHVwZGF0ZUNhbWVyYShjYW1lcmEsIHNpemUpO1xuICAgICAgZ2wuc2V0UGl4ZWxSYXRpbyh2aWV3cG9ydC5kcHIpO1xuICAgICAgY29uc3QgdXBkYXRlU3R5bGUgPSAoX3NpemUkdXBkYXRlU3R5bGUgPSBzaXplLnVwZGF0ZVN0eWxlKSAhPSBudWxsID8gX3NpemUkdXBkYXRlU3R5bGUgOiB0eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGdsLmRvbUVsZW1lbnQgaW5zdGFuY2VvZiBIVE1MQ2FudmFzRWxlbWVudDtcbiAgICAgIGdsLnNldFNpemUoc2l6ZS53aWR0aCwgc2l6ZS5oZWlnaHQsIHVwZGF0ZVN0eWxlKTtcbiAgICB9XG5cbiAgICAvLyBVcGRhdGUgdmlld3BvcnQgb25jZSB0aGUgY2FtZXJhIGNoYW5nZXNcbiAgICBpZiAoY2FtZXJhICE9PSBvbGRDYW1lcmEpIHtcbiAgICAgIG9sZENhbWVyYSA9IGNhbWVyYTtcbiAgICAgIC8vIFVwZGF0ZSB2aWV3cG9ydFxuICAgICAgc2V0KHN0YXRlID0+ICh7XG4gICAgICAgIHZpZXdwb3J0OiB7XG4gICAgICAgICAgLi4uc3RhdGUudmlld3BvcnQsXG4gICAgICAgICAgLi4uc3RhdGUudmlld3BvcnQuZ2V0Q3VycmVudFZpZXdwb3J0KGNhbWVyYSlcbiAgICAgICAgfVxuICAgICAgfSkpO1xuICAgIH1cbiAgfSk7XG5cbiAgLy8gSW52YWxpZGF0ZSBvbiBhbnkgY2hhbmdlXG4gIHJvb3RTdGF0ZS5zdWJzY3JpYmUoc3RhdGUgPT4gaW52YWxpZGF0ZShzdGF0ZSkpO1xuXG4gIC8vIFJldHVybiByb290IHN0YXRlXG4gIHJldHVybiByb290U3RhdGU7XG59O1xuXG5mdW5jdGlvbiBjcmVhdGVTdWJzKGNhbGxiYWNrLCBzdWJzKSB7XG4gIGNvbnN0IHN1YiA9IHtcbiAgICBjYWxsYmFja1xuICB9O1xuICBzdWJzLmFkZChzdWIpO1xuICByZXR1cm4gKCkgPT4gdm9pZCBzdWJzLmRlbGV0ZShzdWIpO1xufVxubGV0IGk7XG5sZXQgZ2xvYmFsRWZmZWN0cyA9IG5ldyBTZXQoKTtcbmxldCBnbG9iYWxBZnRlckVmZmVjdHMgPSBuZXcgU2V0KCk7XG5sZXQgZ2xvYmFsVGFpbEVmZmVjdHMgPSBuZXcgU2V0KCk7XG5cbi8qKlxuICogQWRkcyBhIGdsb2JhbCByZW5kZXIgY2FsbGJhY2sgd2hpY2ggaXMgY2FsbGVkIGVhY2ggZnJhbWUuXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9hZGRpdGlvbmFsLWV4cG9ydHMjYWRkRWZmZWN0XG4gKi9cbmNvbnN0IGFkZEVmZmVjdCA9IGNhbGxiYWNrID0+IGNyZWF0ZVN1YnMoY2FsbGJhY2ssIGdsb2JhbEVmZmVjdHMpO1xuXG4vKipcbiAqIEFkZHMgYSBnbG9iYWwgYWZ0ZXItcmVuZGVyIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCBlYWNoIGZyYW1lLlxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvYWRkaXRpb25hbC1leHBvcnRzI2FkZEFmdGVyRWZmZWN0XG4gKi9cbmNvbnN0IGFkZEFmdGVyRWZmZWN0ID0gY2FsbGJhY2sgPT4gY3JlYXRlU3VicyhjYWxsYmFjaywgZ2xvYmFsQWZ0ZXJFZmZlY3RzKTtcblxuLyoqXG4gKiBBZGRzIGEgZ2xvYmFsIGNhbGxiYWNrIHdoaWNoIGlzIGNhbGxlZCB3aGVuIHJlbmRlcmluZyBzdG9wcy5cbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2FkZGl0aW9uYWwtZXhwb3J0cyNhZGRUYWlsXG4gKi9cbmNvbnN0IGFkZFRhaWwgPSBjYWxsYmFjayA9PiBjcmVhdGVTdWJzKGNhbGxiYWNrLCBnbG9iYWxUYWlsRWZmZWN0cyk7XG5mdW5jdGlvbiBydW4oZWZmZWN0cywgdGltZXN0YW1wKSB7XG4gIGlmICghZWZmZWN0cy5zaXplKSByZXR1cm47XG4gIGZvciAoY29uc3Qge1xuICAgIGNhbGxiYWNrXG4gIH0gb2YgZWZmZWN0cy52YWx1ZXMoKSkge1xuICAgIGNhbGxiYWNrKHRpbWVzdGFtcCk7XG4gIH1cbn1cbmZ1bmN0aW9uIGZsdXNoR2xvYmFsRWZmZWN0cyh0eXBlLCB0aW1lc3RhbXApIHtcbiAgc3dpdGNoICh0eXBlKSB7XG4gICAgY2FzZSAnYmVmb3JlJzpcbiAgICAgIHJldHVybiBydW4oZ2xvYmFsRWZmZWN0cywgdGltZXN0YW1wKTtcbiAgICBjYXNlICdhZnRlcic6XG4gICAgICByZXR1cm4gcnVuKGdsb2JhbEFmdGVyRWZmZWN0cywgdGltZXN0YW1wKTtcbiAgICBjYXNlICd0YWlsJzpcbiAgICAgIHJldHVybiBydW4oZ2xvYmFsVGFpbEVmZmVjdHMsIHRpbWVzdGFtcCk7XG4gIH1cbn1cbmxldCBzdWJzY3JpYmVycztcbmxldCBzdWJzY3JpcHRpb247XG5mdW5jdGlvbiByZW5kZXIkMSh0aW1lc3RhbXAsIHN0YXRlLCBmcmFtZSkge1xuICAvLyBSdW4gbG9jYWwgZWZmZWN0c1xuICBsZXQgZGVsdGEgPSBzdGF0ZS5jbG9jay5nZXREZWx0YSgpO1xuICAvLyBJbiBmcmFtZWxvb3A9J25ldmVyJyBtb2RlLCBjbG9jayB0aW1lcyBhcmUgdXBkYXRlZCB1c2luZyB0aGUgcHJvdmlkZWQgdGltZXN0YW1wXG4gIGlmIChzdGF0ZS5mcmFtZWxvb3AgPT09ICduZXZlcicgJiYgdHlwZW9mIHRpbWVzdGFtcCA9PT0gJ251bWJlcicpIHtcbiAgICBkZWx0YSA9IHRpbWVzdGFtcCAtIHN0YXRlLmNsb2NrLmVsYXBzZWRUaW1lO1xuICAgIHN0YXRlLmNsb2NrLm9sZFRpbWUgPSBzdGF0ZS5jbG9jay5lbGFwc2VkVGltZTtcbiAgICBzdGF0ZS5jbG9jay5lbGFwc2VkVGltZSA9IHRpbWVzdGFtcDtcbiAgfVxuICAvLyBDYWxsIHN1YnNjcmliZXJzICh1c2VGcmFtZSlcbiAgc3Vic2NyaWJlcnMgPSBzdGF0ZS5pbnRlcm5hbC5zdWJzY3JpYmVycztcbiAgZm9yIChpID0gMDsgaSA8IHN1YnNjcmliZXJzLmxlbmd0aDsgaSsrKSB7XG4gICAgc3Vic2NyaXB0aW9uID0gc3Vic2NyaWJlcnNbaV07XG4gICAgc3Vic2NyaXB0aW9uLnJlZi5jdXJyZW50KHN1YnNjcmlwdGlvbi5zdG9yZS5nZXRTdGF0ZSgpLCBkZWx0YSwgZnJhbWUpO1xuICB9XG4gIC8vIFJlbmRlciBjb250ZW50XG4gIGlmICghc3RhdGUuaW50ZXJuYWwucHJpb3JpdHkgJiYgc3RhdGUuZ2wucmVuZGVyKSBzdGF0ZS5nbC5yZW5kZXIoc3RhdGUuc2NlbmUsIHN0YXRlLmNhbWVyYSk7XG4gIC8vIERlY3JlYXNlIGZyYW1lIGNvdW50XG4gIHN0YXRlLmludGVybmFsLmZyYW1lcyA9IE1hdGgubWF4KDAsIHN0YXRlLmludGVybmFsLmZyYW1lcyAtIDEpO1xuICByZXR1cm4gc3RhdGUuZnJhbWVsb29wID09PSAnYWx3YXlzJyA/IDEgOiBzdGF0ZS5pbnRlcm5hbC5mcmFtZXM7XG59XG5mdW5jdGlvbiBjcmVhdGVMb29wKHJvb3RzKSB7XG4gIGxldCBydW5uaW5nID0gZmFsc2U7XG4gIGxldCByZXBlYXQ7XG4gIGxldCBmcmFtZTtcbiAgbGV0IHN0YXRlO1xuICBmdW5jdGlvbiBsb29wKHRpbWVzdGFtcCkge1xuICAgIGZyYW1lID0gcmVxdWVzdEFuaW1hdGlvbkZyYW1lKGxvb3ApO1xuICAgIHJ1bm5pbmcgPSB0cnVlO1xuICAgIHJlcGVhdCA9IDA7XG5cbiAgICAvLyBSdW4gZWZmZWN0c1xuICAgIGZsdXNoR2xvYmFsRWZmZWN0cygnYmVmb3JlJywgdGltZXN0YW1wKTtcblxuICAgIC8vIFJlbmRlciBhbGwgcm9vdHNcbiAgICBmb3IgKGNvbnN0IHJvb3Qgb2Ygcm9vdHMudmFsdWVzKCkpIHtcbiAgICAgIHZhciBfc3RhdGUkZ2wkeHI7XG4gICAgICBzdGF0ZSA9IHJvb3Quc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICAgIC8vIElmIHRoZSBmcmFtZWxvb3AgaXMgaW52YWxpZGF0ZWQsIGRvIG5vdCBydW4gYW5vdGhlciBmcmFtZVxuICAgICAgaWYgKHN0YXRlLmludGVybmFsLmFjdGl2ZSAmJiAoc3RhdGUuZnJhbWVsb29wID09PSAnYWx3YXlzJyB8fCBzdGF0ZS5pbnRlcm5hbC5mcmFtZXMgPiAwKSAmJiAhKChfc3RhdGUkZ2wkeHIgPSBzdGF0ZS5nbC54cikgIT0gbnVsbCAmJiBfc3RhdGUkZ2wkeHIuaXNQcmVzZW50aW5nKSkge1xuICAgICAgICByZXBlYXQgKz0gcmVuZGVyJDEodGltZXN0YW1wLCBzdGF0ZSk7XG4gICAgICB9XG4gICAgfVxuXG4gICAgLy8gUnVuIGFmdGVyLWVmZmVjdHNcbiAgICBmbHVzaEdsb2JhbEVmZmVjdHMoJ2FmdGVyJywgdGltZXN0YW1wKTtcblxuICAgIC8vIFN0b3AgdGhlIGxvb3AgaWYgbm90aGluZyBpbnZhbGlkYXRlcyBpdFxuICAgIGlmIChyZXBlYXQgPT09IDApIHtcbiAgICAgIC8vIFRhaWwgY2FsbCBlZmZlY3RzLCB0aGV5IGFyZSBjYWxsZWQgd2hlbiByZW5kZXJpbmcgc3RvcHNcbiAgICAgIGZsdXNoR2xvYmFsRWZmZWN0cygndGFpbCcsIHRpbWVzdGFtcCk7XG5cbiAgICAgIC8vIEZsYWcgZW5kIG9mIG9wZXJhdGlvblxuICAgICAgcnVubmluZyA9IGZhbHNlO1xuICAgICAgcmV0dXJuIGNhbmNlbEFuaW1hdGlvbkZyYW1lKGZyYW1lKTtcbiAgICB9XG4gIH1cbiAgZnVuY3Rpb24gaW52YWxpZGF0ZShzdGF0ZSwgZnJhbWVzID0gMSkge1xuICAgIHZhciBfc3RhdGUkZ2wkeHIyO1xuICAgIGlmICghc3RhdGUpIHJldHVybiByb290cy5mb3JFYWNoKHJvb3QgPT4gaW52YWxpZGF0ZShyb290LnN0b3JlLmdldFN0YXRlKCkpLCBmcmFtZXMpO1xuICAgIGlmICgoX3N0YXRlJGdsJHhyMiA9IHN0YXRlLmdsLnhyKSAhPSBudWxsICYmIF9zdGF0ZSRnbCR4cjIuaXNQcmVzZW50aW5nIHx8ICFzdGF0ZS5pbnRlcm5hbC5hY3RpdmUgfHwgc3RhdGUuZnJhbWVsb29wID09PSAnbmV2ZXInKSByZXR1cm47XG4gICAgLy8gSW5jcmVhc2UgZnJhbWVzLCBkbyBub3QgZ28gaGlnaGVyIHRoYW4gNjBcbiAgICBzdGF0ZS5pbnRlcm5hbC5mcmFtZXMgPSBNYXRoLm1pbig2MCwgc3RhdGUuaW50ZXJuYWwuZnJhbWVzICsgZnJhbWVzKTtcbiAgICAvLyBJZiB0aGUgcmVuZGVyLWxvb3AgaXNuJ3QgYWN0aXZlLCBzdGFydCBpdFxuICAgIGlmICghcnVubmluZykge1xuICAgICAgcnVubmluZyA9IHRydWU7XG4gICAgICByZXF1ZXN0QW5pbWF0aW9uRnJhbWUobG9vcCk7XG4gICAgfVxuICB9XG4gIGZ1bmN0aW9uIGFkdmFuY2UodGltZXN0YW1wLCBydW5HbG9iYWxFZmZlY3RzID0gdHJ1ZSwgc3RhdGUsIGZyYW1lKSB7XG4gICAgaWYgKHJ1bkdsb2JhbEVmZmVjdHMpIGZsdXNoR2xvYmFsRWZmZWN0cygnYmVmb3JlJywgdGltZXN0YW1wKTtcbiAgICBpZiAoIXN0YXRlKSBmb3IgKGNvbnN0IHJvb3Qgb2Ygcm9vdHMudmFsdWVzKCkpIHJlbmRlciQxKHRpbWVzdGFtcCwgcm9vdC5zdG9yZS5nZXRTdGF0ZSgpKTtlbHNlIHJlbmRlciQxKHRpbWVzdGFtcCwgc3RhdGUsIGZyYW1lKTtcbiAgICBpZiAocnVuR2xvYmFsRWZmZWN0cykgZmx1c2hHbG9iYWxFZmZlY3RzKCdhZnRlcicsIHRpbWVzdGFtcCk7XG4gIH1cbiAgcmV0dXJuIHtcbiAgICBsb29wLFxuICAgIC8qKlxuICAgICAqIEludmFsaWRhdGVzIHRoZSB2aWV3LCByZXF1ZXN0aW5nIGEgZnJhbWUgdG8gYmUgcmVuZGVyZWQuIFdpbGwgZ2xvYmFsbHkgaW52YWxpZGF0ZSB1bmxlc3MgcGFzc2VkIGEgcm9vdCdzIHN0YXRlLlxuICAgICAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2FkZGl0aW9uYWwtZXhwb3J0cyNpbnZhbGlkYXRlXG4gICAgICovXG4gICAgaW52YWxpZGF0ZSxcbiAgICAvKipcbiAgICAgKiBBZHZhbmNlcyB0aGUgZnJhbWVsb29wIGFuZCBydW5zIHJlbmRlciBlZmZlY3RzLCB1c2VmdWwgZm9yIHdoZW4gbWFudWFsbHkgcmVuZGVyaW5nIHZpYSBgZnJhbWVsb29wPVwibmV2ZXJcImAuXG4gICAgICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvYWRkaXRpb25hbC1leHBvcnRzI2FkdmFuY2VcbiAgICAgKi9cbiAgICBhZHZhbmNlXG4gIH07XG59XG5cbi8qKlxuICogRXhwb3NlcyBhbiBvYmplY3QncyB7QGxpbmsgTG9jYWxTdGF0ZX0uXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9hZGRpdGlvbmFsLWV4cG9ydHMjdXNlSW5zdGFuY2VIYW5kbGVcbiAqXG4gKiAqKk5vdGUqKjogdGhpcyBpcyBhbiBlc2NhcGUgaGF0Y2ggdG8gcmVhY3QtaW50ZXJuYWwgZmllbGRzLiBFeHBlY3QgdGhpcyB0byBjaGFuZ2Ugc2lnbmlmaWNhbnRseSBiZXR3ZWVuIHZlcnNpb25zLlxuICovXG5mdW5jdGlvbiB1c2VJbnN0YW5jZUhhbmRsZShyZWYpIHtcbiAgY29uc3QgaW5zdGFuY2UgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QoKCkgPT4gdm9pZCAoaW5zdGFuY2UuY3VycmVudCA9IHJlZi5jdXJyZW50Ll9fcjNmKSwgW3JlZl0pO1xuICByZXR1cm4gaW5zdGFuY2U7XG59XG5mdW5jdGlvbiB1c2VTdG9yZSgpIHtcbiAgY29uc3Qgc3RvcmUgPSBSZWFjdC51c2VDb250ZXh0KGNvbnRleHQpO1xuICBpZiAoIXN0b3JlKSB0aHJvdyBuZXcgRXJyb3IoJ1IzRjogSG9va3MgY2FuIG9ubHkgYmUgdXNlZCB3aXRoaW4gdGhlIENhbnZhcyBjb21wb25lbnQhJyk7XG4gIHJldHVybiBzdG9yZTtcbn1cblxuLyoqXG4gKiBBY2Nlc3NlcyBSM0YncyBpbnRlcm5hbCBzdGF0ZSwgY29udGFpbmluZyByZW5kZXJlciwgY2FudmFzLCBzY2VuZSwgZXRjLlxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvaG9va3MjdXNldGhyZWVcbiAqL1xuZnVuY3Rpb24gdXNlVGhyZWUoc2VsZWN0b3IgPSBzdGF0ZSA9PiBzdGF0ZSwgZXF1YWxpdHlGbikge1xuICByZXR1cm4gdXNlU3RvcmUoKShzZWxlY3RvciwgZXF1YWxpdHlGbik7XG59XG5cbi8qKlxuICogRXhlY3V0ZXMgYSBjYWxsYmFjayBiZWZvcmUgcmVuZGVyIGluIGEgc2hhcmVkIGZyYW1lIGxvb3AuXG4gKiBDYW4gb3JkZXIgZWZmZWN0cyB3aXRoIHJlbmRlciBwcmlvcml0eSBvciBtYW51YWxseSByZW5kZXIgd2l0aCBhIHBvc2l0aXZlIHByaW9yaXR5LlxuICogQHNlZSBodHRwczovL2RvY3MucG1uZC5ycy9yZWFjdC10aHJlZS1maWJlci9hcGkvaG9va3MjdXNlZnJhbWVcbiAqL1xuZnVuY3Rpb24gdXNlRnJhbWUoY2FsbGJhY2ssIHJlbmRlclByaW9yaXR5ID0gMCkge1xuICBjb25zdCBzdG9yZSA9IHVzZVN0b3JlKCk7XG4gIGNvbnN0IHN1YnNjcmliZSA9IHN0b3JlLmdldFN0YXRlKCkuaW50ZXJuYWwuc3Vic2NyaWJlO1xuICAvLyBNZW1vaXplIHJlZlxuICBjb25zdCByZWYgPSB1c2VNdXRhYmxlQ2FsbGJhY2soY2FsbGJhY2spO1xuICAvLyBTdWJzY3JpYmUgb24gbW91bnQsIHVuc3Vic2NyaWJlIG9uIHVubW91bnRcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiBzdWJzY3JpYmUocmVmLCByZW5kZXJQcmlvcml0eSwgc3RvcmUpLCBbcmVuZGVyUHJpb3JpdHksIHN1YnNjcmliZSwgc3RvcmVdKTtcbiAgcmV0dXJuIG51bGw7XG59XG5cbi8qKlxuICogUmV0dXJucyBhIG5vZGUgZ3JhcGggb2YgYW4gb2JqZWN0IHdpdGggbmFtZWQgbm9kZXMgJiBtYXRlcmlhbHMuXG4gKiBAc2VlIGh0dHBzOi8vZG9jcy5wbW5kLnJzL3JlYWN0LXRocmVlLWZpYmVyL2FwaS9ob29rcyN1c2VncmFwaFxuICovXG5mdW5jdGlvbiB1c2VHcmFwaChvYmplY3QpIHtcbiAgcmV0dXJuIFJlYWN0LnVzZU1lbW8oKCkgPT4gYnVpbGRHcmFwaChvYmplY3QpLCBbb2JqZWN0XSk7XG59XG5mdW5jdGlvbiBsb2FkaW5nRm4oZXh0ZW5zaW9ucywgb25Qcm9ncmVzcykge1xuICByZXR1cm4gZnVuY3Rpb24gKFByb3RvLCAuLi5pbnB1dCkge1xuICAgIC8vIENvbnN0cnVjdCBuZXcgbG9hZGVyIGFuZCBydW4gZXh0ZW5zaW9uc1xuICAgIGNvbnN0IGxvYWRlciA9IG5ldyBQcm90bygpO1xuICAgIGlmIChleHRlbnNpb25zKSBleHRlbnNpb25zKGxvYWRlcik7XG4gICAgLy8gR28gdGhyb3VnaCB0aGUgdXJscyBhbmQgbG9hZCB0aGVtXG4gICAgcmV0dXJuIFByb21pc2UuYWxsKGlucHV0Lm1hcChpbnB1dCA9PiBuZXcgUHJvbWlzZSgocmVzLCByZWplY3QpID0+IGxvYWRlci5sb2FkKGlucHV0LCBkYXRhID0+IHtcbiAgICAgIGlmIChkYXRhLnNjZW5lKSBPYmplY3QuYXNzaWduKGRhdGEsIGJ1aWxkR3JhcGgoZGF0YS5zY2VuZSkpO1xuICAgICAgcmVzKGRhdGEpO1xuICAgIH0sIG9uUHJvZ3Jlc3MsIGVycm9yID0+IHJlamVjdChuZXcgRXJyb3IoYENvdWxkIG5vdCBsb2FkICR7aW5wdXR9OiAke2Vycm9yLm1lc3NhZ2V9YCkpKSkpKTtcbiAgfTtcbn1cblxuLyoqXG4gKiBTeW5jaHJvbm91c2x5IGxvYWRzIGFuZCBjYWNoZXMgYXNzZXRzIHdpdGggYSB0aHJlZSBsb2FkZXIuXG4gKlxuICogTm90ZTogdGhpcyBob29rJ3MgY2FsbGVyIG11c3QgYmUgd3JhcHBlZCB3aXRoIGBSZWFjdC5TdXNwZW5zZWBcbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2hvb2tzI3VzZWxvYWRlclxuICovXG5mdW5jdGlvbiB1c2VMb2FkZXIoUHJvdG8sIGlucHV0LCBleHRlbnNpb25zLCBvblByb2dyZXNzKSB7XG4gIC8vIFVzZSBzdXNwZW5zZSB0byBsb2FkIGFzeW5jIGFzc2V0c1xuICBjb25zdCBrZXlzID0gQXJyYXkuaXNBcnJheShpbnB1dCkgPyBpbnB1dCA6IFtpbnB1dF07XG4gIGNvbnN0IHJlc3VsdHMgPSBzdXNwZW5kKGxvYWRpbmdGbihleHRlbnNpb25zLCBvblByb2dyZXNzKSwgW1Byb3RvLCAuLi5rZXlzXSwge1xuICAgIGVxdWFsOiBpcy5lcXVcbiAgfSk7XG4gIC8vIFJldHVybiB0aGUgb2JqZWN0L3NcbiAgcmV0dXJuIEFycmF5LmlzQXJyYXkoaW5wdXQpID8gcmVzdWx0cyA6IHJlc3VsdHNbMF07XG59XG5cbi8qKlxuICogUHJlbG9hZHMgYW4gYXNzZXQgaW50byBjYWNoZSBhcyBhIHNpZGUtZWZmZWN0LlxuICovXG51c2VMb2FkZXIucHJlbG9hZCA9IGZ1bmN0aW9uIChQcm90bywgaW5wdXQsIGV4dGVuc2lvbnMpIHtcbiAgY29uc3Qga2V5cyA9IEFycmF5LmlzQXJyYXkoaW5wdXQpID8gaW5wdXQgOiBbaW5wdXRdO1xuICByZXR1cm4gcHJlbG9hZChsb2FkaW5nRm4oZXh0ZW5zaW9ucyksIFtQcm90bywgLi4ua2V5c10pO1xufTtcblxuLyoqXG4gKiBSZW1vdmVzIGEgbG9hZGVkIGFzc2V0IGZyb20gY2FjaGUuXG4gKi9cbnVzZUxvYWRlci5jbGVhciA9IGZ1bmN0aW9uIChQcm90bywgaW5wdXQpIHtcbiAgY29uc3Qga2V5cyA9IEFycmF5LmlzQXJyYXkoaW5wdXQpID8gaW5wdXQgOiBbaW5wdXRdO1xuICByZXR1cm4gY2xlYXIoW1Byb3RvLCAuLi5rZXlzXSk7XG59O1xuXG5jb25zdCByb290cyA9IG5ldyBNYXAoKTtcbmNvbnN0IHtcbiAgaW52YWxpZGF0ZSxcbiAgYWR2YW5jZVxufSA9IGNyZWF0ZUxvb3Aocm9vdHMpO1xuY29uc3Qge1xuICByZWNvbmNpbGVyLFxuICBhcHBseVByb3BzXG59ID0gY3JlYXRlUmVuZGVyZXIocm9vdHMsIGdldEV2ZW50UHJpb3JpdHkpO1xuY29uc3Qgc2hhbGxvd0xvb3NlID0ge1xuICBvYmplY3RzOiAnc2hhbGxvdycsXG4gIHN0cmljdDogZmFsc2Vcbn07XG5jb25zdCBjcmVhdGVSZW5kZXJlckluc3RhbmNlID0gKGdsLCBjYW52YXMpID0+IHtcbiAgY29uc3QgY3VzdG9tUmVuZGVyZXIgPSB0eXBlb2YgZ2wgPT09ICdmdW5jdGlvbicgPyBnbChjYW52YXMpIDogZ2w7XG4gIGlmIChpc1JlbmRlcmVyKGN1c3RvbVJlbmRlcmVyKSkgcmV0dXJuIGN1c3RvbVJlbmRlcmVyO2Vsc2UgcmV0dXJuIG5ldyBUSFJFRS5XZWJHTFJlbmRlcmVyKHtcbiAgICBwb3dlclByZWZlcmVuY2U6ICdoaWdoLXBlcmZvcm1hbmNlJyxcbiAgICBjYW52YXM6IGNhbnZhcyxcbiAgICBhbnRpYWxpYXM6IHRydWUsXG4gICAgYWxwaGE6IHRydWUsXG4gICAgLi4uZ2xcbiAgfSk7XG59O1xuZnVuY3Rpb24gY29tcHV0ZUluaXRpYWxTaXplKGNhbnZhcywgZGVmYXVsdFNpemUpIHtcbiAgaWYgKGRlZmF1bHRTaXplKSByZXR1cm4gZGVmYXVsdFNpemU7XG4gIGlmICh0eXBlb2YgSFRNTENhbnZhc0VsZW1lbnQgIT09ICd1bmRlZmluZWQnICYmIGNhbnZhcyBpbnN0YW5jZW9mIEhUTUxDYW52YXNFbGVtZW50ICYmIGNhbnZhcy5wYXJlbnRFbGVtZW50KSB7XG4gICAgY29uc3Qge1xuICAgICAgd2lkdGgsXG4gICAgICBoZWlnaHQsXG4gICAgICB0b3AsXG4gICAgICBsZWZ0XG4gICAgfSA9IGNhbnZhcy5wYXJlbnRFbGVtZW50LmdldEJvdW5kaW5nQ2xpZW50UmVjdCgpO1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aCxcbiAgICAgIGhlaWdodCxcbiAgICAgIHRvcCxcbiAgICAgIGxlZnRcbiAgICB9O1xuICB9IGVsc2UgaWYgKHR5cGVvZiBPZmZzY3JlZW5DYW52YXMgIT09ICd1bmRlZmluZWQnICYmIGNhbnZhcyBpbnN0YW5jZW9mIE9mZnNjcmVlbkNhbnZhcykge1xuICAgIHJldHVybiB7XG4gICAgICB3aWR0aDogY2FudmFzLndpZHRoLFxuICAgICAgaGVpZ2h0OiBjYW52YXMuaGVpZ2h0LFxuICAgICAgdG9wOiAwLFxuICAgICAgbGVmdDogMFxuICAgIH07XG4gIH1cbiAgcmV0dXJuIHtcbiAgICB3aWR0aDogMCxcbiAgICBoZWlnaHQ6IDAsXG4gICAgdG9wOiAwLFxuICAgIGxlZnQ6IDBcbiAgfTtcbn1cbmZ1bmN0aW9uIGNyZWF0ZVJvb3QoY2FudmFzKSB7XG4gIC8vIENoZWNrIGFnYWluc3QgbWlzdGFrZW4gdXNlIG9mIGNyZWF0ZVJvb3RcbiAgY29uc3QgcHJldlJvb3QgPSByb290cy5nZXQoY2FudmFzKTtcbiAgY29uc3QgcHJldkZpYmVyID0gcHJldlJvb3QgPT0gbnVsbCA/IHZvaWQgMCA6IHByZXZSb290LmZpYmVyO1xuICBjb25zdCBwcmV2U3RvcmUgPSBwcmV2Um9vdCA9PSBudWxsID8gdm9pZCAwIDogcHJldlJvb3Quc3RvcmU7XG4gIGlmIChwcmV2Um9vdCkgY29uc29sZS53YXJuKCdSM0YuY3JlYXRlUm9vdCBzaG91bGQgb25seSBiZSBjYWxsZWQgb25jZSEnKTtcblxuICAvLyBSZXBvcnQgd2hlbiBhbiBlcnJvciB3YXMgZGV0ZWN0ZWQgaW4gYSBwcmV2aW91cyByZW5kZXJcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9wdWxsLzIyNjFcbiAgY29uc3QgbG9nUmVjb3ZlcmFibGVFcnJvciA9IHR5cGVvZiByZXBvcnRFcnJvciA9PT0gJ2Z1bmN0aW9uJyA/XG4gIC8vIEluIG1vZGVybiBicm93c2VycywgcmVwb3J0RXJyb3Igd2lsbCBkaXNwYXRjaCBhbiBlcnJvciBldmVudCxcbiAgLy8gZW11bGF0aW5nIGFuIHVuY2F1Z2h0IEphdmFTY3JpcHQgZXJyb3IuXG4gIHJlcG9ydEVycm9yIDpcbiAgLy8gSW4gb2xkZXIgYnJvd3NlcnMgYW5kIHRlc3QgZW52aXJvbm1lbnRzLCBmYWxsYmFjayB0byBjb25zb2xlLmVycm9yLlxuICBjb25zb2xlLmVycm9yO1xuXG4gIC8vIENyZWF0ZSBzdG9yZVxuICBjb25zdCBzdG9yZSA9IHByZXZTdG9yZSB8fCBjcmVhdGVTdG9yZShpbnZhbGlkYXRlLCBhZHZhbmNlKTtcbiAgLy8gQ3JlYXRlIHJlbmRlcmVyXG4gIGNvbnN0IGZpYmVyID0gcHJldkZpYmVyIHx8IHJlY29uY2lsZXIuY3JlYXRlQ29udGFpbmVyKHN0b3JlLCBDb25jdXJyZW50Um9vdCwgbnVsbCwgZmFsc2UsIG51bGwsICcnLCBsb2dSZWNvdmVyYWJsZUVycm9yLCBudWxsKTtcbiAgLy8gTWFwIGl0XG4gIGlmICghcHJldlJvb3QpIHJvb3RzLnNldChjYW52YXMsIHtcbiAgICBmaWJlcixcbiAgICBzdG9yZVxuICB9KTtcblxuICAvLyBMb2NhbHNcbiAgbGV0IG9uQ3JlYXRlZDtcbiAgbGV0IGNvbmZpZ3VyZWQgPSBmYWxzZTtcbiAgbGV0IGxhc3RDYW1lcmE7XG4gIHJldHVybiB7XG4gICAgY29uZmlndXJlKHByb3BzID0ge30pIHtcbiAgICAgIGxldCB7XG4gICAgICAgIGdsOiBnbENvbmZpZyxcbiAgICAgICAgc2l6ZTogcHJvcHNTaXplLFxuICAgICAgICBzY2VuZTogc2NlbmVPcHRpb25zLFxuICAgICAgICBldmVudHMsXG4gICAgICAgIG9uQ3JlYXRlZDogb25DcmVhdGVkQ2FsbGJhY2ssXG4gICAgICAgIHNoYWRvd3MgPSBmYWxzZSxcbiAgICAgICAgbGluZWFyID0gZmFsc2UsXG4gICAgICAgIGZsYXQgPSBmYWxzZSxcbiAgICAgICAgbGVnYWN5ID0gZmFsc2UsXG4gICAgICAgIG9ydGhvZ3JhcGhpYyA9IGZhbHNlLFxuICAgICAgICBmcmFtZWxvb3AgPSAnYWx3YXlzJyxcbiAgICAgICAgZHByID0gWzEsIDJdLFxuICAgICAgICBwZXJmb3JtYW5jZSxcbiAgICAgICAgcmF5Y2FzdGVyOiByYXljYXN0T3B0aW9ucyxcbiAgICAgICAgY2FtZXJhOiBjYW1lcmFPcHRpb25zLFxuICAgICAgICBvblBvaW50ZXJNaXNzZWRcbiAgICAgIH0gPSBwcm9wcztcbiAgICAgIGxldCBzdGF0ZSA9IHN0b3JlLmdldFN0YXRlKCk7XG5cbiAgICAgIC8vIFNldCB1cCByZW5kZXJlciAob25lIHRpbWUgb25seSEpXG4gICAgICBsZXQgZ2wgPSBzdGF0ZS5nbDtcbiAgICAgIGlmICghc3RhdGUuZ2wpIHN0YXRlLnNldCh7XG4gICAgICAgIGdsOiBnbCA9IGNyZWF0ZVJlbmRlcmVySW5zdGFuY2UoZ2xDb25maWcsIGNhbnZhcylcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTZXQgdXAgcmF5Y2FzdGVyIChvbmUgdGltZSBvbmx5ISlcbiAgICAgIGxldCByYXljYXN0ZXIgPSBzdGF0ZS5yYXljYXN0ZXI7XG4gICAgICBpZiAoIXJheWNhc3Rlcikgc3RhdGUuc2V0KHtcbiAgICAgICAgcmF5Y2FzdGVyOiByYXljYXN0ZXIgPSBuZXcgVEhSRUUuUmF5Y2FzdGVyKClcbiAgICAgIH0pO1xuXG4gICAgICAvLyBTZXQgcmF5Y2FzdGVyIG9wdGlvbnNcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgcGFyYW1zLFxuICAgICAgICAuLi5vcHRpb25zXG4gICAgICB9ID0gcmF5Y2FzdE9wdGlvbnMgfHwge307XG4gICAgICBpZiAoIWlzLmVxdShvcHRpb25zLCByYXljYXN0ZXIsIHNoYWxsb3dMb29zZSkpIGFwcGx5UHJvcHMocmF5Y2FzdGVyLCB7XG4gICAgICAgIC4uLm9wdGlvbnNcbiAgICAgIH0pO1xuICAgICAgaWYgKCFpcy5lcXUocGFyYW1zLCByYXljYXN0ZXIucGFyYW1zLCBzaGFsbG93TG9vc2UpKSBhcHBseVByb3BzKHJheWNhc3Rlciwge1xuICAgICAgICBwYXJhbXM6IHtcbiAgICAgICAgICAuLi5yYXljYXN0ZXIucGFyYW1zLFxuICAgICAgICAgIC4uLnBhcmFtc1xuICAgICAgICB9XG4gICAgICB9KTtcblxuICAgICAgLy8gQ3JlYXRlIGRlZmF1bHQgY2FtZXJhLCBkb24ndCBvdmVyd3JpdGUgYW55IHVzZXItc2V0IHN0YXRlXG4gICAgICBpZiAoIXN0YXRlLmNhbWVyYSB8fCBzdGF0ZS5jYW1lcmEgPT09IGxhc3RDYW1lcmEgJiYgIWlzLmVxdShsYXN0Q2FtZXJhLCBjYW1lcmFPcHRpb25zLCBzaGFsbG93TG9vc2UpKSB7XG4gICAgICAgIGxhc3RDYW1lcmEgPSBjYW1lcmFPcHRpb25zO1xuICAgICAgICBjb25zdCBpc0NhbWVyYSA9IGNhbWVyYU9wdGlvbnMgaW5zdGFuY2VvZiBUSFJFRS5DYW1lcmE7XG4gICAgICAgIGNvbnN0IGNhbWVyYSA9IGlzQ2FtZXJhID8gY2FtZXJhT3B0aW9ucyA6IG9ydGhvZ3JhcGhpYyA/IG5ldyBUSFJFRS5PcnRob2dyYXBoaWNDYW1lcmEoMCwgMCwgMCwgMCwgMC4xLCAxMDAwKSA6IG5ldyBUSFJFRS5QZXJzcGVjdGl2ZUNhbWVyYSg3NSwgMCwgMC4xLCAxMDAwKTtcbiAgICAgICAgaWYgKCFpc0NhbWVyYSkge1xuICAgICAgICAgIGNhbWVyYS5wb3NpdGlvbi56ID0gNTtcbiAgICAgICAgICBpZiAoY2FtZXJhT3B0aW9ucykgYXBwbHlQcm9wcyhjYW1lcmEsIGNhbWVyYU9wdGlvbnMpO1xuICAgICAgICAgIC8vIEFsd2F5cyBsb29rIGF0IGNlbnRlciBieSBkZWZhdWx0XG4gICAgICAgICAgaWYgKCFzdGF0ZS5jYW1lcmEgJiYgIShjYW1lcmFPcHRpb25zICE9IG51bGwgJiYgY2FtZXJhT3B0aW9ucy5yb3RhdGlvbikpIGNhbWVyYS5sb29rQXQoMCwgMCwgMCk7XG4gICAgICAgIH1cbiAgICAgICAgc3RhdGUuc2V0KHtcbiAgICAgICAgICBjYW1lcmFcbiAgICAgICAgfSk7XG4gICAgICB9XG5cbiAgICAgIC8vIFNldCB1cCBzY2VuZSAob25lIHRpbWUgb25seSEpXG4gICAgICBpZiAoIXN0YXRlLnNjZW5lKSB7XG4gICAgICAgIGxldCBzY2VuZTtcbiAgICAgICAgaWYgKHNjZW5lT3B0aW9ucyBpbnN0YW5jZW9mIFRIUkVFLlNjZW5lKSB7XG4gICAgICAgICAgc2NlbmUgPSBzY2VuZU9wdGlvbnM7XG4gICAgICAgIH0gZWxzZSB7XG4gICAgICAgICAgc2NlbmUgPSBuZXcgVEhSRUUuU2NlbmUoKTtcbiAgICAgICAgICBpZiAoc2NlbmVPcHRpb25zKSBhcHBseVByb3BzKHNjZW5lLCBzY2VuZU9wdGlvbnMpO1xuICAgICAgICB9XG4gICAgICAgIHN0YXRlLnNldCh7XG4gICAgICAgICAgc2NlbmU6IHByZXBhcmUoc2NlbmUpXG4gICAgICAgIH0pO1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgdXAgWFIgKG9uZSB0aW1lIG9ubHkhKVxuICAgICAgaWYgKCFzdGF0ZS54cikge1xuICAgICAgICB2YXIgX2dsJHhyO1xuICAgICAgICAvLyBIYW5kbGUgZnJhbWUgYmVoYXZpb3IgaW4gV2ViWFJcbiAgICAgICAgY29uc3QgaGFuZGxlWFJGcmFtZSA9ICh0aW1lc3RhbXAsIGZyYW1lKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgIGlmIChzdGF0ZS5mcmFtZWxvb3AgPT09ICduZXZlcicpIHJldHVybjtcbiAgICAgICAgICBhZHZhbmNlKHRpbWVzdGFtcCwgdHJ1ZSwgc3RhdGUsIGZyYW1lKTtcbiAgICAgICAgfTtcblxuICAgICAgICAvLyBUb2dnbGUgcmVuZGVyIHN3aXRjaGluZyBvbiBzZXNzaW9uXG4gICAgICAgIGNvbnN0IGhhbmRsZVNlc3Npb25DaGFuZ2UgPSAoKSA9PiB7XG4gICAgICAgICAgY29uc3Qgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgICAgIHN0YXRlLmdsLnhyLmVuYWJsZWQgPSBzdGF0ZS5nbC54ci5pc1ByZXNlbnRpbmc7XG4gICAgICAgICAgc3RhdGUuZ2wueHIuc2V0QW5pbWF0aW9uTG9vcChzdGF0ZS5nbC54ci5pc1ByZXNlbnRpbmcgPyBoYW5kbGVYUkZyYW1lIDogbnVsbCk7XG4gICAgICAgICAgaWYgKCFzdGF0ZS5nbC54ci5pc1ByZXNlbnRpbmcpIGludmFsaWRhdGUoc3RhdGUpO1xuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFdlYlhSIHNlc3Npb24gbWFuYWdlclxuICAgICAgICBjb25zdCB4ciA9IHtcbiAgICAgICAgICBjb25uZWN0KCkge1xuICAgICAgICAgICAgY29uc3QgZ2wgPSBzdG9yZS5nZXRTdGF0ZSgpLmdsO1xuICAgICAgICAgICAgZ2wueHIuYWRkRXZlbnRMaXN0ZW5lcignc2Vzc2lvbnN0YXJ0JywgaGFuZGxlU2Vzc2lvbkNoYW5nZSk7XG4gICAgICAgICAgICBnbC54ci5hZGRFdmVudExpc3RlbmVyKCdzZXNzaW9uZW5kJywgaGFuZGxlU2Vzc2lvbkNoYW5nZSk7XG4gICAgICAgICAgfSxcbiAgICAgICAgICBkaXNjb25uZWN0KCkge1xuICAgICAgICAgICAgY29uc3QgZ2wgPSBzdG9yZS5nZXRTdGF0ZSgpLmdsO1xuICAgICAgICAgICAgZ2wueHIucmVtb3ZlRXZlbnRMaXN0ZW5lcignc2Vzc2lvbnN0YXJ0JywgaGFuZGxlU2Vzc2lvbkNoYW5nZSk7XG4gICAgICAgICAgICBnbC54ci5yZW1vdmVFdmVudExpc3RlbmVyKCdzZXNzaW9uZW5kJywgaGFuZGxlU2Vzc2lvbkNoYW5nZSk7XG4gICAgICAgICAgfVxuICAgICAgICB9O1xuXG4gICAgICAgIC8vIFN1YnNjcmliZSB0byBXZWJYUiBzZXNzaW9uIGV2ZW50c1xuICAgICAgICBpZiAodHlwZW9mICgoX2dsJHhyID0gZ2wueHIpID09IG51bGwgPyB2b2lkIDAgOiBfZ2wkeHIuYWRkRXZlbnRMaXN0ZW5lcikgPT09ICdmdW5jdGlvbicpIHhyLmNvbm5lY3QoKTtcbiAgICAgICAgc3RhdGUuc2V0KHtcbiAgICAgICAgICB4clxuICAgICAgICB9KTtcbiAgICAgIH1cblxuICAgICAgLy8gU2V0IHNoYWRvd21hcFxuICAgICAgaWYgKGdsLnNoYWRvd01hcCkge1xuICAgICAgICBjb25zdCBvbGRFbmFibGVkID0gZ2wuc2hhZG93TWFwLmVuYWJsZWQ7XG4gICAgICAgIGNvbnN0IG9sZFR5cGUgPSBnbC5zaGFkb3dNYXAudHlwZTtcbiAgICAgICAgZ2wuc2hhZG93TWFwLmVuYWJsZWQgPSAhIXNoYWRvd3M7XG4gICAgICAgIGlmIChpcy5ib28oc2hhZG93cykpIHtcbiAgICAgICAgICBnbC5zaGFkb3dNYXAudHlwZSA9IFRIUkVFLlBDRlNvZnRTaGFkb3dNYXA7XG4gICAgICAgIH0gZWxzZSBpZiAoaXMuc3RyKHNoYWRvd3MpKSB7XG4gICAgICAgICAgdmFyIF90eXBlcyRzaGFkb3dzO1xuICAgICAgICAgIGNvbnN0IHR5cGVzID0ge1xuICAgICAgICAgICAgYmFzaWM6IFRIUkVFLkJhc2ljU2hhZG93TWFwLFxuICAgICAgICAgICAgcGVyY2VudGFnZTogVEhSRUUuUENGU2hhZG93TWFwLFxuICAgICAgICAgICAgc29mdDogVEhSRUUuUENGU29mdFNoYWRvd01hcCxcbiAgICAgICAgICAgIHZhcmlhbmNlOiBUSFJFRS5WU01TaGFkb3dNYXBcbiAgICAgICAgICB9O1xuICAgICAgICAgIGdsLnNoYWRvd01hcC50eXBlID0gKF90eXBlcyRzaGFkb3dzID0gdHlwZXNbc2hhZG93c10pICE9IG51bGwgPyBfdHlwZXMkc2hhZG93cyA6IFRIUkVFLlBDRlNvZnRTaGFkb3dNYXA7XG4gICAgICAgIH0gZWxzZSBpZiAoaXMub2JqKHNoYWRvd3MpKSB7XG4gICAgICAgICAgT2JqZWN0LmFzc2lnbihnbC5zaGFkb3dNYXAsIHNoYWRvd3MpO1xuICAgICAgICB9XG4gICAgICAgIGlmIChvbGRFbmFibGVkICE9PSBnbC5zaGFkb3dNYXAuZW5hYmxlZCB8fCBvbGRUeXBlICE9PSBnbC5zaGFkb3dNYXAudHlwZSkgZ2wuc2hhZG93TWFwLm5lZWRzVXBkYXRlID0gdHJ1ZTtcbiAgICAgIH1cblxuICAgICAgLy8gU2FmZWx5IHNldCBjb2xvciBtYW5hZ2VtZW50IGlmIGF2YWlsYWJsZS5cbiAgICAgIC8vIEF2b2lkIGFjY2Vzc2luZyBUSFJFRS5Db2xvck1hbmFnZW1lbnQgdG8gcGxheSBuaWNlIHdpdGggb2xkZXIgdmVyc2lvbnNcbiAgICAgIGNvbnN0IENvbG9yTWFuYWdlbWVudCA9IGdldENvbG9yTWFuYWdlbWVudCgpO1xuICAgICAgaWYgKENvbG9yTWFuYWdlbWVudCkge1xuICAgICAgICBpZiAoJ2VuYWJsZWQnIGluIENvbG9yTWFuYWdlbWVudCkgQ29sb3JNYW5hZ2VtZW50LmVuYWJsZWQgPSAhbGVnYWN5O2Vsc2UgaWYgKCdsZWdhY3lNb2RlJyBpbiBDb2xvck1hbmFnZW1lbnQpIENvbG9yTWFuYWdlbWVudC5sZWdhY3lNb2RlID0gbGVnYWN5O1xuICAgICAgfVxuXG4gICAgICAvLyBTZXQgY29sb3Igc3BhY2UgYW5kIHRvbmVtYXBwaW5nIHByZWZlcmVuY2VzXG4gICAgICBjb25zdCBMaW5lYXJFbmNvZGluZyA9IDMwMDA7XG4gICAgICBjb25zdCBzUkdCRW5jb2RpbmcgPSAzMDAxO1xuICAgICAgYXBwbHlQcm9wcyhnbCwge1xuICAgICAgICBvdXRwdXRFbmNvZGluZzogbGluZWFyID8gTGluZWFyRW5jb2RpbmcgOiBzUkdCRW5jb2RpbmcsXG4gICAgICAgIHRvbmVNYXBwaW5nOiBmbGF0ID8gVEhSRUUuTm9Ub25lTWFwcGluZyA6IFRIUkVFLkFDRVNGaWxtaWNUb25lTWFwcGluZ1xuICAgICAgfSk7XG5cbiAgICAgIC8vIFVwZGF0ZSBjb2xvciBtYW5hZ2VtZW50IHN0YXRlXG4gICAgICBpZiAoc3RhdGUubGVnYWN5ICE9PSBsZWdhY3kpIHN0YXRlLnNldCgoKSA9PiAoe1xuICAgICAgICBsZWdhY3lcbiAgICAgIH0pKTtcbiAgICAgIGlmIChzdGF0ZS5saW5lYXIgIT09IGxpbmVhcikgc3RhdGUuc2V0KCgpID0+ICh7XG4gICAgICAgIGxpbmVhclxuICAgICAgfSkpO1xuICAgICAgaWYgKHN0YXRlLmZsYXQgIT09IGZsYXQpIHN0YXRlLnNldCgoKSA9PiAoe1xuICAgICAgICBmbGF0XG4gICAgICB9KSk7XG5cbiAgICAgIC8vIFNldCBnbCBwcm9wc1xuICAgICAgaWYgKGdsQ29uZmlnICYmICFpcy5mdW4oZ2xDb25maWcpICYmICFpc1JlbmRlcmVyKGdsQ29uZmlnKSAmJiAhaXMuZXF1KGdsQ29uZmlnLCBnbCwgc2hhbGxvd0xvb3NlKSkgYXBwbHlQcm9wcyhnbCwgZ2xDb25maWcpO1xuICAgICAgLy8gU3RvcmUgZXZlbnRzIGludGVybmFsbHlcbiAgICAgIGlmIChldmVudHMgJiYgIXN0YXRlLmV2ZW50cy5oYW5kbGVycykgc3RhdGUuc2V0KHtcbiAgICAgICAgZXZlbnRzOiBldmVudHMoc3RvcmUpXG4gICAgICB9KTtcbiAgICAgIC8vIENoZWNrIHNpemUsIGFsbG93IGl0IHRvIHRha2Ugb24gY29udGFpbmVyIGJvdW5kcyBpbml0aWFsbHlcbiAgICAgIGNvbnN0IHNpemUgPSBjb21wdXRlSW5pdGlhbFNpemUoY2FudmFzLCBwcm9wc1NpemUpO1xuICAgICAgaWYgKCFpcy5lcXUoc2l6ZSwgc3RhdGUuc2l6ZSwgc2hhbGxvd0xvb3NlKSkge1xuICAgICAgICBzdGF0ZS5zZXRTaXplKHNpemUud2lkdGgsIHNpemUuaGVpZ2h0LCBzaXplLnVwZGF0ZVN0eWxlLCBzaXplLnRvcCwgc2l6ZS5sZWZ0KTtcbiAgICAgIH1cbiAgICAgIC8vIENoZWNrIHBpeGVscmF0aW9cbiAgICAgIGlmIChkcHIgJiYgc3RhdGUudmlld3BvcnQuZHByICE9PSBjYWxjdWxhdGVEcHIoZHByKSkgc3RhdGUuc2V0RHByKGRwcik7XG4gICAgICAvLyBDaGVjayBmcmFtZWxvb3BcbiAgICAgIGlmIChzdGF0ZS5mcmFtZWxvb3AgIT09IGZyYW1lbG9vcCkgc3RhdGUuc2V0RnJhbWVsb29wKGZyYW1lbG9vcCk7XG4gICAgICAvLyBDaGVjayBwb2ludGVyIG1pc3NlZFxuICAgICAgaWYgKCFzdGF0ZS5vblBvaW50ZXJNaXNzZWQpIHN0YXRlLnNldCh7XG4gICAgICAgIG9uUG9pbnRlck1pc3NlZFxuICAgICAgfSk7XG4gICAgICAvLyBDaGVjayBwZXJmb3JtYW5jZVxuICAgICAgaWYgKHBlcmZvcm1hbmNlICYmICFpcy5lcXUocGVyZm9ybWFuY2UsIHN0YXRlLnBlcmZvcm1hbmNlLCBzaGFsbG93TG9vc2UpKSBzdGF0ZS5zZXQoc3RhdGUgPT4gKHtcbiAgICAgICAgcGVyZm9ybWFuY2U6IHtcbiAgICAgICAgICAuLi5zdGF0ZS5wZXJmb3JtYW5jZSxcbiAgICAgICAgICAuLi5wZXJmb3JtYW5jZVxuICAgICAgICB9XG4gICAgICB9KSk7XG5cbiAgICAgIC8vIFNldCBsb2NhbHNcbiAgICAgIG9uQ3JlYXRlZCA9IG9uQ3JlYXRlZENhbGxiYWNrO1xuICAgICAgY29uZmlndXJlZCA9IHRydWU7XG4gICAgICByZXR1cm4gdGhpcztcbiAgICB9LFxuICAgIHJlbmRlcihjaGlsZHJlbikge1xuICAgICAgLy8gVGhlIHJvb3QgaGFzIHRvIGJlIGNvbmZpZ3VyZWQgYmVmb3JlIGl0IGNhbiBiZSByZW5kZXJlZFxuICAgICAgaWYgKCFjb25maWd1cmVkKSB0aGlzLmNvbmZpZ3VyZSgpO1xuICAgICAgcmVjb25jaWxlci51cGRhdGVDb250YWluZXIoIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFByb3ZpZGVyLCB7XG4gICAgICAgIHN0b3JlOiBzdG9yZSxcbiAgICAgICAgY2hpbGRyZW46IGNoaWxkcmVuLFxuICAgICAgICBvbkNyZWF0ZWQ6IG9uQ3JlYXRlZCxcbiAgICAgICAgcm9vdEVsZW1lbnQ6IGNhbnZhc1xuICAgICAgfSksIGZpYmVyLCBudWxsLCAoKSA9PiB1bmRlZmluZWQpO1xuICAgICAgcmV0dXJuIHN0b3JlO1xuICAgIH0sXG4gICAgdW5tb3VudCgpIHtcbiAgICAgIHVubW91bnRDb21wb25lbnRBdE5vZGUoY2FudmFzKTtcbiAgICB9XG4gIH07XG59XG5mdW5jdGlvbiByZW5kZXIoY2hpbGRyZW4sIGNhbnZhcywgY29uZmlnKSB7XG4gIGNvbnNvbGUud2FybignUjNGLnJlbmRlciBpcyBubyBsb25nZXIgc3VwcG9ydGVkIGluIFJlYWN0IDE4LiBVc2UgY3JlYXRlUm9vdCBpbnN0ZWFkIScpO1xuICBjb25zdCByb290ID0gY3JlYXRlUm9vdChjYW52YXMpO1xuICByb290LmNvbmZpZ3VyZShjb25maWcpO1xuICByZXR1cm4gcm9vdC5yZW5kZXIoY2hpbGRyZW4pO1xufVxuZnVuY3Rpb24gUHJvdmlkZXIoe1xuICBzdG9yZSxcbiAgY2hpbGRyZW4sXG4gIG9uQ3JlYXRlZCxcbiAgcm9vdEVsZW1lbnRcbn0pIHtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3Qgc3RhdGUgPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgIC8vIEZsYWcgdGhlIGNhbnZhcyBhY3RpdmUsIHJlbmRlcmluZyB3aWxsIG5vdyBiZWdpblxuICAgIHN0YXRlLnNldChzdGF0ZSA9PiAoe1xuICAgICAgaW50ZXJuYWw6IHtcbiAgICAgICAgLi4uc3RhdGUuaW50ZXJuYWwsXG4gICAgICAgIGFjdGl2ZTogdHJ1ZVxuICAgICAgfVxuICAgIH0pKTtcbiAgICAvLyBOb3RpZml5IHRoYXQgaW5pdCBpcyBjb21wbGV0ZWQsIHRoZSBzY2VuZSBncmFwaCBleGlzdHMsIGJ1dCBub3RoaW5nIGhhcyB5ZXQgcmVuZGVyZWRcbiAgICBpZiAob25DcmVhdGVkKSBvbkNyZWF0ZWQoc3RhdGUpO1xuICAgIC8vIENvbm5lY3QgZXZlbnRzIHRvIHRoZSB0YXJnZXRzIHBhcmVudCwgdGhpcyBpcyBkb25lIHRvIGVuc3VyZSBldmVudHMgYXJlIHJlZ2lzdGVyZWQgb25cbiAgICAvLyBhIHNoYXJlZCB0YXJnZXQsIGFuZCBub3Qgb24gdGhlIGNhbnZhcyBpdHNlbGZcbiAgICBpZiAoIXN0b3JlLmdldFN0YXRlKCkuZXZlbnRzLmNvbm5lY3RlZCkgc3RhdGUuZXZlbnRzLmNvbm5lY3QgPT0gbnVsbCA/IHZvaWQgMCA6IHN0YXRlLmV2ZW50cy5jb25uZWN0KHJvb3RFbGVtZW50KTtcbiAgICAvLyBlc2xpbnQtZGlzYWJsZS1uZXh0LWxpbmUgcmVhY3QtaG9va3MvZXhoYXVzdGl2ZS1kZXBzXG4gIH0sIFtdKTtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KGNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogc3RvcmVcbiAgfSwgY2hpbGRyZW4pO1xufVxuZnVuY3Rpb24gdW5tb3VudENvbXBvbmVudEF0Tm9kZShjYW52YXMsIGNhbGxiYWNrKSB7XG4gIGNvbnN0IHJvb3QgPSByb290cy5nZXQoY2FudmFzKTtcbiAgY29uc3QgZmliZXIgPSByb290ID09IG51bGwgPyB2b2lkIDAgOiByb290LmZpYmVyO1xuICBpZiAoZmliZXIpIHtcbiAgICBjb25zdCBzdGF0ZSA9IHJvb3QgPT0gbnVsbCA/IHZvaWQgMCA6IHJvb3Quc3RvcmUuZ2V0U3RhdGUoKTtcbiAgICBpZiAoc3RhdGUpIHN0YXRlLmludGVybmFsLmFjdGl2ZSA9IGZhbHNlO1xuICAgIHJlY29uY2lsZXIudXBkYXRlQ29udGFpbmVyKG51bGwsIGZpYmVyLCBudWxsLCAoKSA9PiB7XG4gICAgICBpZiAoc3RhdGUpIHtcbiAgICAgICAgc2V0VGltZW91dCgoKSA9PiB7XG4gICAgICAgICAgdHJ5IHtcbiAgICAgICAgICAgIHZhciBfc3RhdGUkZ2wsIF9zdGF0ZSRnbCRyZW5kZXJMaXN0cywgX3N0YXRlJGdsMiwgX3N0YXRlJGdsMztcbiAgICAgICAgICAgIHN0YXRlLmV2ZW50cy5kaXNjb25uZWN0ID09IG51bGwgPyB2b2lkIDAgOiBzdGF0ZS5ldmVudHMuZGlzY29ubmVjdCgpO1xuICAgICAgICAgICAgKF9zdGF0ZSRnbCA9IHN0YXRlLmdsKSA9PSBudWxsID8gdm9pZCAwIDogKF9zdGF0ZSRnbCRyZW5kZXJMaXN0cyA9IF9zdGF0ZSRnbC5yZW5kZXJMaXN0cykgPT0gbnVsbCA/IHZvaWQgMCA6IF9zdGF0ZSRnbCRyZW5kZXJMaXN0cy5kaXNwb3NlID09IG51bGwgPyB2b2lkIDAgOiBfc3RhdGUkZ2wkcmVuZGVyTGlzdHMuZGlzcG9zZSgpO1xuICAgICAgICAgICAgKF9zdGF0ZSRnbDIgPSBzdGF0ZS5nbCkgPT0gbnVsbCA/IHZvaWQgMCA6IF9zdGF0ZSRnbDIuZm9yY2VDb250ZXh0TG9zcyA9PSBudWxsID8gdm9pZCAwIDogX3N0YXRlJGdsMi5mb3JjZUNvbnRleHRMb3NzKCk7XG4gICAgICAgICAgICBpZiAoKF9zdGF0ZSRnbDMgPSBzdGF0ZS5nbCkgIT0gbnVsbCAmJiBfc3RhdGUkZ2wzLnhyKSBzdGF0ZS54ci5kaXNjb25uZWN0KCk7XG4gICAgICAgICAgICBkaXNwb3NlKHN0YXRlKTtcbiAgICAgICAgICAgIHJvb3RzLmRlbGV0ZShjYW52YXMpO1xuICAgICAgICAgICAgaWYgKGNhbGxiYWNrKSBjYWxsYmFjayhjYW52YXMpO1xuICAgICAgICAgIH0gY2F0Y2ggKGUpIHtcbiAgICAgICAgICAgIC8qIC4uLiAqL1xuICAgICAgICAgIH1cbiAgICAgICAgfSwgNTAwKTtcbiAgICAgIH1cbiAgICB9KTtcbiAgfVxufVxuZnVuY3Rpb24gY3JlYXRlUG9ydGFsKGNoaWxkcmVuLCBjb250YWluZXIsIHN0YXRlKSB7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChQb3J0YWwsIHtcbiAgICBrZXk6IGNvbnRhaW5lci51dWlkLFxuICAgIGNoaWxkcmVuOiBjaGlsZHJlbixcbiAgICBjb250YWluZXI6IGNvbnRhaW5lcixcbiAgICBzdGF0ZTogc3RhdGVcbiAgfSk7XG59XG5mdW5jdGlvbiBQb3J0YWwoe1xuICBzdGF0ZSA9IHt9LFxuICBjaGlsZHJlbixcbiAgY29udGFpbmVyXG59KSB7XG4gIC8qKiBUaGlzIGhhcyB0byBiZSBhIGNvbXBvbmVudCBiZWNhdXNlIGl0IHdvdWxkIG5vdCBiZSBhYmxlIHRvIGNhbGwgdXNlVGhyZWUvdXNlU3RvcmUgb3RoZXJ3aXNlIHNpbmNlXG4gICAqICBpZiB0aGlzIGlzIG91ciBlbnZpcm9ubWVudCwgdGhlbiB3ZSBhcmUgbm90IGluIHIzZidzIHJlbmRlcmVyIGJ1dCBpbiByZWFjdC1kb20sIGl0IHdvdWxkIHRyaWdnZXJcbiAgICogIHRoZSBcIlIzRiBob29rcyBjYW4gb25seSBiZSB1c2VkIHdpdGhpbiB0aGUgQ2FudmFzIGNvbXBvbmVudCFcIiB3YXJuaW5nOlxuICAgKiAgPENhbnZhcz5cbiAgICogICAge2NyZWF0ZVBvcnRhbCguLi4pfSAqL1xuICBjb25zdCB7XG4gICAgZXZlbnRzLFxuICAgIHNpemUsXG4gICAgLi4ucmVzdFxuICB9ID0gc3RhdGU7XG4gIGNvbnN0IHByZXZpb3VzUm9vdCA9IHVzZVN0b3JlKCk7XG4gIGNvbnN0IFtyYXljYXN0ZXJdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gbmV3IFRIUkVFLlJheWNhc3RlcigpKTtcbiAgY29uc3QgW3BvaW50ZXJdID0gUmVhY3QudXNlU3RhdGUoKCkgPT4gbmV3IFRIUkVFLlZlY3RvcjIoKSk7XG4gIGNvbnN0IGluamVjdCA9IFJlYWN0LnVzZUNhbGxiYWNrKChyb290U3RhdGUsIGluamVjdFN0YXRlKSA9PiB7XG4gICAgY29uc3QgaW50ZXJzZWN0ID0ge1xuICAgICAgLi4ucm9vdFN0YXRlXG4gICAgfTsgLy8gYWxsIHByZXYgc3RhdGUgcHJvcHNcblxuICAgIC8vIE9ubHkgdGhlIGZpZWxkcyBvZiBcInJvb3RTdGF0ZVwiIHRoYXQgZG8gbm90IGRpZmZlciBmcm9tIGluamVjdFN0YXRlXG4gICAgLy8gU29tZSBwcm9wcyBzaG91bGQgYmUgb2ZmLWxpbWl0c1xuICAgIC8vIE90aGVyd2lzZSBmaWx0ZXIgb3V0IHRoZSBwcm9wcyB0aGF0IGFyZSBkaWZmZXJlbnQgYW5kIGxldCB0aGUgaW5qZWN0IGxheWVyIHRha2UgcHJlY2VkZW5jZVxuICAgIE9iamVjdC5rZXlzKHJvb3RTdGF0ZSkuZm9yRWFjaChrZXkgPT4ge1xuICAgICAgaWYgKFxuICAgICAgLy8gU29tZSBwcm9wcyBzaG91bGQgYmUgb2ZmLWxpbWl0c1xuICAgICAgcHJpdmF0ZUtleXMuaW5jbHVkZXMoa2V5KSB8fFxuICAgICAgLy8gT3RoZXJ3aXNlIGZpbHRlciBvdXQgdGhlIHByb3BzIHRoYXQgYXJlIGRpZmZlcmVudCBhbmQgbGV0IHRoZSBpbmplY3QgbGF5ZXIgdGFrZSBwcmVjZWRlbmNlXG4gICAgICAvLyBVbmxlc3MgdGhlIGluamVjdCBsYXllciBwcm9wcyBpcyB1bmRlZmluZWQsIHRoZW4gd2Uga2VlcCB0aGUgcm9vdCBsYXllclxuICAgICAgcm9vdFN0YXRlW2tleV0gIT09IGluamVjdFN0YXRlW2tleV0gJiYgaW5qZWN0U3RhdGVba2V5XSkge1xuICAgICAgICBkZWxldGUgaW50ZXJzZWN0W2tleV07XG4gICAgICB9XG4gICAgfSk7XG4gICAgbGV0IHZpZXdwb3J0ID0gdW5kZWZpbmVkO1xuICAgIGlmIChpbmplY3RTdGF0ZSAmJiBzaXplKSB7XG4gICAgICBjb25zdCBjYW1lcmEgPSBpbmplY3RTdGF0ZS5jYW1lcmE7XG4gICAgICAvLyBDYWxjdWxhdGUgdGhlIG92ZXJyaWRlIHZpZXdwb3J0LCBpZiBwcmVzZW50XG4gICAgICB2aWV3cG9ydCA9IHJvb3RTdGF0ZS52aWV3cG9ydC5nZXRDdXJyZW50Vmlld3BvcnQoY2FtZXJhLCBuZXcgVEhSRUUuVmVjdG9yMygpLCBzaXplKTtcbiAgICAgIC8vIFVwZGF0ZSB0aGUgcG9ydGFsIGNhbWVyYSwgaWYgaXQgZGlmZmVycyBmcm9tIHRoZSBwcmV2aW91cyBsYXllclxuICAgICAgaWYgKGNhbWVyYSAhPT0gcm9vdFN0YXRlLmNhbWVyYSkgdXBkYXRlQ2FtZXJhKGNhbWVyYSwgc2l6ZSk7XG4gICAgfVxuICAgIHJldHVybiB7XG4gICAgICAvLyBUaGUgaW50ZXJzZWN0IGNvbnNpc3RzIG9mIHRoZSBwcmV2aW91cyByb290IHN0YXRlXG4gICAgICAuLi5pbnRlcnNlY3QsXG4gICAgICAvLyBQb3J0YWxzIGhhdmUgdGhlaXIgb3duIHNjZW5lLCB3aGljaCBmb3JtcyB0aGUgcm9vdCwgYSByYXljYXN0ZXIgYW5kIGEgcG9pbnRlclxuICAgICAgc2NlbmU6IGNvbnRhaW5lcixcbiAgICAgIHJheWNhc3RlcixcbiAgICAgIHBvaW50ZXIsXG4gICAgICBtb3VzZTogcG9pbnRlcixcbiAgICAgIC8vIFRoZWlyIHByZXZpb3VzIHJvb3QgaXMgdGhlIGxheWVyIGJlZm9yZSBpdFxuICAgICAgcHJldmlvdXNSb290LFxuICAgICAgLy8gRXZlbnRzLCBzaXplIGFuZCB2aWV3cG9ydCBjYW4gYmUgb3ZlcnJpZGRlbiBieSB0aGUgaW5qZWN0IGxheWVyXG4gICAgICBldmVudHM6IHtcbiAgICAgICAgLi4ucm9vdFN0YXRlLmV2ZW50cyxcbiAgICAgICAgLi4uKGluamVjdFN0YXRlID09IG51bGwgPyB2b2lkIDAgOiBpbmplY3RTdGF0ZS5ldmVudHMpLFxuICAgICAgICAuLi5ldmVudHNcbiAgICAgIH0sXG4gICAgICBzaXplOiB7XG4gICAgICAgIC4uLnJvb3RTdGF0ZS5zaXplLFxuICAgICAgICAuLi5zaXplXG4gICAgICB9LFxuICAgICAgdmlld3BvcnQ6IHtcbiAgICAgICAgLi4ucm9vdFN0YXRlLnZpZXdwb3J0LFxuICAgICAgICAuLi52aWV3cG9ydFxuICAgICAgfSxcbiAgICAgIC4uLnJlc3RcbiAgICB9O1xuICB9LCBbc3RhdGVdKTtcbiAgY29uc3QgW3VzZVBvcnRhbFN0b3JlXSA9IFJlYWN0LnVzZVN0YXRlKCgpID0+IHtcbiAgICAvLyBDcmVhdGUgYSBtaXJyb3JlZCBzdG9yZSwgYmFzZWQgb24gdGhlIHByZXZpb3VzIHJvb3Qgd2l0aCBhIGZldyBvdmVycmlkZXMgLi4uXG4gICAgY29uc3QgcHJldmlvdXNTdGF0ZSA9IHByZXZpb3VzUm9vdC5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHN0b3JlID0gY3JlYXRlKChzZXQsIGdldCkgPT4gKHtcbiAgICAgIC4uLnByZXZpb3VzU3RhdGUsXG4gICAgICBzY2VuZTogY29udGFpbmVyLFxuICAgICAgcmF5Y2FzdGVyLFxuICAgICAgcG9pbnRlcixcbiAgICAgIG1vdXNlOiBwb2ludGVyLFxuICAgICAgcHJldmlvdXNSb290LFxuICAgICAgZXZlbnRzOiB7XG4gICAgICAgIC4uLnByZXZpb3VzU3RhdGUuZXZlbnRzLFxuICAgICAgICAuLi5ldmVudHNcbiAgICAgIH0sXG4gICAgICBzaXplOiB7XG4gICAgICAgIC4uLnByZXZpb3VzU3RhdGUuc2l6ZSxcbiAgICAgICAgLi4uc2l6ZVxuICAgICAgfSxcbiAgICAgIC4uLnJlc3QsXG4gICAgICAvLyBTZXQgYW5kIGdldCByZWZlciB0byB0aGlzIHJvb3Qtc3RhdGVcbiAgICAgIHNldCxcbiAgICAgIGdldCxcbiAgICAgIC8vIExheWVycyBhcmUgYWxsb3dlZCB0byBvdmVycmlkZSBldmVudHNcbiAgICAgIHNldEV2ZW50czogZXZlbnRzID0+IHNldChzdGF0ZSA9PiAoe1xuICAgICAgICAuLi5zdGF0ZSxcbiAgICAgICAgZXZlbnRzOiB7XG4gICAgICAgICAgLi4uc3RhdGUuZXZlbnRzLFxuICAgICAgICAgIC4uLmV2ZW50c1xuICAgICAgICB9XG4gICAgICB9KSlcbiAgICB9KSk7XG4gICAgcmV0dXJuIHN0b3JlO1xuICB9KTtcbiAgUmVhY3QudXNlRWZmZWN0KCgpID0+IHtcbiAgICAvLyBTdWJzY3JpYmUgdG8gcHJldmlvdXMgcm9vdC1zdGF0ZSBhbmQgY29weSBjaGFuZ2VzIG92ZXIgdG8gdGhlIG1pcnJvcmVkIHBvcnRhbC1zdGF0ZVxuICAgIGNvbnN0IHVuc3ViID0gcHJldmlvdXNSb290LnN1YnNjcmliZShwcmV2ID0+IHVzZVBvcnRhbFN0b3JlLnNldFN0YXRlKHN0YXRlID0+IGluamVjdChwcmV2LCBzdGF0ZSkpKTtcbiAgICByZXR1cm4gKCkgPT4ge1xuICAgICAgdW5zdWIoKTtcbiAgICAgIHVzZVBvcnRhbFN0b3JlLmRlc3Ryb3koKTtcbiAgICB9O1xuICB9LCBbXSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgdXNlUG9ydGFsU3RvcmUuc2V0U3RhdGUoaW5qZWN0U3RhdGUgPT4gaW5qZWN0KHByZXZpb3VzUm9vdC5nZXRTdGF0ZSgpLCBpbmplY3RTdGF0ZSkpO1xuICB9LCBbaW5qZWN0XSk7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChSZWFjdC5GcmFnbWVudCwgbnVsbCwgcmVjb25jaWxlci5jcmVhdGVQb3J0YWwoIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KGNvbnRleHQuUHJvdmlkZXIsIHtcbiAgICB2YWx1ZTogdXNlUG9ydGFsU3RvcmVcbiAgfSwgY2hpbGRyZW4pLCB1c2VQb3J0YWxTdG9yZSwgbnVsbCkpO1xufVxucmVjb25jaWxlci5pbmplY3RJbnRvRGV2VG9vbHMoe1xuICBidW5kbGVUeXBlOiBwcm9jZXNzLmVudi5OT0RFX0VOViA9PT0gJ3Byb2R1Y3Rpb24nID8gMCA6IDEsXG4gIHJlbmRlcmVyUGFja2FnZU5hbWU6ICdAcmVhY3QtdGhyZWUvZmliZXInLFxuICB2ZXJzaW9uOiBSZWFjdC52ZXJzaW9uXG59KTtcbmNvbnN0IGFjdCA9IFJlYWN0LnVuc3RhYmxlX2FjdDtcblxuZXhwb3J0IHsgdXNlRnJhbWUgYXMgQSwgQmxvY2sgYXMgQiwgdXNlR3JhcGggYXMgQywgdXNlTG9hZGVyIGFzIEQsIEVycm9yQm91bmRhcnkgYXMgRSwgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCBhcyBhLCBjcmVhdGVSb290IGFzIGIsIGNyZWF0ZUV2ZW50cyBhcyBjLCB1bm1vdW50Q29tcG9uZW50QXROb2RlIGFzIGQsIGV4dGVuZCBhcyBlLCBjb250ZXh0IGFzIGYsIGNyZWF0ZVBvcnRhbCBhcyBnLCByZWNvbmNpbGVyIGFzIGgsIGlzUmVmIGFzIGksIGFwcGx5UHJvcHMgYXMgaiwgZGlzcG9zZSBhcyBrLCBpbnZhbGlkYXRlIGFzIGwsIGFkdmFuY2UgYXMgbSwgYWRkRWZmZWN0IGFzIG4sIGFkZEFmdGVyRWZmZWN0IGFzIG8sIGFkZFRhaWwgYXMgcCwgZmx1c2hHbG9iYWxFZmZlY3RzIGFzIHEsIHJlbmRlciBhcyByLCBnZXRSb290U3RhdGUgYXMgcywgdGhyZWVUeXBlcyBhcyB0LCB1c2VNdXRhYmxlQ2FsbGJhY2sgYXMgdSwgYWN0IGFzIHYsIHJvb3RzIGFzIHcsIHVzZUluc3RhbmNlSGFuZGxlIGFzIHgsIHVzZVN0b3JlIGFzIHksIHVzZVRocmVlIGFzIHogfTtcbiJdLCJuYW1lcyI6WyJUSFJFRSIsIlJlYWN0IiwiRGVmYXVsdEV2ZW50UHJpb3JpdHkiLCJDb250aW51b3VzRXZlbnRQcmlvcml0eSIsIkRpc2NyZXRlRXZlbnRQcmlvcml0eSIsIkNvbmN1cnJlbnRSb290IiwiY3JlYXRlIiwiUmVjb25jaWxlciIsInVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2siLCJ1bnN0YWJsZV9JZGxlUHJpb3JpdHkiLCJzdXNwZW5kIiwicHJlbG9hZCIsImNsZWFyIiwidGhyZWVUeXBlcyIsIk9iamVjdCIsImZyZWV6ZSIsIl9fcHJvdG9fXyIsImNhdGFsb2d1ZSIsImV4dGVuZCIsIm9iamVjdHMiLCJhc3NpZ24iLCJjcmVhdGVSZW5kZXJlciIsIl9yb290cyIsIl9nZXRFdmVudFByaW9yaXR5IiwiY3JlYXRlSW5zdGFuY2UiLCJ0eXBlIiwiYXJncyIsImF0dGFjaCIsInByb3BzIiwicm9vdCIsIm5hbWUiLCJ0b1VwcGVyQ2FzZSIsInNsaWNlIiwiaW5zdGFuY2UiLCJvYmplY3QiLCJ1bmRlZmluZWQiLCJFcnJvciIsInByZXBhcmUiLCJwcmltaXRpdmUiLCJ0YXJnZXQiLCJBcnJheSIsImlzQXJyYXkiLCJtZW1vaXplZFByb3BzIiwiX19yM2YiLCJCdWZmZXJHZW9tZXRyeSIsIk1hdGVyaWFsIiwiYXBwbHlQcm9wcyQxIiwiYXBwZW5kQ2hpbGQiLCJwYXJlbnRJbnN0YW5jZSIsImNoaWxkIiwiYWRkZWQiLCJfY2hpbGQkX19yM2YiLCJfcGFyZW50SW5zdGFuY2UkX19yM2YiLCJpc09iamVjdDNEIiwiYWRkIiwicHVzaCIsInBhcmVudCIsInVwZGF0ZUluc3RhbmNlIiwiaW52YWxpZGF0ZUluc3RhbmNlIiwiaW5zZXJ0QmVmb3JlIiwiYmVmb3JlQ2hpbGQiLCJfY2hpbGQkX19yM2YyIiwiX3BhcmVudEluc3RhbmNlJF9fcjNmMiIsImRpc3BhdGNoRXZlbnQiLCJyZXN0U2libGluZ3MiLCJjaGlsZHJlbiIsImZpbHRlciIsInNpYmxpbmciLCJpbmRleCIsImluZGV4T2YiLCJyZW1vdmVSZWN1cnNpdmUiLCJhcnJheSIsImRpc3Bvc2UiLCJmb3JFYWNoIiwicmVtb3ZlQ2hpbGQiLCJfcGFyZW50SW5zdGFuY2UkX19yM2YzIiwiX2NoaWxkJF9fcjNmMyIsIl9jaGlsZCRfX3IzZjUiLCJ4IiwiZGV0YWNoIiwiX2NoaWxkJF9fcjNmNCIsInJlbW92ZSIsInJlbW92ZUludGVyYWN0aXZpdHkiLCJpc1ByaW1pdGl2ZSIsInNob3VsZERpc3Bvc2UiLCJfY2hpbGQkX19yM2Y2IiwiZSIsInN3aXRjaEluc3RhbmNlIiwibmV3UHJvcHMiLCJmaWJlciIsIl9pbnN0YW5jZSRfX3IzZiIsIm5ld0luc3RhbmNlIiwiYXV0b1JlbW92ZWRCZWZvcmVBcHBlbmQiLCJyYXljYXN0IiwiZXZlbnRDb3VudCIsInJvb3RTdGF0ZSIsImdldFN0YXRlIiwiaW50ZXJuYWwiLCJpbnRlcmFjdGlvbiIsImFsdGVybmF0ZSIsInN0YXRlTm9kZSIsInJlZiIsImN1cnJlbnQiLCJoYW5kbGVUZXh0SW5zdGFuY2UiLCJjb25zb2xlIiwid2FybiIsInJlY29uY2lsZXIiLCJhcHBlbmRJbml0aWFsQ2hpbGQiLCJzdXBwb3J0c011dGF0aW9uIiwiaXNQcmltYXJ5UmVuZGVyZXIiLCJzdXBwb3J0c1BlcnNpc3RlbmNlIiwic3VwcG9ydHNIeWRyYXRpb24iLCJub1RpbWVvdXQiLCJhcHBlbmRDaGlsZFRvQ29udGFpbmVyIiwiY29udGFpbmVyIiwic2NlbmUiLCJyZW1vdmVDaGlsZEZyb21Db250YWluZXIiLCJpbnNlcnRJbkNvbnRhaW5lckJlZm9yZSIsImdldFJvb3RIb3N0Q29udGV4dCIsImdldENoaWxkSG9zdENvbnRleHQiLCJwYXJlbnRIb3N0Q29udGV4dCIsImZpbmFsaXplSW5pdGlhbENoaWxkcmVuIiwiX2luc3RhbmNlJF9fcjNmMiIsImxvY2FsU3RhdGUiLCJCb29sZWFuIiwiaGFuZGxlcnMiLCJwcmVwYXJlVXBkYXRlIiwiX3R5cGUiLCJvbGRQcm9wcyIsIl9pbnN0YW5jZSRfX3IzZjMiLCJhcmdzTmV3IiwiY04iLCJyZXN0TmV3IiwiYXJnc09sZCIsImNPIiwicmVzdE9sZCIsInNvbWUiLCJ2YWx1ZSIsImRpZmYiLCJkaWZmUHJvcHMiLCJjaGFuZ2VzIiwibGVuZ3RoIiwiY29tbWl0VXBkYXRlIiwicmVjb25zdHJ1Y3QiLCJfb2xkUHJvcHMiLCJjb21taXRNb3VudCIsIl9wcm9wcyIsIl9pbnQiLCJfaW5zdGFuY2UkX19yM2Y0IiwiZ2V0UHVibGljSW5zdGFuY2UiLCJwcmVwYXJlRm9yQ29tbWl0IiwicHJlcGFyZVBvcnRhbE1vdW50IiwicmVzZXRBZnRlckNvbW1pdCIsInNob3VsZFNldFRleHRDb250ZW50IiwiY2xlYXJDb250YWluZXIiLCJoaWRlSW5zdGFuY2UiLCJfaW5zdGFuY2UkX19yM2Y1IiwidmlzaWJsZSIsInVuaGlkZUluc3RhbmNlIiwiX2luc3RhbmNlJF9fcjNmNiIsImNyZWF0ZVRleHRJbnN0YW5jZSIsImhpZGVUZXh0SW5zdGFuY2UiLCJ1bmhpZGVUZXh0SW5zdGFuY2UiLCJnZXRDdXJyZW50RXZlbnRQcmlvcml0eSIsImJlZm9yZUFjdGl2ZUluc3RhbmNlQmx1ciIsImFmdGVyQWN0aXZlSW5zdGFuY2VCbHVyIiwiZGV0YWNoRGVsZXRlZEluc3RhbmNlIiwibm93IiwicGVyZm9ybWFuY2UiLCJpcyIsImZ1biIsIkRhdGUiLCJzY2hlZHVsZVRpbWVvdXQiLCJzZXRUaW1lb3V0IiwiY2FuY2VsVGltZW91dCIsImNsZWFyVGltZW91dCIsImFwcGx5UHJvcHMiLCJfd2luZG93JGRvY3VtZW50IiwiX3dpbmRvdyRuYXZpZ2F0b3IiLCJoYXNDb2xvclNwYWNlIiwiZ2V0Q29sb3JNYW5hZ2VtZW50IiwiX0NvbG9yTWFuYWdlbWVudCIsIkNvbG9yTWFuYWdlbWVudCIsImlzT3J0aG9ncmFwaGljQ2FtZXJhIiwiZGVmIiwiaXNSZWYiLCJvYmoiLCJoYXNPd25Qcm9wZXJ0eSIsInVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QiLCJ3aW5kb3ciLCJkb2N1bWVudCIsImNyZWF0ZUVsZW1lbnQiLCJuYXZpZ2F0b3IiLCJwcm9kdWN0IiwidXNlTGF5b3V0RWZmZWN0IiwidXNlRWZmZWN0IiwidXNlTXV0YWJsZUNhbGxiYWNrIiwiZm4iLCJ1c2VSZWYiLCJCbG9jayIsInNldCIsIlByb21pc2UiLCJFcnJvckJvdW5kYXJ5IiwiQ29tcG9uZW50IiwiY29uc3RydWN0b3IiLCJzdGF0ZSIsImVycm9yIiwiY29tcG9uZW50RGlkQ2F0Y2giLCJlcnIiLCJyZW5kZXIiLCJnZXREZXJpdmVkU3RhdGVGcm9tRXJyb3IiLCJERUZBVUxUIiwiREVGQVVMVFMiLCJNYXAiLCJpc0RpZmZTZXQiLCJtZW1vaXplZCIsImNhbGN1bGF0ZURwciIsImRwciIsIl93aW5kb3ckZGV2aWNlUGl4ZWxSYSIsImRldmljZVBpeGVsUmF0aW8iLCJNYXRoIiwibWluIiwibWF4IiwiZ2V0Um9vdFN0YXRlIiwiX3IzZiIsImEiLCJhcnIiLCJzdHIiLCJudW0iLCJib28iLCJ1bmQiLCJlcXUiLCJiIiwiYXJyYXlzIiwic3RyaWN0IiwiaXNPYmoiLCJpc0FyciIsImkiLCJrZXlzIiwiYnVpbGRHcmFwaCIsImRhdGEiLCJub2RlcyIsIm1hdGVyaWFscyIsInRyYXZlcnNlIiwibWF0ZXJpYWwiLCJwIiwicHJldmlvdXNBdHRhY2giLCJyZXNvbHZlIiwia2V5IiwiaW5jbHVkZXMiLCJlbnRyaWVzIiwic3BsaXQiLCJsYXN0IiwicG9wIiwicmVkdWNlIiwiYWNjIiwiSU5ERVhfUkVHRVgiLCJ0ZXN0IiwicmVwbGFjZSIsInByZXZpb3VzIiwia04iLCJyTiIsImNQIiwia1AiLCJyUCIsInByZXZpb3VzS2V5cyIsInVuc2hpZnQiLCJwcm9wIiwic3RhcnRzV2l0aCIsIl9yb290JGdldFN0YXRlIiwicHJldkhhbmRsZXJzIiwiaXNFdmVudCIsInNSR0JFbmNvZGluZyIsIlNSR0JDb2xvclNwYWNlIiwiTGluZWFyU1JHQkNvbG9yU3BhY2UiLCJjdXJyZW50SW5zdGFuY2UiLCJ0YXJnZXRQcm9wIiwicmV2ZXJzZUVudHJpZXMiLCJyZXZlcnNlIiwiY3RvciIsImdldCIsImNvcHkiLCJMYXllcnMiLCJmcm9tQXJyYXkiLCJpc0NvbG9yIiwiQ29sb3IiLCJzZXRTY2FsYXIiLCJtYXNrIiwibGluZWFyIiwiY29udmVydFNSR0JUb0xpbmVhciIsIlRleHR1cmUiLCJmb3JtYXQiLCJSR0JBRm9ybWF0IiwiVW5zaWduZWRCeXRlVHlwZSIsInRleHR1cmUiLCJnbCIsImNvbG9yU3BhY2UiLCJvdXRwdXRDb2xvclNwYWNlIiwiZW5jb2RpbmciLCJvdXRwdXRFbmNvZGluZyIsInNwbGljZSIsImlzQ2lyY3VsYXIiLCJfaW5zdGFuY2UkX19yM2Y1JHJvb3QiLCJmcmFtZXMiLCJpbnZhbGlkYXRlIiwib25VcGRhdGUiLCJ1cGRhdGVDYW1lcmEiLCJjYW1lcmEiLCJzaXplIiwibWFudWFsIiwibGVmdCIsIndpZHRoIiwicmlnaHQiLCJ0b3AiLCJoZWlnaHQiLCJib3R0b20iLCJhc3BlY3QiLCJ1cGRhdGVQcm9qZWN0aW9uTWF0cml4IiwidXBkYXRlTWF0cml4V29ybGQiLCJtYWtlSWQiLCJldmVudCIsImV2ZW50T2JqZWN0IiwidXVpZCIsImluc3RhbmNlSWQiLCJnZXRFdmVudFByaW9yaXR5IiwiX2dsb2JhbFNjb3BlJGV2ZW50IiwiZ2xvYmFsU2NvcGUiLCJzZWxmIiwicmVsZWFzZUludGVybmFsUG9pbnRlckNhcHR1cmUiLCJjYXB0dXJlZE1hcCIsImNhcHR1cmVzIiwicG9pbnRlcklkIiwiY2FwdHVyZURhdGEiLCJkZWxldGUiLCJyZWxlYXNlUG9pbnRlckNhcHR1cmUiLCJzdG9yZSIsIm8iLCJpbml0aWFsSGl0cyIsImhvdmVyZWQiLCJjcmVhdGVFdmVudHMiLCJjYWxjdWxhdGVEaXN0YW5jZSIsImR4Iiwib2Zmc2V0WCIsImluaXRpYWxDbGljayIsImR5Iiwib2Zmc2V0WSIsInJvdW5kIiwic3FydCIsImZpbHRlclBvaW50ZXJFdmVudHMiLCJpbnRlcnNlY3QiLCJkdXBsaWNhdGVzIiwiU2V0IiwiaW50ZXJzZWN0aW9ucyIsImV2ZW50c09iamVjdHMiLCJyYXljYXN0ZXIiLCJwcmV2aW91c1Jvb3QiLCJldmVudHMiLCJjb21wdXRlIiwiaGFuZGxlUmF5Y2FzdCIsImVuYWJsZWQiLCJfc3RhdGUkcHJldmlvdXNSb290IiwiaW50ZXJzZWN0T2JqZWN0IiwiaGl0cyIsImZsYXRNYXAiLCJzb3J0IiwiYVN0YXRlIiwiYlN0YXRlIiwiZGlzdGFuY2UiLCJwcmlvcml0eSIsIml0ZW0iLCJpZCIsImhhcyIsImhpdCIsIl9yM2YyIiwidmFsdWVzIiwiaW50ZXJzZWN0aW9uIiwiaGFuZGxlSW50ZXJzZWN0cyIsImRlbHRhIiwiY2FsbGJhY2siLCJzdG9wcGVkIiwicG9pbnRlciIsInVucHJvamVjdGVkUG9pbnQiLCJWZWN0b3IzIiwieSIsInVucHJvamVjdCIsImhhc1BvaW50ZXJDYXB0dXJlIiwiX2ludGVybmFsJGNhcHR1cmVkTWFwIiwiX2ludGVybmFsJGNhcHR1cmVkTWFwMiIsInNldFBvaW50ZXJDYXB0dXJlIiwiZXh0cmFjdEV2ZW50UHJvcHMiLCJwcm9wZXJ0eSIsInJheWNhc3RFdmVudCIsInJheSIsInN0b3BQcm9wYWdhdGlvbiIsImNhcHR1cmVzRm9yUG9pbnRlciIsImZyb20iLCJmaW5kIiwiaGlnaGVyIiwiY2FuY2VsUG9pbnRlciIsImN1cnJlbnRUYXJnZXQiLCJuYXRpdmVFdmVudCIsImhvdmVyZWRPYmoiLCJvblBvaW50ZXJPdXQiLCJvblBvaW50ZXJMZWF2ZSIsInBvaW50ZXJNaXNzZWQiLCJvblBvaW50ZXJNaXNzZWQiLCJoYW5kbGVQb2ludGVyIiwicmVxdWVzdEFuaW1hdGlvbkZyYW1lIiwiaGFuZGxlRXZlbnQiLCJsYXN0RXZlbnQiLCJpc1BvaW50ZXJNb3ZlIiwiaXNDbGlja0V2ZW50IiwibWFwIiwib25JbnRlcnNlY3QiLCJvblBvaW50ZXJPdmVyIiwib25Qb2ludGVyRW50ZXIiLCJob3ZlcmVkSXRlbSIsIm9uUG9pbnRlck1vdmUiLCJoYW5kbGVyIiwicHJpdmF0ZUtleXMiLCJpc1JlbmRlcmVyIiwiY29udGV4dCIsImNyZWF0ZUNvbnRleHQiLCJjcmVhdGVTdG9yZSIsImFkdmFuY2UiLCJwb3NpdGlvbiIsImRlZmF1bHRUYXJnZXQiLCJ0ZW1wVGFyZ2V0IiwiZ2V0Q3VycmVudFZpZXdwb3J0IiwiZ2V0V29ybGRQb3NpdGlvbiIsImRpc3RhbmNlVG8iLCJ6b29tIiwiZmFjdG9yIiwiZm92IiwiUEkiLCJoIiwidGFuIiwidyIsInBlcmZvcm1hbmNlVGltZW91dCIsInNldFBlcmZvcm1hbmNlQ3VycmVudCIsIlZlY3RvcjIiLCJjb25uZWN0ZWQiLCJ4ciIsInRpbWVzdGFtcCIsInJ1bkdsb2JhbEVmZmVjdHMiLCJsZWdhY3kiLCJmbGF0IiwiY29udHJvbHMiLCJjbG9jayIsIkNsb2NrIiwibW91c2UiLCJmcmFtZWxvb3AiLCJkZWJvdW5jZSIsInJlZ3Jlc3MiLCJ1cGRhdGVTdHlsZSIsInZpZXdwb3J0IiwiaW5pdGlhbERwciIsInNldEV2ZW50cyIsInNldFNpemUiLCJzZXREcHIiLCJyZXNvbHZlZCIsInNldEZyYW1lbG9vcCIsInN0b3AiLCJlbGFwc2VkVGltZSIsInN0YXJ0IiwiYWN0aXZlIiwiY3JlYXRlUmVmIiwic3Vic2NyaWJlcnMiLCJzdWJzY3JpYmUiLCJzIiwib2xkU2l6ZSIsIm9sZERwciIsIm9sZENhbWVyYSIsIl9zaXplJHVwZGF0ZVN0eWxlIiwic2V0UGl4ZWxSYXRpbyIsIkhUTUxDYW52YXNFbGVtZW50IiwiZG9tRWxlbWVudCIsImNyZWF0ZVN1YnMiLCJzdWJzIiwic3ViIiwiZ2xvYmFsRWZmZWN0cyIsImdsb2JhbEFmdGVyRWZmZWN0cyIsImdsb2JhbFRhaWxFZmZlY3RzIiwiYWRkRWZmZWN0IiwiYWRkQWZ0ZXJFZmZlY3QiLCJhZGRUYWlsIiwicnVuIiwiZWZmZWN0cyIsImZsdXNoR2xvYmFsRWZmZWN0cyIsInN1YnNjcmlwdGlvbiIsInJlbmRlciQxIiwiZnJhbWUiLCJnZXREZWx0YSIsIm9sZFRpbWUiLCJjcmVhdGVMb29wIiwicm9vdHMiLCJydW5uaW5nIiwicmVwZWF0IiwibG9vcCIsIl9zdGF0ZSRnbCR4ciIsImlzUHJlc2VudGluZyIsImNhbmNlbEFuaW1hdGlvbkZyYW1lIiwiX3N0YXRlJGdsJHhyMiIsInVzZUluc3RhbmNlSGFuZGxlIiwidXNlU3RvcmUiLCJ1c2VDb250ZXh0IiwidXNlVGhyZWUiLCJzZWxlY3RvciIsImVxdWFsaXR5Rm4iLCJ1c2VGcmFtZSIsInJlbmRlclByaW9yaXR5IiwidXNlR3JhcGgiLCJ1c2VNZW1vIiwibG9hZGluZ0ZuIiwiZXh0ZW5zaW9ucyIsIm9uUHJvZ3Jlc3MiLCJQcm90byIsImlucHV0IiwibG9hZGVyIiwiYWxsIiwicmVzIiwicmVqZWN0IiwibG9hZCIsIm1lc3NhZ2UiLCJ1c2VMb2FkZXIiLCJyZXN1bHRzIiwiZXF1YWwiLCJzaGFsbG93TG9vc2UiLCJjcmVhdGVSZW5kZXJlckluc3RhbmNlIiwiY2FudmFzIiwiY3VzdG9tUmVuZGVyZXIiLCJXZWJHTFJlbmRlcmVyIiwicG93ZXJQcmVmZXJlbmNlIiwiYW50aWFsaWFzIiwiYWxwaGEiLCJjb21wdXRlSW5pdGlhbFNpemUiLCJkZWZhdWx0U2l6ZSIsInBhcmVudEVsZW1lbnQiLCJnZXRCb3VuZGluZ0NsaWVudFJlY3QiLCJPZmZzY3JlZW5DYW52YXMiLCJjcmVhdGVSb290IiwicHJldlJvb3QiLCJwcmV2RmliZXIiLCJwcmV2U3RvcmUiLCJsb2dSZWNvdmVyYWJsZUVycm9yIiwicmVwb3J0RXJyb3IiLCJjcmVhdGVDb250YWluZXIiLCJvbkNyZWF0ZWQiLCJjb25maWd1cmVkIiwibGFzdENhbWVyYSIsImNvbmZpZ3VyZSIsImdsQ29uZmlnIiwicHJvcHNTaXplIiwic2NlbmVPcHRpb25zIiwib25DcmVhdGVkQ2FsbGJhY2siLCJzaGFkb3dzIiwib3J0aG9ncmFwaGljIiwicmF5Y2FzdE9wdGlvbnMiLCJjYW1lcmFPcHRpb25zIiwiUmF5Y2FzdGVyIiwicGFyYW1zIiwib3B0aW9ucyIsImlzQ2FtZXJhIiwiQ2FtZXJhIiwiT3J0aG9ncmFwaGljQ2FtZXJhIiwiUGVyc3BlY3RpdmVDYW1lcmEiLCJ6Iiwicm90YXRpb24iLCJsb29rQXQiLCJTY2VuZSIsIl9nbCR4ciIsImhhbmRsZVhSRnJhbWUiLCJoYW5kbGVTZXNzaW9uQ2hhbmdlIiwic2V0QW5pbWF0aW9uTG9vcCIsImNvbm5lY3QiLCJhZGRFdmVudExpc3RlbmVyIiwiZGlzY29ubmVjdCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJzaGFkb3dNYXAiLCJvbGRFbmFibGVkIiwib2xkVHlwZSIsIlBDRlNvZnRTaGFkb3dNYXAiLCJfdHlwZXMkc2hhZG93cyIsInR5cGVzIiwiYmFzaWMiLCJCYXNpY1NoYWRvd01hcCIsInBlcmNlbnRhZ2UiLCJQQ0ZTaGFkb3dNYXAiLCJzb2Z0IiwidmFyaWFuY2UiLCJWU01TaGFkb3dNYXAiLCJuZWVkc1VwZGF0ZSIsImxlZ2FjeU1vZGUiLCJMaW5lYXJFbmNvZGluZyIsInRvbmVNYXBwaW5nIiwiTm9Ub25lTWFwcGluZyIsIkFDRVNGaWxtaWNUb25lTWFwcGluZyIsInVwZGF0ZUNvbnRhaW5lciIsIlByb3ZpZGVyIiwicm9vdEVsZW1lbnQiLCJ1bm1vdW50IiwidW5tb3VudENvbXBvbmVudEF0Tm9kZSIsImNvbmZpZyIsIl9zdGF0ZSRnbCIsIl9zdGF0ZSRnbCRyZW5kZXJMaXN0cyIsIl9zdGF0ZSRnbDIiLCJfc3RhdGUkZ2wzIiwicmVuZGVyTGlzdHMiLCJmb3JjZUNvbnRleHRMb3NzIiwiY3JlYXRlUG9ydGFsIiwiUG9ydGFsIiwicmVzdCIsInVzZVN0YXRlIiwiaW5qZWN0IiwidXNlQ2FsbGJhY2siLCJpbmplY3RTdGF0ZSIsInVzZVBvcnRhbFN0b3JlIiwicHJldmlvdXNTdGF0ZSIsInVuc3ViIiwicHJldiIsInNldFN0YXRlIiwiZGVzdHJveSIsIkZyYWdtZW50IiwiaW5qZWN0SW50b0RldlRvb2xzIiwiYnVuZGxlVHlwZSIsInByb2Nlc3MiLCJyZW5kZXJlclBhY2thZ2VOYW1lIiwidmVyc2lvbiIsImFjdCIsInVuc3RhYmxlX2FjdCIsIkEiLCJCIiwiQyIsIkQiLCJFIiwiYyIsImQiLCJmIiwiZyIsImoiLCJrIiwibCIsIm0iLCJuIiwicSIsInIiLCJ0IiwidSIsInYiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/dist/index-673ef987.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js":
/*!***********************************************************************!*\
  !*** ./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js ***!
  \***********************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   Canvas: () => (/* binding */ Canvas),\n/* harmony export */   ReactThreeFiber: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.t),\n/* harmony export */   _roots: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.w),\n/* harmony export */   act: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.v),\n/* harmony export */   addAfterEffect: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.o),\n/* harmony export */   addEffect: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.n),\n/* harmony export */   addTail: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.p),\n/* harmony export */   advance: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.m),\n/* harmony export */   applyProps: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.j),\n/* harmony export */   context: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.f),\n/* harmony export */   createEvents: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.c),\n/* harmony export */   createPortal: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.g),\n/* harmony export */   createRoot: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.b),\n/* harmony export */   dispose: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.k),\n/* harmony export */   events: () => (/* binding */ createPointerEvents),\n/* harmony export */   extend: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.e),\n/* harmony export */   flushGlobalEffects: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.q),\n/* harmony export */   getRootState: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.s),\n/* harmony export */   invalidate: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.l),\n/* harmony export */   reconciler: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.h),\n/* harmony export */   render: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.r),\n/* harmony export */   unmountComponentAtNode: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.d),\n/* harmony export */   useFrame: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.A),\n/* harmony export */   useGraph: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.C),\n/* harmony export */   useInstanceHandle: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.x),\n/* harmony export */   useLoader: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.D),\n/* harmony export */   useStore: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.y),\n/* harmony export */   useThree: () => (/* reexport safe */ _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.z)\n/* harmony export */ });\n/* harmony import */ var _index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./index-673ef987.esm.js */ \"(ssr)/./node_modules/@react-three/fiber/dist/index-673ef987.esm.js\");\n/* harmony import */ var _babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! @babel/runtime/helpers/esm/extends */ \"(ssr)/./node_modules/@babel/runtime/helpers/esm/extends.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_2___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_2__);\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.module.js\");\n/* harmony import */ var react_use_measure__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! react-use-measure */ \"(ssr)/./node_modules/react-use-measure/dist/index.js\");\n/* harmony import */ var its_fine__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! its-fine */ \"(ssr)/./node_modules/its-fine/dist/index.js\");\n/* harmony import */ var react_reconciler_constants__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! react-reconciler/constants */ \"(ssr)/./node_modules/react-reconciler/constants.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! react-reconciler */ \"(ssr)/./node_modules/react-reconciler/index.js\");\n/* harmony import */ var react_reconciler__WEBPACK_IMPORTED_MODULE_4___default = /*#__PURE__*/__webpack_require__.n(react_reconciler__WEBPACK_IMPORTED_MODULE_4__);\n/* harmony import */ var scheduler__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! scheduler */ \"(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/index.js\");\n\n\n\n\n\n\n\n\n\n\n\n\nconst DOM_EVENTS = {\n    onClick: [\n        \"click\",\n        false\n    ],\n    onContextMenu: [\n        \"contextmenu\",\n        false\n    ],\n    onDoubleClick: [\n        \"dblclick\",\n        false\n    ],\n    onWheel: [\n        \"wheel\",\n        true\n    ],\n    onPointerDown: [\n        \"pointerdown\",\n        true\n    ],\n    onPointerUp: [\n        \"pointerup\",\n        true\n    ],\n    onPointerLeave: [\n        \"pointerleave\",\n        true\n    ],\n    onPointerMove: [\n        \"pointermove\",\n        true\n    ],\n    onPointerCancel: [\n        \"pointercancel\",\n        true\n    ],\n    onLostPointerCapture: [\n        \"lostpointercapture\",\n        true\n    ]\n};\n/** Default R3F event manager for web */ function createPointerEvents(store) {\n    const { handlePointer } = (0,_index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.c)(store);\n    return {\n        priority: 1,\n        enabled: true,\n        compute (event, state, previous) {\n            // https://github.com/pmndrs/react-three-fiber/pull/782\n            // Events trigger outside of canvas when moved, use offsetX/Y by default and allow overrides\n            state.pointer.set(event.offsetX / state.size.width * 2 - 1, -(event.offsetY / state.size.height) * 2 + 1);\n            state.raycaster.setFromCamera(state.pointer, state.camera);\n        },\n        connected: undefined,\n        handlers: Object.keys(DOM_EVENTS).reduce((acc, key)=>({\n                ...acc,\n                [key]: handlePointer(key)\n            }), {}),\n        update: ()=>{\n            var _internal$lastEvent;\n            const { events, internal } = store.getState();\n            if ((_internal$lastEvent = internal.lastEvent) != null && _internal$lastEvent.current && events.handlers) events.handlers.onPointerMove(internal.lastEvent.current);\n        },\n        connect: (target)=>{\n            var _events$handlers;\n            const { set, events } = store.getState();\n            events.disconnect == null ? void 0 : events.disconnect();\n            set((state)=>({\n                    events: {\n                        ...state.events,\n                        connected: target\n                    }\n                }));\n            Object.entries((_events$handlers = events.handlers) != null ? _events$handlers : []).forEach(([name, event])=>{\n                const [eventName, passive] = DOM_EVENTS[name];\n                target.addEventListener(eventName, event, {\n                    passive\n                });\n            });\n        },\n        disconnect: ()=>{\n            const { set, events } = store.getState();\n            if (events.connected) {\n                var _events$handlers2;\n                Object.entries((_events$handlers2 = events.handlers) != null ? _events$handlers2 : []).forEach(([name, event])=>{\n                    if (events && events.connected instanceof HTMLElement) {\n                        const [eventName] = DOM_EVENTS[name];\n                        events.connected.removeEventListener(eventName, event);\n                    }\n                });\n                set((state)=>({\n                        events: {\n                            ...state.events,\n                            connected: undefined\n                        }\n                    }));\n            }\n        }\n    };\n}\nconst CanvasImpl = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.forwardRef(function Canvas({ children, fallback, resize, style, gl, events = createPointerEvents, eventSource, eventPrefix, shadows, linear, flat, legacy, orthographic, frameloop, dpr, performance, raycaster, camera, onPointerMissed, onCreated, ...props }, forwardedRef) {\n    // Create a known catalogue of Threejs-native elements\n    // This will include the entire THREE namespace by default, users can extend\n    // their own elements by using the createRoot API instead\n    react__WEBPACK_IMPORTED_MODULE_2__.useMemo(()=>(0,_index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.e)(three__WEBPACK_IMPORTED_MODULE_6__), []);\n    const Bridge = (0,its_fine__WEBPACK_IMPORTED_MODULE_7__.useContextBridge)();\n    const [containerRef, containerRect] = (0,react_use_measure__WEBPACK_IMPORTED_MODULE_8__[\"default\"])({\n        scroll: true,\n        debounce: {\n            scroll: 50,\n            resize: 0\n        },\n        ...resize\n    });\n    const canvasRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(null);\n    const divRef = react__WEBPACK_IMPORTED_MODULE_2__.useRef(null);\n    react__WEBPACK_IMPORTED_MODULE_2__.useImperativeHandle(forwardedRef, ()=>canvasRef.current);\n    const handlePointerMissed = (0,_index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.u)(onPointerMissed);\n    const [block, setBlock] = react__WEBPACK_IMPORTED_MODULE_2__.useState(false);\n    const [error, setError] = react__WEBPACK_IMPORTED_MODULE_2__.useState(false);\n    // Suspend this component if block is a promise (2nd run)\n    if (block) throw block;\n    // Throw exception outwards if anything within canvas throws\n    if (error) throw error;\n    const root = react__WEBPACK_IMPORTED_MODULE_2__.useRef(null);\n    (0,_index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.a)(()=>{\n        const canvas = canvasRef.current;\n        if (containerRect.width > 0 && containerRect.height > 0 && canvas) {\n            if (!root.current) root.current = (0,_index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.b)(canvas);\n            root.current.configure({\n                gl,\n                events,\n                shadows,\n                linear,\n                flat,\n                legacy,\n                orthographic,\n                frameloop,\n                dpr,\n                performance,\n                raycaster,\n                camera,\n                size: containerRect,\n                // Pass mutable reference to onPointerMissed so it's free to update\n                onPointerMissed: (...args)=>handlePointerMissed.current == null ? void 0 : handlePointerMissed.current(...args),\n                onCreated: (state)=>{\n                    // Connect to event source\n                    state.events.connect == null ? void 0 : state.events.connect(eventSource ? (0,_index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.i)(eventSource) ? eventSource.current : eventSource : divRef.current);\n                    // Set up compute function\n                    if (eventPrefix) {\n                        state.setEvents({\n                            compute: (event, state)=>{\n                                const x = event[eventPrefix + \"X\"];\n                                const y = event[eventPrefix + \"Y\"];\n                                state.pointer.set(x / state.size.width * 2 - 1, -(y / state.size.height) * 2 + 1);\n                                state.raycaster.setFromCamera(state.pointer, state.camera);\n                            }\n                        });\n                    }\n                    // Call onCreated callback\n                    onCreated == null ? void 0 : onCreated(state);\n                }\n            });\n            root.current.render(/*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(Bridge, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(_index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.E, {\n                set: setError\n            }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(react__WEBPACK_IMPORTED_MODULE_2__.Suspense, {\n                fallback: /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(_index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.B, {\n                    set: setBlock\n                })\n            }, children))));\n        }\n    });\n    react__WEBPACK_IMPORTED_MODULE_2__.useEffect(()=>{\n        const canvas = canvasRef.current;\n        if (canvas) return ()=>(0,_index_673ef987_esm_js__WEBPACK_IMPORTED_MODULE_0__.d)(canvas);\n    }, []);\n    // When the event source is not this div, we need to set pointer-events to none\n    // Or else the canvas will block events from reaching the event source\n    const pointerEvents = eventSource ? \"none\" : \"auto\";\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(\"div\", (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({\n        ref: divRef,\n        style: {\n            position: \"relative\",\n            width: \"100%\",\n            height: \"100%\",\n            overflow: \"hidden\",\n            pointerEvents,\n            ...style\n        }\n    }, props), /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(\"div\", {\n        ref: containerRef,\n        style: {\n            width: \"100%\",\n            height: \"100%\"\n        }\n    }, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(\"canvas\", {\n        ref: canvasRef,\n        style: {\n            display: \"block\"\n        }\n    }, fallback)));\n});\n/**\n * A DOM canvas which accepts threejs elements as children.\n * @see https://docs.pmnd.rs/react-three-fiber/api/canvas\n */ const Canvas = /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.forwardRef(function CanvasWrapper(props, ref) {\n    return /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(its_fine__WEBPACK_IMPORTED_MODULE_7__.FiberProvider, null, /*#__PURE__*/ react__WEBPACK_IMPORTED_MODULE_2__.createElement(CanvasImpl, (0,_babel_runtime_helpers_esm_extends__WEBPACK_IMPORTED_MODULE_1__[\"default\"])({}, props, {\n        ref: ref\n    })));\n});\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL2Rpc3QvcmVhY3QtdGhyZWUtZmliZXIuZXNtLmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7OztBQUE0TjtBQUN3UTtBQUMxYTtBQUMzQjtBQUNBO0FBQ1k7QUFDZ0I7QUFDdkI7QUFDbkI7QUFDUztBQUNQO0FBQ0k7QUFFdkIsTUFBTW9FLGFBQWE7SUFDakJDLFNBQVM7UUFBQztRQUFTO0tBQU07SUFDekJDLGVBQWU7UUFBQztRQUFlO0tBQU07SUFDckNDLGVBQWU7UUFBQztRQUFZO0tBQU07SUFDbENDLFNBQVM7UUFBQztRQUFTO0tBQUs7SUFDeEJDLGVBQWU7UUFBQztRQUFlO0tBQUs7SUFDcENDLGFBQWE7UUFBQztRQUFhO0tBQUs7SUFDaENDLGdCQUFnQjtRQUFDO1FBQWdCO0tBQUs7SUFDdENDLGVBQWU7UUFBQztRQUFlO0tBQUs7SUFDcENDLGlCQUFpQjtRQUFDO1FBQWlCO0tBQUs7SUFDeENDLHNCQUFzQjtRQUFDO1FBQXNCO0tBQUs7QUFDcEQ7QUFFQSxzQ0FBc0MsR0FDdEMsU0FBU0Msb0JBQW9CQyxLQUFLO0lBQ2hDLE1BQU0sRUFDSkMsYUFBYSxFQUNkLEdBQUdoRix5REFBWUEsQ0FBQytFO0lBQ2pCLE9BQU87UUFDTEUsVUFBVTtRQUNWQyxTQUFTO1FBQ1RDLFNBQVFDLEtBQUssRUFBRUMsS0FBSyxFQUFFQyxRQUFRO1lBQzVCLHVEQUF1RDtZQUN2RCw0RkFBNEY7WUFDNUZELE1BQU1FLE9BQU8sQ0FBQ0MsR0FBRyxDQUFDSixNQUFNSyxPQUFPLEdBQUdKLE1BQU1LLElBQUksQ0FBQ0MsS0FBSyxHQUFHLElBQUksR0FBRyxDQUFFUCxDQUFBQSxNQUFNUSxPQUFPLEdBQUdQLE1BQU1LLElBQUksQ0FBQ0csTUFBTSxJQUFJLElBQUk7WUFDdkdSLE1BQU1TLFNBQVMsQ0FBQ0MsYUFBYSxDQUFDVixNQUFNRSxPQUFPLEVBQUVG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LE9BQU8sSUFBTXBKLHlEQUFzQkEsQ0FBQ29KO0lBQ2xELEdBQUcsRUFBRTtJQUVMLCtFQUErRTtJQUMvRSxzRUFBc0U7SUFDdEUsTUFBTU8sZ0JBQWdCdEMsY0FBYyxTQUFTO0lBQzdDLE9BQU8sV0FBVyxHQUFFdkUsZ0RBQW1CLENBQUMsT0FBT0QsOEVBQVFBLENBQUM7UUFDdEQrRyxLQUFLakI7UUFDTHhCLE9BQU87WUFDTDBDLFVBQVU7WUFDVmxGLE9BQU87WUFDUEUsUUFBUTtZQUNSaUYsVUFBVTtZQUNWSDtZQUNBLEdBQUd4QyxLQUFLO1FBQ1Y7SUFDRixHQUFHYyxRQUFRLFdBQVcsR0FBRW5GLGdEQUFtQixDQUFDLE9BQU87UUFDakQ4RyxLQUFLdkI7UUFDTGxCLE9BQU87WUFDTHhDLE9BQU87WUFDUEUsUUFBUTtRQUNWO0lBQ0YsR0FBRyxXQUFXLEdBQUUvQixnREFBbUIsQ0FBQyxVQUFVO1FBQzVDOEcsS0FBS25CO1FBQ0x0QixPQUFPO1lBQ0w0QyxTQUFTO1FBQ1g7SUFDRixHQUFHOUM7QUFDTDtBQUVBOzs7Q0FHQyxHQUNELE1BQU1GLFNBQVMsV0FBVyxHQUFFakUsNkNBQWdCLENBQUMsU0FBU2tILGNBQWMvQixLQUFLLEVBQUUyQixHQUFHO0lBQzVFLE9BQU8sV0FBVyxHQUFFOUcsZ0RBQW1CLENBQUNHLG1EQUFhQSxFQUFFLE1BQU0sV0FBVyxHQUFFSCxnREFBbUIsQ0FBQytELFlBQVloRSw4RUFBUUEsQ0FBQyxDQUFDLEdBQUdvRixPQUFPO1FBQzVIMkIsS0FBS0E7SUFDUDtBQUNGO0FBRWlEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmliZS0zZC1jb2RlLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9maWJlci9kaXN0L3JlYWN0LXRocmVlLWZpYmVyLmVzbS5qcz83OWNkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGMgYXMgY3JlYXRlRXZlbnRzLCBlIGFzIGV4dGVuZCwgdSBhcyB1c2VNdXRhYmxlQ2FsbGJhY2ssIGEgYXMgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCwgYiBhcyBjcmVhdGVSb290LCBpIGFzIGlzUmVmLCBFIGFzIEVycm9yQm91bmRhcnksIEIgYXMgQmxvY2ssIGQgYXMgdW5tb3VudENvbXBvbmVudEF0Tm9kZSB9IGZyb20gJy4vaW5kZXgtNjczZWY5ODcuZXNtLmpzJztcbmV4cG9ydCB7IHQgYXMgUmVhY3RUaHJlZUZpYmVyLCB3IGFzIF9yb290cywgdiBhcyBhY3QsIG8gYXMgYWRkQWZ0ZXJFZmZlY3QsIG4gYXMgYWRkRWZmZWN0LCBwIGFzIGFkZFRhaWwsIG0gYXMgYWR2YW5jZSwgaiBhcyBhcHBseVByb3BzLCBmIGFzIGNvbnRleHQsIGMgYXMgY3JlYXRlRXZlbnRzLCBnIGFzIGNyZWF0ZVBvcnRhbCwgYiBhcyBjcmVhdGVSb290LCBrIGFzIGRpc3Bvc2UsIGUgYXMgZXh0ZW5kLCBxIGFzIGZsdXNoR2xvYmFsRWZmZWN0cywgcyBhcyBnZXRSb290U3RhdGUsIGwgYXMgaW52YWxpZGF0ZSwgaCBhcyByZWNvbmNpbGVyLCByIGFzIHJlbmRlciwgZCBhcyB1bm1vdW50Q29tcG9uZW50QXROb2RlLCBBIGFzIHVzZUZyYW1lLCBDIGFzIHVzZUdyYXBoLCB4IGFzIHVzZUluc3RhbmNlSGFuZGxlLCBEIGFzIHVzZUxvYWRlciwgeSBhcyB1c2VTdG9yZSwgeiBhcyB1c2VUaHJlZSB9IGZyb20gJy4vaW5kZXgtNjczZWY5ODcuZXNtLmpzJztcbmltcG9ydCBfZXh0ZW5kcyBmcm9tICdAYmFiZWwvcnVudGltZS9oZWxwZXJzL2VzbS9leHRlbmRzJztcbmltcG9ydCAqIGFzIFJlYWN0IGZyb20gJ3JlYWN0JztcbmltcG9ydCAqIGFzIFRIUkVFIGZyb20gJ3RocmVlJztcbmltcG9ydCB1c2VNZWFzdXJlIGZyb20gJ3JlYWN0LXVzZS1tZWFzdXJlJztcbmltcG9ydCB7IEZpYmVyUHJvdmlkZXIsIHVzZUNvbnRleHRCcmlkZ2UgfSBmcm9tICdpdHMtZmluZSc7XG5pbXBvcnQgJ3JlYWN0LXJlY29uY2lsZXIvY29uc3RhbnRzJztcbmltcG9ydCAnenVzdGFuZCc7XG5pbXBvcnQgJ3JlYWN0LXJlY29uY2lsZXInO1xuaW1wb3J0ICdzY2hlZHVsZXInO1xuaW1wb3J0ICdzdXNwZW5kLXJlYWN0JztcblxuY29uc3QgRE9NX0VWRU5UUyA9IHtcbiAgb25DbGljazogWydjbGljaycsIGZhbHNlXSxcbiAgb25Db250ZXh0TWVudTogWydjb250ZXh0bWVudScsIGZhbHNlXSxcbiAgb25Eb3VibGVDbGljazogWydkYmxjbGljaycsIGZhbHNlXSxcbiAgb25XaGVlbDogWyd3aGVlbCcsIHRydWVdLFxuICBvblBvaW50ZXJEb3duOiBbJ3BvaW50ZXJkb3duJywgdHJ1ZV0sXG4gIG9uUG9pbnRlclVwOiBbJ3BvaW50ZXJ1cCcsIHRydWVdLFxuICBvblBvaW50ZXJMZWF2ZTogWydwb2ludGVybGVhdmUnLCB0cnVlXSxcbiAgb25Qb2ludGVyTW92ZTogWydwb2ludGVybW92ZScsIHRydWVdLFxuICBvblBvaW50ZXJDYW5jZWw6IFsncG9pbnRlcmNhbmNlbCcsIHRydWVdLFxuICBvbkxvc3RQb2ludGVyQ2FwdHVyZTogWydsb3N0cG9pbnRlcmNhcHR1cmUnLCB0cnVlXVxufTtcblxuLyoqIERlZmF1bHQgUjNGIGV2ZW50IG1hbmFnZXIgZm9yIHdlYiAqL1xuZnVuY3Rpb24gY3JlYXRlUG9pbnRlckV2ZW50cyhzdG9yZSkge1xuICBjb25zdCB7XG4gICAgaGFuZGxlUG9pbnRlclxuICB9ID0gY3JlYXRlRXZlbnRzKHN0b3JlKTtcbiAgcmV0dXJuIHtcbiAgICBwcmlvcml0eTogMSxcbiAgICBlbmFibGVkOiB0cnVlLFxuICAgIGNvbXB1dGUoZXZlbnQsIHN0YXRlLCBwcmV2aW91cykge1xuICAgICAgLy8gaHR0cHM6Ly9naXRodWIuY29tL3BtbmRycy9yZWFjdC10aHJlZS1maWJlci9wdWxsLzc4MlxuICAgICAgLy8gRXZlbnRzIHRyaWdnZXIgb3V0c2lkZSBvZiBjYW52YXMgd2hlbiBtb3ZlZCwgdXNlIG9mZnNldFgvWSBieSBkZWZhdWx0IGFuZCBhbGxvdyBvdmVycmlkZXNcbiAgICAgIHN0YXRlLnBvaW50ZXIuc2V0KGV2ZW50Lm9mZnNldFggLyBzdGF0ZS5zaXplLndpZHRoICogMiAtIDEsIC0oZXZlbnQub2Zmc2V0WSAvIHN0YXRlLnNpemUuaGVpZ2h0KSAqIDIgKyAxKTtcbiAgICAgIHN0YXRlLnJheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKHN0YXRlLnBvaW50ZXIsIHN0YXRlLmNhbWVyYSk7XG4gICAgfSxcbiAgICBjb25uZWN0ZWQ6IHVuZGVmaW5lZCxcbiAgICBoYW5kbGVyczogT2JqZWN0LmtleXMoRE9NX0VWRU5UUykucmVkdWNlKChhY2MsIGtleSkgPT4gKHtcbiAgICAgIC4uLmFjYyxcbiAgICAgIFtrZXldOiBoYW5kbGVQb2ludGVyKGtleSlcbiAgICB9KSwge30pLFxuICAgIHVwZGF0ZTogKCkgPT4ge1xuICAgICAgdmFyIF9pbnRlcm5hbCRsYXN0RXZlbnQ7XG4gICAgICBjb25zdCB7XG4gICAgICAgIGV2ZW50cyxcbiAgICAgICAgaW50ZXJuYWxcbiAgICAgIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgaWYgKChfaW50ZXJuYWwkbGFzdEV2ZW50ID0gaW50ZXJuYWwubGFzdEV2ZW50KSAhPSBudWxsICYmIF9pbnRlcm5hbCRsYXN0RXZlbnQuY3VycmVudCAmJiBldmVudHMuaGFuZGxlcnMpIGV2ZW50cy5oYW5kbGVycy5vblBvaW50ZXJNb3ZlKGludGVybmFsLmxhc3RFdmVudC5jdXJyZW50KTtcbiAgICB9LFxuICAgIGNvbm5lY3Q6IHRhcmdldCA9PiB7XG4gICAgICB2YXIgX2V2ZW50cyRoYW5kbGVycztcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2V0LFxuICAgICAgICBldmVudHNcbiAgICAgIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgZXZlbnRzLmRpc2Nvbm5lY3QgPT0gbnVsbCA/IHZvaWQgMCA6IGV2ZW50cy5kaXNjb25uZWN0KCk7XG4gICAgICBzZXQoc3RhdGUgPT4gKHtcbiAgICAgICAgZXZlbnRzOiB7XG4gICAgICAgICAgLi4uc3RhdGUuZXZlbnRzLFxuICAgICAgICAgIGNvbm5lY3RlZDogdGFyZ2V0XG4gICAgICAgIH1cbiAgICAgIH0pKTtcbiAgICAgIE9iamVjdC5lbnRyaWVzKChfZXZlbnRzJGhhbmRsZXJzID0gZXZlbnRzLmhhbmRsZXJzKSAhPSBudWxsID8gX2V2ZW50cyRoYW5kbGVycyA6IFtdKS5mb3JFYWNoKChbbmFtZSwgZXZlbnRdKSA9PiB7XG4gICAgICAgIGNvbnN0IFtldmVudE5hbWUsIHBhc3NpdmVdID0gRE9NX0VWRU5UU1tuYW1lXTtcbiAgICAgICAgdGFyZ2V0LmFkZEV2ZW50TGlzdGVuZXIoZXZlbnROYW1lLCBldmVudCwge1xuICAgICAgICAgIHBhc3NpdmVcbiAgICAgICAgfSk7XG4gICAgICB9KTtcbiAgICB9LFxuICAgIGRpc2Nvbm5lY3Q6ICgpID0+IHtcbiAgICAgIGNvbnN0IHtcbiAgICAgICAgc2V0LFxuICAgICAgICBldmVudHNcbiAgICAgIH0gPSBzdG9yZS5nZXRTdGF0ZSgpO1xuICAgICAgaWYgKGV2ZW50cy5jb25uZWN0ZWQpIHtcbiAgICAgICAgdmFyIF9ldmVudHMkaGFuZGxlcnMyO1xuICAgICAgICBPYmplY3QuZW50cmllcygoX2V2ZW50cyRoYW5kbGVyczIgPSBldmVudHMuaGFuZGxlcnMpICE9IG51bGwgPyBfZXZlbnRzJGhhbmRsZXJzMiA6IFtdKS5mb3JFYWNoKChbbmFtZSwgZXZlbnRdKSA9PiB7XG4gICAgICAgICAgaWYgKGV2ZW50cyAmJiBldmVudHMuY29ubmVjdGVkIGluc3RhbmNlb2YgSFRNTEVsZW1lbnQpIHtcbiAgICAgICAgICAgIGNvbnN0IFtldmVudE5hbWVdID0gRE9NX0VWRU5UU1tuYW1lXTtcbiAgICAgICAgICAgIGV2ZW50cy5jb25uZWN0ZWQucmVtb3ZlRXZlbnRMaXN0ZW5lcihldmVudE5hbWUsIGV2ZW50KTtcbiAgICAgICAgICB9XG4gICAgICAgIH0pO1xuICAgICAgICBzZXQoc3RhdGUgPT4gKHtcbiAgICAgICAgICBldmVudHM6IHtcbiAgICAgICAgICAgIC4uLnN0YXRlLmV2ZW50cyxcbiAgICAgICAgICAgIGNvbm5lY3RlZDogdW5kZWZpbmVkXG4gICAgICAgICAgfVxuICAgICAgICB9KSk7XG4gICAgICB9XG4gICAgfVxuICB9O1xufVxuXG5jb25zdCBDYW52YXNJbXBsID0gLyojX19QVVJFX18qL1JlYWN0LmZvcndhcmRSZWYoZnVuY3Rpb24gQ2FudmFzKHtcbiAgY2hpbGRyZW4sXG4gIGZhbGxiYWNrLFxuICByZXNpemUsXG4gIHN0eWxlLFxuICBnbCxcbiAgZXZlbnRzID0gY3JlYXRlUG9pbnRlckV2ZW50cyxcbiAgZXZlbnRTb3VyY2UsXG4gIGV2ZW50UHJlZml4LFxuICBzaGFkb3dzLFxuICBsaW5lYXIsXG4gIGZsYXQsXG4gIGxlZ2FjeSxcbiAgb3J0aG9ncmFwaGljLFxuICBmcmFtZWxvb3AsXG4gIGRwcixcbiAgcGVyZm9ybWFuY2UsXG4gIHJheWNhc3RlcixcbiAgY2FtZXJhLFxuICBvblBvaW50ZXJNaXNzZWQsXG4gIG9uQ3JlYXRlZCxcbiAgLi4ucHJvcHNcbn0sIGZvcndhcmRlZFJlZikge1xuICAvLyBDcmVhdGUgYSBrbm93biBjYXRhbG9ndWUgb2YgVGhyZWVqcy1uYXRpdmUgZWxlbWVudHNcbiAgLy8gVGhpcyB3aWxsIGluY2x1ZGUgdGhlIGVudGlyZSBUSFJFRSBuYW1lc3BhY2UgYnkgZGVmYXVsdCwgdXNlcnMgY2FuIGV4dGVuZFxuICAvLyB0aGVpciBvd24gZWxlbWVudHMgYnkgdXNpbmcgdGhlIGNyZWF0ZVJvb3QgQVBJIGluc3RlYWRcbiAgUmVhY3QudXNlTWVtbygoKSA9PiBleHRlbmQoVEhSRUUpLCBbXSk7XG4gIGNvbnN0IEJyaWRnZSA9IHVzZUNvbnRleHRCcmlkZ2UoKTtcbiAgY29uc3QgW2NvbnRhaW5lclJlZiwgY29udGFpbmVyUmVjdF0gPSB1c2VNZWFzdXJlKHtcbiAgICBzY3JvbGw6IHRydWUsXG4gICAgZGVib3VuY2U6IHtcbiAgICAgIHNjcm9sbDogNTAsXG4gICAgICByZXNpemU6IDBcbiAgICB9LFxuICAgIC4uLnJlc2l6ZVxuICB9KTtcbiAgY29uc3QgY2FudmFzUmVmID0gUmVhY3QudXNlUmVmKG51bGwpO1xuICBjb25zdCBkaXZSZWYgPSBSZWFjdC51c2VSZWYobnVsbCk7XG4gIFJlYWN0LnVzZUltcGVyYXRpdmVIYW5kbGUoZm9yd2FyZGVkUmVmLCAoKSA9PiBjYW52YXNSZWYuY3VycmVudCk7XG4gIGNvbnN0IGhhbmRsZVBvaW50ZXJNaXNzZWQgPSB1c2VNdXRhYmxlQ2FsbGJhY2sob25Qb2ludGVyTWlzc2VkKTtcbiAgY29uc3QgW2Jsb2NrLCBzZXRCbG9ja10gPSBSZWFjdC51c2VTdGF0ZShmYWxzZSk7XG4gIGNvbnN0IFtlcnJvciwgc2V0RXJyb3JdID0gUmVhY3QudXNlU3RhdGUoZmFsc2UpO1xuXG4gIC8vIFN1c3BlbmQgdGhpcyBjb21wb25lbnQgaWYgYmxvY2sgaXMgYSBwcm9taXNlICgybmQgcnVuKVxuICBpZiAoYmxvY2spIHRocm93IGJsb2NrO1xuICAvLyBUaHJvdyBleGNlcHRpb24gb3V0d2FyZHMgaWYgYW55dGhpbmcgd2l0aGluIGNhbnZhcyB0aHJvd3NcbiAgaWYgKGVycm9yKSB0aHJvdyBlcnJvcjtcbiAgY29uc3Qgcm9vdCA9IFJlYWN0LnVzZVJlZihudWxsKTtcbiAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgaWYgKGNvbnRhaW5lclJlY3Qud2lkdGggPiAwICYmIGNvbnRhaW5lclJlY3QuaGVpZ2h0ID4gMCAmJiBjYW52YXMpIHtcbiAgICAgIGlmICghcm9vdC5jdXJyZW50KSByb290LmN1cnJlbnQgPSBjcmVhdGVSb290KGNhbnZhcyk7XG4gICAgICByb290LmN1cnJlbnQuY29uZmlndXJlKHtcbiAgICAgICAgZ2wsXG4gICAgICAgIGV2ZW50cyxcbiAgICAgICAgc2hhZG93cyxcbiAgICAgICAgbGluZWFyLFxuICAgICAgICBmbGF0LFxuICAgICAgICBsZWdhY3ksXG4gICAgICAgIG9ydGhvZ3JhcGhpYyxcbiAgICAgICAgZnJhbWVsb29wLFxuICAgICAgICBkcHIsXG4gICAgICAgIHBlcmZvcm1hbmNlLFxuICAgICAgICByYXljYXN0ZXIsXG4gICAgICAgIGNhbWVyYSxcbiAgICAgICAgc2l6ZTogY29udGFpbmVyUmVjdCxcbiAgICAgICAgLy8gUGFzcyBtdXRhYmxlIHJlZmVyZW5jZSB0byBvblBvaW50ZXJNaXNzZWQgc28gaXQncyBmcmVlIHRvIHVwZGF0ZVxuICAgICAgICBvblBvaW50ZXJNaXNzZWQ6ICguLi5hcmdzKSA9PiBoYW5kbGVQb2ludGVyTWlzc2VkLmN1cnJlbnQgPT0gbnVsbCA/IHZvaWQgMCA6IGhhbmRsZVBvaW50ZXJNaXNzZWQuY3VycmVudCguLi5hcmdzKSxcbiAgICAgICAgb25DcmVhdGVkOiBzdGF0ZSA9PiB7XG4gICAgICAgICAgLy8gQ29ubmVjdCB0byBldmVudCBzb3VyY2VcbiAgICAgICAgICBzdGF0ZS5ldmVudHMuY29ubmVjdCA9PSBudWxsID8gdm9pZCAwIDogc3RhdGUuZXZlbnRzLmNvbm5lY3QoZXZlbnRTb3VyY2UgPyBpc1JlZihldmVudFNvdXJjZSkgPyBldmVudFNvdXJjZS5jdXJyZW50IDogZXZlbnRTb3VyY2UgOiBkaXZSZWYuY3VycmVudCk7XG4gICAgICAgICAgLy8gU2V0IHVwIGNvbXB1dGUgZnVuY3Rpb25cbiAgICAgICAgICBpZiAoZXZlbnRQcmVmaXgpIHtcbiAgICAgICAgICAgIHN0YXRlLnNldEV2ZW50cyh7XG4gICAgICAgICAgICAgIGNvbXB1dGU6IChldmVudCwgc3RhdGUpID0+IHtcbiAgICAgICAgICAgICAgICBjb25zdCB4ID0gZXZlbnRbZXZlbnRQcmVmaXggKyAnWCddO1xuICAgICAgICAgICAgICAgIGNvbnN0IHkgPSBldmVudFtldmVudFByZWZpeCArICdZJ107XG4gICAgICAgICAgICAgICAgc3RhdGUucG9pbnRlci5zZXQoeCAvIHN0YXRlLnNpemUud2lkdGggKiAyIC0gMSwgLSh5IC8gc3RhdGUuc2l6ZS5oZWlnaHQpICogMiArIDEpO1xuICAgICAgICAgICAgICAgIHN0YXRlLnJheWNhc3Rlci5zZXRGcm9tQ2FtZXJhKHN0YXRlLnBvaW50ZXIsIHN0YXRlLmNhbWVyYSk7XG4gICAgICAgICAgICAgIH1cbiAgICAgICAgICAgIH0pO1xuICAgICAgICAgIH1cbiAgICAgICAgICAvLyBDYWxsIG9uQ3JlYXRlZCBjYWxsYmFja1xuICAgICAgICAgIG9uQ3JlYXRlZCA9PSBudWxsID8gdm9pZCAwIDogb25DcmVhdGVkKHN0YXRlKTtcbiAgICAgICAgfVxuICAgICAgfSk7XG4gICAgICByb290LmN1cnJlbnQucmVuZGVyKCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChCcmlkZ2UsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEVycm9yQm91bmRhcnksIHtcbiAgICAgICAgc2V0OiBzZXRFcnJvclxuICAgICAgfSwgLyojX19QVVJFX18qL1JlYWN0LmNyZWF0ZUVsZW1lbnQoUmVhY3QuU3VzcGVuc2UsIHtcbiAgICAgICAgZmFsbGJhY2s6IC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEJsb2NrLCB7XG4gICAgICAgICAgc2V0OiBzZXRCbG9ja1xuICAgICAgICB9KVxuICAgICAgfSwgY2hpbGRyZW4pKSkpO1xuICAgIH1cbiAgfSk7XG4gIFJlYWN0LnVzZUVmZmVjdCgoKSA9PiB7XG4gICAgY29uc3QgY2FudmFzID0gY2FudmFzUmVmLmN1cnJlbnQ7XG4gICAgaWYgKGNhbnZhcykgcmV0dXJuICgpID0+IHVubW91bnRDb21wb25lbnRBdE5vZGUoY2FudmFzKTtcbiAgfSwgW10pO1xuXG4gIC8vIFdoZW4gdGhlIGV2ZW50IHNvdXJjZSBpcyBub3QgdGhpcyBkaXYsIHdlIG5lZWQgdG8gc2V0IHBvaW50ZXItZXZlbnRzIHRvIG5vbmVcbiAgLy8gT3IgZWxzZSB0aGUgY2FudmFzIHdpbGwgYmxvY2sgZXZlbnRzIGZyb20gcmVhY2hpbmcgdGhlIGV2ZW50IHNvdXJjZVxuICBjb25zdCBwb2ludGVyRXZlbnRzID0gZXZlbnRTb3VyY2UgPyAnbm9uZScgOiAnYXV0byc7XG4gIHJldHVybiAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImRpdlwiLCBfZXh0ZW5kcyh7XG4gICAgcmVmOiBkaXZSZWYsXG4gICAgc3R5bGU6IHtcbiAgICAgIHBvc2l0aW9uOiAncmVsYXRpdmUnLFxuICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgIGhlaWdodDogJzEwMCUnLFxuICAgICAgb3ZlcmZsb3c6ICdoaWRkZW4nLFxuICAgICAgcG9pbnRlckV2ZW50cyxcbiAgICAgIC4uLnN0eWxlXG4gICAgfVxuICB9LCBwcm9wcyksIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KFwiZGl2XCIsIHtcbiAgICByZWY6IGNvbnRhaW5lclJlZixcbiAgICBzdHlsZToge1xuICAgICAgd2lkdGg6ICcxMDAlJyxcbiAgICAgIGhlaWdodDogJzEwMCUnXG4gICAgfVxuICB9LCAvKiNfX1BVUkVfXyovUmVhY3QuY3JlYXRlRWxlbWVudChcImNhbnZhc1wiLCB7XG4gICAgcmVmOiBjYW52YXNSZWYsXG4gICAgc3R5bGU6IHtcbiAgICAgIGRpc3BsYXk6ICdibG9jaydcbiAgICB9XG4gIH0sIGZhbGxiYWNrKSkpO1xufSk7XG5cbi8qKlxuICogQSBET00gY2FudmFzIHdoaWNoIGFjY2VwdHMgdGhyZWVqcyBlbGVtZW50cyBhcyBjaGlsZHJlbi5cbiAqIEBzZWUgaHR0cHM6Ly9kb2NzLnBtbmQucnMvcmVhY3QtdGhyZWUtZmliZXIvYXBpL2NhbnZhc1xuICovXG5jb25zdCBDYW52YXMgPSAvKiNfX1BVUkVfXyovUmVhY3QuZm9yd2FyZFJlZihmdW5jdGlvbiBDYW52YXNXcmFwcGVyKHByb3BzLCByZWYpIHtcbiAgcmV0dXJuIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KEZpYmVyUHJvdmlkZXIsIG51bGwsIC8qI19fUFVSRV9fKi9SZWFjdC5jcmVhdGVFbGVtZW50KENhbnZhc0ltcGwsIF9leHRlbmRzKHt9LCBwcm9wcywge1xuICAgIHJlZjogcmVmXG4gIH0pKSk7XG59KTtcblxuZXhwb3J0IHsgQ2FudmFzLCBjcmVhdGVQb2ludGVyRXZlbnRzIGFzIGV2ZW50cyB9O1xuIl0sIm5hbWVzIjpbImMiLCJjcmVhdGVFdmVudHMiLCJlIiwiZXh0ZW5kIiwidSIsInVzZU11dGFibGVDYWxsYmFjayIsImEiLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IiwiYiIsImNyZWF0ZVJvb3QiLCJpIiwiaXNSZWYiLCJFIiwiRXJyb3JCb3VuZGFyeSIsIkIiLCJCbG9jayIsImQiLCJ1bm1vdW50Q29tcG9uZW50QXROb2RlIiwidCIsIlJlYWN0VGhyZWVGaWJlciIsInciLCJfcm9vdHMiLCJ2IiwiYWN0IiwibyIsImFkZEFmdGVyRWZmZWN0IiwibiIsImFkZEVmZmVjdCIsInAiLCJhZGRUYWlsIiwibSIsImFkdmFuY2UiLCJqIiwiYXBwbHlQcm9wcyIsImYiLCJjb250ZXh0IiwiZyIsImNyZWF0ZVBvcnRhbCIsImsiLCJkaXNwb3NlIiwicSIsImZsdXNoR2xvYmFsRWZmZWN0cyIsInMiLCJnZXRSb290U3RhdGUiLCJsIiwiaW52YWxpZGF0ZSIsImgiLCJyZWNvbmNpbGVyIiwiciIsInJlbmRlciIsIkEiLCJ1c2VGcmFtZSIsIkMiLCJ1c2VHcmFwaCIsIngiLCJ1c2VJbnN0YW5jZUhhbmRsZSIsIkQiLCJ1c2VMb2FkZXIiLCJ5IiwidXNlU3RvcmUiLCJ6IiwidXNlVGhyZWUiLCJfZXh0ZW5kcyIsIlJlYWN0IiwiVEhSRUUiLCJ1c2VNZWFzdXJlIiwiRmliZXJQcm92aWRlciIsInVzZUNvbnRleHRCcmlkZ2UiLCJET01fRVZFTlRTIiwib25DbGljayIsIm9uQ29udGV4dE1lbnUiLCJvbkRvdWJsZUNsaWNrIiwib25XaGVlbCIsIm9uUG9pbnRlckRvd24iLCJvblBvaW50ZXJVcCIsIm9uUG9pbnRlckxlYXZlIiwib25Qb2ludGVyTW92ZSIsIm9uUG9pbnRlckNhbmNlbCIsIm9uTG9zdFBvaW50ZXJDYXB0dXJlIiwiY3JlYXRlUG9pbnRlckV2ZW50cyIsInN0b3JlIiwiaGFuZGxlUG9pbnRlciIsInByaW9yaXR5IiwiZW5hYmxlZCIsImNvbXB1dGUiLCJldmVudCIsInN0YXRlIiwicHJldmlvdXMiLCJwb2ludGVyIiwic2V0Iiwib2Zmc2V0WCIsInNpemUiLCJ3aWR0aCIsIm9mZnNldFkiLCJoZWlnaHQiLCJyYXljYXN0ZXIiLCJzZXRGcm9tQ2FtZXJhIiwiY2FtZXJhIiwiY29ubmVjdGVkIiwidW5kZWZpbmVkIiwiaGFuZGxlcnMiLCJPYmplY3QiLCJrZXlzIiwicmVkdWNlIiwiYWNjIiwia2V5IiwidXBkYXRlIiwiX2ludGVybmFsJGxhc3RFdmVudCIsImV2ZW50cyIsImludGVybmFsIiwiZ2V0U3RhdGUiLCJsYXN0RXZlbnQiLCJjdXJyZW50IiwiY29ubmVjdCIsInRhcmdldCIsIl9ldmVudHMkaGFuZGxlcnMiLCJkaXNjb25uZWN0IiwiZW50cmllcyIsImZvckVhY2giLCJuYW1lIiwiZXZlbnROYW1lIiwicGFzc2l2ZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJfZXZlbnRzJGhhbmRsZXJzMiIsIkhUTUxFbGVtZW50IiwicmVtb3ZlRXZlbnRMaXN0ZW5lciIsIkNhbnZhc0ltcGwiLCJmb3J3YXJkUmVmIiwiQ2FudmFzIiwiY2hpbGRyZW4iLCJmYWxsYmFjayIsInJlc2l6ZSIsInN0eWxlIiwiZ2wiLCJldmVudFNvdXJjZSIsImV2ZW50UHJlZml4Iiwic2hhZG93cyIsImxpbmVhciIsImZsYXQiLCJsZWdhY3kiLCJvcnRob2dyYXBoaWMiLCJmcmFtZWxvb3AiLCJkcHIiLCJwZXJmb3JtYW5jZSIsIm9uUG9pbnRlck1pc3NlZCIsIm9uQ3JlYXRlZCIsInByb3BzIiwiZm9yd2FyZGVkUmVmIiwidXNlTWVtbyIsIkJyaWRnZSIsImNvbnRhaW5lclJlZiIsImNvbnRhaW5lclJlY3QiLCJzY3JvbGwiLCJkZWJvdW5jZSIsImNhbnZhc1JlZiIsInVzZVJlZiIsImRpdlJlZiIsInVzZUltcGVyYXRpdmVIYW5kbGUiLCJoYW5kbGVQb2ludGVyTWlzc2VkIiwiYmxvY2siLCJzZXRCbG9jayIsInVzZVN0YXRlIiwiZXJyb3IiLCJzZXRFcnJvciIsInJvb3QiLCJjYW52YXMiLCJjb25maWd1cmUiLCJhcmdzIiwic2V0RXZlbnRzIiwiY3JlYXRlRWxlbWVudCIsIlN1c3BlbnNlIiwidXNlRWZmZWN0IiwicG9pbnRlckV2ZW50cyIsInJlZiIsInBvc2l0aW9uIiwib3ZlcmZsb3ciLCJkaXNwbGF5IiwiQ2FudmFzV3JhcHBlciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/dist/react-three-fiber.esm.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/cjs/scheduler.development.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@react-three/fiber/node_modules/scheduler/cjs/scheduler.development.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack_module, exports) => {

eval("/**\n * @license React\n * scheduler.development.js\n *\n * Copyright (c) Facebook, Inc. and its affiliates.\n *\n * This source code is licensed under the MIT license found in the\n * LICENSE file in the root directory of this source tree.\n */ \nif (true) {\n    (function() {\n        \"use strict\";\n        /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart === \"function\") {\n            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStart(new Error());\n        }\n        var enableSchedulerDebugging = false;\n        var enableProfiling = false;\n        var frameYieldMs = 5;\n        function push(heap, node) {\n            var index = heap.length;\n            heap.push(node);\n            siftUp(heap, node, index);\n        }\n        function peek(heap) {\n            return heap.length === 0 ? null : heap[0];\n        }\n        function pop(heap) {\n            if (heap.length === 0) {\n                return null;\n            }\n            var first = heap[0];\n            var last = heap.pop();\n            if (last !== first) {\n                heap[0] = last;\n                siftDown(heap, last, 0);\n            }\n            return first;\n        }\n        function siftUp(heap, node, i) {\n            var index = i;\n            while(index > 0){\n                var parentIndex = index - 1 >>> 1;\n                var parent = heap[parentIndex];\n                if (compare(parent, node) > 0) {\n                    // The parent is larger. Swap positions.\n                    heap[parentIndex] = node;\n                    heap[index] = parent;\n                    index = parentIndex;\n                } else {\n                    // The parent is smaller. Exit.\n                    return;\n                }\n            }\n        }\n        function siftDown(heap, node, i) {\n            var index = i;\n            var length = heap.length;\n            var halfLength = length >>> 1;\n            while(index < halfLength){\n                var leftIndex = (index + 1) * 2 - 1;\n                var left = heap[leftIndex];\n                var rightIndex = leftIndex + 1;\n                var right = heap[rightIndex]; // If the left or right node is smaller, swap with the smaller of those.\n                if (compare(left, node) < 0) {\n                    if (rightIndex < length && compare(right, left) < 0) {\n                        heap[index] = right;\n                        heap[rightIndex] = node;\n                        index = rightIndex;\n                    } else {\n                        heap[index] = left;\n                        heap[leftIndex] = node;\n                        index = leftIndex;\n                    }\n                } else if (rightIndex < length && compare(right, node) < 0) {\n                    heap[index] = right;\n                    heap[rightIndex] = node;\n                    index = rightIndex;\n                } else {\n                    // Neither child is smaller. Exit.\n                    return;\n                }\n            }\n        }\n        function compare(a, b) {\n            // Compare sort index first, then task id.\n            var diff = a.sortIndex - b.sortIndex;\n            return diff !== 0 ? diff : a.id - b.id;\n        }\n        // TODO: Use symbols?\n        var ImmediatePriority = 1;\n        var UserBlockingPriority = 2;\n        var NormalPriority = 3;\n        var LowPriority = 4;\n        var IdlePriority = 5;\n        function markTaskErrored(task, ms) {}\n        /* eslint-disable no-var */ var hasPerformanceNow = typeof performance === \"object\" && typeof performance.now === \"function\";\n        if (hasPerformanceNow) {\n            var localPerformance = performance;\n            exports.unstable_now = function() {\n                return localPerformance.now();\n            };\n        } else {\n            var localDate = Date;\n            var initialTime = localDate.now();\n            exports.unstable_now = function() {\n                return localDate.now() - initialTime;\n            };\n        } // Max 31 bit integer. The max integer size in V8 for 32-bit systems.\n        // Math.pow(2, 30) - 1\n        // 0b111111111111111111111111111111\n        var maxSigned31BitInt = 1073741823; // Times out immediately\n        var IMMEDIATE_PRIORITY_TIMEOUT = -1; // Eventually times out\n        var USER_BLOCKING_PRIORITY_TIMEOUT = 250;\n        var NORMAL_PRIORITY_TIMEOUT = 5000;\n        var LOW_PRIORITY_TIMEOUT = 10000; // Never times out\n        var IDLE_PRIORITY_TIMEOUT = maxSigned31BitInt; // Tasks are stored on a min heap\n        var taskQueue = [];\n        var timerQueue = []; // Incrementing id counter. Used to maintain insertion order.\n        var taskIdCounter = 1; // Pausing the scheduler is useful for debugging.\n        var currentTask = null;\n        var currentPriorityLevel = NormalPriority; // This is set while performing work, to prevent re-entrance.\n        var isPerformingWork = false;\n        var isHostCallbackScheduled = false;\n        var isHostTimeoutScheduled = false; // Capture local references to native APIs, in case a polyfill overrides them.\n        var localSetTimeout = typeof setTimeout === \"function\" ? setTimeout : null;\n        var localClearTimeout = typeof clearTimeout === \"function\" ? clearTimeout : null;\n        var localSetImmediate = typeof setImmediate !== \"undefined\" ? setImmediate : null; // IE and Node.js + jsdom\n        var isInputPending = typeof navigator !== \"undefined\" && navigator.scheduling !== undefined && navigator.scheduling.isInputPending !== undefined ? navigator.scheduling.isInputPending.bind(navigator.scheduling) : null;\n        function advanceTimers(currentTime) {\n            // Check for tasks that are no longer delayed and add them to the queue.\n            var timer = peek(timerQueue);\n            while(timer !== null){\n                if (timer.callback === null) {\n                    // Timer was cancelled.\n                    pop(timerQueue);\n                } else if (timer.startTime <= currentTime) {\n                    // Timer fired. Transfer to the task queue.\n                    pop(timerQueue);\n                    timer.sortIndex = timer.expirationTime;\n                    push(taskQueue, timer);\n                } else {\n                    // Remaining timers are pending.\n                    return;\n                }\n                timer = peek(timerQueue);\n            }\n        }\n        function handleTimeout(currentTime) {\n            isHostTimeoutScheduled = false;\n            advanceTimers(currentTime);\n            if (!isHostCallbackScheduled) {\n                if (peek(taskQueue) !== null) {\n                    isHostCallbackScheduled = true;\n                    requestHostCallback(flushWork);\n                } else {\n                    var firstTimer = peek(timerQueue);\n                    if (firstTimer !== null) {\n                        requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n                    }\n                }\n            }\n        }\n        function flushWork(hasTimeRemaining, initialTime) {\n            isHostCallbackScheduled = false;\n            if (isHostTimeoutScheduled) {\n                // We scheduled a timeout but it's no longer needed. Cancel it.\n                isHostTimeoutScheduled = false;\n                cancelHostTimeout();\n            }\n            isPerformingWork = true;\n            var previousPriorityLevel = currentPriorityLevel;\n            try {\n                if (enableProfiling) {\n                    try {\n                        return workLoop(hasTimeRemaining, initialTime);\n                    } catch (error) {\n                        if (currentTask !== null) {\n                            var currentTime = exports.unstable_now();\n                            markTaskErrored(currentTask, currentTime);\n                            currentTask.isQueued = false;\n                        }\n                        throw error;\n                    }\n                } else {\n                    // No catch in prod code path.\n                    return workLoop(hasTimeRemaining, initialTime);\n                }\n            } finally{\n                currentTask = null;\n                currentPriorityLevel = previousPriorityLevel;\n                isPerformingWork = false;\n            }\n        }\n        function workLoop(hasTimeRemaining, initialTime) {\n            var currentTime = initialTime;\n            advanceTimers(currentTime);\n            currentTask = peek(taskQueue);\n            while(currentTask !== null && !enableSchedulerDebugging){\n                if (currentTask.expirationTime > currentTime && (!hasTimeRemaining || shouldYieldToHost())) {\n                    break;\n                }\n                var callback = currentTask.callback;\n                if (typeof callback === \"function\") {\n                    currentTask.callback = null;\n                    currentPriorityLevel = currentTask.priorityLevel;\n                    var didUserCallbackTimeout = currentTask.expirationTime <= currentTime;\n                    var continuationCallback = callback(didUserCallbackTimeout);\n                    currentTime = exports.unstable_now();\n                    if (typeof continuationCallback === \"function\") {\n                        currentTask.callback = continuationCallback;\n                    } else {\n                        if (currentTask === peek(taskQueue)) {\n                            pop(taskQueue);\n                        }\n                    }\n                    advanceTimers(currentTime);\n                } else {\n                    pop(taskQueue);\n                }\n                currentTask = peek(taskQueue);\n            } // Return whether there's additional work\n            if (currentTask !== null) {\n                return true;\n            } else {\n                var firstTimer = peek(timerQueue);\n                if (firstTimer !== null) {\n                    requestHostTimeout(handleTimeout, firstTimer.startTime - currentTime);\n                }\n                return false;\n            }\n        }\n        function unstable_runWithPriority(priorityLevel, eventHandler) {\n            switch(priorityLevel){\n                case ImmediatePriority:\n                case UserBlockingPriority:\n                case NormalPriority:\n                case LowPriority:\n                case IdlePriority:\n                    break;\n                default:\n                    priorityLevel = NormalPriority;\n            }\n            var previousPriorityLevel = currentPriorityLevel;\n            currentPriorityLevel = priorityLevel;\n            try {\n                return eventHandler();\n            } finally{\n                currentPriorityLevel = previousPriorityLevel;\n            }\n        }\n        function unstable_next(eventHandler) {\n            var priorityLevel;\n            switch(currentPriorityLevel){\n                case ImmediatePriority:\n                case UserBlockingPriority:\n                case NormalPriority:\n                    // Shift down to normal priority\n                    priorityLevel = NormalPriority;\n                    break;\n                default:\n                    // Anything lower than normal priority should remain at the current level.\n                    priorityLevel = currentPriorityLevel;\n                    break;\n            }\n            var previousPriorityLevel = currentPriorityLevel;\n            currentPriorityLevel = priorityLevel;\n            try {\n                return eventHandler();\n            } finally{\n                currentPriorityLevel = previousPriorityLevel;\n            }\n        }\n        function unstable_wrapCallback(callback) {\n            var parentPriorityLevel = currentPriorityLevel;\n            return function() {\n                // This is a fork of runWithPriority, inlined for performance.\n                var previousPriorityLevel = currentPriorityLevel;\n                currentPriorityLevel = parentPriorityLevel;\n                try {\n                    return callback.apply(this, arguments);\n                } finally{\n                    currentPriorityLevel = previousPriorityLevel;\n                }\n            };\n        }\n        function unstable_scheduleCallback(priorityLevel, callback, options) {\n            var currentTime = exports.unstable_now();\n            var startTime;\n            if (typeof options === \"object\" && options !== null) {\n                var delay = options.delay;\n                if (typeof delay === \"number\" && delay > 0) {\n                    startTime = currentTime + delay;\n                } else {\n                    startTime = currentTime;\n                }\n            } else {\n                startTime = currentTime;\n            }\n            var timeout;\n            switch(priorityLevel){\n                case ImmediatePriority:\n                    timeout = IMMEDIATE_PRIORITY_TIMEOUT;\n                    break;\n                case UserBlockingPriority:\n                    timeout = USER_BLOCKING_PRIORITY_TIMEOUT;\n                    break;\n                case IdlePriority:\n                    timeout = IDLE_PRIORITY_TIMEOUT;\n                    break;\n                case LowPriority:\n                    timeout = LOW_PRIORITY_TIMEOUT;\n                    break;\n                case NormalPriority:\n                default:\n                    timeout = NORMAL_PRIORITY_TIMEOUT;\n                    break;\n            }\n            var expirationTime = startTime + timeout;\n            var newTask = {\n                id: taskIdCounter++,\n                callback: callback,\n                priorityLevel: priorityLevel,\n                startTime: startTime,\n                expirationTime: expirationTime,\n                sortIndex: -1\n            };\n            if (startTime > currentTime) {\n                // This is a delayed task.\n                newTask.sortIndex = startTime;\n                push(timerQueue, newTask);\n                if (peek(taskQueue) === null && newTask === peek(timerQueue)) {\n                    // All tasks are delayed, and this is the task with the earliest delay.\n                    if (isHostTimeoutScheduled) {\n                        // Cancel an existing timeout.\n                        cancelHostTimeout();\n                    } else {\n                        isHostTimeoutScheduled = true;\n                    } // Schedule a timeout.\n                    requestHostTimeout(handleTimeout, startTime - currentTime);\n                }\n            } else {\n                newTask.sortIndex = expirationTime;\n                push(taskQueue, newTask);\n                // wait until the next time we yield.\n                if (!isHostCallbackScheduled && !isPerformingWork) {\n                    isHostCallbackScheduled = true;\n                    requestHostCallback(flushWork);\n                }\n            }\n            return newTask;\n        }\n        function unstable_pauseExecution() {}\n        function unstable_continueExecution() {\n            if (!isHostCallbackScheduled && !isPerformingWork) {\n                isHostCallbackScheduled = true;\n                requestHostCallback(flushWork);\n            }\n        }\n        function unstable_getFirstCallbackNode() {\n            return peek(taskQueue);\n        }\n        function unstable_cancelCallback(task) {\n            // remove from the queue because you can't remove arbitrary nodes from an\n            // array based heap, only the first one.)\n            task.callback = null;\n        }\n        function unstable_getCurrentPriorityLevel() {\n            return currentPriorityLevel;\n        }\n        var isMessageLoopRunning = false;\n        var scheduledHostCallback = null;\n        var taskTimeoutID = -1; // Scheduler periodically yields in case there is other work on the main\n        // thread, like user events. By default, it yields multiple times per frame.\n        // It does not attempt to align with frame boundaries, since most tasks don't\n        // need to be frame aligned; for those that do, use requestAnimationFrame.\n        var frameInterval = frameYieldMs;\n        var startTime = -1;\n        function shouldYieldToHost() {\n            var timeElapsed = exports.unstable_now() - startTime;\n            if (timeElapsed < frameInterval) {\n                // The main thread has only been blocked for a really short amount of time;\n                // smaller than a single frame. Don't yield yet.\n                return false;\n            } // The main thread has been blocked for a non-negligible amount of time. We\n            return true;\n        }\n        function requestPaint() {}\n        function forceFrameRate(fps) {\n            if (fps < 0 || fps > 125) {\n                // Using console['error'] to evade Babel and ESLint\n                console[\"error\"](\"forceFrameRate takes a positive int between 0 and 125, \" + \"forcing frame rates higher than 125 fps is not supported\");\n                return;\n            }\n            if (fps > 0) {\n                frameInterval = Math.floor(1000 / fps);\n            } else {\n                // reset the framerate\n                frameInterval = frameYieldMs;\n            }\n        }\n        var performWorkUntilDeadline = function() {\n            if (scheduledHostCallback !== null) {\n                var currentTime = exports.unstable_now(); // Keep track of the start time so we can measure how long the main thread\n                // has been blocked.\n                startTime = currentTime;\n                var hasTimeRemaining = true; // If a scheduler task throws, exit the current browser task so the\n                // error can be observed.\n                //\n                // Intentionally not using a try-catch, since that makes some debugging\n                // techniques harder. Instead, if `scheduledHostCallback` errors, then\n                // `hasMoreWork` will remain true, and we'll continue the work loop.\n                var hasMoreWork = true;\n                try {\n                    hasMoreWork = scheduledHostCallback(hasTimeRemaining, currentTime);\n                } finally{\n                    if (hasMoreWork) {\n                        // If there's more work, schedule the next message event at the end\n                        // of the preceding one.\n                        schedulePerformWorkUntilDeadline();\n                    } else {\n                        isMessageLoopRunning = false;\n                        scheduledHostCallback = null;\n                    }\n                }\n            } else {\n                isMessageLoopRunning = false;\n            } // Yielding to the browser will give it a chance to paint, so we can\n        };\n        var schedulePerformWorkUntilDeadline;\n        if (typeof localSetImmediate === \"function\") {\n            // Node.js and old IE.\n            // There's a few reasons for why we prefer setImmediate.\n            //\n            // Unlike MessageChannel, it doesn't prevent a Node.js process from exiting.\n            // (Even though this is a DOM fork of the Scheduler, you could get here\n            // with a mix of Node.js 15+, which has a MessageChannel, and jsdom.)\n            // https://github.com/facebook/react/issues/20756\n            //\n            // But also, it runs earlier which is the semantic we want.\n            // If other browsers ever implement it, it's better to use it.\n            // Although both of these would be inferior to native scheduling.\n            schedulePerformWorkUntilDeadline = function() {\n                localSetImmediate(performWorkUntilDeadline);\n            };\n        } else if (typeof MessageChannel !== \"undefined\") {\n            // DOM and Worker environments.\n            // We prefer MessageChannel because of the 4ms setTimeout clamping.\n            var channel = new MessageChannel();\n            var port = channel.port2;\n            channel.port1.onmessage = performWorkUntilDeadline;\n            schedulePerformWorkUntilDeadline = function() {\n                port.postMessage(null);\n            };\n        } else {\n            // We should only fallback here in non-browser environments.\n            schedulePerformWorkUntilDeadline = function() {\n                localSetTimeout(performWorkUntilDeadline, 0);\n            };\n        }\n        function requestHostCallback(callback) {\n            scheduledHostCallback = callback;\n            if (!isMessageLoopRunning) {\n                isMessageLoopRunning = true;\n                schedulePerformWorkUntilDeadline();\n            }\n        }\n        function requestHostTimeout(callback, ms) {\n            taskTimeoutID = localSetTimeout(function() {\n                callback(exports.unstable_now());\n            }, ms);\n        }\n        function cancelHostTimeout() {\n            localClearTimeout(taskTimeoutID);\n            taskTimeoutID = -1;\n        }\n        var unstable_requestPaint = requestPaint;\n        var unstable_Profiling = null;\n        exports.unstable_IdlePriority = IdlePriority;\n        exports.unstable_ImmediatePriority = ImmediatePriority;\n        exports.unstable_LowPriority = LowPriority;\n        exports.unstable_NormalPriority = NormalPriority;\n        exports.unstable_Profiling = unstable_Profiling;\n        exports.unstable_UserBlockingPriority = UserBlockingPriority;\n        exports.unstable_cancelCallback = unstable_cancelCallback;\n        exports.unstable_continueExecution = unstable_continueExecution;\n        exports.unstable_forceFrameRate = forceFrameRate;\n        exports.unstable_getCurrentPriorityLevel = unstable_getCurrentPriorityLevel;\n        exports.unstable_getFirstCallbackNode = unstable_getFirstCallbackNode;\n        exports.unstable_next = unstable_next;\n        exports.unstable_pauseExecution = unstable_pauseExecution;\n        exports.unstable_requestPaint = unstable_requestPaint;\n        exports.unstable_runWithPriority = unstable_runWithPriority;\n        exports.unstable_scheduleCallback = unstable_scheduleCallback;\n        exports.unstable_shouldYield = shouldYieldToHost;\n        exports.unstable_wrapCallback = unstable_wrapCallback;\n        /* global __REACT_DEVTOOLS_GLOBAL_HOOK__ */ if (typeof __REACT_DEVTOOLS_GLOBAL_HOOK__ !== \"undefined\" && typeof __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop === \"function\") {\n            __REACT_DEVTOOLS_GLOBAL_HOOK__.registerInternalModuleStop(new Error());\n        }\n    })();\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL25vZGVfbW9kdWxlcy9zY2hlZHVsZXIvY2pzL3NjaGVkdWxlci5kZXZlbG9wbWVudC5qcyIsIm1hcHBpbmdzIjoiQUFBQTs7Ozs7Ozs7Q0FRQyxHQUVEO0FBRUEsSUFBSUEsSUFBcUMsRUFBRTtJQUN4QztRQUVPO1FBRVYseUNBQXlDLEdBQ3pDLElBQ0UsT0FBT0MsbUNBQW1DLGVBQzFDLE9BQU9BLCtCQUErQkMsMkJBQTJCLEtBQy9ELFlBQ0Y7WUFDQUQsK0JBQStCQywyQkFBMkIsQ0FBQyxJQUFJQztRQUNqRTtRQUNVLElBQUlDLDJCQUEyQjtRQUN6QyxJQUFJQyxrQkFBa0I7UUFDdEIsSUFBSUMsZUFBZTtRQUVuQixTQUFTQyxLQUFLQyxJQUFJLEVBQUVDLElBQUk7WUFDdEIsSUFBSUMsUUFBUUYsS0FBS0csTUFBTTtZQUN2QkgsS0FBS0QsSUFBSSxDQUFDRTtZQUNWRyxPQUFPSixNQUFNQyxNQUFNQztRQUNyQjtRQUNBLFNBQVNHLEtBQUtMLElBQUk7WUFDaEIsT0FBT0EsS0FBS0csTUFBTSxLQUFLLElBQUksT0FBT0gsSUFBSSxDQUFDLEVBQUU7UUFDM0M7UUFDQSxTQUFTTSxJQUFJTixJQUFJO1lBQ2YsSUFBSUEsS0FBS0csTUFBTSxLQUFLLEdBQUc7Z0JBQ3JCLE9BQU87WUFDVDtZQUVBLElBQUlJLFFBQVFQLElBQUksQ0FBQyxFQUFFO1lBQ25CLElBQUlRLE9BQU9SLEtBQUtNLEdBQUc7WUFFbkIsSUFBSUUsU0FBU0QsT0FBTztnQkFDbEJQLElBQUksQ0FBQyxFQUFFLEdBQUdRO2dCQUNWQyxTQUFTVCxNQUFNUSxNQUFNO1lBQ3ZCO1lBRUEsT0FBT0Q7UUFDVDtRQUVBLFNBQVNILE9BQU9KLElBQUksRUFBRUMsSUFBSSxFQUFFUyxDQUFDO1lBQzNCLElBQUlSLFFBQVFRO1lBRVosTUFBT1IsUUFBUSxFQUFHO2dCQUNoQixJQUFJUyxjQUFjVCxRQUFRLE1BQU07Z0JBQ2hDLElBQUlV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LHdDQUF3QyxHQUFHbUU7UUFDM0NuRSxxQ0FBcUMsR0FBR2lFO1FBQ3hDakUscUJBQXFCLEdBQUdxRDtRQUN4QnJELCtCQUErQixHQUFHK0Q7UUFDbEMvRCw2QkFBNkIsR0FBR3lGO1FBQ2hDekYsZ0NBQWdDLEdBQUdtRDtRQUNuQ25ELGlDQUFpQyxHQUFHMEQ7UUFDcEMxRCw0QkFBNEIsR0FBRytDO1FBQy9CL0MsNkJBQTZCLEdBQUdzRDtRQUN0Qix5Q0FBeUMsR0FDbkQsSUFDRSxPQUFPakcsbUNBQW1DLGVBQzFDLE9BQU9BLCtCQUErQjZJLDBCQUEwQixLQUM5RCxZQUNGO1lBQ0E3SSwrQkFBK0I2SSwwQkFBMEIsQ0FBQyxJQUFJM0k7UUFDaEU7SUFFRTtBQUNGIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmliZS0zZC1jb2RlLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9maWJlci9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2Nqcy9zY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanM/YjExNiJdLCJzb3VyY2VzQ29udGVudCI6WyIvKipcbiAqIEBsaWNlbnNlIFJlYWN0XG4gKiBzY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanNcbiAqXG4gKiBDb3B5cmlnaHQgKGMpIEZhY2Vib29rLCBJbmMuIGFuZCBpdHMgYWZmaWxpYXRlcy5cbiAqXG4gKiBUaGlzIHNvdXJjZSBjb2RlIGlzIGxpY2Vuc2VkIHVuZGVyIHRoZSBNSVQgbGljZW5zZSBmb3VuZCBpbiB0aGVcbiAqIExJQ0VOU0UgZmlsZSBpbiB0aGUgcm9vdCBkaXJlY3Rvcnkgb2YgdGhpcyBzb3VyY2UgdHJlZS5cbiAqL1xuXG4ndXNlIHN0cmljdCc7XG5cbmlmIChwcm9jZXNzLmVudi5OT0RFX0VOViAhPT0gXCJwcm9kdWN0aW9uXCIpIHtcbiAgKGZ1bmN0aW9uKCkge1xuXG4gICAgICAgICAgJ3VzZSBzdHJpY3QnO1xuXG4vKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG5pZiAoXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0ID09PVxuICAgICdmdW5jdGlvbidcbikge1xuICBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0YXJ0KG5ldyBFcnJvcigpKTtcbn1cbiAgICAgICAgICB2YXIgZW5hYmxlU2NoZWR1bGVyRGVidWdnaW5nID0gZmFsc2U7XG52YXIgZW5hYmxlUHJvZmlsaW5nID0gZmFsc2U7XG52YXIgZnJhbWVZaWVsZE1zID0gNTtcblxuZnVuY3Rpb24gcHVzaChoZWFwLCBub2RlKSB7XG4gIHZhciBpbmRleCA9IGhlYXAubGVuZ3RoO1xuICBoZWFwLnB1c2gobm9kZSk7XG4gIHNpZnRVcChoZWFwLCBub2RlLCBpbmRleCk7XG59XG5mdW5jdGlvbiBwZWVrKGhlYXApIHtcbiAgcmV0dXJuIGhlYXAubGVuZ3RoID09PSAwID8gbnVsbCA6IGhlYXBbMF07XG59XG5mdW5jdGlvbiBwb3AoaGVhcCkge1xuICBpZiAoaGVhcC5sZW5ndGggPT09IDApIHtcbiAgICByZXR1cm4gbnVsbDtcbiAgfVxuXG4gIHZhciBmaXJzdCA9IGhlYXBbMF07XG4gIHZhciBsYXN0ID0gaGVhcC5wb3AoKTtcblxuICBpZiAobGFzdCAhPT0gZmlyc3QpIHtcbiAgICBoZWFwWzBdID0gbGFzdDtcbiAgICBzaWZ0RG93bihoZWFwLCBsYXN0LCAwKTtcbiAgfVxuXG4gIHJldHVybiBmaXJzdDtcbn1cblxuZnVuY3Rpb24gc2lmdFVwKGhlYXAsIG5vZGUsIGkpIHtcbiAgdmFyIGluZGV4ID0gaTtcblxuICB3aGlsZSAoaW5kZXggPiAwKSB7XG4gICAgdmFyIHBhcmVudEluZGV4ID0gaW5kZXggLSAxID4+PiAxO1xuICAgIHZhciBwYXJlbnQgPSBoZWFwW3BhcmVudEluZGV4XTtcblxuICAgIGlmIChjb21wYXJlKHBhcmVudCwgbm9kZSkgPiAwKSB7XG4gICAgICAvLyBUaGUgcGFyZW50IGlzIGxhcmdlci4gU3dhcCBwb3NpdGlvbnMuXG4gICAgICBoZWFwW3BhcmVudEluZGV4XSA9IG5vZGU7XG4gICAgICBoZWFwW2luZGV4XSA9IHBhcmVudDtcbiAgICAgIGluZGV4ID0gcGFyZW50SW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIFRoZSBwYXJlbnQgaXMgc21hbGxlci4gRXhpdC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gc2lmdERvd24oaGVhcCwgbm9kZSwgaSkge1xuICB2YXIgaW5kZXggPSBpO1xuICB2YXIgbGVuZ3RoID0gaGVhcC5sZW5ndGg7XG4gIHZhciBoYWxmTGVuZ3RoID0gbGVuZ3RoID4+PiAxO1xuXG4gIHdoaWxlIChpbmRleCA8IGhhbGZMZW5ndGgpIHtcbiAgICB2YXIgbGVmdEluZGV4ID0gKGluZGV4ICsgMSkgKiAyIC0gMTtcbiAgICB2YXIgbGVmdCA9IGhlYXBbbGVmdEluZGV4XTtcbiAgICB2YXIgcmlnaHRJbmRleCA9IGxlZnRJbmRleCArIDE7XG4gICAgdmFyIHJpZ2h0ID0gaGVhcFtyaWdodEluZGV4XTsgLy8gSWYgdGhlIGxlZnQgb3IgcmlnaHQgbm9kZSBpcyBzbWFsbGVyLCBzd2FwIHdpdGggdGhlIHNtYWxsZXIgb2YgdGhvc2UuXG5cbiAgICBpZiAoY29tcGFyZShsZWZ0LCBub2RlKSA8IDApIHtcbiAgICAgIGlmIChyaWdodEluZGV4IDwgbGVuZ3RoICYmIGNvbXBhcmUocmlnaHQsIGxlZnQpIDwgMCkge1xuICAgICAgICBoZWFwW2luZGV4XSA9IHJpZ2h0O1xuICAgICAgICBoZWFwW3JpZ2h0SW5kZXhdID0gbm9kZTtcbiAgICAgICAgaW5kZXggPSByaWdodEluZGV4O1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaGVhcFtpbmRleF0gPSBsZWZ0O1xuICAgICAgICBoZWFwW2xlZnRJbmRleF0gPSBub2RlO1xuICAgICAgICBpbmRleCA9IGxlZnRJbmRleDtcbiAgICAgIH1cbiAgICB9IGVsc2UgaWYgKHJpZ2h0SW5kZXggPCBsZW5ndGggJiYgY29tcGFyZShyaWdodCwgbm9kZSkgPCAwKSB7XG4gICAgICBoZWFwW2luZGV4XSA9IHJpZ2h0O1xuICAgICAgaGVhcFtyaWdodEluZGV4XSA9IG5vZGU7XG4gICAgICBpbmRleCA9IHJpZ2h0SW5kZXg7XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5laXRoZXIgY2hpbGQgaXMgc21hbGxlci4gRXhpdC5cbiAgICAgIHJldHVybjtcbiAgICB9XG4gIH1cbn1cblxuZnVuY3Rpb24gY29tcGFyZShhLCBiKSB7XG4gIC8vIENvbXBhcmUgc29ydCBpbmRleCBmaXJzdCwgdGhlbiB0YXNrIGlkLlxuICB2YXIgZGlmZiA9IGEuc29ydEluZGV4IC0gYi5zb3J0SW5kZXg7XG4gIHJldHVybiBkaWZmICE9PSAwID8gZGlmZiA6IGEuaWQgLSBiLmlkO1xufVxuXG4vLyBUT0RPOiBVc2Ugc3ltYm9scz9cbnZhciBJbW1lZGlhdGVQcmlvcml0eSA9IDE7XG52YXIgVXNlckJsb2NraW5nUHJpb3JpdHkgPSAyO1xudmFyIE5vcm1hbFByaW9yaXR5ID0gMztcbnZhciBMb3dQcmlvcml0eSA9IDQ7XG52YXIgSWRsZVByaW9yaXR5ID0gNTtcblxuZnVuY3Rpb24gbWFya1Rhc2tFcnJvcmVkKHRhc2ssIG1zKSB7XG59XG5cbi8qIGVzbGludC1kaXNhYmxlIG5vLXZhciAqL1xuXG52YXIgaGFzUGVyZm9ybWFuY2VOb3cgPSB0eXBlb2YgcGVyZm9ybWFuY2UgPT09ICdvYmplY3QnICYmIHR5cGVvZiBwZXJmb3JtYW5jZS5ub3cgPT09ICdmdW5jdGlvbic7XG5cbmlmIChoYXNQZXJmb3JtYW5jZU5vdykge1xuICB2YXIgbG9jYWxQZXJmb3JtYW5jZSA9IHBlcmZvcm1hbmNlO1xuXG4gIGV4cG9ydHMudW5zdGFibGVfbm93ID0gZnVuY3Rpb24gKCkge1xuICAgIHJldHVybiBsb2NhbFBlcmZvcm1hbmNlLm5vdygpO1xuICB9O1xufSBlbHNlIHtcbiAgdmFyIGxvY2FsRGF0ZSA9IERhdGU7XG4gIHZhciBpbml0aWFsVGltZSA9IGxvY2FsRGF0ZS5ub3coKTtcblxuICBleHBvcnRzLnVuc3RhYmxlX25vdyA9IGZ1bmN0aW9uICgpIHtcbiAgICByZXR1cm4gbG9jYWxEYXRlLm5vdygpIC0gaW5pdGlhbFRpbWU7XG4gIH07XG59IC8vIE1heCAzMSBiaXQgaW50ZWdlci4gVGhlIG1heCBpbnRlZ2VyIHNpemUgaW4gVjggZm9yIDMyLWJpdCBzeXN0ZW1zLlxuLy8gTWF0aC5wb3coMiwgMzApIC0gMVxuLy8gMGIxMTExMTExMTExMTExMTExMTExMTExMTExMTExMTFcblxuXG52YXIgbWF4U2lnbmVkMzFCaXRJbnQgPSAxMDczNzQxODIzOyAvLyBUaW1lcyBvdXQgaW1tZWRpYXRlbHlcblxudmFyIElNTUVESUFURV9QUklPUklUWV9USU1FT1VUID0gLTE7IC8vIEV2ZW50dWFsbHkgdGltZXMgb3V0XG5cbnZhciBVU0VSX0JMT0NLSU5HX1BSSU9SSVRZX1RJTUVPVVQgPSAyNTA7XG52YXIgTk9STUFMX1BSSU9SSVRZX1RJTUVPVVQgPSA1MDAwO1xudmFyIExPV19QUklPUklUWV9USU1FT1VUID0gMTAwMDA7IC8vIE5ldmVyIHRpbWVzIG91dFxuXG52YXIgSURMRV9QUklPUklUWV9USU1FT1VUID0gbWF4U2lnbmVkMzFCaXRJbnQ7IC8vIFRhc2tzIGFyZSBzdG9yZWQgb24gYSBtaW4gaGVhcFxuXG52YXIgdGFza1F1ZXVlID0gW107XG52YXIgdGltZXJRdWV1ZSA9IFtdOyAvLyBJbmNyZW1lbnRpbmcgaWQgY291bnRlci4gVXNlZCB0byBtYWludGFpbiBpbnNlcnRpb24gb3JkZXIuXG5cbnZhciB0YXNrSWRDb3VudGVyID0gMTsgLy8gUGF1c2luZyB0aGUgc2NoZWR1bGVyIGlzIHVzZWZ1bCBmb3IgZGVidWdnaW5nLlxudmFyIGN1cnJlbnRUYXNrID0gbnVsbDtcbnZhciBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IE5vcm1hbFByaW9yaXR5OyAvLyBUaGlzIGlzIHNldCB3aGlsZSBwZXJmb3JtaW5nIHdvcmssIHRvIHByZXZlbnQgcmUtZW50cmFuY2UuXG5cbnZhciBpc1BlcmZvcm1pbmdXb3JrID0gZmFsc2U7XG52YXIgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSBmYWxzZTtcbnZhciBpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gZmFsc2U7IC8vIENhcHR1cmUgbG9jYWwgcmVmZXJlbmNlcyB0byBuYXRpdmUgQVBJcywgaW4gY2FzZSBhIHBvbHlmaWxsIG92ZXJyaWRlcyB0aGVtLlxuXG52YXIgbG9jYWxTZXRUaW1lb3V0ID0gdHlwZW9mIHNldFRpbWVvdXQgPT09ICdmdW5jdGlvbicgPyBzZXRUaW1lb3V0IDogbnVsbDtcbnZhciBsb2NhbENsZWFyVGltZW91dCA9IHR5cGVvZiBjbGVhclRpbWVvdXQgPT09ICdmdW5jdGlvbicgPyBjbGVhclRpbWVvdXQgOiBudWxsO1xudmFyIGxvY2FsU2V0SW1tZWRpYXRlID0gdHlwZW9mIHNldEltbWVkaWF0ZSAhPT0gJ3VuZGVmaW5lZCcgPyBzZXRJbW1lZGlhdGUgOiBudWxsOyAvLyBJRSBhbmQgTm9kZS5qcyArIGpzZG9tXG5cbnZhciBpc0lucHV0UGVuZGluZyA9IHR5cGVvZiBuYXZpZ2F0b3IgIT09ICd1bmRlZmluZWQnICYmIG5hdmlnYXRvci5zY2hlZHVsaW5nICE9PSB1bmRlZmluZWQgJiYgbmF2aWdhdG9yLnNjaGVkdWxpbmcuaXNJbnB1dFBlbmRpbmcgIT09IHVuZGVmaW5lZCA/IG5hdmlnYXRvci5zY2hlZHVsaW5nLmlzSW5wdXRQZW5kaW5nLmJpbmQobmF2aWdhdG9yLnNjaGVkdWxpbmcpIDogbnVsbDtcblxuZnVuY3Rpb24gYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSkge1xuICAvLyBDaGVjayBmb3IgdGFza3MgdGhhdCBhcmUgbm8gbG9uZ2VyIGRlbGF5ZWQgYW5kIGFkZCB0aGVtIHRvIHRoZSBxdWV1ZS5cbiAgdmFyIHRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcblxuICB3aGlsZSAodGltZXIgIT09IG51bGwpIHtcbiAgICBpZiAodGltZXIuY2FsbGJhY2sgPT09IG51bGwpIHtcbiAgICAgIC8vIFRpbWVyIHdhcyBjYW5jZWxsZWQuXG4gICAgICBwb3AodGltZXJRdWV1ZSk7XG4gICAgfSBlbHNlIGlmICh0aW1lci5zdGFydFRpbWUgPD0gY3VycmVudFRpbWUpIHtcbiAgICAgIC8vIFRpbWVyIGZpcmVkLiBUcmFuc2ZlciB0byB0aGUgdGFzayBxdWV1ZS5cbiAgICAgIHBvcCh0aW1lclF1ZXVlKTtcbiAgICAgIHRpbWVyLnNvcnRJbmRleCA9IHRpbWVyLmV4cGlyYXRpb25UaW1lO1xuICAgICAgcHVzaCh0YXNrUXVldWUsIHRpbWVyKTtcbiAgICB9IGVsc2Uge1xuICAgICAgLy8gUmVtYWluaW5nIHRpbWVycyBhcmUgcGVuZGluZy5cbiAgICAgIHJldHVybjtcbiAgICB9XG5cbiAgICB0aW1lciA9IHBlZWsodGltZXJRdWV1ZSk7XG4gIH1cbn1cblxuZnVuY3Rpb24gaGFuZGxlVGltZW91dChjdXJyZW50VGltZSkge1xuICBpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gZmFsc2U7XG4gIGFkdmFuY2VUaW1lcnMoY3VycmVudFRpbWUpO1xuXG4gIGlmICghaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQpIHtcbiAgICBpZiAocGVlayh0YXNrUXVldWUpICE9PSBudWxsKSB7XG4gICAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9IHRydWU7XG4gICAgICByZXF1ZXN0SG9zdENhbGxiYWNrKGZsdXNoV29yayk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHZhciBmaXJzdFRpbWVyID0gcGVlayh0aW1lclF1ZXVlKTtcblxuICAgICAgaWYgKGZpcnN0VGltZXIgIT09IG51bGwpIHtcbiAgICAgICAgcmVxdWVzdEhvc3RUaW1lb3V0KGhhbmRsZVRpbWVvdXQsIGZpcnN0VGltZXIuc3RhcnRUaW1lIC0gY3VycmVudFRpbWUpO1xuICAgICAgfVxuICAgIH1cbiAgfVxufVxuXG5mdW5jdGlvbiBmbHVzaFdvcmsoaGFzVGltZVJlbWFpbmluZywgaW5pdGlhbFRpbWUpIHtcblxuXG4gIGlzSG9zdENhbGxiYWNrU2NoZWR1bGVkID0gZmFsc2U7XG5cbiAgaWYgKGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQpIHtcbiAgICAvLyBXZSBzY2hlZHVsZWQgYSB0aW1lb3V0IGJ1dCBpdCdzIG5vIGxvbmdlciBuZWVkZWQuIENhbmNlbCBpdC5cbiAgICBpc0hvc3RUaW1lb3V0U2NoZWR1bGVkID0gZmFsc2U7XG4gICAgY2FuY2VsSG9zdFRpbWVvdXQoKTtcbiAgfVxuXG4gIGlzUGVyZm9ybWluZ1dvcmsgPSB0cnVlO1xuICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG5cbiAgdHJ5IHtcbiAgICBpZiAoZW5hYmxlUHJvZmlsaW5nKSB7XG4gICAgICB0cnkge1xuICAgICAgICByZXR1cm4gd29ya0xvb3AoaGFzVGltZVJlbWFpbmluZywgaW5pdGlhbFRpbWUpO1xuICAgICAgfSBjYXRjaCAoZXJyb3IpIHtcbiAgICAgICAgaWYgKGN1cnJlbnRUYXNrICE9PSBudWxsKSB7XG4gICAgICAgICAgdmFyIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcbiAgICAgICAgICBtYXJrVGFza0Vycm9yZWQoY3VycmVudFRhc2ssIGN1cnJlbnRUaW1lKTtcbiAgICAgICAgICBjdXJyZW50VGFzay5pc1F1ZXVlZCA9IGZhbHNlO1xuICAgICAgICB9XG5cbiAgICAgICAgdGhyb3cgZXJyb3I7XG4gICAgICB9XG4gICAgfSBlbHNlIHtcbiAgICAgIC8vIE5vIGNhdGNoIGluIHByb2QgY29kZSBwYXRoLlxuICAgICAgcmV0dXJuIHdvcmtMb29wKGhhc1RpbWVSZW1haW5pbmcsIGluaXRpYWxUaW1lKTtcbiAgICB9XG4gIH0gZmluYWxseSB7XG4gICAgY3VycmVudFRhc2sgPSBudWxsO1xuICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJldmlvdXNQcmlvcml0eUxldmVsO1xuICAgIGlzUGVyZm9ybWluZ1dvcmsgPSBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiB3b3JrTG9vcChoYXNUaW1lUmVtYWluaW5nLCBpbml0aWFsVGltZSkge1xuICB2YXIgY3VycmVudFRpbWUgPSBpbml0aWFsVGltZTtcbiAgYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSk7XG4gIGN1cnJlbnRUYXNrID0gcGVlayh0YXNrUXVldWUpO1xuXG4gIHdoaWxlIChjdXJyZW50VGFzayAhPT0gbnVsbCAmJiAhKGVuYWJsZVNjaGVkdWxlckRlYnVnZ2luZyApKSB7XG4gICAgaWYgKGN1cnJlbnRUYXNrLmV4cGlyYXRpb25UaW1lID4gY3VycmVudFRpbWUgJiYgKCFoYXNUaW1lUmVtYWluaW5nIHx8IHNob3VsZFlpZWxkVG9Ib3N0KCkpKSB7XG4gICAgICAvLyBUaGlzIGN1cnJlbnRUYXNrIGhhc24ndCBleHBpcmVkLCBhbmQgd2UndmUgcmVhY2hlZCB0aGUgZGVhZGxpbmUuXG4gICAgICBicmVhaztcbiAgICB9XG5cbiAgICB2YXIgY2FsbGJhY2sgPSBjdXJyZW50VGFzay5jYWxsYmFjaztcblxuICAgIGlmICh0eXBlb2YgY2FsbGJhY2sgPT09ICdmdW5jdGlvbicpIHtcbiAgICAgIGN1cnJlbnRUYXNrLmNhbGxiYWNrID0gbnVsbDtcbiAgICAgIGN1cnJlbnRQcmlvcml0eUxldmVsID0gY3VycmVudFRhc2sucHJpb3JpdHlMZXZlbDtcbiAgICAgIHZhciBkaWRVc2VyQ2FsbGJhY2tUaW1lb3V0ID0gY3VycmVudFRhc2suZXhwaXJhdGlvblRpbWUgPD0gY3VycmVudFRpbWU7XG5cbiAgICAgIHZhciBjb250aW51YXRpb25DYWxsYmFjayA9IGNhbGxiYWNrKGRpZFVzZXJDYWxsYmFja1RpbWVvdXQpO1xuICAgICAgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpO1xuXG4gICAgICBpZiAodHlwZW9mIGNvbnRpbnVhdGlvbkNhbGxiYWNrID09PSAnZnVuY3Rpb24nKSB7XG4gICAgICAgIGN1cnJlbnRUYXNrLmNhbGxiYWNrID0gY29udGludWF0aW9uQ2FsbGJhY2s7XG4gICAgICB9IGVsc2Uge1xuXG4gICAgICAgIGlmIChjdXJyZW50VGFzayA9PT0gcGVlayh0YXNrUXVldWUpKSB7XG4gICAgICAgICAgcG9wKHRhc2tRdWV1ZSk7XG4gICAgICAgIH1cbiAgICAgIH1cblxuICAgICAgYWR2YW5jZVRpbWVycyhjdXJyZW50VGltZSk7XG4gICAgfSBlbHNlIHtcbiAgICAgIHBvcCh0YXNrUXVldWUpO1xuICAgIH1cblxuICAgIGN1cnJlbnRUYXNrID0gcGVlayh0YXNrUXVldWUpO1xuICB9IC8vIFJldHVybiB3aGV0aGVyIHRoZXJlJ3MgYWRkaXRpb25hbCB3b3JrXG5cblxuICBpZiAoY3VycmVudFRhc2sgIT09IG51bGwpIHtcbiAgICByZXR1cm4gdHJ1ZTtcbiAgfSBlbHNlIHtcbiAgICB2YXIgZmlyc3RUaW1lciA9IHBlZWsodGltZXJRdWV1ZSk7XG5cbiAgICBpZiAoZmlyc3RUaW1lciAhPT0gbnVsbCkge1xuICAgICAgcmVxdWVzdEhvc3RUaW1lb3V0KGhhbmRsZVRpbWVvdXQsIGZpcnN0VGltZXIuc3RhcnRUaW1lIC0gY3VycmVudFRpbWUpO1xuICAgIH1cblxuICAgIHJldHVybiBmYWxzZTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9ydW5XaXRoUHJpb3JpdHkocHJpb3JpdHlMZXZlbCwgZXZlbnRIYW5kbGVyKSB7XG4gIHN3aXRjaCAocHJpb3JpdHlMZXZlbCkge1xuICAgIGNhc2UgSW1tZWRpYXRlUHJpb3JpdHk6XG4gICAgY2FzZSBVc2VyQmxvY2tpbmdQcmlvcml0eTpcbiAgICBjYXNlIE5vcm1hbFByaW9yaXR5OlxuICAgIGNhc2UgTG93UHJpb3JpdHk6XG4gICAgY2FzZSBJZGxlUHJpb3JpdHk6XG4gICAgICBicmVhaztcblxuICAgIGRlZmF1bHQ6XG4gICAgICBwcmlvcml0eUxldmVsID0gTm9ybWFsUHJpb3JpdHk7XG4gIH1cblxuICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gIGN1cnJlbnRQcmlvcml0eUxldmVsID0gcHJpb3JpdHlMZXZlbDtcblxuICB0cnkge1xuICAgIHJldHVybiBldmVudEhhbmRsZXIoKTtcbiAgfSBmaW5hbGx5IHtcbiAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9uZXh0KGV2ZW50SGFuZGxlcikge1xuICB2YXIgcHJpb3JpdHlMZXZlbDtcblxuICBzd2l0Y2ggKGN1cnJlbnRQcmlvcml0eUxldmVsKSB7XG4gICAgY2FzZSBJbW1lZGlhdGVQcmlvcml0eTpcbiAgICBjYXNlIFVzZXJCbG9ja2luZ1ByaW9yaXR5OlxuICAgIGNhc2UgTm9ybWFsUHJpb3JpdHk6XG4gICAgICAvLyBTaGlmdCBkb3duIHRvIG5vcm1hbCBwcmlvcml0eVxuICAgICAgcHJpb3JpdHlMZXZlbCA9IE5vcm1hbFByaW9yaXR5O1xuICAgICAgYnJlYWs7XG5cbiAgICBkZWZhdWx0OlxuICAgICAgLy8gQW55dGhpbmcgbG93ZXIgdGhhbiBub3JtYWwgcHJpb3JpdHkgc2hvdWxkIHJlbWFpbiBhdCB0aGUgY3VycmVudCBsZXZlbC5cbiAgICAgIHByaW9yaXR5TGV2ZWwgPSBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbiAgICAgIGJyZWFrO1xuICB9XG5cbiAgdmFyIHByZXZpb3VzUHJpb3JpdHlMZXZlbCA9IGN1cnJlbnRQcmlvcml0eUxldmVsO1xuICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByaW9yaXR5TGV2ZWw7XG5cbiAgdHJ5IHtcbiAgICByZXR1cm4gZXZlbnRIYW5kbGVyKCk7XG4gIH0gZmluYWxseSB7XG4gICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwcmV2aW91c1ByaW9yaXR5TGV2ZWw7XG4gIH1cbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfd3JhcENhbGxiYWNrKGNhbGxiYWNrKSB7XG4gIHZhciBwYXJlbnRQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gIHJldHVybiBmdW5jdGlvbiAoKSB7XG4gICAgLy8gVGhpcyBpcyBhIGZvcmsgb2YgcnVuV2l0aFByaW9yaXR5LCBpbmxpbmVkIGZvciBwZXJmb3JtYW5jZS5cbiAgICB2YXIgcHJldmlvdXNQcmlvcml0eUxldmVsID0gY3VycmVudFByaW9yaXR5TGV2ZWw7XG4gICAgY3VycmVudFByaW9yaXR5TGV2ZWwgPSBwYXJlbnRQcmlvcml0eUxldmVsO1xuXG4gICAgdHJ5IHtcbiAgICAgIHJldHVybiBjYWxsYmFjay5hcHBseSh0aGlzLCBhcmd1bWVudHMpO1xuICAgIH0gZmluYWxseSB7XG4gICAgICBjdXJyZW50UHJpb3JpdHlMZXZlbCA9IHByZXZpb3VzUHJpb3JpdHlMZXZlbDtcbiAgICB9XG4gIH07XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2socHJpb3JpdHlMZXZlbCwgY2FsbGJhY2ssIG9wdGlvbnMpIHtcbiAgdmFyIGN1cnJlbnRUaW1lID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKTtcbiAgdmFyIHN0YXJ0VGltZTtcblxuICBpZiAodHlwZW9mIG9wdGlvbnMgPT09ICdvYmplY3QnICYmIG9wdGlvbnMgIT09IG51bGwpIHtcbiAgICB2YXIgZGVsYXkgPSBvcHRpb25zLmRlbGF5O1xuXG4gICAgaWYgKHR5cGVvZiBkZWxheSA9PT0gJ251bWJlcicgJiYgZGVsYXkgPiAwKSB7XG4gICAgICBzdGFydFRpbWUgPSBjdXJyZW50VGltZSArIGRlbGF5O1xuICAgIH0gZWxzZSB7XG4gICAgICBzdGFydFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgc3RhcnRUaW1lID0gY3VycmVudFRpbWU7XG4gIH1cblxuICB2YXIgdGltZW91dDtcblxuICBzd2l0Y2ggKHByaW9yaXR5TGV2ZWwpIHtcbiAgICBjYXNlIEltbWVkaWF0ZVByaW9yaXR5OlxuICAgICAgdGltZW91dCA9IElNTUVESUFURV9QUklPUklUWV9USU1FT1VUO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIFVzZXJCbG9ja2luZ1ByaW9yaXR5OlxuICAgICAgdGltZW91dCA9IFVTRVJfQkxPQ0tJTkdfUFJJT1JJVFlfVElNRU9VVDtcbiAgICAgIGJyZWFrO1xuXG4gICAgY2FzZSBJZGxlUHJpb3JpdHk6XG4gICAgICB0aW1lb3V0ID0gSURMRV9QUklPUklUWV9USU1FT1VUO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIExvd1ByaW9yaXR5OlxuICAgICAgdGltZW91dCA9IExPV19QUklPUklUWV9USU1FT1VUO1xuICAgICAgYnJlYWs7XG5cbiAgICBjYXNlIE5vcm1hbFByaW9yaXR5OlxuICAgIGRlZmF1bHQ6XG4gICAgICB0aW1lb3V0ID0gTk9STUFMX1BSSU9SSVRZX1RJTUVPVVQ7XG4gICAgICBicmVhaztcbiAgfVxuXG4gIHZhciBleHBpcmF0aW9uVGltZSA9IHN0YXJ0VGltZSArIHRpbWVvdXQ7XG4gIHZhciBuZXdUYXNrID0ge1xuICAgIGlkOiB0YXNrSWRDb3VudGVyKyssXG4gICAgY2FsbGJhY2s6IGNhbGxiYWNrLFxuICAgIHByaW9yaXR5TGV2ZWw6IHByaW9yaXR5TGV2ZWwsXG4gICAgc3RhcnRUaW1lOiBzdGFydFRpbWUsXG4gICAgZXhwaXJhdGlvblRpbWU6IGV4cGlyYXRpb25UaW1lLFxuICAgIHNvcnRJbmRleDogLTFcbiAgfTtcblxuICBpZiAoc3RhcnRUaW1lID4gY3VycmVudFRpbWUpIHtcbiAgICAvLyBUaGlzIGlzIGEgZGVsYXllZCB0YXNrLlxuICAgIG5ld1Rhc2suc29ydEluZGV4ID0gc3RhcnRUaW1lO1xuICAgIHB1c2godGltZXJRdWV1ZSwgbmV3VGFzayk7XG5cbiAgICBpZiAocGVlayh0YXNrUXVldWUpID09PSBudWxsICYmIG5ld1Rhc2sgPT09IHBlZWsodGltZXJRdWV1ZSkpIHtcbiAgICAgIC8vIEFsbCB0YXNrcyBhcmUgZGVsYXllZCwgYW5kIHRoaXMgaXMgdGhlIHRhc2sgd2l0aCB0aGUgZWFybGllc3QgZGVsYXkuXG4gICAgICBpZiAoaXNIb3N0VGltZW91dFNjaGVkdWxlZCkge1xuICAgICAgICAvLyBDYW5jZWwgYW4gZXhpc3RpbmcgdGltZW91dC5cbiAgICAgICAgY2FuY2VsSG9zdFRpbWVvdXQoKTtcbiAgICAgIH0gZWxzZSB7XG4gICAgICAgIGlzSG9zdFRpbWVvdXRTY2hlZHVsZWQgPSB0cnVlO1xuICAgICAgfSAvLyBTY2hlZHVsZSBhIHRpbWVvdXQuXG5cblxuICAgICAgcmVxdWVzdEhvc3RUaW1lb3V0KGhhbmRsZVRpbWVvdXQsIHN0YXJ0VGltZSAtIGN1cnJlbnRUaW1lKTtcbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgbmV3VGFzay5zb3J0SW5kZXggPSBleHBpcmF0aW9uVGltZTtcbiAgICBwdXNoKHRhc2tRdWV1ZSwgbmV3VGFzayk7XG4gICAgLy8gd2FpdCB1bnRpbCB0aGUgbmV4dCB0aW1lIHdlIHlpZWxkLlxuXG5cbiAgICBpZiAoIWlzSG9zdENhbGxiYWNrU2NoZWR1bGVkICYmICFpc1BlcmZvcm1pbmdXb3JrKSB7XG4gICAgICBpc0hvc3RDYWxsYmFja1NjaGVkdWxlZCA9IHRydWU7XG4gICAgICByZXF1ZXN0SG9zdENhbGxiYWNrKGZsdXNoV29yayk7XG4gICAgfVxuICB9XG5cbiAgcmV0dXJuIG5ld1Rhc2s7XG59XG5cbmZ1bmN0aW9uIHVuc3RhYmxlX3BhdXNlRXhlY3V0aW9uKCkge1xufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9jb250aW51ZUV4ZWN1dGlvbigpIHtcblxuICBpZiAoIWlzSG9zdENhbGxiYWNrU2NoZWR1bGVkICYmICFpc1BlcmZvcm1pbmdXb3JrKSB7XG4gICAgaXNIb3N0Q2FsbGJhY2tTY2hlZHVsZWQgPSB0cnVlO1xuICAgIHJlcXVlc3RIb3N0Q2FsbGJhY2soZmx1c2hXb3JrKTtcbiAgfVxufVxuXG5mdW5jdGlvbiB1bnN0YWJsZV9nZXRGaXJzdENhbGxiYWNrTm9kZSgpIHtcbiAgcmV0dXJuIHBlZWsodGFza1F1ZXVlKTtcbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfY2FuY2VsQ2FsbGJhY2sodGFzaykge1xuICAvLyByZW1vdmUgZnJvbSB0aGUgcXVldWUgYmVjYXVzZSB5b3UgY2FuJ3QgcmVtb3ZlIGFyYml0cmFyeSBub2RlcyBmcm9tIGFuXG4gIC8vIGFycmF5IGJhc2VkIGhlYXAsIG9ubHkgdGhlIGZpcnN0IG9uZS4pXG5cblxuICB0YXNrLmNhbGxiYWNrID0gbnVsbDtcbn1cblxuZnVuY3Rpb24gdW5zdGFibGVfZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWwoKSB7XG4gIHJldHVybiBjdXJyZW50UHJpb3JpdHlMZXZlbDtcbn1cblxudmFyIGlzTWVzc2FnZUxvb3BSdW5uaW5nID0gZmFsc2U7XG52YXIgc2NoZWR1bGVkSG9zdENhbGxiYWNrID0gbnVsbDtcbnZhciB0YXNrVGltZW91dElEID0gLTE7IC8vIFNjaGVkdWxlciBwZXJpb2RpY2FsbHkgeWllbGRzIGluIGNhc2UgdGhlcmUgaXMgb3RoZXIgd29yayBvbiB0aGUgbWFpblxuLy8gdGhyZWFkLCBsaWtlIHVzZXIgZXZlbnRzLiBCeSBkZWZhdWx0LCBpdCB5aWVsZHMgbXVsdGlwbGUgdGltZXMgcGVyIGZyYW1lLlxuLy8gSXQgZG9lcyBub3QgYXR0ZW1wdCB0byBhbGlnbiB3aXRoIGZyYW1lIGJvdW5kYXJpZXMsIHNpbmNlIG1vc3QgdGFza3MgZG9uJ3Rcbi8vIG5lZWQgdG8gYmUgZnJhbWUgYWxpZ25lZDsgZm9yIHRob3NlIHRoYXQgZG8sIHVzZSByZXF1ZXN0QW5pbWF0aW9uRnJhbWUuXG5cbnZhciBmcmFtZUludGVydmFsID0gZnJhbWVZaWVsZE1zO1xudmFyIHN0YXJ0VGltZSA9IC0xO1xuXG5mdW5jdGlvbiBzaG91bGRZaWVsZFRvSG9zdCgpIHtcbiAgdmFyIHRpbWVFbGFwc2VkID0gZXhwb3J0cy51bnN0YWJsZV9ub3coKSAtIHN0YXJ0VGltZTtcblxuICBpZiAodGltZUVsYXBzZWQgPCBmcmFtZUludGVydmFsKSB7XG4gICAgLy8gVGhlIG1haW4gdGhyZWFkIGhhcyBvbmx5IGJlZW4gYmxvY2tlZCBmb3IgYSByZWFsbHkgc2hvcnQgYW1vdW50IG9mIHRpbWU7XG4gICAgLy8gc21hbGxlciB0aGFuIGEgc2luZ2xlIGZyYW1lLiBEb24ndCB5aWVsZCB5ZXQuXG4gICAgcmV0dXJuIGZhbHNlO1xuICB9IC8vIFRoZSBtYWluIHRocmVhZCBoYXMgYmVlbiBibG9ja2VkIGZvciBhIG5vbi1uZWdsaWdpYmxlIGFtb3VudCBvZiB0aW1lLiBXZVxuXG5cbiAgcmV0dXJuIHRydWU7XG59XG5cbmZ1bmN0aW9uIHJlcXVlc3RQYWludCgpIHtcblxufVxuXG5mdW5jdGlvbiBmb3JjZUZyYW1lUmF0ZShmcHMpIHtcbiAgaWYgKGZwcyA8IDAgfHwgZnBzID4gMTI1KSB7XG4gICAgLy8gVXNpbmcgY29uc29sZVsnZXJyb3InXSB0byBldmFkZSBCYWJlbCBhbmQgRVNMaW50XG4gICAgY29uc29sZVsnZXJyb3InXSgnZm9yY2VGcmFtZVJhdGUgdGFrZXMgYSBwb3NpdGl2ZSBpbnQgYmV0d2VlbiAwIGFuZCAxMjUsICcgKyAnZm9yY2luZyBmcmFtZSByYXRlcyBoaWdoZXIgdGhhbiAxMjUgZnBzIGlzIG5vdCBzdXBwb3J0ZWQnKTtcbiAgICByZXR1cm47XG4gIH1cblxuICBpZiAoZnBzID4gMCkge1xuICAgIGZyYW1lSW50ZXJ2YWwgPSBNYXRoLmZsb29yKDEwMDAgLyBmcHMpO1xuICB9IGVsc2Uge1xuICAgIC8vIHJlc2V0IHRoZSBmcmFtZXJhdGVcbiAgICBmcmFtZUludGVydmFsID0gZnJhbWVZaWVsZE1zO1xuICB9XG59XG5cbnZhciBwZXJmb3JtV29ya1VudGlsRGVhZGxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gIGlmIChzY2hlZHVsZWRIb3N0Q2FsbGJhY2sgIT09IG51bGwpIHtcbiAgICB2YXIgY3VycmVudFRpbWUgPSBleHBvcnRzLnVuc3RhYmxlX25vdygpOyAvLyBLZWVwIHRyYWNrIG9mIHRoZSBzdGFydCB0aW1lIHNvIHdlIGNhbiBtZWFzdXJlIGhvdyBsb25nIHRoZSBtYWluIHRocmVhZFxuICAgIC8vIGhhcyBiZWVuIGJsb2NrZWQuXG5cbiAgICBzdGFydFRpbWUgPSBjdXJyZW50VGltZTtcbiAgICB2YXIgaGFzVGltZVJlbWFpbmluZyA9IHRydWU7IC8vIElmIGEgc2NoZWR1bGVyIHRhc2sgdGhyb3dzLCBleGl0IHRoZSBjdXJyZW50IGJyb3dzZXIgdGFzayBzbyB0aGVcbiAgICAvLyBlcnJvciBjYW4gYmUgb2JzZXJ2ZWQuXG4gICAgLy9cbiAgICAvLyBJbnRlbnRpb25hbGx5IG5vdCB1c2luZyBhIHRyeS1jYXRjaCwgc2luY2UgdGhhdCBtYWtlcyBzb21lIGRlYnVnZ2luZ1xuICAgIC8vIHRlY2huaXF1ZXMgaGFyZGVyLiBJbnN0ZWFkLCBpZiBgc2NoZWR1bGVkSG9zdENhbGxiYWNrYCBlcnJvcnMsIHRoZW5cbiAgICAvLyBgaGFzTW9yZVdvcmtgIHdpbGwgcmVtYWluIHRydWUsIGFuZCB3ZSdsbCBjb250aW51ZSB0aGUgd29yayBsb29wLlxuXG4gICAgdmFyIGhhc01vcmVXb3JrID0gdHJ1ZTtcblxuICAgIHRyeSB7XG4gICAgICBoYXNNb3JlV29yayA9IHNjaGVkdWxlZEhvc3RDYWxsYmFjayhoYXNUaW1lUmVtYWluaW5nLCBjdXJyZW50VGltZSk7XG4gICAgfSBmaW5hbGx5IHtcbiAgICAgIGlmIChoYXNNb3JlV29yaykge1xuICAgICAgICAvLyBJZiB0aGVyZSdzIG1vcmUgd29yaywgc2NoZWR1bGUgdGhlIG5leHQgbWVzc2FnZSBldmVudCBhdCB0aGUgZW5kXG4gICAgICAgIC8vIG9mIHRoZSBwcmVjZWRpbmcgb25lLlxuICAgICAgICBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSgpO1xuICAgICAgfSBlbHNlIHtcbiAgICAgICAgaXNNZXNzYWdlTG9vcFJ1bm5pbmcgPSBmYWxzZTtcbiAgICAgICAgc2NoZWR1bGVkSG9zdENhbGxiYWNrID0gbnVsbDtcbiAgICAgIH1cbiAgICB9XG4gIH0gZWxzZSB7XG4gICAgaXNNZXNzYWdlTG9vcFJ1bm5pbmcgPSBmYWxzZTtcbiAgfSAvLyBZaWVsZGluZyB0byB0aGUgYnJvd3NlciB3aWxsIGdpdmUgaXQgYSBjaGFuY2UgdG8gcGFpbnQsIHNvIHdlIGNhblxufTtcblxudmFyIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lO1xuXG5pZiAodHlwZW9mIGxvY2FsU2V0SW1tZWRpYXRlID09PSAnZnVuY3Rpb24nKSB7XG4gIC8vIE5vZGUuanMgYW5kIG9sZCBJRS5cbiAgLy8gVGhlcmUncyBhIGZldyByZWFzb25zIGZvciB3aHkgd2UgcHJlZmVyIHNldEltbWVkaWF0ZS5cbiAgLy9cbiAgLy8gVW5saWtlIE1lc3NhZ2VDaGFubmVsLCBpdCBkb2Vzbid0IHByZXZlbnQgYSBOb2RlLmpzIHByb2Nlc3MgZnJvbSBleGl0aW5nLlxuICAvLyAoRXZlbiB0aG91Z2ggdGhpcyBpcyBhIERPTSBmb3JrIG9mIHRoZSBTY2hlZHVsZXIsIHlvdSBjb3VsZCBnZXQgaGVyZVxuICAvLyB3aXRoIGEgbWl4IG9mIE5vZGUuanMgMTUrLCB3aGljaCBoYXMgYSBNZXNzYWdlQ2hhbm5lbCwgYW5kIGpzZG9tLilcbiAgLy8gaHR0cHM6Ly9naXRodWIuY29tL2ZhY2Vib29rL3JlYWN0L2lzc3Vlcy8yMDc1NlxuICAvL1xuICAvLyBCdXQgYWxzbywgaXQgcnVucyBlYXJsaWVyIHdoaWNoIGlzIHRoZSBzZW1hbnRpYyB3ZSB3YW50LlxuICAvLyBJZiBvdGhlciBicm93c2VycyBldmVyIGltcGxlbWVudCBpdCwgaXQncyBiZXR0ZXIgdG8gdXNlIGl0LlxuICAvLyBBbHRob3VnaCBib3RoIG9mIHRoZXNlIHdvdWxkIGJlIGluZmVyaW9yIHRvIG5hdGl2ZSBzY2hlZHVsaW5nLlxuICBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSA9IGZ1bmN0aW9uICgpIHtcbiAgICBsb2NhbFNldEltbWVkaWF0ZShwZXJmb3JtV29ya1VudGlsRGVhZGxpbmUpO1xuICB9O1xufSBlbHNlIGlmICh0eXBlb2YgTWVzc2FnZUNoYW5uZWwgIT09ICd1bmRlZmluZWQnKSB7XG4gIC8vIERPTSBhbmQgV29ya2VyIGVudmlyb25tZW50cy5cbiAgLy8gV2UgcHJlZmVyIE1lc3NhZ2VDaGFubmVsIGJlY2F1c2Ugb2YgdGhlIDRtcyBzZXRUaW1lb3V0IGNsYW1waW5nLlxuICB2YXIgY2hhbm5lbCA9IG5ldyBNZXNzYWdlQ2hhbm5lbCgpO1xuICB2YXIgcG9ydCA9IGNoYW5uZWwucG9ydDI7XG4gIGNoYW5uZWwucG9ydDEub25tZXNzYWdlID0gcGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lO1xuXG4gIHNjaGVkdWxlUGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lID0gZnVuY3Rpb24gKCkge1xuICAgIHBvcnQucG9zdE1lc3NhZ2UobnVsbCk7XG4gIH07XG59IGVsc2Uge1xuICAvLyBXZSBzaG91bGQgb25seSBmYWxsYmFjayBoZXJlIGluIG5vbi1icm93c2VyIGVudmlyb25tZW50cy5cbiAgc2NoZWR1bGVQZXJmb3JtV29ya1VudGlsRGVhZGxpbmUgPSBmdW5jdGlvbiAoKSB7XG4gICAgbG9jYWxTZXRUaW1lb3V0KHBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSwgMCk7XG4gIH07XG59XG5cbmZ1bmN0aW9uIHJlcXVlc3RIb3N0Q2FsbGJhY2soY2FsbGJhY2spIHtcbiAgc2NoZWR1bGVkSG9zdENhbGxiYWNrID0gY2FsbGJhY2s7XG5cbiAgaWYgKCFpc01lc3NhZ2VMb29wUnVubmluZykge1xuICAgIGlzTWVzc2FnZUxvb3BSdW5uaW5nID0gdHJ1ZTtcbiAgICBzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSgpO1xuICB9XG59XG5cbmZ1bmN0aW9uIHJlcXVlc3RIb3N0VGltZW91dChjYWxsYmFjaywgbXMpIHtcbiAgdGFza1RpbWVvdXRJRCA9IGxvY2FsU2V0VGltZW91dChmdW5jdGlvbiAoKSB7XG4gICAgY2FsbGJhY2soZXhwb3J0cy51bnN0YWJsZV9ub3coKSk7XG4gIH0sIG1zKTtcbn1cblxuZnVuY3Rpb24gY2FuY2VsSG9zdFRpbWVvdXQoKSB7XG4gIGxvY2FsQ2xlYXJUaW1lb3V0KHRhc2tUaW1lb3V0SUQpO1xuICB0YXNrVGltZW91dElEID0gLTE7XG59XG5cbnZhciB1bnN0YWJsZV9yZXF1ZXN0UGFpbnQgPSByZXF1ZXN0UGFpbnQ7XG52YXIgdW5zdGFibGVfUHJvZmlsaW5nID0gIG51bGw7XG5cbmV4cG9ydHMudW5zdGFibGVfSWRsZVByaW9yaXR5ID0gSWRsZVByaW9yaXR5O1xuZXhwb3J0cy51bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eSA9IEltbWVkaWF0ZVByaW9yaXR5O1xuZXhwb3J0cy51bnN0YWJsZV9Mb3dQcmlvcml0eSA9IExvd1ByaW9yaXR5O1xuZXhwb3J0cy51bnN0YWJsZV9Ob3JtYWxQcmlvcml0eSA9IE5vcm1hbFByaW9yaXR5O1xuZXhwb3J0cy51bnN0YWJsZV9Qcm9maWxpbmcgPSB1bnN0YWJsZV9Qcm9maWxpbmc7XG5leHBvcnRzLnVuc3RhYmxlX1VzZXJCbG9ja2luZ1ByaW9yaXR5ID0gVXNlckJsb2NraW5nUHJpb3JpdHk7XG5leHBvcnRzLnVuc3RhYmxlX2NhbmNlbENhbGxiYWNrID0gdW5zdGFibGVfY2FuY2VsQ2FsbGJhY2s7XG5leHBvcnRzLnVuc3RhYmxlX2NvbnRpbnVlRXhlY3V0aW9uID0gdW5zdGFibGVfY29udGludWVFeGVjdXRpb247XG5leHBvcnRzLnVuc3RhYmxlX2ZvcmNlRnJhbWVSYXRlID0gZm9yY2VGcmFtZVJhdGU7XG5leHBvcnRzLnVuc3RhYmxlX2dldEN1cnJlbnRQcmlvcml0eUxldmVsID0gdW5zdGFibGVfZ2V0Q3VycmVudFByaW9yaXR5TGV2ZWw7XG5leHBvcnRzLnVuc3RhYmxlX2dldEZpcnN0Q2FsbGJhY2tOb2RlID0gdW5zdGFibGVfZ2V0Rmlyc3RDYWxsYmFja05vZGU7XG5leHBvcnRzLnVuc3RhYmxlX25leHQgPSB1bnN0YWJsZV9uZXh0O1xuZXhwb3J0cy51bnN0YWJsZV9wYXVzZUV4ZWN1dGlvbiA9IHVuc3RhYmxlX3BhdXNlRXhlY3V0aW9uO1xuZXhwb3J0cy51bnN0YWJsZV9yZXF1ZXN0UGFpbnQgPSB1bnN0YWJsZV9yZXF1ZXN0UGFpbnQ7XG5leHBvcnRzLnVuc3RhYmxlX3J1bldpdGhQcmlvcml0eSA9IHVuc3RhYmxlX3J1bldpdGhQcmlvcml0eTtcbmV4cG9ydHMudW5zdGFibGVfc2NoZWR1bGVDYWxsYmFjayA9IHVuc3RhYmxlX3NjaGVkdWxlQ2FsbGJhY2s7XG5leHBvcnRzLnVuc3RhYmxlX3Nob3VsZFlpZWxkID0gc2hvdWxkWWllbGRUb0hvc3Q7XG5leHBvcnRzLnVuc3RhYmxlX3dyYXBDYWxsYmFjayA9IHVuc3RhYmxlX3dyYXBDYWxsYmFjaztcbiAgICAgICAgICAvKiBnbG9iYWwgX19SRUFDVF9ERVZUT09MU19HTE9CQUxfSE9PS19fICovXG5pZiAoXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18gIT09ICd1bmRlZmluZWQnICYmXG4gIHR5cGVvZiBfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18ucmVnaXN0ZXJJbnRlcm5hbE1vZHVsZVN0b3AgPT09XG4gICAgJ2Z1bmN0aW9uJ1xuKSB7XG4gIF9fUkVBQ1RfREVWVE9PTFNfR0xPQkFMX0hPT0tfXy5yZWdpc3RlckludGVybmFsTW9kdWxlU3RvcChuZXcgRXJyb3IoKSk7XG59XG4gICAgICAgIFxuICB9KSgpO1xufVxuIl0sIm5hbWVzIjpbInByb2Nlc3MiLCJfX1JFQUNUX0RFVlRPT0xTX0dMT0JBTF9IT09LX18iLCJyZWdpc3RlckludGVybmFsTW9kdWxlU3RhcnQiLCJFcnJvciIsImVuYWJsZVNjaGVkdWxlckRlYnVnZ2luZyIsImVuYWJsZVByb2ZpbGluZyIsImZyYW1lWWllbGRNcyIsInB1c2giLCJoZWFwIiwibm9kZSIsImluZGV4IiwibGVuZ3RoIiwic2lmdFVwIiwicGVlayIsInBvcCIsImZpcnN0IiwibGFzdCIsInNpZnREb3duIiwiaSIsInBhcmVudEluZGV4IiwicGFyZW50IiwiY29tcGFyZSIsImhhbGZMZW5ndGgiLCJsZWZ0SW5kZXgiLCJsZWZ0IiwicmlnaHRJbmRleCIsInJpZ2h0IiwiYSIsImIiLCJkaWZmIiwic29ydEluZGV4IiwiaWQiLCJJbW1lZGlhdGVQcmlvcml0eSIsIlVzZXJCbG9ja2luZ1ByaW9yaXR5IiwiTm9ybWFsUHJpb3JpdHkiLCJMb3dQcmlvcml0eSIsIklkbGVQcmlvcml0eSIsIm1hcmtUYXNrRXJyb3JlZCIsInRhc2siLCJtcyIsImhhc1BlcmZvcm1hbmNlTm93IiwicGVyZm9ybWFuY2UiLCJub3ciLCJsb2NhbFBlcmZvcm1hbmNlIiwiZXhwb3J0cyIsInVuc3RhYmxlX25vdyIsImxvY2FsRGF0ZSIsIkRhdGUiLCJpbml0aWFsVGltZSIsIm1heFNpZ25lZDMxQml0SW50IiwiSU1NRURJQVRFX1BSSU9SSVRZX1RJTUVPVVQiLCJVU0VSX0JMT0NLSU5HX1BSSU9SSVRZX1RJTUVPVVQiLCJOT1JNQUxfUFJJT1JJVFlfVElNRU9VVCIsIkxPV19QUklPUklUWV9USU1FT1VUIiwiSURMRV9QUklPUklUWV9USU1FT1VUIiwidGFza1F1ZXVlIiwidGltZXJRdWV1ZSIsInRhc2tJZENvdW50ZXIiLCJjdXJyZW50VGFzayIsImN1cnJlbnRQcmlvcml0eUxldmVsIiwiaXNQZXJmb3JtaW5nV29yayIsImlzSG9zdENhbGxiYWNrU2NoZWR1bGVkIiwiaXNIb3N0VGltZW91dFNjaGVkdWxlZCIsImxvY2FsU2V0VGltZW91dCIsInNldFRpbWVvdXQiLCJsb2NhbENsZWFyVGltZW91dCIsImNsZWFyVGltZW91dCIsImxvY2FsU2V0SW1tZWRpYXRlIiwic2V0SW1tZWRpYXRlIiwiaXNJbnB1dFBlbmRpbmciLCJuYXZpZ2F0b3IiLCJzY2hlZHVsaW5nIiwidW5kZWZpbmVkIiwiYmluZCIsImFkdmFuY2VUaW1lcnMiLCJjdXJyZW50VGltZSIsInRpbWVyIiwiY2FsbGJhY2siLCJzdGFydFRpbWUiLCJleHBpcmF0aW9uVGltZSIsImhhbmRsZVRpbWVvdXQiLCJyZXF1ZXN0SG9zdENhbGxiYWNrIiwiZmx1c2hXb3JrIiwiZmlyc3RUaW1lciIsInJlcXVlc3RIb3N0VGltZW91dCIsImhhc1RpbWVSZW1haW5pbmciLCJjYW5jZWxIb3N0VGltZW91dCIsInByZXZpb3VzUHJpb3JpdHlMZXZlbCIsIndvcmtMb29wIiwiZXJyb3IiLCJpc1F1ZXVlZCIsInNob3VsZFlpZWxkVG9Ib3N0IiwicHJpb3JpdHlMZXZlbCIsImRpZFVzZXJDYWxsYmFja1RpbWVvdXQiLCJjb250aW51YXRpb25DYWxsYmFjayIsInVuc3RhYmxlX3J1bldpdGhQcmlvcml0eSIsImV2ZW50SGFuZGxlciIsInVuc3RhYmxlX25leHQiLCJ1bnN0YWJsZV93cmFwQ2FsbGJhY2siLCJwYXJlbnRQcmlvcml0eUxldmVsIiwiYXBwbHkiLCJhcmd1bWVudHMiLCJ1bnN0YWJsZV9zY2hlZHVsZUNhbGxiYWNrIiwib3B0aW9ucyIsImRlbGF5IiwidGltZW91dCIsIm5ld1Rhc2siLCJ1bnN0YWJsZV9wYXVzZUV4ZWN1dGlvbiIsInVuc3RhYmxlX2NvbnRpbnVlRXhlY3V0aW9uIiwidW5zdGFibGVfZ2V0Rmlyc3RDYWxsYmFja05vZGUiLCJ1bnN0YWJsZV9jYW5jZWxDYWxsYmFjayIsInVuc3RhYmxlX2dldEN1cnJlbnRQcmlvcml0eUxldmVsIiwiaXNNZXNzYWdlTG9vcFJ1bm5pbmciLCJzY2hlZHVsZWRIb3N0Q2FsbGJhY2siLCJ0YXNrVGltZW91dElEIiwiZnJhbWVJbnRlcnZhbCIsInRpbWVFbGFwc2VkIiwicmVxdWVzdFBhaW50IiwiZm9yY2VGcmFtZVJhdGUiLCJmcHMiLCJjb25zb2xlIiwiTWF0aCIsImZsb29yIiwicGVyZm9ybVdvcmtVbnRpbERlYWRsaW5lIiwiaGFzTW9yZVdvcmsiLCJzY2hlZHVsZVBlcmZvcm1Xb3JrVW50aWxEZWFkbGluZSIsIk1lc3NhZ2VDaGFubmVsIiwiY2hhbm5lbCIsInBvcnQiLCJwb3J0MiIsInBvcnQxIiwib25tZXNzYWdlIiwicG9zdE1lc3NhZ2UiLCJ1bnN0YWJsZV9yZXF1ZXN0UGFpbnQiLCJ1bnN0YWJsZV9Qcm9maWxpbmciLCJ1bnN0YWJsZV9JZGxlUHJpb3JpdHkiLCJ1bnN0YWJsZV9JbW1lZGlhdGVQcmlvcml0eSIsInVuc3RhYmxlX0xvd1ByaW9yaXR5IiwidW5zdGFibGVfTm9ybWFsUHJpb3JpdHkiLCJ1bnN0YWJsZV9Vc2VyQmxvY2tpbmdQcmlvcml0eSIsInVuc3RhYmxlX2ZvcmNlRnJhbWVSYXRlIiwidW5zdGFibGVfc2hvdWxkWWllbGQiLCJyZWdpc3RlckludGVybmFsTW9kdWxlU3RvcCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/cjs/scheduler.development.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/index.js":
/*!*************************************************************************!*\
  !*** ./node_modules/@react-three/fiber/node_modules/scheduler/index.js ***!
  \*************************************************************************/
/***/ ((module, __unused_webpack_exports, __webpack_require__) => {

eval("\nif (false) {} else {\n    module.exports = __webpack_require__(/*! ./cjs/scheduler.development.js */ \"(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/cjs/scheduler.development.js\");\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL25vZGVfbW9kdWxlcy9zY2hlZHVsZXIvaW5kZXguanMiLCJtYXBwaW5ncyI6IkFBQUE7QUFFQSxJQUFJQSxLQUF5QixFQUFjLEVBRTFDLE1BQU07SUFDTEMseUtBQXlCO0FBQzNCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmliZS0zZC1jb2RlLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9maWJlci9ub2RlX21vZHVsZXMvc2NoZWR1bGVyL2luZGV4LmpzPzZiYTkiXSwic291cmNlc0NvbnRlbnQiOlsiJ3VzZSBzdHJpY3QnO1xuXG5pZiAocHJvY2Vzcy5lbnYuTk9ERV9FTlYgPT09ICdwcm9kdWN0aW9uJykge1xuICBtb2R1bGUuZXhwb3J0cyA9IHJlcXVpcmUoJy4vY2pzL3NjaGVkdWxlci5wcm9kdWN0aW9uLm1pbi5qcycpO1xufSBlbHNlIHtcbiAgbW9kdWxlLmV4cG9ydHMgPSByZXF1aXJlKCcuL2Nqcy9zY2hlZHVsZXIuZGV2ZWxvcG1lbnQuanMnKTtcbn1cbiJdLCJuYW1lcyI6WyJwcm9jZXNzIiwibW9kdWxlIiwiZXhwb3J0cyIsInJlcXVpcmUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/node_modules/scheduler/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/fiber/node_modules/zustand/esm/index.js":
/*!***************************************************************************!*\
  !*** ./node_modules/@react-three/fiber/node_modules/zustand/esm/index.js ***!
  \***************************************************************************/
/***/ ((__unused_webpack_module, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   \"default\": () => (/* binding */ create)\n/* harmony export */ });\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react */ \"(ssr)/./node_modules/next/dist/server/future/route-modules/app-page/vendored/ssr/react.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_0___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_0__);\n\nfunction createStore(createState) {\n    let state;\n    const listeners = /* @__PURE__ */ new Set();\n    const setState = (partial, replace)=>{\n        const nextState = typeof partial === \"function\" ? partial(state) : partial;\n        if (nextState !== state) {\n            const previousState = state;\n            state = replace ? nextState : Object.assign({}, state, nextState);\n            listeners.forEach((listener)=>listener(state, previousState));\n        }\n    };\n    const getState = ()=>state;\n    const subscribeWithSelector = (listener, selector = getState, equalityFn = Object.is)=>{\n        console.warn(\"[DEPRECATED] Please use `subscribeWithSelector` middleware\");\n        let currentSlice = selector(state);\n        function listenerToAdd() {\n            const nextSlice = selector(state);\n            if (!equalityFn(currentSlice, nextSlice)) {\n                const previousSlice = currentSlice;\n                listener(currentSlice = nextSlice, previousSlice);\n            }\n        }\n        listeners.add(listenerToAdd);\n        return ()=>listeners.delete(listenerToAdd);\n    };\n    const subscribe = (listener, selector, equalityFn)=>{\n        if (selector || equalityFn) {\n            return subscribeWithSelector(listener, selector, equalityFn);\n        }\n        listeners.add(listener);\n        return ()=>listeners.delete(listener);\n    };\n    const destroy = ()=>listeners.clear();\n    const api = {\n        setState,\n        getState,\n        subscribe,\n        destroy\n    };\n    state = createState(setState, getState, api);\n    return api;\n}\nconst isSSR =  true || 0;\nconst useIsomorphicLayoutEffect = isSSR ? react__WEBPACK_IMPORTED_MODULE_0__.useEffect : react__WEBPACK_IMPORTED_MODULE_0__.useLayoutEffect;\nfunction create(createState) {\n    const api = typeof createState === \"function\" ? createStore(createState) : createState;\n    const useStore = (selector = api.getState, equalityFn = Object.is)=>{\n        const [, forceUpdate] = (0,react__WEBPACK_IMPORTED_MODULE_0__.useReducer)((c)=>c + 1, 0);\n        const state = api.getState();\n        const stateRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(state);\n        const selectorRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(selector);\n        const equalityFnRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(equalityFn);\n        const erroredRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(false);\n        const currentSliceRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)();\n        if (currentSliceRef.current === void 0) {\n            currentSliceRef.current = selector(state);\n        }\n        let newStateSlice;\n        let hasNewStateSlice = false;\n        if (stateRef.current !== state || selectorRef.current !== selector || equalityFnRef.current !== equalityFn || erroredRef.current) {\n            newStateSlice = selector(state);\n            hasNewStateSlice = !equalityFn(currentSliceRef.current, newStateSlice);\n        }\n        useIsomorphicLayoutEffect(()=>{\n            if (hasNewStateSlice) {\n                currentSliceRef.current = newStateSlice;\n            }\n            stateRef.current = state;\n            selectorRef.current = selector;\n            equalityFnRef.current = equalityFn;\n            erroredRef.current = false;\n        });\n        const stateBeforeSubscriptionRef = (0,react__WEBPACK_IMPORTED_MODULE_0__.useRef)(state);\n        useIsomorphicLayoutEffect(()=>{\n            const listener = ()=>{\n                try {\n                    const nextState = api.getState();\n                    const nextStateSlice = selectorRef.current(nextState);\n                    if (!equalityFnRef.current(currentSliceRef.current, nextStateSlice)) {\n                        stateRef.current = nextState;\n                        currentSliceRef.current = nextStateSlice;\n                        forceUpdate();\n                    }\n                } catch (error) {\n                    erroredRef.current = true;\n                    forceUpdate();\n                }\n            };\n            const unsubscribe = api.subscribe(listener);\n            if (api.getState() !== stateBeforeSubscriptionRef.current) {\n                listener();\n            }\n            return unsubscribe;\n        }, []);\n        const sliceToReturn = hasNewStateSlice ? newStateSlice : currentSliceRef.current;\n        (0,react__WEBPACK_IMPORTED_MODULE_0__.useDebugValue)(sliceToReturn);\n        return sliceToReturn;\n    };\n    Object.assign(useStore, api);\n    useStore[Symbol.iterator] = function() {\n        console.warn(\"[useStore, api] = create() is deprecated and will be removed in v4\");\n        const items = [\n            useStore,\n            api\n        ];\n        return {\n            next () {\n                const done = items.length <= 0;\n                return {\n                    value: items.shift(),\n                    done\n                };\n            }\n        };\n    };\n    return useStore;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL25vZGVfbW9kdWxlcy96dXN0YW5kL2VzbS9pbmRleC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBc0Y7QUFFdEYsU0FBU0ssWUFBWUMsV0FBVztJQUM5QixJQUFJQztJQUNKLE1BQU1DLFlBQVksYUFBYSxHQUFHLElBQUlDO0lBQ3RDLE1BQU1DLFdBQVcsQ0FBQ0MsU0FBU0M7UUFDekIsTUFBTUMsWUFBWSxPQUFPRixZQUFZLGFBQWFBLFFBQVFKLFNBQVNJO1FBQ25FLElBQUlFLGNBQWNOLE9BQU87WUFDdkIsTUFBTU8sZ0JBQWdCUDtZQUN0QkEsUUFBUUssVUFBVUMsWUFBWUUsT0FBT0MsTUFBTSxDQUFDLENBQUMsR0FBR1QsT0FBT007WUFDdkRMLFVBQVVTLE9BQU8sQ0FBQyxDQUFDQyxXQUFhQSxTQUFTWCxPQUFPTztRQUNsRDtJQUNGO0lBQ0EsTUFBTUssV0FBVyxJQUFNWjtJQUN2QixNQUFNYSx3QkFBd0IsQ0FBQ0YsVUFBVUcsV0FBV0YsUUFBUSxFQUFFRyxhQUFhUCxPQUFPUSxFQUFFO1FBQ2xGQyxRQUFRQyxJQUFJLENBQUM7UUFDYixJQUFJQyxlQUFlTCxTQUFTZDtRQUM1QixTQUFTb0I7WUFDUCxNQUFNQyxZQUFZUCxTQUFTZDtZQUMzQixJQUFJLENBQUNlLFdBQVdJLGNBQWNFLFlBQVk7Z0JBQ3hDLE1BQU1DLGdCQUFnQkg7Z0JBQ3RCUixTQUFTUSxlQUFlRSxXQUFXQztZQUNyQztRQUNGO1FBQ0FyQixVQUFVc0IsR0FBRyxDQUFDSDtRQUNkLE9BQU8sSUFBTW5CLFVBQVV1QixNQUFNLENBQUNKO0lBQ2hDO0lBQ0EsTUFBTUssWUFBWSxDQUFDZCxVQUFVRyxVQUFVQztRQUNyQyxJQUFJRCxZQUFZQyxZQUFZO1lBQzFCLE9BQU9GLHNCQUFzQkYsVUFBVUcsVUFBVUM7UUFDbkQ7UUFDQWQsVUFBVXNCLEdBQUcsQ0FBQ1o7UUFDZCxPQUFPLElBQU1WLFVBQVV1QixNQUFNLENBQUNi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LE1BQU1HLE1BQU0sSUFBSTtnQkFDN0IsT0FBTztvQkFBRUMsT0FBT0osTUFBTUssS0FBSztvQkFBSUg7Z0JBQUs7WUFDdEM7UUFDRjtJQUNGO0lBQ0EsT0FBT3BCO0FBQ1Q7QUFFNkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aWJlLTNkLWNvZGUvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2ZpYmVyL25vZGVfbW9kdWxlcy96dXN0YW5kL2VzbS9pbmRleC5qcz8zMzAyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IHVzZVJlZHVjZXIsIHVzZVJlZiwgdXNlRGVidWdWYWx1ZSwgdXNlRWZmZWN0LCB1c2VMYXlvdXRFZmZlY3QgfSBmcm9tICdyZWFjdCc7XG5cbmZ1bmN0aW9uIGNyZWF0ZVN0b3JlKGNyZWF0ZVN0YXRlKSB7XG4gIGxldCBzdGF0ZTtcbiAgY29uc3QgbGlzdGVuZXJzID0gLyogQF9fUFVSRV9fICovIG5ldyBTZXQoKTtcbiAgY29uc3Qgc2V0U3RhdGUgPSAocGFydGlhbCwgcmVwbGFjZSkgPT4ge1xuICAgIGNvbnN0IG5leHRTdGF0ZSA9IHR5cGVvZiBwYXJ0aWFsID09PSBcImZ1bmN0aW9uXCIgPyBwYXJ0aWFsKHN0YXRlKSA6IHBhcnRpYWw7XG4gICAgaWYgKG5leHRTdGF0ZSAhPT0gc3RhdGUpIHtcbiAgICAgIGNvbnN0IHByZXZpb3VzU3RhdGUgPSBzdGF0ZTtcbiAgICAgIHN0YXRlID0gcmVwbGFjZSA/IG5leHRTdGF0ZSA6IE9iamVjdC5hc3NpZ24oe30sIHN0YXRlLCBuZXh0U3RhdGUpO1xuICAgICAgbGlzdGVuZXJzLmZvckVhY2goKGxpc3RlbmVyKSA9PiBsaXN0ZW5lcihzdGF0ZSwgcHJldmlvdXNTdGF0ZSkpO1xuICAgIH1cbiAgfTtcbiAgY29uc3QgZ2V0U3RhdGUgPSAoKSA9PiBzdGF0ZTtcbiAgY29uc3Qgc3Vic2NyaWJlV2l0aFNlbGVjdG9yID0gKGxpc3RlbmVyLCBzZWxlY3RvciA9IGdldFN0YXRlLCBlcXVhbGl0eUZuID0gT2JqZWN0LmlzKSA9PiB7XG4gICAgY29uc29sZS53YXJuKFwiW0RFUFJFQ0FURURdIFBsZWFzZSB1c2UgYHN1YnNjcmliZVdpdGhTZWxlY3RvcmAgbWlkZGxld2FyZVwiKTtcbiAgICBsZXQgY3VycmVudFNsaWNlID0gc2VsZWN0b3Ioc3RhdGUpO1xuICAgIGZ1bmN0aW9uIGxpc3RlbmVyVG9BZGQoKSB7XG4gICAgICBjb25zdCBuZXh0U2xpY2UgPSBzZWxlY3RvcihzdGF0ZSk7XG4gICAgICBpZiAoIWVxdWFsaXR5Rm4oY3VycmVudFNsaWNlLCBuZXh0U2xpY2UpKSB7XG4gICAgICAgIGNvbnN0IHByZXZpb3VzU2xpY2UgPSBjdXJyZW50U2xpY2U7XG4gICAgICAgIGxpc3RlbmVyKGN1cnJlbnRTbGljZSA9IG5leHRTbGljZSwgcHJldmlvdXNTbGljZSk7XG4gICAgICB9XG4gICAgfVxuICAgIGxpc3RlbmVycy5hZGQobGlzdGVuZXJUb0FkZCk7XG4gICAgcmV0dXJuICgpID0+IGxpc3RlbmVycy5kZWxldGUobGlzdGVuZXJUb0FkZCk7XG4gIH07XG4gIGNvbnN0IHN1YnNjcmliZSA9IChsaXN0ZW5lciwgc2VsZWN0b3IsIGVxdWFsaXR5Rm4pID0+IHtcbiAgICBpZiAoc2VsZWN0b3IgfHwgZXF1YWxpdHlGbikge1xuICAgICAgcmV0dXJuIHN1YnNjcmliZVdpdGhTZWxlY3RvcihsaXN0ZW5lciwgc2VsZWN0b3IsIGVxdWFsaXR5Rm4pO1xuICAgIH1cbiAgICBsaXN0ZW5lcnMuYWRkKGxpc3RlbmVyKTtcbiAgICByZXR1cm4gKCkgPT4gbGlzdGVuZXJzLmRlbGV0ZShsaXN0ZW5lcik7XG4gIH07XG4gIGNvbnN0IGRlc3Ryb3kgPSAoKSA9PiBsaXN0ZW5lcnMuY2xlYXIoKTtcbiAgY29uc3QgYXBpID0geyBzZXRTdGF0ZSwgZ2V0U3RhdGUsIHN1YnNjcmliZSwgZGVzdHJveSB9O1xuICBzdGF0ZSA9IGNyZWF0ZVN0YXRlKHNldFN0YXRlLCBnZXRTdGF0ZSwgYXBpKTtcbiAgcmV0dXJuIGFwaTtcbn1cblxuY29uc3QgaXNTU1IgPSB0eXBlb2Ygd2luZG93ID09PSBcInVuZGVmaW5lZFwiIHx8ICF3aW5kb3cubmF2aWdhdG9yIHx8IC9TZXJ2ZXJTaWRlUmVuZGVyaW5nfF5EZW5vXFwvLy50ZXN0KHdpbmRvdy5uYXZpZ2F0b3IudXNlckFnZW50KTtcbmNvbnN0IHVzZUlzb21vcnBoaWNMYXlvdXRFZmZlY3QgPSBpc1NTUiA/IHVzZUVmZmVjdCA6IHVzZUxheW91dEVmZmVjdDtcbmZ1bmN0aW9uIGNyZWF0ZShjcmVhdGVTdGF0ZSkge1xuICBjb25zdCBhcGkgPSB0eXBlb2YgY3JlYXRlU3RhdGUgPT09IFwiZnVuY3Rpb25cIiA/IGNyZWF0ZVN0b3JlKGNyZWF0ZVN0YXRlKSA6IGNyZWF0ZVN0YXRlO1xuICBjb25zdCB1c2VTdG9yZSA9IChzZWxlY3RvciA9IGFwaS5nZXRTdGF0ZSwgZXF1YWxpdHlGbiA9IE9iamVjdC5pcykgPT4ge1xuICAgIGNvbnN0IFssIGZvcmNlVXBkYXRlXSA9IHVzZVJlZHVjZXIoKGMpID0+IGMgKyAxLCAwKTtcbiAgICBjb25zdCBzdGF0ZSA9IGFwaS5nZXRTdGF0ZSgpO1xuICAgIGNvbnN0IHN0YXRlUmVmID0gdXNlUmVmKHN0YXRlKTtcbiAgICBjb25zdCBzZWxlY3RvclJlZiA9IHVzZVJlZihzZWxlY3Rvcik7XG4gICAgY29uc3QgZXF1YWxpdHlGblJlZiA9IHVzZVJlZihlcXVhbGl0eUZuKTtcbiAgICBjb25zdCBlcnJvcmVkUmVmID0gdXNlUmVmKGZhbHNlKTtcbiAgICBjb25zdCBjdXJyZW50U2xpY2VSZWYgPSB1c2VSZWYoKTtcbiAgICBpZiAoY3VycmVudFNsaWNlUmVmLmN1cnJlbnQgPT09IHZvaWQgMCkge1xuICAgICAgY3VycmVudFNsaWNlUmVmLmN1cnJlbnQgPSBzZWxlY3RvcihzdGF0ZSk7XG4gICAgfVxuICAgIGxldCBuZXdTdGF0ZVNsaWNlO1xuICAgIGxldCBoYXNOZXdTdGF0ZVNsaWNlID0gZmFsc2U7XG4gICAgaWYgKHN0YXRlUmVmLmN1cnJlbnQgIT09IHN0YXRlIHx8IHNlbGVjdG9yUmVmLmN1cnJlbnQgIT09IHNlbGVjdG9yIHx8IGVxdWFsaXR5Rm5SZWYuY3VycmVudCAhPT0gZXF1YWxpdHlGbiB8fCBlcnJvcmVkUmVmLmN1cnJlbnQpIHtcbiAgICAgIG5ld1N0YXRlU2xpY2UgPSBzZWxlY3RvcihzdGF0ZSk7XG4gICAgICBoYXNOZXdTdGF0ZVNsaWNlID0gIWVxdWFsaXR5Rm4oY3VycmVudFNsaWNlUmVmLmN1cnJlbnQsIG5ld1N0YXRlU2xpY2UpO1xuICAgIH1cbiAgICB1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0KCgpID0+IHtcbiAgICAgIGlmIChoYXNOZXdTdGF0ZVNsaWNlKSB7XG4gICAgICAgIGN1cnJlbnRTbGljZVJlZi5jdXJyZW50ID0gbmV3U3RhdGVTbGljZTtcbiAgICAgIH1cbiAgICAgIHN0YXRlUmVmLmN1cnJlbnQgPSBzdGF0ZTtcbiAgICAgIHNlbGVjdG9yUmVmLmN1cnJlbnQgPSBzZWxlY3RvcjtcbiAgICAgIGVxdWFsaXR5Rm5SZWYuY3VycmVudCA9IGVxdWFsaXR5Rm47XG4gICAgICBlcnJvcmVkUmVmLmN1cnJlbnQgPSBmYWxzZTtcbiAgICB9KTtcbiAgICBjb25zdCBzdGF0ZUJlZm9yZVN1YnNjcmlwdGlvblJlZiA9IHVzZVJlZihzdGF0ZSk7XG4gICAgdXNlSXNvbW9ycGhpY0xheW91dEVmZmVjdCgoKSA9PiB7XG4gICAgICBjb25zdCBsaXN0ZW5lciA9ICgpID0+IHtcbiAgICAgICAgdHJ5IHtcbiAgICAgICAgICBjb25zdCBuZXh0U3RhdGUgPSBhcGkuZ2V0U3RhdGUoKTtcbiAgICAgICAgICBjb25zdCBuZXh0U3RhdGVTbGljZSA9IHNlbGVjdG9yUmVmLmN1cnJlbnQobmV4dFN0YXRlKTtcbiAgICAgICAgICBpZiAoIWVxdWFsaXR5Rm5SZWYuY3VycmVudChjdXJyZW50U2xpY2VSZWYuY3VycmVudCwgbmV4dFN0YXRlU2xpY2UpKSB7XG4gICAgICAgICAgICBzdGF0ZVJlZi5jdXJyZW50ID0gbmV4dFN0YXRlO1xuICAgICAgICAgICAgY3VycmVudFNsaWNlUmVmLmN1cnJlbnQgPSBuZXh0U3RhdGVTbGljZTtcbiAgICAgICAgICAgIGZvcmNlVXBkYXRlKCk7XG4gICAgICAgICAgfVxuICAgICAgICB9IGNhdGNoIChlcnJvcikge1xuICAgICAgICAgIGVycm9yZWRSZWYuY3VycmVudCA9IHRydWU7XG4gICAgICAgICAgZm9yY2VVcGRhdGUoKTtcbiAgICAgICAgfVxuICAgICAgfTtcbiAgICAgIGNvbnN0IHVuc3Vic2NyaWJlID0gYXBpLnN1YnNjcmliZShsaXN0ZW5lcik7XG4gICAgICBpZiAoYXBpLmdldFN0YXRlKCkgIT09IHN0YXRlQmVmb3JlU3Vic2NyaXB0aW9uUmVmLmN1cnJlbnQpIHtcbiAgICAgICAgbGlzdGVuZXIoKTtcbiAgICAgIH1cbiAgICAgIHJldHVybiB1bnN1YnNjcmliZTtcbiAgICB9LCBbXSk7XG4gICAgY29uc3Qgc2xpY2VUb1JldHVybiA9IGhhc05ld1N0YXRlU2xpY2UgPyBuZXdTdGF0ZVNsaWNlIDogY3VycmVudFNsaWNlUmVmLmN1cnJlbnQ7XG4gICAgdXNlRGVidWdWYWx1ZShzbGljZVRvUmV0dXJuKTtcbiAgICByZXR1cm4gc2xpY2VUb1JldHVybjtcbiAgfTtcbiAgT2JqZWN0LmFzc2lnbih1c2VTdG9yZSwgYXBpKTtcbiAgdXNlU3RvcmVbU3ltYm9sLml0ZXJhdG9yXSA9IGZ1bmN0aW9uKCkge1xuICAgIGNvbnNvbGUud2FybihcIlt1c2VTdG9yZSwgYXBpXSA9IGNyZWF0ZSgpIGlzIGRlcHJlY2F0ZWQgYW5kIHdpbGwgYmUgcmVtb3ZlZCBpbiB2NFwiKTtcbiAgICBjb25zdCBpdGVtcyA9IFt1c2VTdG9yZSwgYXBpXTtcbiAgICByZXR1cm4ge1xuICAgICAgbmV4dCgpIHtcbiAgICAgICAgY29uc3QgZG9uZSA9IGl0ZW1zLmxlbmd0aCA8PSAwO1xuICAgICAgICByZXR1cm4geyB2YWx1ZTogaXRlbXMuc2hpZnQoKSwgZG9uZSB9O1xuICAgICAgfVxuICAgIH07XG4gIH07XG4gIHJldHVybiB1c2VTdG9yZTtcbn1cblxuZXhwb3J0IHsgY3JlYXRlIGFzIGRlZmF1bHQgfTtcbiJdLCJuYW1lcyI6WyJ1c2VSZWR1Y2VyIiwidXNlUmVmIiwidXNlRGVidWdWYWx1ZSIsInVzZUVmZmVjdCIsInVzZUxheW91dEVmZmVjdCIsImNyZWF0ZVN0b3JlIiwiY3JlYXRlU3RhdGUiLCJzdGF0ZSIsImxpc3RlbmVycyIsIlNldCIsInNldFN0YXRlIiwicGFydGlhbCIsInJlcGxhY2UiLCJuZXh0U3RhdGUiLCJwcmV2aW91c1N0YXRlIiwiT2JqZWN0IiwiYXNzaWduIiwiZm9yRWFjaCIsImxpc3RlbmVyIiwiZ2V0U3RhdGUiLCJzdWJzY3JpYmVXaXRoU2VsZWN0b3IiLCJzZWxlY3RvciIsImVxdWFsaXR5Rm4iLCJpcyIsImNvbnNvbGUiLCJ3YXJuIiwiY3VycmVudFNsaWNlIiwibGlzdGVuZXJUb0FkZCIsIm5leHRTbGljZSIsInByZXZpb3VzU2xpY2UiLCJhZGQiLCJkZWxldGUiLCJzdWJzY3JpYmUiLCJkZXN0cm95IiwiY2xlYXIiLCJhcGkiLCJpc1NTUiIsIndpbmRvdyIsIm5hdmlnYXRvciIsInRlc3QiLCJ1c2VyQWdlbnQiLCJ1c2VJc29tb3JwaGljTGF5b3V0RWZmZWN0IiwiY3JlYXRlIiwidXNlU3RvcmUiLCJmb3JjZVVwZGF0ZSIsImMiLCJzdGF0ZVJlZiIsInNlbGVjdG9yUmVmIiwiZXF1YWxpdHlGblJlZiIsImVycm9yZWRSZWYiLCJjdXJyZW50U2xpY2VSZWYiLCJjdXJyZW50IiwibmV3U3RhdGVTbGljZSIsImhhc05ld1N0YXRlU2xpY2UiLCJzdGF0ZUJlZm9yZVN1YnNjcmlwdGlvblJlZiIsIm5leHRTdGF0ZVNsaWNlIiwiZXJyb3IiLCJ1bnN1YnNjcmliZSIsInNsaWNlVG9SZXR1cm4iLCJTeW1ib2wiLCJpdGVyYXRvciIsIml0ZW1zIiwibmV4dCIsImRvbmUiLCJsZW5ndGgiLCJ2YWx1ZSIsInNoaWZ0IiwiZGVmYXVsdCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/fiber/node_modules/zustand/esm/index.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/Constants.js":
/*!******************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/Constants.js ***!
  \******************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   AVERAGE: () => (/* binding */ AVERAGE),\n/* harmony export */   BYTES_PER_NODE: () => (/* binding */ BYTES_PER_NODE),\n/* harmony export */   CENTER: () => (/* binding */ CENTER),\n/* harmony export */   CONTAINED: () => (/* binding */ CONTAINED),\n/* harmony export */   FLOAT32_EPSILON: () => (/* binding */ FLOAT32_EPSILON),\n/* harmony export */   INTERSECTED: () => (/* binding */ INTERSECTED),\n/* harmony export */   IS_LEAFNODE_FLAG: () => (/* binding */ IS_LEAFNODE_FLAG),\n/* harmony export */   NOT_INTERSECTED: () => (/* binding */ NOT_INTERSECTED),\n/* harmony export */   SAH: () => (/* binding */ SAH),\n/* harmony export */   SKIP_GENERATION: () => (/* binding */ SKIP_GENERATION),\n/* harmony export */   TRAVERSAL_COST: () => (/* binding */ TRAVERSAL_COST),\n/* harmony export */   TRIANGLE_INTERSECT_COST: () => (/* binding */ TRIANGLE_INTERSECT_COST)\n/* harmony export */ });\n// Split strategy constants\nconst CENTER = 0;\nconst AVERAGE = 1;\nconst SAH = 2;\n// Traversal constants\nconst NOT_INTERSECTED = 0;\nconst INTERSECTED = 1;\nconst CONTAINED = 2;\n// SAH cost constants\n// TODO: hone these costs more. The relative difference between them should be the\n// difference in measured time to perform a triangle intersection vs traversing\n// bounds.\nconst TRIANGLE_INTERSECT_COST = 1.25;\nconst TRAVERSAL_COST = 1;\n// Build constants\nconst BYTES_PER_NODE = 6 * 4 + 4 + 4;\nconst IS_LEAFNODE_FLAG = 0xFFFF;\n// EPSILON for computing floating point error during build\n// https://en.wikipedia.org/wiki/Machine_epsilon#Values_for_standard_hardware_floating_point_arithmetics\nconst FLOAT32_EPSILON = Math.pow(2, -24);\nconst SKIP_GENERATION = Symbol(\"SKIP_GENERATION\");\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9jb3JlL0NvbnN0YW50cy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7Ozs7Ozs7QUFBQSwyQkFBMkI7QUFDcEIsTUFBTUEsU0FBUyxFQUFFO0FBQ2pCLE1BQU1DLFVBQVUsRUFBRTtBQUNsQixNQUFNQyxNQUFNLEVBQUU7QUFFckIsc0JBQXNCO0FBQ2YsTUFBTUMsa0JBQWtCLEVBQUU7QUFDMUIsTUFBTUMsY0FBYyxFQUFFO0FBQ3RCLE1BQU1DLFlBQVksRUFBRTtBQUUzQixxQkFBcUI7QUFDckIsa0ZBQWtGO0FBQ2xGLCtFQUErRTtBQUMvRSxVQUFVO0FBQ0gsTUFBTUMsMEJBQTBCLEtBQUs7QUFDckMsTUFBTUMsaUJBQWlCLEVBQUU7QUFHaEMsa0JBQWtCO0FBQ1gsTUFBTUMsaUJBQWlCLElBQUksSUFBSSxJQUFJLEVBQUU7QUFDckMsTUFBTUMsbUJBQW1CLE9BQU87QUFFdkMsMERBQTBEO0FBQzFELHdHQUF3RztBQUNqRyxNQUFNQyxrQkFBa0JDLEtBQUtDLEdBQUcsQ0FBRSxHQUFHLENBQUUsSUFBSztBQUU1QyxNQUFNQyxrQkFBa0JDLE9BQVEsbUJBQW9CIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmliZS0zZC1jb2RlLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvY29yZS9Db25zdGFudHMuanM/YmY1NyJdLCJzb3VyY2VzQ29udGVudCI6WyIvLyBTcGxpdCBzdHJhdGVneSBjb25zdGFudHNcbmV4cG9ydCBjb25zdCBDRU5URVIgPSAwO1xuZXhwb3J0IGNvbnN0IEFWRVJBR0UgPSAxO1xuZXhwb3J0IGNvbnN0IFNBSCA9IDI7XG5cbi8vIFRyYXZlcnNhbCBjb25zdGFudHNcbmV4cG9ydCBjb25zdCBOT1RfSU5URVJTRUNURUQgPSAwO1xuZXhwb3J0IGNvbnN0IElOVEVSU0VDVEVEID0gMTtcbmV4cG9ydCBjb25zdCBDT05UQUlORUQgPSAyO1xuXG4vLyBTQUggY29zdCBjb25zdGFudHNcbi8vIFRPRE86IGhvbmUgdGhlc2UgY29zdHMgbW9yZS4gVGhlIHJlbGF0aXZlIGRpZmZlcmVuY2UgYmV0d2VlbiB0aGVtIHNob3VsZCBiZSB0aGVcbi8vIGRpZmZlcmVuY2UgaW4gbWVhc3VyZWQgdGltZSB0byBwZXJmb3JtIGEgdHJpYW5nbGUgaW50ZXJzZWN0aW9uIHZzIHRyYXZlcnNpbmdcbi8vIGJvdW5kcy5cbmV4cG9ydCBjb25zdCBUUklBTkdMRV9JTlRFUlNFQ1RfQ09TVCA9IDEuMjU7XG5leHBvcnQgY29uc3QgVFJBVkVSU0FMX0NPU1QgPSAxO1xuXG5cbi8vIEJ1aWxkIGNvbnN0YW50c1xuZXhwb3J0IGNvbnN0IEJZVEVTX1BFUl9OT0RFID0gNiAqIDQgKyA0ICsgNDtcbmV4cG9ydCBjb25zdCBJU19MRUFGTk9ERV9GTEFHID0gMHhGRkZGO1xuXG4vLyBFUFNJTE9OIGZvciBjb21wdXRpbmcgZmxvYXRpbmcgcG9pbnQgZXJyb3IgZHVyaW5nIGJ1aWxkXG4vLyBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9NYWNoaW5lX2Vwc2lsb24jVmFsdWVzX2Zvcl9zdGFuZGFyZF9oYXJkd2FyZV9mbG9hdGluZ19wb2ludF9hcml0aG1ldGljc1xuZXhwb3J0IGNvbnN0IEZMT0FUMzJfRVBTSUxPTiA9IE1hdGgucG93KCAyLCAtIDI0ICk7XG5cbmV4cG9ydCBjb25zdCBTS0lQX0dFTkVSQVRJT04gPSBTeW1ib2woICdTS0lQX0dFTkVSQVRJT04nICk7XG4iXSwibmFtZXMiOlsiQ0VOVEVSIiwiQVZFUkFHRSIsIlNBSCIsIk5PVF9JTlRFUlNFQ1RFRCIsIklOVEVSU0VDVEVEIiwiQ09OVEFJTkVEIiwiVFJJQU5HTEVfSU5URVJTRUNUX0NPU1QiLCJUUkFWRVJTQUxfQ09TVCIsIkJZVEVTX1BFUl9OT0RFIiwiSVNfTEVBRk5PREVfRkxBRyIsIkZMT0FUMzJfRVBTSUxPTiIsIk1hdGgiLCJwb3ciLCJTS0lQX0dFTkVSQVRJT04iLCJTeW1ib2wiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/Constants.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/MeshBVH.js":
/*!****************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/MeshBVH.js ***!
  \****************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MeshBVH: () => (/* binding */ MeshBVH)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var _Constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./Constants.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/Constants.js\");\n/* harmony import */ var _build_buildTree_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./build/buildTree.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/build/buildTree.js\");\n/* harmony import */ var _math_OrientedBox_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../math/OrientedBox.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/math/OrientedBox.js\");\n/* harmony import */ var _utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_22__ = __webpack_require__(/*! ../utils/ArrayBoxUtilities.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js\");\n/* harmony import */ var _utils_ExtendedTrianglePool_js__WEBPACK_IMPORTED_MODULE_13__ = __webpack_require__(/*! ../utils/ExtendedTrianglePool.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/ExtendedTrianglePool.js\");\n/* harmony import */ var _cast_shapecast_js__WEBPACK_IMPORTED_MODULE_16__ = __webpack_require__(/*! ./cast/shapecast.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/shapecast.js\");\n/* harmony import */ var _cast_closestPointToPoint_js__WEBPACK_IMPORTED_MODULE_21__ = __webpack_require__(/*! ./cast/closestPointToPoint.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/closestPointToPoint.js\");\n/* harmony import */ var _utils_iterationUtils_generated_js__WEBPACK_IMPORTED_MODULE_15__ = __webpack_require__(/*! ./utils/iterationUtils.generated.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/utils/iterationUtils.generated.js\");\n/* harmony import */ var _cast_refit_generated_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ./cast/refit.generated.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/refit.generated.js\");\n/* harmony import */ var _cast_raycast_generated_js__WEBPACK_IMPORTED_MODULE_8__ = __webpack_require__(/*! ./cast/raycast.generated.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/raycast.generated.js\");\n/* harmony import */ var _cast_raycastFirst_generated_js__WEBPACK_IMPORTED_MODULE_10__ = __webpack_require__(/*! ./cast/raycastFirst.generated.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/raycastFirst.generated.js\");\n/* harmony import */ var _cast_intersectsGeometry_generated_js__WEBPACK_IMPORTED_MODULE_12__ = __webpack_require__(/*! ./cast/intersectsGeometry.generated.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/intersectsGeometry.generated.js\");\n/* harmony import */ var _cast_closestPointToGeometry_generated_js__WEBPACK_IMPORTED_MODULE_20__ = __webpack_require__(/*! ./cast/closestPointToGeometry.generated.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry.generated.js\");\n/* harmony import */ var _utils_iterationUtils_indirect_generated_js__WEBPACK_IMPORTED_MODULE_14__ = __webpack_require__(/*! ./utils/iterationUtils_indirect.generated.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/utils/iterationUtils_indirect.generated.js\");\n/* harmony import */ var _cast_refit_indirect_generated_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./cast/refit_indirect.generated.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/refit_indirect.generated.js\");\n/* harmony import */ var _cast_raycast_indirect_generated_js__WEBPACK_IMPORTED_MODULE_7__ = __webpack_require__(/*! ./cast/raycast_indirect.generated.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/raycast_indirect.generated.js\");\n/* harmony import */ var _cast_raycastFirst_indirect_generated_js__WEBPACK_IMPORTED_MODULE_9__ = __webpack_require__(/*! ./cast/raycastFirst_indirect.generated.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/raycastFirst_indirect.generated.js\");\n/* harmony import */ var _cast_intersectsGeometry_indirect_generated_js__WEBPACK_IMPORTED_MODULE_11__ = __webpack_require__(/*! ./cast/intersectsGeometry_indirect.generated.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/intersectsGeometry_indirect.generated.js\");\n/* harmony import */ var _cast_closestPointToGeometry_indirect_generated_js__WEBPACK_IMPORTED_MODULE_19__ = __webpack_require__(/*! ./cast/closestPointToGeometry_indirect.generated.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry_indirect.generated.js\");\n/* harmony import */ var _utils_BufferUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/BufferUtils.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/BufferUtils.js\");\n/* harmony import */ var _utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_17__ = __webpack_require__(/*! ../utils/TriangleUtilities.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js\");\n/* harmony import */ var _cast_bvhcast_js__WEBPACK_IMPORTED_MODULE_18__ = __webpack_require__(/*! ./cast/bvhcast.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/bvhcast.js\");\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\n\nconst obb = /* @__PURE__ */ new _math_OrientedBox_js__WEBPACK_IMPORTED_MODULE_0__.OrientedBox();\nconst tempBox = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_1__.Box3();\nclass MeshBVH {\n    static serialize(bvh, options = {}) {\n        options = {\n            cloneBuffers: true,\n            ...options\n        };\n        const geometry = bvh.geometry;\n        const rootData = bvh._roots;\n        const indirectBuffer = bvh._indirectBuffer;\n        const indexAttribute = geometry.getIndex();\n        let result;\n        if (options.cloneBuffers) {\n            result = {\n                roots: rootData.map((root)=>root.slice()),\n                index: indexAttribute.array.slice(),\n                indirectBuffer: indirectBuffer ? indirectBuffer.slice() : null\n            };\n        } else {\n            result = {\n                roots: rootData,\n                index: indexAttribute.array,\n                indirectBuffer: indirectBuffer\n            };\n        }\n        return result;\n    }\n    static deserialize(data, geometry, options = {}) {\n        options = {\n            setIndex: true,\n            indirect: Boolean(data.indirectBuffer),\n            ...options\n        };\n        const { index, roots, indirectBuffer } = data;\n        const bvh = new MeshBVH(geometry, {\n            ...options,\n            [_Constants_js__WEBPACK_IMPORTED_MODULE_2__.SKIP_GENERATION]: true\n        });\n        bvh._roots = roots;\n        bvh._indirectBuffer = indirectBuffer || null;\n        if (options.setIndex) {\n            const indexAttribute = geometry.getIndex();\n            if (indexAttribute === null) {\n                const newIndex = new three__WEBPACK_IMPORTED_MODULE_1__.BufferAttribute(data.index, 1, false);\n                geometry.setIndex(newIndex);\n            } else if (indexAttribute.array !== index) {\n                indexAttribute.array.set(index);\n                indexAttribute.needsUpdate = true;\n            }\n        }\n        return bvh;\n    }\n    get indirect() {\n        return !!this._indirectBuffer;\n    }\n    constructor(geometry, options = {}){\n        if (!geometry.isBufferGeometry) {\n            throw new Error(\"MeshBVH: Only BufferGeometries are supported.\");\n        } else if (geometry.index && geometry.index.isInterleavedBufferAttribute) {\n            throw new Error(\"MeshBVH: InterleavedBufferAttribute is not supported for the index attribute.\");\n        }\n        // default options\n        options = Object.assign({\n            strategy: _Constants_js__WEBPACK_IMPORTED_MODULE_2__.CENTER,\n            maxDepth: 40,\n            maxLeafTris: 10,\n            verbose: true,\n            useSharedArrayBuffer: false,\n            setBoundingBox: true,\n            onProgress: null,\n            indirect: false,\n            // undocumented options\n            // Whether to skip generating the tree. Used for deserialization.\n            [_Constants_js__WEBPACK_IMPORTED_MODULE_2__.SKIP_GENERATION]: false\n        }, options);\n        if (options.useSharedArrayBuffer && !(0,_utils_BufferUtils_js__WEBPACK_IMPORTED_MODULE_3__.isSharedArrayBufferSupported)()) {\n            throw new Error(\"MeshBVH: SharedArrayBuffer is not available.\");\n        }\n        // retain references to the geometry so we can use them it without having to\n        // take a geometry reference in every function.\n        this.geometry = geometry;\n        this._roots = null;\n        this._indirectBuffer = null;\n        if (!options[_Constants_js__WEBPACK_IMPORTED_MODULE_2__.SKIP_GENERATION]) {\n            (0,_build_buildTree_js__WEBPACK_IMPORTED_MODULE_4__.buildPackedTree)(this, options);\n            if (!geometry.boundingBox && options.setBoundingBox) {\n                geometry.boundingBox = this.getBoundingBox(new three__WEBPACK_IMPORTED_MODULE_1__.Box3());\n            }\n        }\n        const { _indirectBuffer } = this;\n        this.resolveTriangleIndex = options.indirect ? (i)=>_indirectBuffer[i] : (i)=>i;\n    }\n    refit(nodeIndices = null) {\n        const refitFunc = this.indirect ? _cast_refit_indirect_generated_js__WEBPACK_IMPORTED_MODULE_5__.refit_indirect : _cast_refit_generated_js__WEBPACK_IMPORTED_MODULE_6__.refit;\n        return refitFunc(this, nodeIndices);\n    }\n    traverse(callback, rootIndex = 0) {\n        const buffer = this._roots[rootIndex];\n        const uint32Array = new Uint32Array(buffer);\n        const uint16Array = new Uint16Array(buffer);\n        _traverse(0);\n        function _traverse(node32Index, depth = 0) {\n            const node16Index = node32Index * 2;\n            const isLeaf = uint16Array[node16Index + 15] === _Constants_js__WEBPACK_IMPORTED_MODULE_2__.IS_LEAFNODE_FLAG;\n            if (isLeaf) {\n                const offset = uint32Array[node32Index + 6];\n                const count = uint16Array[node16Index + 14];\n                callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), offset, count);\n            } else {\n                // TODO: use node functions here\n                const left = node32Index + _Constants_js__WEBPACK_IMPORTED_MODULE_2__.BYTES_PER_NODE / 4;\n                const right = uint32Array[node32Index + 6];\n                const splitAxis = uint32Array[node32Index + 7];\n                const stopTraversal = callback(depth, isLeaf, new Float32Array(buffer, node32Index * 4, 6), splitAxis);\n                if (!stopTraversal) {\n                    _traverse(left, depth + 1);\n                    _traverse(right, depth + 1);\n                }\n            }\n        }\n    }\n    /* Core Cast Functions */ raycast(ray, materialOrSide = three__WEBPACK_IMPORTED_MODULE_1__.FrontSide) {\n        const roots = this._roots;\n        const geometry = this.geometry;\n        const intersects = [];\n        const isMaterial = materialOrSide.isMaterial;\n        const isArrayMaterial = Array.isArray(materialOrSide);\n        const groups = geometry.groups;\n        const side = isMaterial ? materialOrSide.side : materialOrSide;\n        const raycastFunc = this.indirect ? _cast_raycast_indirect_generated_js__WEBPACK_IMPORTED_MODULE_7__.raycast_indirect : _cast_raycast_generated_js__WEBPACK_IMPORTED_MODULE_8__.raycast;\n        for(let i = 0, l = roots.length; i < l; i++){\n            const materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;\n            const startCount = intersects.length;\n            raycastFunc(this, i, materialSide, ray, intersects);\n            if (isArrayMaterial) {\n                const materialIndex = groups[i].materialIndex;\n                for(let j = startCount, jl = intersects.length; j < jl; j++){\n                    intersects[j].face.materialIndex = materialIndex;\n                }\n            }\n        }\n        return intersects;\n    }\n    raycastFirst(ray, materialOrSide = three__WEBPACK_IMPORTED_MODULE_1__.FrontSide) {\n        const roots = this._roots;\n        const geometry = this.geometry;\n        const isMaterial = materialOrSide.isMaterial;\n        const isArrayMaterial = Array.isArray(materialOrSide);\n        let closestResult = null;\n        const groups = geometry.groups;\n        const side = isMaterial ? materialOrSide.side : materialOrSide;\n        const raycastFirstFunc = this.indirect ? _cast_raycastFirst_indirect_generated_js__WEBPACK_IMPORTED_MODULE_9__.raycastFirst_indirect : _cast_raycastFirst_generated_js__WEBPACK_IMPORTED_MODULE_10__.raycastFirst;\n        for(let i = 0, l = roots.length; i < l; i++){\n            const materialSide = isArrayMaterial ? materialOrSide[groups[i].materialIndex].side : side;\n            const result = raycastFirstFunc(this, i, materialSide, ray);\n            if (result != null && (closestResult == null || result.distance < closestResult.distance)) {\n                closestResult = result;\n                if (isArrayMaterial) {\n                    result.face.materialIndex = groups[i].materialIndex;\n                }\n            }\n        }\n        return closestResult;\n    }\n    intersectsGeometry(otherGeometry, geomToMesh) {\n        let result = false;\n        const roots = this._roots;\n        const intersectsGeometryFunc = this.indirect ? _cast_intersectsGeometry_indirect_generated_js__WEBPACK_IMPORTED_MODULE_11__.intersectsGeometry_indirect : _cast_intersectsGeometry_generated_js__WEBPACK_IMPORTED_MODULE_12__.intersectsGeometry;\n        for(let i = 0, l = roots.length; i < l; i++){\n            result = intersectsGeometryFunc(this, i, otherGeometry, geomToMesh);\n            if (result) {\n                break;\n            }\n        }\n        return result;\n    }\n    shapecast(callbacks) {\n        const triangle = _utils_ExtendedTrianglePool_js__WEBPACK_IMPORTED_MODULE_13__.ExtendedTrianglePool.getPrimitive();\n        const iterateFunc = this.indirect ? _utils_iterationUtils_indirect_generated_js__WEBPACK_IMPORTED_MODULE_14__.iterateOverTriangles_indirect : _utils_iterationUtils_generated_js__WEBPACK_IMPORTED_MODULE_15__.iterateOverTriangles;\n        let { boundsTraverseOrder, intersectsBounds, intersectsRange, intersectsTriangle } = callbacks;\n        // wrap the intersectsRange function\n        if (intersectsRange && intersectsTriangle) {\n            const originalIntersectsRange = intersectsRange;\n            intersectsRange = (offset, count, contained, depth, nodeIndex)=>{\n                if (!originalIntersectsRange(offset, count, contained, depth, nodeIndex)) {\n                    return iterateFunc(offset, count, this, intersectsTriangle, contained, depth, triangle);\n                }\n                return true;\n            };\n        } else if (!intersectsRange) {\n            if (intersectsTriangle) {\n                intersectsRange = (offset, count, contained, depth)=>{\n                    return iterateFunc(offset, count, this, intersectsTriangle, contained, depth, triangle);\n                };\n            } else {\n                intersectsRange = (offset, count, contained)=>{\n                    return contained;\n                };\n            }\n        }\n        // run shapecast\n        let result = false;\n        let byteOffset = 0;\n        const roots = this._roots;\n        for(let i = 0, l = roots.length; i < l; i++){\n            const root = roots[i];\n            result = (0,_cast_shapecast_js__WEBPACK_IMPORTED_MODULE_16__.shapecast)(this, i, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);\n            if (result) {\n                break;\n            }\n            byteOffset += root.byteLength;\n        }\n        _utils_ExtendedTrianglePool_js__WEBPACK_IMPORTED_MODULE_13__.ExtendedTrianglePool.releasePrimitive(triangle);\n        return result;\n    }\n    bvhcast(otherBvh, matrixToLocal, callbacks) {\n        let { intersectsRanges, intersectsTriangles } = callbacks;\n        const triangle1 = _utils_ExtendedTrianglePool_js__WEBPACK_IMPORTED_MODULE_13__.ExtendedTrianglePool.getPrimitive();\n        const indexAttr1 = this.geometry.index;\n        const positionAttr1 = this.geometry.attributes.position;\n        const assignTriangle1 = this.indirect ? (i1)=>{\n            const ti = this.resolveTriangleIndex(i1);\n            (0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_17__.setTriangle)(triangle1, ti * 3, indexAttr1, positionAttr1);\n        } : (i1)=>{\n            (0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_17__.setTriangle)(triangle1, i1 * 3, indexAttr1, positionAttr1);\n        };\n        const triangle2 = _utils_ExtendedTrianglePool_js__WEBPACK_IMPORTED_MODULE_13__.ExtendedTrianglePool.getPrimitive();\n        const indexAttr2 = otherBvh.geometry.index;\n        const positionAttr2 = otherBvh.geometry.attributes.position;\n        const assignTriangle2 = otherBvh.indirect ? (i2)=>{\n            const ti2 = otherBvh.resolveTriangleIndex(i2);\n            (0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_17__.setTriangle)(triangle2, ti2 * 3, indexAttr2, positionAttr2);\n        } : (i2)=>{\n            (0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_17__.setTriangle)(triangle2, i2 * 3, indexAttr2, positionAttr2);\n        };\n        // generate triangle callback if needed\n        if (intersectsTriangles) {\n            const iterateOverDoubleTriangles = (offset1, count1, offset2, count2, depth1, index1, depth2, index2)=>{\n                for(let i2 = offset2, l2 = offset2 + count2; i2 < l2; i2++){\n                    assignTriangle2(i2);\n                    triangle2.a.applyMatrix4(matrixToLocal);\n                    triangle2.b.applyMatrix4(matrixToLocal);\n                    triangle2.c.applyMatrix4(matrixToLocal);\n                    triangle2.needsUpdate = true;\n                    for(let i1 = offset1, l1 = offset1 + count1; i1 < l1; i1++){\n                        assignTriangle1(i1);\n                        triangle1.needsUpdate = true;\n                        if (intersectsTriangles(triangle1, triangle2, i1, i2, depth1, index1, depth2, index2)) {\n                            return true;\n                        }\n                    }\n                }\n                return false;\n            };\n            if (intersectsRanges) {\n                const originalIntersectsRanges = intersectsRanges;\n                intersectsRanges = function(offset1, count1, offset2, count2, depth1, index1, depth2, index2) {\n                    if (!originalIntersectsRanges(offset1, count1, offset2, count2, depth1, index1, depth2, index2)) {\n                        return iterateOverDoubleTriangles(offset1, count1, offset2, count2, depth1, index1, depth2, index2);\n                    }\n                    return true;\n                };\n            } else {\n                intersectsRanges = iterateOverDoubleTriangles;\n            }\n        }\n        return (0,_cast_bvhcast_js__WEBPACK_IMPORTED_MODULE_18__.bvhcast)(this, otherBvh, matrixToLocal, intersectsRanges);\n    }\n    /* Derived Cast Functions */ intersectsBox(box, boxToMesh) {\n        obb.set(box.min, box.max, boxToMesh);\n        obb.needsUpdate = true;\n        return this.shapecast({\n            intersectsBounds: (box)=>obb.intersectsBox(box),\n            intersectsTriangle: (tri)=>obb.intersectsTriangle(tri)\n        });\n    }\n    intersectsSphere(sphere) {\n        return this.shapecast({\n            intersectsBounds: (box)=>sphere.intersectsBox(box),\n            intersectsTriangle: (tri)=>tri.intersectsSphere(sphere)\n        });\n    }\n    closestPointToGeometry(otherGeometry, geometryToBvh, target1 = {}, target2 = {}, minThreshold = 0, maxThreshold = Infinity) {\n        const closestPointToGeometryFunc = this.indirect ? _cast_closestPointToGeometry_indirect_generated_js__WEBPACK_IMPORTED_MODULE_19__.closestPointToGeometry_indirect : _cast_closestPointToGeometry_generated_js__WEBPACK_IMPORTED_MODULE_20__.closestPointToGeometry;\n        return closestPointToGeometryFunc(this, otherGeometry, geometryToBvh, target1, target2, minThreshold, maxThreshold);\n    }\n    closestPointToPoint(point, target = {}, minThreshold = 0, maxThreshold = Infinity) {\n        return (0,_cast_closestPointToPoint_js__WEBPACK_IMPORTED_MODULE_21__.closestPointToPoint)(this, point, target, minThreshold, maxThreshold);\n    }\n    getBoundingBox(target) {\n        target.makeEmpty();\n        const roots = this._roots;\n        roots.forEach((buffer)=>{\n            (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_22__.arrayToBox)(0, new Float32Array(buffer), tempBox);\n            target.union(tempBox);\n        });\n        return target;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9jb3JlL01lc2hCVkguanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7Ozs7O0FBQXlEO0FBQ2tDO0FBQ3BDO0FBQ0Y7QUFDTTtBQUNhO0FBQ3hCO0FBQ29CO0FBRU87QUFDekI7QUFDSTtBQUNVO0FBQ1k7QUFDUTtBQUVTO0FBQ3pCO0FBQ0k7QUFDVTtBQUNZO0FBQ1E7QUFDL0I7QUFDWDtBQUNoQjtBQUU1QyxNQUFNNEIsTUFBTSxhQUFhLEdBQUcsSUFBSXBCLDZEQUFXQTtBQUMzQyxNQUFNcUIsVUFBVSxhQUFhLEdBQUcsSUFBSTVCLHVDQUFJQTtBQUVqQyxNQUFNNkI7SUFFWixPQUFPQyxVQUFXQyxHQUFHLEVBQUVDLFVBQVUsQ0FBQyxDQUFDLEVBQUc7UUFFckNBLFVBQVU7WUFDVEMsY0FBYztZQUNkLEdBQUdELE9BQU87UUFDWDtRQUVBLE1BQU1FLFdBQVdILElBQUlHLFFBQVE7UUFDN0IsTUFBTUMsV0FBV0osSUFBSUssTUFBTTtRQUMzQixNQUFNQyxpQkFBaUJOLElBQUlPLGVBQWU7UUFDMUMsTUFBTUMsaUJBQWlCTCxTQUFTTSxRQUFRO1FBQ3hDLElBQUlDO1FBQ0osSUFBS1QsUUFBUUMsWUFBWSxFQUFHO1lBRTNCUSxTQUFTO2dCQUNSQyxPQUFPUCxTQUFTUSxHQUFHLENBQUVDLENBQUFBLE9BQVFBLEtBQUtDLEtBQUs7Z0JBQ3ZDQyxPQUFPUCxlQUFlUSxLQUFLLENBQUNGLEtBQUs7Z0JBQ2pDUixnQkFBZ0JBLGlCQUFpQkEsZUFBZVEsS0FBSyxLQUFLO1lBQzNEO1FBRUQsT0FBTztZQUVOSixTQUFTO2dCQUNSQyxPQUFPUDtnQkFDUFcsT0FBT1AsZUFBZVEsS0FBSztnQkFDM0JWLGdCQUFnQkE7WUFDakI7UUFFRDtRQUVBLE9BQU9JO0lBRVI7SUFFQSxPQUFPTyxZQUFhQyxJQUFJLEVBQUVmLFFBQVEs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LENBQUUsR0FBRyxJQUFJa0YsYUFBY1osU0FBVWxEO1lBQzNDMkosT0FBT0csS0FBSyxDQUFFOUo7UUFFZjtRQUVBLE9BQU8ySjtJQUVSO0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aWJlLTNkLWNvZGUvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9jb3JlL01lc2hCVkguanM/YzgyNSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCdWZmZXJBdHRyaWJ1dGUsIEJveDMsIEZyb250U2lkZSB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IENFTlRFUiwgQllURVNfUEVSX05PREUsIElTX0xFQUZOT0RFX0ZMQUcsIFNLSVBfR0VORVJBVElPTiB9IGZyb20gJy4vQ29uc3RhbnRzLmpzJztcbmltcG9ydCB7IGJ1aWxkUGFja2VkVHJlZSB9IGZyb20gJy4vYnVpbGQvYnVpbGRUcmVlLmpzJztcbmltcG9ydCB7IE9yaWVudGVkQm94IH0gZnJvbSAnLi4vbWF0aC9PcmllbnRlZEJveC5qcyc7XG5pbXBvcnQgeyBhcnJheVRvQm94IH0gZnJvbSAnLi4vdXRpbHMvQXJyYXlCb3hVdGlsaXRpZXMuanMnO1xuaW1wb3J0IHsgRXh0ZW5kZWRUcmlhbmdsZVBvb2wgfSBmcm9tICcuLi91dGlscy9FeHRlbmRlZFRyaWFuZ2xlUG9vbC5qcyc7XG5pbXBvcnQgeyBzaGFwZWNhc3QgfSBmcm9tICcuL2Nhc3Qvc2hhcGVjYXN0LmpzJztcbmltcG9ydCB7IGNsb3Nlc3RQb2ludFRvUG9pbnQgfSBmcm9tICcuL2Nhc3QvY2xvc2VzdFBvaW50VG9Qb2ludC5qcyc7XG5cbmltcG9ydCB7IGl0ZXJhdGVPdmVyVHJpYW5nbGVzIH0gZnJvbSAnLi91dGlscy9pdGVyYXRpb25VdGlscy5nZW5lcmF0ZWQuanMnO1xuaW1wb3J0IHsgcmVmaXQgfSBmcm9tICcuL2Nhc3QvcmVmaXQuZ2VuZXJhdGVkLmpzJztcbmltcG9ydCB7IHJheWNhc3QgfSBmcm9tICcuL2Nhc3QvcmF5Y2FzdC5nZW5lcmF0ZWQuanMnO1xuaW1wb3J0IHsgcmF5Y2FzdEZpcnN0IH0gZnJvbSAnLi9jYXN0L3JheWNhc3RGaXJzdC5nZW5lcmF0ZWQuanMnO1xuaW1wb3J0IHsgaW50ZXJzZWN0c0dlb21ldHJ5IH0gZnJvbSAnLi9jYXN0L2ludGVyc2VjdHNHZW9tZXRyeS5nZW5lcmF0ZWQuanMnO1xuaW1wb3J0IHsgY2xvc2VzdFBvaW50VG9HZW9tZXRyeSB9IGZyb20gJy4vY2FzdC9jbG9zZXN0UG9pbnRUb0dlb21ldHJ5LmdlbmVyYXRlZC5qcyc7XG5cbmltcG9ydCB7IGl0ZXJhdGVPdmVyVHJpYW5nbGVzX2luZGlyZWN0IH0gZnJvbSAnLi91dGlscy9pdGVyYXRpb25VdGlsc19pbmRpcmVjdC5nZW5lcmF0ZWQuanMnO1xuaW1wb3J0IHsgcmVmaXRfaW5kaXJlY3QgfSBmcm9tICcuL2Nhc3QvcmVmaXRfaW5kaXJlY3QuZ2VuZXJhdGVkLmpzJztcbmltcG9ydCB7IHJheWNhc3RfaW5kaXJlY3QgfSBmcm9tICcuL2Nhc3QvcmF5Y2FzdF9pbmRpcmVjdC5nZW5lcmF0ZWQuanMnO1xuaW1wb3J0IHsgcmF5Y2FzdEZpcnN0X2luZGlyZWN0IH0gZnJvbSAnLi9jYXN0L3JheWNhc3RGaXJzdF9pbmRpcmVjdC5nZW5lcmF0ZWQuanMnO1xuaW1wb3J0IHsgaW50ZXJzZWN0c0dlb21ldHJ5X2luZGlyZWN0IH0gZnJvbSAnLi9jYXN0L2ludGVyc2VjdHNHZW9tZXRyeV9pbmRpcmVjdC5nZW5lcmF0ZWQuanMnO1xuaW1wb3J0IHsgY2xvc2VzdFBvaW50VG9HZW9tZXRyeV9pbmRpcmVjdCB9IGZyb20gJy4vY2FzdC9jbG9zZXN0UG9pbnRUb0dlb21ldHJ5X2luZGlyZWN0LmdlbmVyYXRlZC5qcyc7XG5pbXBvcnQgeyBpc1NoYXJlZEFycmF5QnVmZmVyU3VwcG9ydGVkIH0gZnJvbSAnLi4vdXRpbHMvQnVmZmVyVXRpbHMuanMnO1xuaW1wb3J0IHsgc2V0VHJpYW5nbGUgfSBmcm9tICcuLi91dGlscy9UcmlhbmdsZVV0aWxpdGllcy5qcyc7XG5pbXBvcnQgeyBidmhjYXN0IH0gZnJvbSAnLi9jYXN0L2J2aGNhc3QuanMnO1xuXG5jb25zdCBvYmIgPSAvKiBAX19QVVJFX18gKi8gbmV3IE9yaWVudGVkQm94KCk7XG5jb25zdCB0ZW1wQm94ID0gLyogQF9fUFVSRV9fICovIG5ldyBCb3gzKCk7XG5cbmV4cG9ydCBjbGFzcyBNZXNoQlZIIHtcblxuXHRzdGF0aWMgc2VyaWFsaXplKCBidmgsIG9wdGlvbnMgPSB7fSApIHtcblxuXHRcdG9wdGlvbnMgPSB7XG5cdFx0XHRjbG9uZUJ1ZmZlcnM6IHRydWUsXG5cdFx0XHQuLi5vcHRpb25zLFxuXHRcdH07XG5cblx0XHRjb25zdCBnZW9tZXRyeSA9IGJ2aC5nZW9tZXRyeTtcblx0XHRjb25zdCByb290RGF0YSA9IGJ2aC5fcm9vdHM7XG5cdFx0Y29uc3QgaW5kaXJlY3RCdWZmZXIgPSBidmguX2luZGlyZWN0QnVmZmVyO1xuXHRcdGNvbnN0IGluZGV4QXR0cmlidXRlID0gZ2VvbWV0cnkuZ2V0SW5kZXgoKTtcblx0XHRsZXQgcmVzdWx0O1xuXHRcdGlmICggb3B0aW9ucy5jbG9uZUJ1ZmZlcnMgKSB7XG5cblx0XHRcdHJlc3VsdCA9IHtcblx0XHRcdFx0cm9vdHM6IHJvb3REYXRhLm1hcCggcm9vdCA9PiByb290LnNsaWNlKCkgKSxcblx0XHRcdFx0aW5kZXg6IGluZGV4QXR0cmlidXRlLmFycmF5LnNsaWNlKCksXG5cdFx0XHRcdGluZGlyZWN0QnVmZmVyOiBpbmRpcmVjdEJ1ZmZlciA/IGluZGlyZWN0QnVmZmVyLnNsaWNlKCkgOiBudWxsLFxuXHRcdFx0fTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJlc3VsdCA9IHtcblx0XHRcdFx0cm9vdHM6IHJvb3REYXRhLFxuXHRcdFx0XHRpbmRleDogaW5kZXhBdHRyaWJ1dGUuYXJyYXksXG5cdFx0XHRcdGluZGlyZWN0QnVmZmVyOiBpbmRpcmVjdEJ1ZmZlcixcblx0XHRcdH07XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gcmVzdWx0O1xuXG5cdH1cblxuXHRzdGF0aWMgZGVzZXJpYWxpemUoIGRhdGEsIGdlb21ldHJ5LCBvcHRpb25zID0ge30gKSB7XG5cblx0XHRvcHRpb25zID0ge1xuXHRcdFx0c2V0SW5kZXg6IHRydWUsXG5cdFx0XHRpbmRpcmVjdDogQm9vbGVhbiggZGF0YS5pbmRpcmVjdEJ1ZmZlciApLFxuXHRcdFx0Li4ub3B0aW9ucyxcblx0XHR9O1xuXG5cdFx0Y29uc3QgeyBpbmRleCwgcm9vdHMsIGluZGlyZWN0QnVmZmVyIH0gPSBkYXRhO1xuXHRcdGNvbnN0IGJ2aCA9IG5ldyBNZXNoQlZIKCBnZW9tZXRyeSwgeyAuLi5vcHRpb25zLCBbIFNLSVBfR0VORVJBVElPTiBdOiB0cnVlIH0gKTtcblx0XHRidmguX3Jvb3RzID0gcm9vdHM7XG5cdFx0YnZoLl9pbmRpcmVjdEJ1ZmZlciA9IGluZGlyZWN0QnVmZmVyIHx8IG51bGw7XG5cblx0XHRpZiAoIG9wdGlvbnMuc2V0SW5kZXggKSB7XG5cblx0XHRcdGNvbnN0IGluZGV4QXR0cmlidXRlID0gZ2VvbWV0cnkuZ2V0SW5kZXgoKTtcblx0XHRcdGlmICggaW5kZXhBdHRyaWJ1dGUgPT09IG51bGwgKSB7XG5cblx0XHRcdFx0Y29uc3QgbmV3SW5kZXggPSBuZXcgQnVmZmVyQXR0cmlidXRlKCBkYXRhLmluZGV4LCAxLCBmYWxzZSApO1xuXHRcdFx0XHRnZW9tZXRyeS5zZXRJbmRleCggbmV3SW5kZXggKTtcblxuXHRcdFx0fSBlbHNlIGlmICggaW5kZXhBdHRyaWJ1dGUuYXJyYXkgIT09IGluZGV4ICkge1xuXG5cdFx0XHRcdGluZGV4QXR0cmlidXRlLmFycmF5LnNldCggaW5kZXggKTtcblx0XHRcdFx0aW5kZXhBdHRyaWJ1dGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gYnZoO1xuXG5cdH1cblxuXHRnZXQgaW5kaXJlY3QoKSB7XG5cblx0XHRyZXR1cm4gISAhIHRoaXMuX2luZGlyZWN0QnVmZmVyO1xuXG5cdH1cblxuXHRjb25zdHJ1Y3RvciggZ2VvbWV0cnksIG9wdGlvbnMgPSB7fSApIHtcblxuXHRcdGlmICggISBnZW9tZXRyeS5pc0J1ZmZlckdlb21ldHJ5ICkge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdNZXNoQlZIOiBPbmx5IEJ1ZmZlckdlb21ldHJpZXMgYXJlIHN1cHBvcnRlZC4nICk7XG5cblx0XHR9IGVsc2UgaWYgKCBnZW9tZXRyeS5pbmRleCAmJiBnZW9tZXRyeS5pbmRleC5pc0ludGVybGVhdmVkQnVmZmVyQXR0cmlidXRlICkge1xuXG5cdFx0XHR0aHJvdyBuZXcgRXJyb3IoICdNZXNoQlZIOiBJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSBpcyBub3Qgc3VwcG9ydGVkIGZvciB0aGUgaW5kZXggYXR0cmlidXRlLicgKTtcblxuXHRcdH1cblxuXHRcdC8vIGRlZmF1bHQgb3B0aW9uc1xuXHRcdG9wdGlvbnMgPSBPYmplY3QuYXNzaWduKCB7XG5cblx0XHRcdHN0cmF0ZWd5OiBDRU5URVIsXG5cdFx0XHRtYXhEZXB0aDogNDAsXG5cdFx0XHRtYXhMZWFmVHJpczogMTAsXG5cdFx0XHR2ZXJib3NlOiB0cnVlLFxuXHRcdFx0dXNlU2hhcmVkQXJyYXlCdWZmZXI6IGZhbHNlLFxuXHRcdFx0c2V0Qm91bmRpbmdCb3g6IHRydWUsXG5cdFx0XHRvblByb2dyZXNzOiBudWxsLFxuXHRcdFx0aW5kaXJlY3Q6IGZhbHNlLFxuXG5cdFx0XHQvLyB1bmRvY3VtZW50ZWQgb3B0aW9uc1xuXG5cdFx0XHQvLyBXaGV0aGVyIHRvIHNraXAgZ2VuZXJhdGluZyB0aGUgdHJlZS4gVXNlZCBmb3IgZGVzZXJpYWxpemF0aW9uLlxuXHRcdFx0WyBTS0lQX0dFTkVSQVRJT04gXTogZmFsc2UsXG5cblx0XHR9LCBvcHRpb25zICk7XG5cblx0XHRpZiAoIG9wdGlvbnMudXNlU2hhcmVkQXJyYXlCdWZmZXIgJiYgISBpc1NoYXJlZEFycmF5QnVmZmVyU3VwcG9ydGVkKCkgKSB7XG5cblx0XHRcdHRocm93IG5ldyBFcnJvciggJ01lc2hCVkg6IFNoYXJlZEFycmF5QnVmZmVyIGlzIG5vdCBhdmFpbGFibGUuJyApO1xuXG5cdFx0fVxuXG5cdFx0Ly8gcmV0YWluIHJlZmVyZW5jZXMgdG8gdGhlIGdlb21ldHJ5IHNvIHdlIGNhbiB1c2UgdGhlbSBpdCB3aXRob3V0IGhhdmluZyB0b1xuXHRcdC8vIHRha2UgYSBnZW9tZXRyeSByZWZlcmVuY2UgaW4gZXZlcnkgZnVuY3Rpb24uXG5cdFx0dGhpcy5nZW9tZXRyeSA9IGdlb21ldHJ5O1xuXHRcdHRoaXMuX3Jvb3RzID0gbnVsbDtcblx0XHR0aGlzLl9pbmRpcmVjdEJ1ZmZlciA9IG51bGw7XG5cdFx0aWYgKCAhIG9wdGlvbnNbIFNLSVBfR0VORVJBVElPTiBdICkge1xuXG5cdFx0XHRidWlsZFBhY2tlZFRyZWUoIHRoaXMsIG9wdGlvbnMgKTtcblxuXHRcdFx0aWYgKCAhIGdlb21ldHJ5LmJvdW5kaW5nQm94ICYmIG9wdGlvbnMuc2V0Qm91bmRpbmdCb3ggKSB7XG5cblx0XHRcdFx0Z2VvbWV0cnkuYm91bmRpbmdCb3ggPSB0aGlzLmdldEJvdW5kaW5nQm94KCBuZXcgQm94MygpICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGNvbnN0IHsgX2luZGlyZWN0QnVmZmVyIH0gPSB0aGlzO1xuXHRcdHRoaXMucmVzb2x2ZVRyaWFuZ2xlSW5kZXggPSBvcHRpb25zLmluZGlyZWN0ID8gaSA9PiBfaW5kaXJlY3RCdWZmZXJbIGkgXSA6IGkgPT4gaTtcblxuXHR9XG5cblx0cmVmaXQoIG5vZGVJbmRpY2VzID0gbnVsbCApIHtcblxuXHRcdGNvbnN0IHJlZml0RnVuYyA9IHRoaXMuaW5kaXJlY3QgPyByZWZpdF9pbmRpcmVjdCA6IHJlZml0O1xuXHRcdHJldHVybiByZWZpdEZ1bmMoIHRoaXMsIG5vZGVJbmRpY2VzICk7XG5cblx0fVxuXG5cdHRyYXZlcnNlKCBjYWxsYmFjaywgcm9vdEluZGV4ID0gMCApIHtcblxuXHRcdGNvbnN0IGJ1ZmZlciA9IHRoaXMuX3Jvb3RzWyByb290SW5kZXggXTtcblx0XHRjb25zdCB1aW50MzJBcnJheSA9IG5ldyBVaW50MzJBcnJheSggYnVmZmVyICk7XG5cdFx0Y29uc3QgdWludDE2QXJyYXkgPSBuZXcgVWludDE2QXJyYXkoIGJ1ZmZlciApO1xuXHRcdF90cmF2ZXJzZSggMCApO1xuXG5cdFx0ZnVuY3Rpb24gX3RyYXZlcnNlKCBub2RlMzJJbmRleCwgZGVwdGggPSAwICkge1xuXG5cdFx0XHRjb25zdCBub2RlMTZJbmRleCA9IG5vZGUzMkluZGV4ICogMjtcblx0XHRcdGNvbnN0IGlzTGVhZiA9IHVpbnQxNkFycmF5WyBub2RlMTZJbmRleCArIDE1IF0gPT09IElTX0xFQUZOT0RFX0ZMQUc7XG5cdFx0XHRpZiAoIGlzTGVhZiApIHtcblxuXHRcdFx0XHRjb25zdCBvZmZzZXQgPSB1aW50MzJBcnJheVsgbm9kZTMySW5kZXggKyA2IF07XG5cdFx0XHRcdGNvbnN0IGNvdW50ID0gdWludDE2QXJyYXlbIG5vZGUxNkluZGV4ICsgMTQgXTtcblx0XHRcdFx0Y2FsbGJhY2soIGRlcHRoLCBpc0xlYWYsIG5ldyBGbG9hdDMyQXJyYXkoIGJ1ZmZlciwgbm9kZTMySW5kZXggKiA0LCA2ICksIG9mZnNldCwgY291bnQgKTtcblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyBUT0RPOiB1c2Ugbm9kZSBmdW5jdGlvbnMgaGVyZVxuXHRcdFx0XHRjb25zdCBsZWZ0ID0gbm9kZTMySW5kZXggKyBCWVRFU19QRVJfTk9ERSAvIDQ7XG5cdFx0XHRcdGNvbnN0IHJpZ2h0ID0gdWludDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgNiBdO1xuXHRcdFx0XHRjb25zdCBzcGxpdEF4aXMgPSB1aW50MzJBcnJheVsgbm9kZTMySW5kZXggKyA3IF07XG5cdFx0XHRcdGNvbnN0IHN0b3BUcmF2ZXJzYWwgPSBjYWxsYmFjayggZGVwdGgsIGlzTGVhZiwgbmV3IEZsb2F0MzJBcnJheSggYnVmZmVyLCBub2RlMzJJbmRleCAqIDQsIDYgKSwgc3BsaXRBeGlzICk7XG5cblx0XHRcdFx0aWYgKCAhIHN0b3BUcmF2ZXJzYWwgKSB7XG5cblx0XHRcdFx0XHRfdHJhdmVyc2UoIGxlZnQsIGRlcHRoICsgMSApO1xuXHRcdFx0XHRcdF90cmF2ZXJzZSggcmlnaHQsIGRlcHRoICsgMSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdH1cblxuXHQvKiBDb3JlIENhc3QgRnVuY3Rpb25zICovXG5cdHJheWNhc3QoIHJheSwgbWF0ZXJpYWxPclNpZGUgPSBGcm9udFNpZGUgKSB7XG5cblx0XHRjb25zdCByb290cyA9IHRoaXMuX3Jvb3RzO1xuXHRcdGNvbnN0IGdlb21ldHJ5ID0gdGhpcy5nZW9tZXRyeTtcblx0XHRjb25zdCBpbnRlcnNlY3RzID0gW107XG5cdFx0Y29uc3QgaXNNYXRlcmlhbCA9IG1hdGVyaWFsT3JTaWRlLmlzTWF0ZXJpYWw7XG5cdFx0Y29uc3QgaXNBcnJheU1hdGVyaWFsID0gQXJyYXkuaXNBcnJheSggbWF0ZXJpYWxPclNpZGUgKTtcblxuXHRcdGNvbnN0IGdyb3VwcyA9IGdlb21ldHJ5Lmdyb3Vwcztcblx0XHRjb25zdCBzaWRlID0gaXNNYXRlcmlhbCA/IG1hdGVyaWFsT3JTaWRlLnNpZGUgOiBtYXRlcmlhbE9yU2lkZTtcblx0XHRjb25zdCByYXljYXN0RnVuYyA9IHRoaXMuaW5kaXJlY3QgPyByYXljYXN0X2luZGlyZWN0IDogcmF5Y2FzdDtcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSByb290cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBtYXRlcmlhbFNpZGUgPSBpc0FycmF5TWF0ZXJpYWwgPyBtYXRlcmlhbE9yU2lkZVsgZ3JvdXBzWyBpIF0ubWF0ZXJpYWxJbmRleCBdLnNpZGUgOiBzaWRlO1xuXHRcdFx0Y29uc3Qgc3RhcnRDb3VudCA9IGludGVyc2VjdHMubGVuZ3RoO1xuXG5cdFx0XHRyYXljYXN0RnVuYyggdGhpcywgaSwgbWF0ZXJpYWxTaWRlLCByYXksIGludGVyc2VjdHMgKTtcblxuXHRcdFx0aWYgKCBpc0FycmF5TWF0ZXJpYWwgKSB7XG5cblx0XHRcdFx0Y29uc3QgbWF0ZXJpYWxJbmRleCA9IGdyb3Vwc1sgaSBdLm1hdGVyaWFsSW5kZXg7XG5cdFx0XHRcdGZvciAoIGxldCBqID0gc3RhcnRDb3VudCwgamwgPSBpbnRlcnNlY3RzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRcdFx0aW50ZXJzZWN0c1sgaiBdLmZhY2UubWF0ZXJpYWxJbmRleCA9IG1hdGVyaWFsSW5kZXg7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gaW50ZXJzZWN0cztcblxuXHR9XG5cblx0cmF5Y2FzdEZpcnN0KCByYXksIG1hdGVyaWFsT3JTaWRlID0gRnJvbnRTaWRlICkge1xuXG5cdFx0Y29uc3Qgcm9vdHMgPSB0aGlzLl9yb290cztcblx0XHRjb25zdCBnZW9tZXRyeSA9IHRoaXMuZ2VvbWV0cnk7XG5cdFx0Y29uc3QgaXNNYXRlcmlhbCA9IG1hdGVyaWFsT3JTaWRlLmlzTWF0ZXJpYWw7XG5cdFx0Y29uc3QgaXNBcnJheU1hdGVyaWFsID0gQXJyYXkuaXNBcnJheSggbWF0ZXJpYWxPclNpZGUgKTtcblxuXHRcdGxldCBjbG9zZXN0UmVzdWx0ID0gbnVsbDtcblxuXHRcdGNvbnN0IGdyb3VwcyA9IGdlb21ldHJ5Lmdyb3Vwcztcblx0XHRjb25zdCBzaWRlID0gaXNNYXRlcmlhbCA/IG1hdGVyaWFsT3JTaWRlLnNpZGUgOiBtYXRlcmlhbE9yU2lkZTtcblx0XHRjb25zdCByYXljYXN0Rmlyc3RGdW5jID0gdGhpcy5pbmRpcmVjdCA/IHJheWNhc3RGaXJzdF9pbmRpcmVjdCA6IHJheWNhc3RGaXJzdDtcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSByb290cy5sZW5ndGg7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBtYXRlcmlhbFNpZGUgPSBpc0FycmF5TWF0ZXJpYWwgPyBtYXRlcmlhbE9yU2lkZVsgZ3JvdXBzWyBpIF0ubWF0ZXJpYWxJbmRleCBdLnNpZGUgOiBzaWRlO1xuXHRcdFx0Y29uc3QgcmVzdWx0ID0gcmF5Y2FzdEZpcnN0RnVuYyggdGhpcywgaSwgbWF0ZXJpYWxTaWRlLCByYXkgKTtcblx0XHRcdGlmICggcmVzdWx0ICE9IG51bGwgJiYgKCBjbG9zZXN0UmVzdWx0ID09IG51bGwgfHwgcmVzdWx0LmRpc3RhbmNlIDwgY2xvc2VzdFJlc3VsdC5kaXN0YW5jZSApICkge1xuXG5cdFx0XHRcdGNsb3Nlc3RSZXN1bHQgPSByZXN1bHQ7XG5cdFx0XHRcdGlmICggaXNBcnJheU1hdGVyaWFsICkge1xuXG5cdFx0XHRcdFx0cmVzdWx0LmZhY2UubWF0ZXJpYWxJbmRleCA9IGdyb3Vwc1sgaSBdLm1hdGVyaWFsSW5kZXg7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gY2xvc2VzdFJlc3VsdDtcblxuXHR9XG5cblx0aW50ZXJzZWN0c0dlb21ldHJ5KCBvdGhlckdlb21ldHJ5LCBnZW9tVG9NZXNoICkge1xuXG5cdFx0bGV0IHJlc3VsdCA9IGZhbHNlO1xuXHRcdGNvbnN0IHJvb3RzID0gdGhpcy5fcm9vdHM7XG5cdFx0Y29uc3QgaW50ZXJzZWN0c0dlb21ldHJ5RnVuYyA9IHRoaXMuaW5kaXJlY3QgPyBpbnRlcnNlY3RzR2VvbWV0cnlfaW5kaXJlY3QgOiBpbnRlcnNlY3RzR2VvbWV0cnk7XG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gcm9vdHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0cmVzdWx0ID0gaW50ZXJzZWN0c0dlb21ldHJ5RnVuYyggdGhpcywgaSwgb3RoZXJHZW9tZXRyeSwgZ2VvbVRvTWVzaCApO1xuXG5cdFx0XHRpZiAoIHJlc3VsdCApIHtcblxuXHRcdFx0XHRicmVhaztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblxuXHR9XG5cblx0c2hhcGVjYXN0KCBjYWxsYmFja3MgKSB7XG5cblx0XHRjb25zdCB0cmlhbmdsZSA9IEV4dGVuZGVkVHJpYW5nbGVQb29sLmdldFByaW1pdGl2ZSgpO1xuXHRcdGNvbnN0IGl0ZXJhdGVGdW5jID0gdGhpcy5pbmRpcmVjdCA/IGl0ZXJhdGVPdmVyVHJpYW5nbGVzX2luZGlyZWN0IDogaXRlcmF0ZU92ZXJUcmlhbmdsZXM7XG5cdFx0bGV0IHtcblx0XHRcdGJvdW5kc1RyYXZlcnNlT3JkZXIsXG5cdFx0XHRpbnRlcnNlY3RzQm91bmRzLFxuXHRcdFx0aW50ZXJzZWN0c1JhbmdlLFxuXHRcdFx0aW50ZXJzZWN0c1RyaWFuZ2xlLFxuXHRcdH0gPSBjYWxsYmFja3M7XG5cblx0XHQvLyB3cmFwIHRoZSBpbnRlcnNlY3RzUmFuZ2UgZnVuY3Rpb25cblx0XHRpZiAoIGludGVyc2VjdHNSYW5nZSAmJiBpbnRlcnNlY3RzVHJpYW5nbGUgKSB7XG5cblx0XHRcdGNvbnN0IG9yaWdpbmFsSW50ZXJzZWN0c1JhbmdlID0gaW50ZXJzZWN0c1JhbmdlO1xuXHRcdFx0aW50ZXJzZWN0c1JhbmdlID0gKCBvZmZzZXQsIGNvdW50LCBjb250YWluZWQsIGRlcHRoLCBub2RlSW5kZXggKSA9PiB7XG5cblx0XHRcdFx0aWYgKCAhIG9yaWdpbmFsSW50ZXJzZWN0c1JhbmdlKCBvZmZzZXQsIGNvdW50LCBjb250YWluZWQsIGRlcHRoLCBub2RlSW5kZXggKSApIHtcblxuXHRcdFx0XHRcdHJldHVybiBpdGVyYXRlRnVuYyggb2Zmc2V0LCBjb3VudCwgdGhpcywgaW50ZXJzZWN0c1RyaWFuZ2xlLCBjb250YWluZWQsIGRlcHRoLCB0cmlhbmdsZSApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0fTtcblxuXHRcdH0gZWxzZSBpZiAoICEgaW50ZXJzZWN0c1JhbmdlICkge1xuXG5cdFx0XHRpZiAoIGludGVyc2VjdHNUcmlhbmdsZSApIHtcblxuXHRcdFx0XHRpbnRlcnNlY3RzUmFuZ2UgPSAoIG9mZnNldCwgY291bnQsIGNvbnRhaW5lZCwgZGVwdGggKSA9PiB7XG5cblx0XHRcdFx0XHRyZXR1cm4gaXRlcmF0ZUZ1bmMoIG9mZnNldCwgY291bnQsIHRoaXMsIGludGVyc2VjdHNUcmlhbmdsZSwgY29udGFpbmVkLCBkZXB0aCwgdHJpYW5nbGUgKTtcblxuXHRcdFx0XHR9O1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGludGVyc2VjdHNSYW5nZSA9ICggb2Zmc2V0LCBjb3VudCwgY29udGFpbmVkICkgPT4ge1xuXG5cdFx0XHRcdFx0cmV0dXJuIGNvbnRhaW5lZDtcblxuXHRcdFx0XHR9O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBydW4gc2hhcGVjYXN0XG5cdFx0bGV0IHJlc3VsdCA9IGZhbHNlO1xuXHRcdGxldCBieXRlT2Zmc2V0ID0gMDtcblx0XHRjb25zdCByb290cyA9IHRoaXMuX3Jvb3RzO1xuXHRcdGZvciAoIGxldCBpID0gMCwgbCA9IHJvb3RzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHJvb3QgPSByb290c1sgaSBdO1xuXHRcdFx0cmVzdWx0ID0gc2hhcGVjYXN0KCB0aGlzLCBpLCBpbnRlcnNlY3RzQm91bmRzLCBpbnRlcnNlY3RzUmFuZ2UsIGJvdW5kc1RyYXZlcnNlT3JkZXIsIGJ5dGVPZmZzZXQgKTtcblxuXHRcdFx0aWYgKCByZXN1bHQgKSB7XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdFx0Ynl0ZU9mZnNldCArPSByb290LmJ5dGVMZW5ndGg7XG5cblx0XHR9XG5cblx0XHRFeHRlbmRlZFRyaWFuZ2xlUG9vbC5yZWxlYXNlUHJpbWl0aXZlKCB0cmlhbmdsZSApO1xuXG5cdFx0cmV0dXJuIHJlc3VsdDtcblxuXHR9XG5cblx0YnZoY2FzdCggb3RoZXJCdmgsIG1hdHJpeFRvTG9jYWwsIGNhbGxiYWNrcyApIHtcblxuXHRcdGxldCB7XG5cdFx0XHRpbnRlcnNlY3RzUmFuZ2VzLFxuXHRcdFx0aW50ZXJzZWN0c1RyaWFuZ2xlcyxcblx0XHR9ID0gY2FsbGJhY2tzO1xuXG5cdFx0Y29uc3QgdHJpYW5nbGUxID0gRXh0ZW5kZWRUcmlhbmdsZVBvb2wuZ2V0UHJpbWl0aXZlKCk7XG5cdFx0Y29uc3QgaW5kZXhBdHRyMSA9IHRoaXMuZ2VvbWV0cnkuaW5kZXg7XG5cdFx0Y29uc3QgcG9zaXRpb25BdHRyMSA9IHRoaXMuZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0XHRjb25zdCBhc3NpZ25UcmlhbmdsZTEgPSB0aGlzLmluZGlyZWN0ID9cblx0XHRcdGkxID0+IHtcblxuXG5cdFx0XHRcdGNvbnN0IHRpID0gdGhpcy5yZXNvbHZlVHJpYW5nbGVJbmRleCggaTEgKTtcblx0XHRcdFx0c2V0VHJpYW5nbGUoIHRyaWFuZ2xlMSwgdGkgKiAzLCBpbmRleEF0dHIxLCBwb3NpdGlvbkF0dHIxICk7XG5cblx0XHRcdH0gOlxuXHRcdFx0aTEgPT4ge1xuXG5cdFx0XHRcdHNldFRyaWFuZ2xlKCB0cmlhbmdsZTEsIGkxICogMywgaW5kZXhBdHRyMSwgcG9zaXRpb25BdHRyMSApO1xuXG5cdFx0XHR9O1xuXG5cdFx0Y29uc3QgdHJpYW5nbGUyID0gRXh0ZW5kZWRUcmlhbmdsZVBvb2wuZ2V0UHJpbWl0aXZlKCk7XG5cdFx0Y29uc3QgaW5kZXhBdHRyMiA9IG90aGVyQnZoLmdlb21ldHJ5LmluZGV4O1xuXHRcdGNvbnN0IHBvc2l0aW9uQXR0cjIgPSBvdGhlckJ2aC5nZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRcdGNvbnN0IGFzc2lnblRyaWFuZ2xlMiA9IG90aGVyQnZoLmluZGlyZWN0ID9cblx0XHRcdGkyID0+IHtcblxuXHRcdFx0XHRjb25zdCB0aTIgPSBvdGhlckJ2aC5yZXNvbHZlVHJpYW5nbGVJbmRleCggaTIgKTtcblx0XHRcdFx0c2V0VHJpYW5nbGUoIHRyaWFuZ2xlMiwgdGkyICogMywgaW5kZXhBdHRyMiwgcG9zaXRpb25BdHRyMiApO1xuXG5cdFx0XHR9IDpcblx0XHRcdGkyID0+IHtcblxuXHRcdFx0XHRzZXRUcmlhbmdsZSggdHJpYW5nbGUyLCBpMiAqIDMsIGluZGV4QXR0cjIsIHBvc2l0aW9uQXR0cjIgKTtcblxuXHRcdFx0fTtcblxuXHRcdC8vIGdlbmVyYXRlIHRyaWFuZ2xlIGNhbGxiYWNrIGlmIG5lZWRlZFxuXHRcdGlmICggaW50ZXJzZWN0c1RyaWFuZ2xlcyApIHtcblxuXHRcdFx0Y29uc3QgaXRlcmF0ZU92ZXJEb3VibGVUcmlhbmdsZXMgPSAoIG9mZnNldDEsIGNvdW50MSwgb2Zmc2V0MiwgY291bnQyLCBkZXB0aDEsIGluZGV4MSwgZGVwdGgyLCBpbmRleDIgKSA9PiB7XG5cblx0XHRcdFx0Zm9yICggbGV0IGkyID0gb2Zmc2V0MiwgbDIgPSBvZmZzZXQyICsgY291bnQyOyBpMiA8IGwyOyBpMiArKyApIHtcblxuXHRcdFx0XHRcdGFzc2lnblRyaWFuZ2xlMiggaTIgKTtcblxuXHRcdFx0XHRcdHRyaWFuZ2xlMi5hLmFwcGx5TWF0cml4NCggbWF0cml4VG9Mb2NhbCApO1xuXHRcdFx0XHRcdHRyaWFuZ2xlMi5iLmFwcGx5TWF0cml4NCggbWF0cml4VG9Mb2NhbCApO1xuXHRcdFx0XHRcdHRyaWFuZ2xlMi5jLmFwcGx5TWF0cml4NCggbWF0cml4VG9Mb2NhbCApO1xuXHRcdFx0XHRcdHRyaWFuZ2xlMi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHRmb3IgKCBsZXQgaTEgPSBvZmZzZXQxLCBsMSA9IG9mZnNldDEgKyBjb3VudDE7IGkxIDwgbDE7IGkxICsrICkge1xuXG5cdFx0XHRcdFx0XHRhc3NpZ25UcmlhbmdsZTEoIGkxICk7XG5cblx0XHRcdFx0XHRcdHRyaWFuZ2xlMS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHRcdGlmICggaW50ZXJzZWN0c1RyaWFuZ2xlcyggdHJpYW5nbGUxLCB0cmlhbmdsZTIsIGkxLCBpMiwgZGVwdGgxLCBpbmRleDEsIGRlcHRoMiwgaW5kZXgyICkgKSB7XG5cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHR9O1xuXG5cdFx0XHRpZiAoIGludGVyc2VjdHNSYW5nZXMgKSB7XG5cblx0XHRcdFx0Y29uc3Qgb3JpZ2luYWxJbnRlcnNlY3RzUmFuZ2VzID0gaW50ZXJzZWN0c1Jhbmdlcztcblx0XHRcdFx0aW50ZXJzZWN0c1JhbmdlcyA9IGZ1bmN0aW9uICggb2Zmc2V0MSwgY291bnQxLCBvZmZzZXQyLCBjb3VudDIsIGRlcHRoMSwgaW5kZXgxLCBkZXB0aDIsIGluZGV4MiApIHtcblxuXHRcdFx0XHRcdGlmICggISBvcmlnaW5hbEludGVyc2VjdHNSYW5nZXMoIG9mZnNldDEsIGNvdW50MSwgb2Zmc2V0MiwgY291bnQyLCBkZXB0aDEsIGluZGV4MSwgZGVwdGgyLCBpbmRleDIgKSApIHtcblxuXHRcdFx0XHRcdFx0cmV0dXJuIGl0ZXJhdGVPdmVyRG91YmxlVHJpYW5nbGVzKCBvZmZzZXQxLCBjb3VudDEsIG9mZnNldDIsIGNvdW50MiwgZGVwdGgxLCBpbmRleDEsIGRlcHRoMiwgaW5kZXgyICk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0XHR9O1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGludGVyc2VjdHNSYW5nZXMgPSBpdGVyYXRlT3ZlckRvdWJsZVRyaWFuZ2xlcztcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGJ2aGNhc3QoIHRoaXMsIG90aGVyQnZoLCBtYXRyaXhUb0xvY2FsLCBpbnRlcnNlY3RzUmFuZ2VzICk7XG5cblx0fVxuXG5cblx0LyogRGVyaXZlZCBDYXN0IEZ1bmN0aW9ucyAqL1xuXHRpbnRlcnNlY3RzQm94KCBib3gsIGJveFRvTWVzaCApIHtcblxuXHRcdG9iYi5zZXQoIGJveC5taW4sIGJveC5tYXgsIGJveFRvTWVzaCApO1xuXHRcdG9iYi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRyZXR1cm4gdGhpcy5zaGFwZWNhc3QoXG5cdFx0XHR7XG5cdFx0XHRcdGludGVyc2VjdHNCb3VuZHM6IGJveCA9PiBvYmIuaW50ZXJzZWN0c0JveCggYm94ICksXG5cdFx0XHRcdGludGVyc2VjdHNUcmlhbmdsZTogdHJpID0+IG9iYi5pbnRlcnNlY3RzVHJpYW5nbGUoIHRyaSApXG5cdFx0XHR9XG5cdFx0KTtcblxuXHR9XG5cblx0aW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlICkge1xuXG5cdFx0cmV0dXJuIHRoaXMuc2hhcGVjYXN0KFxuXHRcdFx0e1xuXHRcdFx0XHRpbnRlcnNlY3RzQm91bmRzOiBib3ggPT4gc3BoZXJlLmludGVyc2VjdHNCb3goIGJveCApLFxuXHRcdFx0XHRpbnRlcnNlY3RzVHJpYW5nbGU6IHRyaSA9PiB0cmkuaW50ZXJzZWN0c1NwaGVyZSggc3BoZXJlIClcblx0XHRcdH1cblx0XHQpO1xuXG5cdH1cblxuXHRjbG9zZXN0UG9pbnRUb0dlb21ldHJ5KCBvdGhlckdlb21ldHJ5LCBnZW9tZXRyeVRvQnZoLCB0YXJnZXQxID0geyB9LCB0YXJnZXQyID0geyB9LCBtaW5UaHJlc2hvbGQgPSAwLCBtYXhUaHJlc2hvbGQgPSBJbmZpbml0eSApIHtcblxuXHRcdGNvbnN0IGNsb3Nlc3RQb2ludFRvR2VvbWV0cnlGdW5jID0gdGhpcy5pbmRpcmVjdCA/IGNsb3Nlc3RQb2ludFRvR2VvbWV0cnlfaW5kaXJlY3QgOiBjbG9zZXN0UG9pbnRUb0dlb21ldHJ5O1xuXHRcdHJldHVybiBjbG9zZXN0UG9pbnRUb0dlb21ldHJ5RnVuYyhcblx0XHRcdHRoaXMsXG5cdFx0XHRvdGhlckdlb21ldHJ5LFxuXHRcdFx0Z2VvbWV0cnlUb0J2aCxcblx0XHRcdHRhcmdldDEsXG5cdFx0XHR0YXJnZXQyLFxuXHRcdFx0bWluVGhyZXNob2xkLFxuXHRcdFx0bWF4VGhyZXNob2xkLFxuXHRcdCk7XG5cblx0fVxuXG5cdGNsb3Nlc3RQb2ludFRvUG9pbnQoIHBvaW50LCB0YXJnZXQgPSB7IH0sIG1pblRocmVzaG9sZCA9IDAsIG1heFRocmVzaG9sZCA9IEluZmluaXR5ICkge1xuXG5cdFx0cmV0dXJuIGNsb3Nlc3RQb2ludFRvUG9pbnQoXG5cdFx0XHR0aGlzLFxuXHRcdFx0cG9pbnQsXG5cdFx0XHR0YXJnZXQsXG5cdFx0XHRtaW5UaHJlc2hvbGQsXG5cdFx0XHRtYXhUaHJlc2hvbGQsXG5cdFx0KTtcblxuXHR9XG5cblx0Z2V0Qm91bmRpbmdCb3goIHRhcmdldCApIHtcblxuXHRcdHRhcmdldC5tYWtlRW1wdHkoKTtcblxuXHRcdGNvbnN0IHJvb3RzID0gdGhpcy5fcm9vdHM7XG5cdFx0cm9vdHMuZm9yRWFjaCggYnVmZmVyID0+IHtcblxuXHRcdFx0YXJyYXlUb0JveCggMCwgbmV3IEZsb2F0MzJBcnJheSggYnVmZmVyICksIHRlbXBCb3ggKTtcblx0XHRcdHRhcmdldC51bmlvbiggdGVtcEJveCApO1xuXG5cdFx0fSApO1xuXG5cdFx0cmV0dXJuIHRhcmdldDtcblxuXHR9XG5cbn1cbiJdLCJuYW1lcyI6WyJCdWZmZXJBdHRyaWJ1dGUiLCJCb3gzIiwiRnJvbnRTaWRlIiwiQ0VOVEVSIiwiQllURVNfUEVSX05PREUiLCJJU19MRUFGTk9ERV9GTEFHIiwiU0tJUF9HRU5FUkFUSU9OIiwiYnVpbGRQYWNrZWRUcmVlIiwiT3JpZW50ZWRCb3giLCJhcnJheVRvQm94IiwiRXh0ZW5kZWRUcmlhbmdsZVBvb2wiLCJzaGFwZWNhc3QiLCJjbG9zZXN0UG9pbnRUb1BvaW50IiwiaXRlcmF0ZU92ZXJUcmlhbmdsZXMiLCJyZWZpdCIsInJheWNhc3QiLCJyYXljYXN0Rmlyc3QiLCJpbnRlcnNlY3RzR2VvbWV0cnkiLCJjbG9zZXN0UG9pbnRUb0dlb21ldHJ5IiwiaXRlcmF0ZU92ZXJUcmlhbmdsZXNfaW5kaXJlY3QiLCJyZWZpdF9pbmRpcmVjdCIsInJheWNhc3RfaW5kaXJlY3QiLCJyYXljYXN0Rmlyc3RfaW5kaXJlY3QiLCJpbnRlcnNlY3RzR2VvbWV0cnlfaW5kaXJlY3QiLCJjbG9zZXN0UG9pbnRUb0dlb21ldHJ5X2luZGlyZWN0IiwiaXNTaGFyZWRBcnJheUJ1ZmZlclN1cHBvcnRlZCIsInNldFRyaWFuZ2xlIiwiYnZoY2FzdCIsIm9iYiIsInRlbXBCb3giLCJNZXNoQlZIIiwic2VyaWFsaXplIiwiYnZoIiwib3B0aW9ucyIsImNsb25lQnVmZmVycyIsImdlb21ldHJ5Iiwicm9vdERhdGEiLCJfcm9vdHMiLCJpbmRpcmVjdEJ1ZmZlciIsIl9pbmRpcmVjdEJ1ZmZlciIsImluZGV4QXR0cmlidXRlIiwiZ2V0SW5kZXgiLCJyZXN1bHQiLCJyb290cyIsIm1hcCIsInJvb3QiLCJzbGljZSIsImluZGV4IiwiYXJyYXkiLCJkZXNlcmlhbGl6ZSIsImRhdGEiLCJzZXRJbmRleCIsImluZGlyZWN0IiwiQm9vbGVhbiIsIm5ld0luZGV4Iiwic2V0IiwibmVlZHNVcGRhdGUiLCJjb25zdHJ1Y3RvciIsImlzQnVmZmVyR2VvbWV0cnkiLCJFcnJvciIsImlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUiLCJPYmplY3QiLCJhc3NpZ24iLCJzdHJhdGVneSIsIm1heERlcHRoIiwibWF4TGVhZlRyaXMiLCJ2ZXJib3NlIiwidXNlU2hhcmVkQXJyYXlCdWZmZXIiLCJzZXRCb3VuZGluZ0JveCIsIm9uUHJvZ3Jlc3MiLCJib3VuZGluZ0JveCIsImdldEJvdW5kaW5nQm94IiwicmVzb2x2ZVRyaWFuZ2xlSW5kZXgiLCJpIiwibm9kZUluZGljZXMiLCJyZWZpdEZ1bmMiLCJ0cmF2ZXJzZSIsImNhbGxiYWNrIiwicm9vdEluZGV4IiwiYnVmZmVyIiwidWludDMyQXJyYXkiLCJVaW50MzJBcnJheSIsInVpbnQxNkFycmF5IiwiVWludDE2QXJyYXkiLCJfdHJhdmVyc2UiLCJub2RlMzJJbmRleCIsImRlcHRoIiwibm9kZTE2SW5kZXgiLCJpc0xlYWYiLCJvZmZzZXQiLCJjb3VudCIsIkZsb2F0MzJBcnJheSIsImxlZnQiLCJyaWdodCIsInNwbGl0QXhpcyIsInN0b3BUcmF2ZXJzYWwiLCJyYXkiLCJtYXRlcmlhbE9yU2lkZSIsImludGVyc2VjdHMiLCJpc01hdGVyaWFsIiwiaXNBcnJheU1hdGVyaWFsIiwiQXJyYXkiLCJpc0FycmF5IiwiZ3JvdXBzIiwic2lkZSIsInJheWNhc3RGdW5jIiwibCIsImxlbmd0aCIsIm1hdGVyaWFsU2lkZSIsIm1hdGVyaWFsSW5kZXgiLCJzdGFydENvdW50IiwiaiIsImpsIiwiZmFjZSIsImNsb3Nlc3RSZXN1bHQiLCJyYXljYXN0Rmlyc3RGdW5jIiwiZGlzdGFuY2UiLCJvdGhlckdlb21ldHJ5IiwiZ2VvbVRvTWVzaCIsImludGVyc2VjdHNHZW9tZXRyeUZ1bmMiLCJjYWxsYmFja3MiLCJ0cmlhbmdsZSIsImdldFByaW1pdGl2ZSIsIml0ZXJhdGVGdW5jIiwiYm91bmRzVHJhdmVyc2VPcmRlciIsImludGVyc2VjdHNCb3VuZHMiLCJpbnRlcnNlY3RzUmFuZ2UiLCJpbnRlcnNlY3RzVHJpYW5nbGUiLCJvcmlnaW5hbEludGVyc2VjdHNSYW5nZSIsImNvbnRhaW5lZCIsIm5vZGVJbmRleCIsImJ5dGVPZmZzZXQiLCJieXRlTGVuZ3RoIiwicmVsZWFzZVByaW1pdGl2ZSIsIm90aGVyQnZoIiwibWF0cml4VG9Mb2NhbCIsImludGVyc2VjdHNSYW5nZXMiLCJpbnRlcnNlY3RzVHJpYW5nbGVzIiwidHJpYW5nbGUxIiwiaW5kZXhBdHRyMSIsInBvc2l0aW9uQXR0cjEiLCJhdHRyaWJ1dGVzIiwicG9zaXRpb24iLCJhc3NpZ25UcmlhbmdsZTEiLCJpMSIsInRpIiwidHJpYW5nbGUyIiwiaW5kZXhBdHRyMiIsInBvc2l0aW9uQXR0cjIiLCJhc3NpZ25UcmlhbmdsZTIiLCJpMiIsInRpMiIsIml0ZXJhdGVPdmVyRG91YmxlVHJpYW5nbGVzIiwib2Zmc2V0MSIsImNvdW50MSIsIm9mZnNldDIiLCJjb3VudDIiLCJkZXB0aDEiLCJpbmRleDEiLCJkZXB0aDIiLCJpbmRleDIiLCJsMiIsImEiLCJhcHBseU1hdHJpeDQiLCJiIiwiYyIsImwxIiwib3JpZ2luYWxJbnRlcnNlY3RzUmFuZ2VzIiwiaW50ZXJzZWN0c0JveCIsImJveCIsImJveFRvTWVzaCIsIm1pbiIsIm1heCIsInRyaSIsImludGVyc2VjdHNTcGhlcmUiLCJzcGhlcmUiLCJnZW9tZXRyeVRvQnZoIiwidGFyZ2V0MSIsInRhcmdldDIiLCJtaW5UaHJlc2hvbGQiLCJtYXhUaHJlc2hvbGQiLCJJbmZpbml0eSIsImNsb3Nlc3RQb2ludFRvR2VvbWV0cnlGdW5jIiwicG9pbnQiLCJ0YXJnZXQiLCJtYWtlRW1wdHkiLCJmb3JFYWNoIiwidW5pb24iXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/MeshBVH.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/MeshBVHNode.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/MeshBVHNode.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   MeshBVHNode: () => (/* binding */ MeshBVHNode)\n/* harmony export */ });\nclass MeshBVHNode {\n    constructor(){\n    // internal nodes have boundingData, left, right, and splitAxis\n    // leaf nodes have offset and count (referring to primitives in the mesh geometry)\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9jb3JlL01lc2hCVkhOb2RlLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyxNQUFNQTtJQUVaQyxhQUFjO0lBRWIsK0RBQStEO0lBQy9ELGtGQUFrRjtJQUVuRjtBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmliZS0zZC1jb2RlLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvY29yZS9NZXNoQlZITm9kZS5qcz9lOTA0Il0sInNvdXJjZXNDb250ZW50IjpbImV4cG9ydCBjbGFzcyBNZXNoQlZITm9kZSB7XG5cblx0Y29uc3RydWN0b3IoKSB7XG5cblx0XHQvLyBpbnRlcm5hbCBub2RlcyBoYXZlIGJvdW5kaW5nRGF0YSwgbGVmdCwgcmlnaHQsIGFuZCBzcGxpdEF4aXNcblx0XHQvLyBsZWFmIG5vZGVzIGhhdmUgb2Zmc2V0IGFuZCBjb3VudCAocmVmZXJyaW5nIHRvIHByaW1pdGl2ZXMgaW4gdGhlIG1lc2ggZ2VvbWV0cnkpXG5cblx0fVxuXG59XG4iXSwibmFtZXMiOlsiTWVzaEJWSE5vZGUiLCJjb25zdHJ1Y3RvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/MeshBVHNode.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/build/buildTree.js":
/*!************************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/build/buildTree.js ***!
  \************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   buildPackedTree: () => (/* binding */ buildPackedTree)\n/* harmony export */ });\n/* harmony import */ var _geometryUtils_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./geometryUtils.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/build/geometryUtils.js\");\n/* harmony import */ var _computeBoundsUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./computeBoundsUtils.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/build/computeBoundsUtils.js\");\n/* harmony import */ var _splitUtils_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./splitUtils.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/build/splitUtils.js\");\n/* harmony import */ var _MeshBVHNode_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../MeshBVHNode.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/MeshBVHNode.js\");\n/* harmony import */ var _Constants_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../Constants.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/Constants.js\");\n/* harmony import */ var _sortUtils_generated_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./sortUtils.generated.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/build/sortUtils.generated.js\");\n/* harmony import */ var _sortUtils_indirect_generated_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./sortUtils_indirect.generated.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/build/sortUtils_indirect.generated.js\");\n\n\n\n\n\n\n\nfunction generateIndirectBuffer(geometry, useSharedArrayBuffer) {\n    const triCount = (geometry.index ? geometry.index.count : geometry.attributes.position.count) / 3;\n    const useUint32 = triCount > 2 ** 16;\n    const byteCount = useUint32 ? 4 : 2;\n    const buffer = useSharedArrayBuffer ? new SharedArrayBuffer(triCount * byteCount) : new ArrayBuffer(triCount * byteCount);\n    const indirectBuffer = useUint32 ? new Uint32Array(buffer) : new Uint16Array(buffer);\n    for(let i = 0, l = indirectBuffer.length; i < l; i++){\n        indirectBuffer[i] = i;\n    }\n    return indirectBuffer;\n}\nfunction buildTree(bvh, options) {\n    // Compute the full bounds of the geometry at the same time as triangle bounds because\n    // we'll need it for the root bounds in the case with no groups and it should be fast here.\n    // We can't use the geometry bounding box if it's available because it may be out of date.\n    const geometry = bvh.geometry;\n    const indexArray = geometry.index ? geometry.index.array : null;\n    const maxDepth = options.maxDepth;\n    const verbose = options.verbose;\n    const maxLeafTris = options.maxLeafTris;\n    const strategy = options.strategy;\n    const onProgress = options.onProgress;\n    const totalTriangles = (0,_geometryUtils_js__WEBPACK_IMPORTED_MODULE_0__.getTriCount)(geometry);\n    const indirectBuffer = bvh._indirectBuffer;\n    let reachedMaxDepth = false;\n    const fullBounds = new Float32Array(6);\n    const cacheCentroidBoundingData = new Float32Array(6);\n    const triangleBounds = (0,_computeBoundsUtils_js__WEBPACK_IMPORTED_MODULE_1__.computeTriangleBounds)(geometry, fullBounds);\n    const partionFunc = options.indirect ? _sortUtils_indirect_generated_js__WEBPACK_IMPORTED_MODULE_2__.partition_indirect : _sortUtils_generated_js__WEBPACK_IMPORTED_MODULE_3__.partition;\n    const roots = [];\n    const ranges = options.indirect ? (0,_geometryUtils_js__WEBPACK_IMPORTED_MODULE_0__.getFullGeometryRange)(geometry) : (0,_geometryUtils_js__WEBPACK_IMPORTED_MODULE_0__.getRootIndexRanges)(geometry);\n    if (ranges.length === 1) {\n        const range = ranges[0];\n        const root = new _MeshBVHNode_js__WEBPACK_IMPORTED_MODULE_4__.MeshBVHNode();\n        root.boundingData = fullBounds;\n        (0,_computeBoundsUtils_js__WEBPACK_IMPORTED_MODULE_1__.getCentroidBounds)(triangleBounds, range.offset, range.count, cacheCentroidBoundingData);\n        splitNode(root, range.offset, range.count, cacheCentroidBoundingData);\n        roots.push(root);\n    } else {\n        for (let range of ranges){\n            const root = new _MeshBVHNode_js__WEBPACK_IMPORTED_MODULE_4__.MeshBVHNode();\n            root.boundingData = new Float32Array(6);\n            (0,_computeBoundsUtils_js__WEBPACK_IMPORTED_MODULE_1__.getBounds)(triangleBounds, range.offset, range.count, root.boundingData, cacheCentroidBoundingData);\n            splitNode(root, range.offset, range.count, cacheCentroidBoundingData);\n            roots.push(root);\n        }\n    }\n    return roots;\n    function triggerProgress(trianglesProcessed) {\n        if (onProgress) {\n            onProgress(trianglesProcessed / totalTriangles);\n        }\n    }\n    // either recursively splits the given node, creating left and right subtrees for it, or makes it a leaf node,\n    // recording the offset and count of its triangles and writing them into the reordered geometry index.\n    function splitNode(node, offset, count, centroidBoundingData = null, depth = 0) {\n        if (!reachedMaxDepth && depth >= maxDepth) {\n            reachedMaxDepth = true;\n            if (verbose) {\n                console.warn(`MeshBVH: Max depth of ${maxDepth} reached when generating BVH. Consider increasing maxDepth.`);\n                console.warn(geometry);\n            }\n        }\n        // early out if we've met our capacity\n        if (count <= maxLeafTris || depth >= maxDepth) {\n            triggerProgress(offset + count);\n            node.offset = offset;\n            node.count = count;\n            return node;\n        }\n        // Find where to split the volume\n        const split = (0,_splitUtils_js__WEBPACK_IMPORTED_MODULE_5__.getOptimalSplit)(node.boundingData, centroidBoundingData, triangleBounds, offset, count, strategy);\n        if (split.axis === -1) {\n            triggerProgress(offset + count);\n            node.offset = offset;\n            node.count = count;\n            return node;\n        }\n        const splitOffset = partionFunc(indirectBuffer, indexArray, triangleBounds, offset, count, split);\n        // create the two new child nodes\n        if (splitOffset === offset || splitOffset === offset + count) {\n            triggerProgress(offset + count);\n            node.offset = offset;\n            node.count = count;\n        } else {\n            node.splitAxis = split.axis;\n            // create the left child and compute its bounding box\n            const left = new _MeshBVHNode_js__WEBPACK_IMPORTED_MODULE_4__.MeshBVHNode();\n            const lstart = offset;\n            const lcount = splitOffset - offset;\n            node.left = left;\n            left.boundingData = new Float32Array(6);\n            (0,_computeBoundsUtils_js__WEBPACK_IMPORTED_MODULE_1__.getBounds)(triangleBounds, lstart, lcount, left.boundingData, cacheCentroidBoundingData);\n            splitNode(left, lstart, lcount, cacheCentroidBoundingData, depth + 1);\n            // repeat for right\n            const right = new _MeshBVHNode_js__WEBPACK_IMPORTED_MODULE_4__.MeshBVHNode();\n            const rstart = splitOffset;\n            const rcount = count - lcount;\n            node.right = right;\n            right.boundingData = new Float32Array(6);\n            (0,_computeBoundsUtils_js__WEBPACK_IMPORTED_MODULE_1__.getBounds)(triangleBounds, rstart, rcount, right.boundingData, cacheCentroidBoundingData);\n            splitNode(right, rstart, rcount, cacheCentroidBoundingData, depth + 1);\n        }\n        return node;\n    }\n}\nfunction buildPackedTree(bvh, options) {\n    const geometry = bvh.geometry;\n    if (options.indirect) {\n        bvh._indirectBuffer = generateIndirectBuffer(geometry, options.useSharedArrayBuffer);\n        if ((0,_geometryUtils_js__WEBPACK_IMPORTED_MODULE_0__.hasGroupGaps)(geometry) && !options.verbose) {\n            console.warn('MeshBVH: Provided geometry contains groups that do not fully span the vertex contents while using the \"indirect\" option. ' + \"BVH may incorrectly report intersections on unrendered portions of the geometry.\");\n        }\n    }\n    if (!bvh._indirectBuffer) {\n        (0,_geometryUtils_js__WEBPACK_IMPORTED_MODULE_0__.ensureIndex)(geometry, options);\n    }\n    // boundingData  \t\t\t\t: 6 float32\n    // right / offset \t\t\t\t: 1 uint32\n    // splitAxis / isLeaf + count \t: 1 uint32 / 2 uint16\n    const roots = buildTree(bvh, options);\n    let float32Array;\n    let uint32Array;\n    let uint16Array;\n    const packedRoots = [];\n    const BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n    for(let i = 0; i < roots.length; i++){\n        const root = roots[i];\n        let nodeCount = countNodes(root);\n        const buffer = new BufferConstructor(_Constants_js__WEBPACK_IMPORTED_MODULE_6__.BYTES_PER_NODE * nodeCount);\n        float32Array = new Float32Array(buffer);\n        uint32Array = new Uint32Array(buffer);\n        uint16Array = new Uint16Array(buffer);\n        populateBuffer(0, root);\n        packedRoots.push(buffer);\n    }\n    bvh._roots = packedRoots;\n    return;\n    function countNodes(node) {\n        if (node.count) {\n            return 1;\n        } else {\n            return 1 + countNodes(node.left) + countNodes(node.right);\n        }\n    }\n    function populateBuffer(byteOffset, node) {\n        const stride4Offset = byteOffset / 4;\n        const stride2Offset = byteOffset / 2;\n        const isLeaf = !!node.count;\n        const boundingData = node.boundingData;\n        for(let i = 0; i < 6; i++){\n            float32Array[stride4Offset + i] = boundingData[i];\n        }\n        if (isLeaf) {\n            const offset = node.offset;\n            const count = node.count;\n            uint32Array[stride4Offset + 6] = offset;\n            uint16Array[stride2Offset + 14] = count;\n            uint16Array[stride2Offset + 15] = _Constants_js__WEBPACK_IMPORTED_MODULE_6__.IS_LEAFNODE_FLAG;\n            return byteOffset + _Constants_js__WEBPACK_IMPORTED_MODULE_6__.BYTES_PER_NODE;\n        } else {\n            const left = node.left;\n            const right = node.right;\n            const splitAxis = node.splitAxis;\n            let nextUnusedPointer;\n            nextUnusedPointer = populateBuffer(byteOffset + _Constants_js__WEBPACK_IMPORTED_MODULE_6__.BYTES_PER_NODE, left);\n            if (nextUnusedPointer / 4 > Math.pow(2, 32)) {\n                throw new Error(\"MeshBVH: Cannot store child pointer greater than 32 bits.\");\n            }\n            uint32Array[stride4Offset + 6] = nextUnusedPointer / 4;\n            nextUnusedPointer = populateBuffer(nextUnusedPointer, right);\n            uint32Array[stride4Offset + 7] = splitAxis;\n            return nextUnusedPointer;\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9jb3JlL2J1aWxkL2J1aWxkVHJlZS5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUF1SDtBQUN6QjtBQUM1QztBQUNGO0FBQ21CO0FBRWQ7QUFDa0I7QUFFdkUsU0FBU2MsdUJBQXdCQyxRQUFRLEVBQUVDLG9CQUFvQjtJQUU5RCxNQUFNQyxXQUFXLENBQUVGLFNBQVNHLEtBQUssR0FBR0gsU0FBU0csS0FBSyxDQUFDQyxLQUFLLEdBQUdKLFNBQVNLLFVBQVUsQ0FBQ0MsUUFBUSxDQUFDRixLQUFLLElBQUs7SUFDbEcsTUFBTUcsWUFBWUwsV0FBVyxLQUFLO0lBQ2xDLE1BQU1NLFlBQVlELFlBQVksSUFBSTtJQUVsQyxNQUFNRSxTQUFTUix1QkFBdUIsSUFBSVMsa0JBQW1CUixXQUFXTSxhQUFjLElBQUlHLFlBQWFULFdBQVdNO0lBQ2xILE1BQU1JLGlCQUFpQkwsWUFBWSxJQUFJTSxZQUFhSixVQUFXLElBQUlLLFlBQWFMO0lBQ2hGLElBQU0sSUFBSU0sSUFBSSxHQUFHQyxJQUFJSixlQUFlSyxNQUFNLEVBQUVGLElBQUlDLEdBQUdELElBQU87UUFFekRILGNBQWMsQ0FBRUcsRUFBRyxHQUFHQTtJQUV2QjtJQUVBLE9BQU9IO0FBRVI7QUFFQSxTQUFTTSxVQUFXQyxHQUFHLEVBQUVDLE9BQU87SUFFL0Isc0ZBQXNGO0lBQ3RGLDJGQUEyRjtJQUMzRiwwRkFBMEY7SUFDMUYsTUFBTXBCLFdBQVdtQixJQUFJbkIsUUFBUTtJQUM3QixNQUFNcUIsYUFBYXJCLFNBQVNHLEtBQUssR0FBR0gsU0FBU0csS0FBSyxDQUFDbUIsS0FBSyxHQUFHO0lBQzNELE1BQU1DLFdBQVdILFFBQVFHLFFBQVE7SUFDakMsTUFBTUMsVUFBVUosUUFBUUksT0FBTztJQUMvQixNQUFNQyxjQUFjTCxRQUFRSyxXQUFXO0lBQ3ZDLE1BQU1DLFdBQVdOLFFBQVFN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LEdBQUcwQixZQUFZLENBQUUxQixFQUFHO1FBRXREO1FBRUEsSUFBSzRELFFBQVM7WUFFYixNQUFNakMsU0FBU0ssS0FBS0wsTUFBTTtZQUMxQixNQUFNdEMsUUFBUTJDLEtBQUszQyxLQUFLO1lBQ3hCNEQsV0FBVyxDQUFFUyxnQkFBZ0IsRUFBRyxHQUFHL0I7WUFDbkN1QixXQUFXLENBQUVTLGdCQUFnQixHQUFJLEdBQUd0RTtZQUNwQzZELFdBQVcsQ0FBRVMsZ0JBQWdCLEdBQUksR0FBRzlFLDJEQUFnQkE7WUFDcEQsT0FBTzRFLGFBQWE3RSx5REFBY0E7UUFFbkMsT0FBTztZQUVOLE1BQU02RCxPQUFPVCxLQUFLUyxJQUFJO1lBQ3RCLE1BQU1HLFFBQVFaLEtBQUtZLEtBQUs7WUFDeEIsTUFBTUosWUFBWVIsS0FBS1EsU0FBUztZQUVoQyxJQUFJcUI7WUFDSkEsb0JBQW9CTixlQUFnQkUsYUFBYTdFLHlEQUFjQSxFQUFFNkQ7WUFFakUsSUFBSyxvQkFBc0IsSUFBTXFCLEtBQUtDLEdBQUcsQ0FBRSxHQUFHLEtBQU87Z0JBRXBELE1BQU0sSUFBSUMsTUFBTztZQUVsQjtZQUVBZixXQUFXLENBQUVTLGdCQUFnQixFQUFHLEdBQUdHLG9CQUFvQjtZQUN2REEsb0JBQW9CTixlQUFnQk0sbUJBQW1CakI7WUFFdkRLLFdBQVcsQ0FBRVMsZ0JBQWdCLEVBQUcsR0FBR2xCO1lBQ25DLE9BQU9xQjtRQUVSO0lBRUQ7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpYmUtM2QtY29kZS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9ub2RlX21vZHVsZXMvdGhyZWUtbWVzaC1idmgvc3JjL2NvcmUvYnVpbGQvYnVpbGRUcmVlLmpzP2YxN2IiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgZW5zdXJlSW5kZXgsIGdldEZ1bGxHZW9tZXRyeVJhbmdlLCBnZXRSb290SW5kZXhSYW5nZXMsIGdldFRyaUNvdW50LCBoYXNHcm91cEdhcHMsIH0gZnJvbSAnLi9nZW9tZXRyeVV0aWxzLmpzJztcbmltcG9ydCB7IGdldEJvdW5kcywgZ2V0Q2VudHJvaWRCb3VuZHMsIGNvbXB1dGVUcmlhbmdsZUJvdW5kcyB9IGZyb20gJy4vY29tcHV0ZUJvdW5kc1V0aWxzLmpzJztcbmltcG9ydCB7IGdldE9wdGltYWxTcGxpdCB9IGZyb20gJy4vc3BsaXRVdGlscy5qcyc7XG5pbXBvcnQgeyBNZXNoQlZITm9kZSB9IGZyb20gJy4uL01lc2hCVkhOb2RlLmpzJztcbmltcG9ydCB7IEJZVEVTX1BFUl9OT0RFLCBJU19MRUFGTk9ERV9GTEFHIH0gZnJvbSAnLi4vQ29uc3RhbnRzLmpzJztcblxuaW1wb3J0IHsgcGFydGl0aW9uIH0gZnJvbSAnLi9zb3J0VXRpbHMuZ2VuZXJhdGVkLmpzJztcbmltcG9ydCB7IHBhcnRpdGlvbl9pbmRpcmVjdCB9IGZyb20gJy4vc29ydFV0aWxzX2luZGlyZWN0LmdlbmVyYXRlZC5qcyc7XG5cbmZ1bmN0aW9uIGdlbmVyYXRlSW5kaXJlY3RCdWZmZXIoIGdlb21ldHJ5LCB1c2VTaGFyZWRBcnJheUJ1ZmZlciApIHtcblxuXHRjb25zdCB0cmlDb3VudCA9ICggZ2VvbWV0cnkuaW5kZXggPyBnZW9tZXRyeS5pbmRleC5jb3VudCA6IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb24uY291bnQgKSAvIDM7XG5cdGNvbnN0IHVzZVVpbnQzMiA9IHRyaUNvdW50ID4gMiAqKiAxNjtcblx0Y29uc3QgYnl0ZUNvdW50ID0gdXNlVWludDMyID8gNCA6IDI7XG5cblx0Y29uc3QgYnVmZmVyID0gdXNlU2hhcmVkQXJyYXlCdWZmZXIgPyBuZXcgU2hhcmVkQXJyYXlCdWZmZXIoIHRyaUNvdW50ICogYnl0ZUNvdW50ICkgOiBuZXcgQXJyYXlCdWZmZXIoIHRyaUNvdW50ICogYnl0ZUNvdW50ICk7XG5cdGNvbnN0IGluZGlyZWN0QnVmZmVyID0gdXNlVWludDMyID8gbmV3IFVpbnQzMkFycmF5KCBidWZmZXIgKSA6IG5ldyBVaW50MTZBcnJheSggYnVmZmVyICk7XG5cdGZvciAoIGxldCBpID0gMCwgbCA9IGluZGlyZWN0QnVmZmVyLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRpbmRpcmVjdEJ1ZmZlclsgaSBdID0gaTtcblxuXHR9XG5cblx0cmV0dXJuIGluZGlyZWN0QnVmZmVyO1xuXG59XG5cbmZ1bmN0aW9uIGJ1aWxkVHJlZSggYnZoLCBvcHRpb25zICkge1xuXG5cdC8vIENvbXB1dGUgdGhlIGZ1bGwgYm91bmRzIG9mIHRoZSBnZW9tZXRyeSBhdCB0aGUgc2FtZSB0aW1lIGFzIHRyaWFuZ2xlIGJvdW5kcyBiZWNhdXNlXG5cdC8vIHdlJ2xsIG5lZWQgaXQgZm9yIHRoZSByb290IGJvdW5kcyBpbiB0aGUgY2FzZSB3aXRoIG5vIGdyb3VwcyBhbmQgaXQgc2hvdWxkIGJlIGZhc3QgaGVyZS5cblx0Ly8gV2UgY2FuJ3QgdXNlIHRoZSBnZW9tZXRyeSBib3VuZGluZyBib3ggaWYgaXQncyBhdmFpbGFibGUgYmVjYXVzZSBpdCBtYXkgYmUgb3V0IG9mIGRhdGUuXG5cdGNvbnN0IGdlb21ldHJ5ID0gYnZoLmdlb21ldHJ5O1xuXHRjb25zdCBpbmRleEFycmF5ID0gZ2VvbWV0cnkuaW5kZXggPyBnZW9tZXRyeS5pbmRleC5hcnJheSA6IG51bGw7XG5cdGNvbnN0IG1heERlcHRoID0gb3B0aW9ucy5tYXhEZXB0aDtcblx0Y29uc3QgdmVyYm9zZSA9IG9wdGlvbnMudmVyYm9zZTtcblx0Y29uc3QgbWF4TGVhZlRyaXMgPSBvcHRpb25zLm1heExlYWZUcmlzO1xuXHRjb25zdCBzdHJhdGVneSA9IG9wdGlvbnMuc3RyYXRlZ3k7XG5cdGNvbnN0IG9uUHJvZ3Jlc3MgPSBvcHRpb25zLm9uUHJvZ3Jlc3M7XG5cdGNvbnN0IHRvdGFsVHJpYW5nbGVzID0gZ2V0VHJpQ291bnQoIGdlb21ldHJ5ICk7XG5cdGNvbnN0IGluZGlyZWN0QnVmZmVyID0gYnZoLl9pbmRpcmVjdEJ1ZmZlcjtcblx0bGV0IHJlYWNoZWRNYXhEZXB0aCA9IGZhbHNlO1xuXG5cdGNvbnN0IGZ1bGxCb3VuZHMgPSBuZXcgRmxvYXQzMkFycmF5KCA2ICk7XG5cdGNvbnN0IGNhY2hlQ2VudHJvaWRCb3VuZGluZ0RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KCA2ICk7XG5cdGNvbnN0IHRyaWFuZ2xlQm91bmRzID0gY29tcHV0ZVRyaWFuZ2xlQm91bmRzKCBnZW9tZXRyeSwgZnVsbEJvdW5kcyApO1xuXHRjb25zdCBwYXJ0aW9uRnVuYyA9IG9wdGlvbnMuaW5kaXJlY3QgPyBwYXJ0aXRpb25faW5kaXJlY3QgOiBwYXJ0aXRpb247XG5cblx0Y29uc3Qgcm9vdHMgPSBbXTtcblx0Y29uc3QgcmFuZ2VzID0gb3B0aW9ucy5pbmRpcmVjdCA/IGdldEZ1bGxHZW9tZXRyeVJhbmdlKCBnZW9tZXRyeSApIDogZ2V0Um9vdEluZGV4UmFuZ2VzKCBnZW9tZXRyeSApO1xuXG5cdGlmICggcmFuZ2VzLmxlbmd0aCA9PT0gMSApIHtcblxuXHRcdGNvbnN0IHJhbmdlID0gcmFuZ2VzWyAwIF07XG5cdFx0Y29uc3Qgcm9vdCA9IG5ldyBNZXNoQlZITm9kZSgpO1xuXHRcdHJvb3QuYm91bmRpbmdEYXRhID0gZnVsbEJvdW5kcztcblx0XHRnZXRDZW50cm9pZEJvdW5kcyggdHJpYW5nbGVCb3VuZHMsIHJhbmdlLm9mZnNldCwgcmFuZ2UuY291bnQsIGNhY2hlQ2VudHJvaWRCb3VuZGluZ0RhdGEgKTtcblxuXHRcdHNwbGl0Tm9kZSggcm9vdCwgcmFuZ2Uub2Zmc2V0LCByYW5nZS5jb3VudCwgY2FjaGVDZW50cm9pZEJvdW5kaW5nRGF0YSApO1xuXHRcdHJvb3RzLnB1c2goIHJvb3QgKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Zm9yICggbGV0IHJhbmdlIG9mIHJhbmdlcyApIHtcblxuXHRcdFx0Y29uc3Qgcm9vdCA9IG5ldyBNZXNoQlZITm9kZSgpO1xuXHRcdFx0cm9vdC5ib3VuZGluZ0RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KCA2ICk7XG5cdFx0XHRnZXRCb3VuZHMoIHRyaWFuZ2xlQm91bmRzLCByYW5nZS5vZmZzZXQsIHJhbmdlLmNvdW50LCByb290LmJvdW5kaW5nRGF0YSwgY2FjaGVDZW50cm9pZEJvdW5kaW5nRGF0YSApO1xuXG5cdFx0XHRzcGxpdE5vZGUoIHJvb3QsIHJhbmdlLm9mZnNldCwgcmFuZ2UuY291bnQsIGNhY2hlQ2VudHJvaWRCb3VuZGluZ0RhdGEgKTtcblx0XHRcdHJvb3RzLnB1c2goIHJvb3QgKTtcblxuXHRcdH1cblxuXHR9XG5cblx0cmV0dXJuIHJvb3RzO1xuXG5cdGZ1bmN0aW9uIHRyaWdnZXJQcm9ncmVzcyggdHJpYW5nbGVzUHJvY2Vzc2VkICkge1xuXG5cdFx0aWYgKCBvblByb2dyZXNzICkge1xuXG5cdFx0XHRvblByb2dyZXNzKCB0cmlhbmdsZXNQcm9jZXNzZWQgLyB0b3RhbFRyaWFuZ2xlcyApO1xuXG5cdFx0fVxuXG5cdH1cblxuXHQvLyBlaXRoZXIgcmVjdXJzaXZlbHkgc3BsaXRzIHRoZSBnaXZlbiBub2RlLCBjcmVhdGluZyBsZWZ0IGFuZCByaWdodCBzdWJ0cmVlcyBmb3IgaXQsIG9yIG1ha2VzIGl0IGEgbGVhZiBub2RlLFxuXHQvLyByZWNvcmRpbmcgdGhlIG9mZnNldCBhbmQgY291bnQgb2YgaXRzIHRyaWFuZ2xlcyBhbmQgd3JpdGluZyB0aGVtIGludG8gdGhlIHJlb3JkZXJlZCBnZW9tZXRyeSBpbmRleC5cblx0ZnVuY3Rpb24gc3BsaXROb2RlKCBub2RlLCBvZmZzZXQsIGNvdW50LCBjZW50cm9pZEJvdW5kaW5nRGF0YSA9IG51bGwsIGRlcHRoID0gMCApIHtcblxuXHRcdGlmICggISByZWFjaGVkTWF4RGVwdGggJiYgZGVwdGggPj0gbWF4RGVwdGggKSB7XG5cblx0XHRcdHJlYWNoZWRNYXhEZXB0aCA9IHRydWU7XG5cdFx0XHRpZiAoIHZlcmJvc2UgKSB7XG5cblx0XHRcdFx0Y29uc29sZS53YXJuKCBgTWVzaEJWSDogTWF4IGRlcHRoIG9mICR7IG1heERlcHRoIH0gcmVhY2hlZCB3aGVuIGdlbmVyYXRpbmcgQlZILiBDb25zaWRlciBpbmNyZWFzaW5nIG1heERlcHRoLmAgKTtcblx0XHRcdFx0Y29uc29sZS53YXJuKCBnZW9tZXRyeSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBlYXJseSBvdXQgaWYgd2UndmUgbWV0IG91ciBjYXBhY2l0eVxuXHRcdGlmICggY291bnQgPD0gbWF4TGVhZlRyaXMgfHwgZGVwdGggPj0gbWF4RGVwdGggKSB7XG5cblx0XHRcdHRyaWdnZXJQcm9ncmVzcyggb2Zmc2V0ICsgY291bnQgKTtcblx0XHRcdG5vZGUub2Zmc2V0ID0gb2Zmc2V0O1xuXHRcdFx0bm9kZS5jb3VudCA9IGNvdW50O1xuXHRcdFx0cmV0dXJuIG5vZGU7XG5cblx0XHR9XG5cblx0XHQvLyBGaW5kIHdoZXJlIHRvIHNwbGl0IHRoZSB2b2x1bWVcblx0XHRjb25zdCBzcGxpdCA9IGdldE9wdGltYWxTcGxpdCggbm9kZS5ib3VuZGluZ0RhdGEsIGNlbnRyb2lkQm91bmRpbmdEYXRhLCB0cmlhbmdsZUJvdW5kcywgb2Zmc2V0LCBjb3VudCwgc3RyYXRlZ3kgKTtcblx0XHRpZiAoIHNwbGl0LmF4aXMgPT09IC0gMSApIHtcblxuXHRcdFx0dHJpZ2dlclByb2dyZXNzKCBvZmZzZXQgKyBjb3VudCApO1xuXHRcdFx0bm9kZS5vZmZzZXQgPSBvZmZzZXQ7XG5cdFx0XHRub2RlLmNvdW50ID0gY291bnQ7XG5cdFx0XHRyZXR1cm4gbm9kZTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHNwbGl0T2Zmc2V0ID0gcGFydGlvbkZ1bmMoIGluZGlyZWN0QnVmZmVyLCBpbmRleEFycmF5LCB0cmlhbmdsZUJvdW5kcywgb2Zmc2V0LCBjb3VudCwgc3BsaXQgKTtcblxuXHRcdC8vIGNyZWF0ZSB0aGUgdHdvIG5ldyBjaGlsZCBub2Rlc1xuXHRcdGlmICggc3BsaXRPZmZzZXQgPT09IG9mZnNldCB8fCBzcGxpdE9mZnNldCA9PT0gb2Zmc2V0ICsgY291bnQgKSB7XG5cblx0XHRcdHRyaWdnZXJQcm9ncmVzcyggb2Zmc2V0ICsgY291bnQgKTtcblx0XHRcdG5vZGUub2Zmc2V0ID0gb2Zmc2V0O1xuXHRcdFx0bm9kZS5jb3VudCA9IGNvdW50O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0bm9kZS5zcGxpdEF4aXMgPSBzcGxpdC5heGlzO1xuXG5cdFx0XHQvLyBjcmVhdGUgdGhlIGxlZnQgY2hpbGQgYW5kIGNvbXB1dGUgaXRzIGJvdW5kaW5nIGJveFxuXHRcdFx0Y29uc3QgbGVmdCA9IG5ldyBNZXNoQlZITm9kZSgpO1xuXHRcdFx0Y29uc3QgbHN0YXJ0ID0gb2Zmc2V0O1xuXHRcdFx0Y29uc3QgbGNvdW50ID0gc3BsaXRPZmZzZXQgLSBvZmZzZXQ7XG5cdFx0XHRub2RlLmxlZnQgPSBsZWZ0O1xuXHRcdFx0bGVmdC5ib3VuZGluZ0RhdGEgPSBuZXcgRmxvYXQzMkFycmF5KCA2ICk7XG5cblx0XHRcdGdldEJvdW5kcyggdHJpYW5nbGVCb3VuZHMsIGxzdGFydCwgbGNvdW50LCBsZWZ0LmJvdW5kaW5nRGF0YSwgY2FjaGVDZW50cm9pZEJvdW5kaW5nRGF0YSApO1xuXHRcdFx0c3BsaXROb2RlKCBsZWZ0LCBsc3RhcnQsIGxjb3VudCwgY2FjaGVDZW50cm9pZEJvdW5kaW5nRGF0YSwgZGVwdGggKyAxICk7XG5cblx0XHRcdC8vIHJlcGVhdCBmb3IgcmlnaHRcblx0XHRcdGNvbnN0IHJpZ2h0ID0gbmV3IE1lc2hCVkhOb2RlKCk7XG5cdFx0XHRjb25zdCByc3RhcnQgPSBzcGxpdE9mZnNldDtcblx0XHRcdGNvbnN0IHJjb3VudCA9IGNvdW50IC0gbGNvdW50O1xuXHRcdFx0bm9kZS5yaWdodCA9IHJpZ2h0O1xuXHRcdFx0cmlnaHQuYm91bmRpbmdEYXRhID0gbmV3IEZsb2F0MzJBcnJheSggNiApO1xuXG5cdFx0XHRnZXRCb3VuZHMoIHRyaWFuZ2xlQm91bmRzLCByc3RhcnQsIHJjb3VudCwgcmlnaHQuYm91bmRpbmdEYXRhLCBjYWNoZUNlbnRyb2lkQm91bmRpbmdEYXRhICk7XG5cdFx0XHRzcGxpdE5vZGUoIHJpZ2h0LCByc3RhcnQsIHJjb3VudCwgY2FjaGVDZW50cm9pZEJvdW5kaW5nRGF0YSwgZGVwdGggKyAxICk7XG5cblx0XHR9XG5cblx0XHRyZXR1cm4gbm9kZTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGJ1aWxkUGFja2VkVHJlZSggYnZoLCBvcHRpb25zICkge1xuXG5cdGNvbnN0IGdlb21ldHJ5ID0gYnZoLmdlb21ldHJ5O1xuXHRpZiAoIG9wdGlvbnMuaW5kaXJlY3QgKSB7XG5cblx0XHRidmguX2luZGlyZWN0QnVmZmVyID0gZ2VuZXJhdGVJbmRpcmVjdEJ1ZmZlciggZ2VvbWV0cnksIG9wdGlvbnMudXNlU2hhcmVkQXJyYXlCdWZmZXIgKTtcblxuXHRcdGlmICggaGFzR3JvdXBHYXBzKCBnZW9tZXRyeSApICYmICEgb3B0aW9ucy52ZXJib3NlICkge1xuXG5cdFx0XHRjb25zb2xlLndhcm4oXG5cdFx0XHRcdCdNZXNoQlZIOiBQcm92aWRlZCBnZW9tZXRyeSBjb250YWlucyBncm91cHMgdGhhdCBkbyBub3QgZnVsbHkgc3BhbiB0aGUgdmVydGV4IGNvbnRlbnRzIHdoaWxlIHVzaW5nIHRoZSBcImluZGlyZWN0XCIgb3B0aW9uLiAnICtcblx0XHRcdFx0J0JWSCBtYXkgaW5jb3JyZWN0bHkgcmVwb3J0IGludGVyc2VjdGlvbnMgb24gdW5yZW5kZXJlZCBwb3J0aW9ucyBvZiB0aGUgZ2VvbWV0cnkuJ1xuXHRcdFx0KTtcblxuXHRcdH1cblxuXHR9XG5cblx0aWYgKCAhIGJ2aC5faW5kaXJlY3RCdWZmZXIgKSB7XG5cblx0XHRlbnN1cmVJbmRleCggZ2VvbWV0cnksIG9wdGlvbnMgKTtcblxuXHR9XG5cblx0Ly8gYm91bmRpbmdEYXRhICBcdFx0XHRcdDogNiBmbG9hdDMyXG5cdC8vIHJpZ2h0IC8gb2Zmc2V0IFx0XHRcdFx0OiAxIHVpbnQzMlxuXHQvLyBzcGxpdEF4aXMgLyBpc0xlYWYgKyBjb3VudCBcdDogMSB1aW50MzIgLyAyIHVpbnQxNlxuXHRjb25zdCByb290cyA9IGJ1aWxkVHJlZSggYnZoLCBvcHRpb25zICk7XG5cblx0bGV0IGZsb2F0MzJBcnJheTtcblx0bGV0IHVpbnQzMkFycmF5O1xuXHRsZXQgdWludDE2QXJyYXk7XG5cdGNvbnN0IHBhY2tlZFJvb3RzID0gW107XG5cdGNvbnN0IEJ1ZmZlckNvbnN0cnVjdG9yID0gb3B0aW9ucy51c2VTaGFyZWRBcnJheUJ1ZmZlciA/IFNoYXJlZEFycmF5QnVmZmVyIDogQXJyYXlCdWZmZXI7XG5cdGZvciAoIGxldCBpID0gMDsgaSA8IHJvb3RzLmxlbmd0aDsgaSArKyApIHtcblxuXHRcdGNvbnN0IHJvb3QgPSByb290c1sgaSBdO1xuXHRcdGxldCBub2RlQ291bnQgPSBjb3VudE5vZGVzKCByb290ICk7XG5cblx0XHRjb25zdCBidWZmZXIgPSBuZXcgQnVmZmVyQ29uc3RydWN0b3IoIEJZVEVTX1BFUl9OT0RFICogbm9kZUNvdW50ICk7XG5cdFx0ZmxvYXQzMkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggYnVmZmVyICk7XG5cdFx0dWludDMyQXJyYXkgPSBuZXcgVWludDMyQXJyYXkoIGJ1ZmZlciApO1xuXHRcdHVpbnQxNkFycmF5ID0gbmV3IFVpbnQxNkFycmF5KCBidWZmZXIgKTtcblx0XHRwb3B1bGF0ZUJ1ZmZlciggMCwgcm9vdCApO1xuXHRcdHBhY2tlZFJvb3RzLnB1c2goIGJ1ZmZlciApO1xuXG5cdH1cblxuXHRidmguX3Jvb3RzID0gcGFja2VkUm9vdHM7XG5cdHJldHVybjtcblxuXHRmdW5jdGlvbiBjb3VudE5vZGVzKCBub2RlICkge1xuXG5cdFx0aWYgKCBub2RlLmNvdW50ICkge1xuXG5cdFx0XHRyZXR1cm4gMTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJldHVybiAxICsgY291bnROb2Rlcyggbm9kZS5sZWZ0ICkgKyBjb3VudE5vZGVzKCBub2RlLnJpZ2h0ICk7XG5cblx0XHR9XG5cblx0fVxuXG5cdGZ1bmN0aW9uIHBvcHVsYXRlQnVmZmVyKCBieXRlT2Zmc2V0LCBub2RlICkge1xuXG5cdFx0Y29uc3Qgc3RyaWRlNE9mZnNldCA9IGJ5dGVPZmZzZXQgLyA0O1xuXHRcdGNvbnN0IHN0cmlkZTJPZmZzZXQgPSBieXRlT2Zmc2V0IC8gMjtcblx0XHRjb25zdCBpc0xlYWYgPSAhICEgbm9kZS5jb3VudDtcblx0XHRjb25zdCBib3VuZGluZ0RhdGEgPSBub2RlLmJvdW5kaW5nRGF0YTtcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA2OyBpICsrICkge1xuXG5cdFx0XHRmbG9hdDMyQXJyYXlbIHN0cmlkZTRPZmZzZXQgKyBpIF0gPSBib3VuZGluZ0RhdGFbIGkgXTtcblxuXHRcdH1cblxuXHRcdGlmICggaXNMZWFmICkge1xuXG5cdFx0XHRjb25zdCBvZmZzZXQgPSBub2RlLm9mZnNldDtcblx0XHRcdGNvbnN0IGNvdW50ID0gbm9kZS5jb3VudDtcblx0XHRcdHVpbnQzMkFycmF5WyBzdHJpZGU0T2Zmc2V0ICsgNiBdID0gb2Zmc2V0O1xuXHRcdFx0dWludDE2QXJyYXlbIHN0cmlkZTJPZmZzZXQgKyAxNCBdID0gY291bnQ7XG5cdFx0XHR1aW50MTZBcnJheVsgc3RyaWRlMk9mZnNldCArIDE1IF0gPSBJU19MRUFGTk9ERV9GTEFHO1xuXHRcdFx0cmV0dXJuIGJ5dGVPZmZzZXQgKyBCWVRFU19QRVJfTk9ERTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnN0IGxlZnQgPSBub2RlLmxlZnQ7XG5cdFx0XHRjb25zdCByaWdodCA9IG5vZGUucmlnaHQ7XG5cdFx0XHRjb25zdCBzcGxpdEF4aXMgPSBub2RlLnNwbGl0QXhpcztcblxuXHRcdFx0bGV0IG5leHRVbnVzZWRQb2ludGVyO1xuXHRcdFx0bmV4dFVudXNlZFBvaW50ZXIgPSBwb3B1bGF0ZUJ1ZmZlciggYnl0ZU9mZnNldCArIEJZVEVTX1BFUl9OT0RFLCBsZWZ0ICk7XG5cblx0XHRcdGlmICggKCBuZXh0VW51c2VkUG9pbnRlciAvIDQgKSA+IE1hdGgucG93KCAyLCAzMiApICkge1xuXG5cdFx0XHRcdHRocm93IG5ldyBFcnJvciggJ01lc2hCVkg6IENhbm5vdCBzdG9yZSBjaGlsZCBwb2ludGVyIGdyZWF0ZXIgdGhhbiAzMiBiaXRzLicgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHR1aW50MzJBcnJheVsgc3RyaWRlNE9mZnNldCArIDYgXSA9IG5leHRVbnVzZWRQb2ludGVyIC8gNDtcblx0XHRcdG5leHRVbnVzZWRQb2ludGVyID0gcG9wdWxhdGVCdWZmZXIoIG5leHRVbnVzZWRQb2ludGVyLCByaWdodCApO1xuXG5cdFx0XHR1aW50MzJBcnJheVsgc3RyaWRlNE9mZnNldCArIDcgXSA9IHNwbGl0QXhpcztcblx0XHRcdHJldHVybiBuZXh0VW51c2VkUG9pbnRlcjtcblxuXHRcdH1cblxuXHR9XG5cbn1cbiJdLCJuYW1lcyI6WyJlbnN1cmVJbmRleCIsImdldEZ1bGxHZW9tZXRyeVJhbmdlIiwiZ2V0Um9vdEluZGV4UmFuZ2VzIiwiZ2V0VHJpQ291bnQiLCJoYXNHcm91cEdhcHMiLCJnZXRCb3VuZHMiLCJnZXRDZW50cm9pZEJvdW5kcyIsImNvbXB1dGVUcmlhbmdsZUJvdW5kcyIsImdldE9wdGltYWxTcGxpdCIsIk1lc2hCVkhOb2RlIiwiQllURVNfUEVSX05PREUiLCJJU19MRUFGTk9ERV9GTEFHIiwicGFydGl0aW9uIiwicGFydGl0aW9uX2luZGlyZWN0IiwiZ2VuZXJhdGVJbmRpcmVjdEJ1ZmZlciIsImdlb21ldHJ5IiwidXNlU2hhcmVkQXJyYXlCdWZmZXIiLCJ0cmlDb3VudCIsImluZGV4IiwiY291bnQiLCJhdHRyaWJ1dGVzIiwicG9zaXRpb24iLCJ1c2VVaW50MzIiLCJieXRlQ291bnQiLCJidWZmZXIiLCJTaGFyZWRBcnJheUJ1ZmZlciIsIkFycmF5QnVmZmVyIiwiaW5kaXJlY3RCdWZmZXIiLCJVaW50MzJBcnJheSIsIlVpbnQxNkFycmF5IiwiaSIsImwiLCJsZW5ndGgiLCJidWlsZFRyZWUiLCJidmgiLCJvcHRpb25zIiwiaW5kZXhBcnJheSIsImFycmF5IiwibWF4RGVwdGgiLCJ2ZXJib3NlIiwibWF4TGVhZlRyaXMiLCJzdHJhdGVneSIsIm9uUHJvZ3Jlc3MiLCJ0b3RhbFRyaWFuZ2xlcyIsIl9pbmRpcmVjdEJ1ZmZlciIsInJlYWNoZWRNYXhEZXB0aCIsImZ1bGxCb3VuZHMiLCJGbG9hdDMyQXJyYXkiLCJjYWNoZUNlbnRyb2lkQm91bmRpbmdEYXRhIiwidHJpYW5nbGVCb3VuZHMiLCJwYXJ0aW9uRnVuYyIsImluZGlyZWN0Iiwicm9vdHMiLCJyYW5nZXMiLCJyYW5nZSIsInJvb3QiLCJib3VuZGluZ0RhdGEiLCJvZmZzZXQiLCJzcGxpdE5vZGUiLCJwdXNoIiwidHJpZ2dlclByb2dyZXNzIiwidHJpYW5nbGVzUHJvY2Vzc2VkIiwibm9kZSIsImNlbnRyb2lkQm91bmRpbmdEYXRhIiwiZGVwdGgiLCJjb25zb2xlIiwid2FybiIsInNwbGl0IiwiYXhpcyIsInNwbGl0T2Zmc2V0Iiwic3BsaXRBeGlzIiwibGVmdCIsImxzdGFydCIsImxjb3VudCIsInJpZ2h0IiwicnN0YXJ0IiwicmNvdW50IiwiYnVpbGRQYWNrZWRUcmVlIiwiZmxvYXQzMkFycmF5IiwidWludDMyQXJyYXkiLCJ1aW50MTZBcnJheSIsInBhY2tlZFJvb3RzIiwiQnVmZmVyQ29uc3RydWN0b3IiLCJub2RlQ291bnQiLCJjb3VudE5vZGVzIiwicG9wdWxhdGVCdWZmZXIiLCJfcm9vdHMiLCJieXRlT2Zmc2V0Iiwic3RyaWRlNE9mZnNldCIsInN0cmlkZTJPZmZzZXQiLCJpc0xlYWYiLCJuZXh0VW51c2VkUG9pbnRlciIsIk1hdGgiLCJwb3ciLCJFcnJvciJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/build/buildTree.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/build/computeBoundsUtils.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/build/computeBoundsUtils.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   computeTriangleBounds: () => (/* binding */ computeTriangleBounds),\n/* harmony export */   getBounds: () => (/* binding */ getBounds),\n/* harmony export */   getCentroidBounds: () => (/* binding */ getCentroidBounds)\n/* harmony export */ });\n/* harmony import */ var _Constants_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../Constants.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/Constants.js\");\n/* harmony import */ var _utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/ArrayBoxUtilities.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js\");\n/* harmony import */ var _geometryUtils_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./geometryUtils.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/build/geometryUtils.js\");\n\n\n\n// computes the union of the bounds of all of the given triangles and puts the resulting box in target. If\n// centroidTarget is provided then a bounding box is computed for the centroids of the triangles, as well.\n// These are computed together to avoid redundant accesses to bounds array.\nfunction getBounds(triangleBounds, offset, count, target, centroidTarget = null) {\n    let minx = Infinity;\n    let miny = Infinity;\n    let minz = Infinity;\n    let maxx = -Infinity;\n    let maxy = -Infinity;\n    let maxz = -Infinity;\n    let cminx = Infinity;\n    let cminy = Infinity;\n    let cminz = Infinity;\n    let cmaxx = -Infinity;\n    let cmaxy = -Infinity;\n    let cmaxz = -Infinity;\n    const includeCentroid = centroidTarget !== null;\n    for(let i = offset * 6, end = (offset + count) * 6; i < end; i += 6){\n        const cx = triangleBounds[i + 0];\n        const hx = triangleBounds[i + 1];\n        const lx = cx - hx;\n        const rx = cx + hx;\n        if (lx < minx) minx = lx;\n        if (rx > maxx) maxx = rx;\n        if (includeCentroid && cx < cminx) cminx = cx;\n        if (includeCentroid && cx > cmaxx) cmaxx = cx;\n        const cy = triangleBounds[i + 2];\n        const hy = triangleBounds[i + 3];\n        const ly = cy - hy;\n        const ry = cy + hy;\n        if (ly < miny) miny = ly;\n        if (ry > maxy) maxy = ry;\n        if (includeCentroid && cy < cminy) cminy = cy;\n        if (includeCentroid && cy > cmaxy) cmaxy = cy;\n        const cz = triangleBounds[i + 4];\n        const hz = triangleBounds[i + 5];\n        const lz = cz - hz;\n        const rz = cz + hz;\n        if (lz < minz) minz = lz;\n        if (rz > maxz) maxz = rz;\n        if (includeCentroid && cz < cminz) cminz = cz;\n        if (includeCentroid && cz > cmaxz) cmaxz = cz;\n    }\n    target[0] = minx;\n    target[1] = miny;\n    target[2] = minz;\n    target[3] = maxx;\n    target[4] = maxy;\n    target[5] = maxz;\n    if (includeCentroid) {\n        centroidTarget[0] = cminx;\n        centroidTarget[1] = cminy;\n        centroidTarget[2] = cminz;\n        centroidTarget[3] = cmaxx;\n        centroidTarget[4] = cmaxy;\n        centroidTarget[5] = cmaxz;\n    }\n}\n// A stand alone function for retrieving the centroid bounds.\nfunction getCentroidBounds(triangleBounds, offset, count, centroidTarget) {\n    let cminx = Infinity;\n    let cminy = Infinity;\n    let cminz = Infinity;\n    let cmaxx = -Infinity;\n    let cmaxy = -Infinity;\n    let cmaxz = -Infinity;\n    for(let i = offset * 6, end = (offset + count) * 6; i < end; i += 6){\n        const cx = triangleBounds[i + 0];\n        if (cx < cminx) cminx = cx;\n        if (cx > cmaxx) cmaxx = cx;\n        const cy = triangleBounds[i + 2];\n        if (cy < cminy) cminy = cy;\n        if (cy > cmaxy) cmaxy = cy;\n        const cz = triangleBounds[i + 4];\n        if (cz < cminz) cminz = cz;\n        if (cz > cmaxz) cmaxz = cz;\n    }\n    centroidTarget[0] = cminx;\n    centroidTarget[1] = cminy;\n    centroidTarget[2] = cminz;\n    centroidTarget[3] = cmaxx;\n    centroidTarget[4] = cmaxy;\n    centroidTarget[5] = cmaxz;\n}\n// precomputes the bounding box for each triangle; required for quickly calculating tree splits.\n// result is an array of size tris.length * 6 where triangle i maps to a\n// [x_center, x_delta, y_center, y_delta, z_center, z_delta] tuple starting at index i * 6,\n// representing the center and half-extent in each dimension of triangle i\nfunction computeTriangleBounds(geo, fullBounds) {\n    // clear the bounds to empty\n    (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_0__.makeEmptyBounds)(fullBounds);\n    const posAttr = geo.attributes.position;\n    const index = geo.index ? geo.index.array : null;\n    const triCount = (0,_geometryUtils_js__WEBPACK_IMPORTED_MODULE_1__.getTriCount)(geo);\n    const triangleBounds = new Float32Array(triCount * 6);\n    const normalized = posAttr.normalized;\n    // used for non-normalized positions\n    const posArr = posAttr.array;\n    // support for an interleaved position buffer\n    const bufferOffset = posAttr.offset || 0;\n    let stride = 3;\n    if (posAttr.isInterleavedBufferAttribute) {\n        stride = posAttr.data.stride;\n    }\n    // used for normalized positions\n    const getters = [\n        \"getX\",\n        \"getY\",\n        \"getZ\"\n    ];\n    for(let tri = 0; tri < triCount; tri++){\n        const tri3 = tri * 3;\n        const tri6 = tri * 6;\n        let ai = tri3 + 0;\n        let bi = tri3 + 1;\n        let ci = tri3 + 2;\n        if (index) {\n            ai = index[ai];\n            bi = index[bi];\n            ci = index[ci];\n        }\n        // we add the stride and offset here since we access the array directly\n        // below for the sake of performance\n        if (!normalized) {\n            ai = ai * stride + bufferOffset;\n            bi = bi * stride + bufferOffset;\n            ci = ci * stride + bufferOffset;\n        }\n        for(let el = 0; el < 3; el++){\n            let a, b, c;\n            if (normalized) {\n                a = posAttr[getters[el]](ai);\n                b = posAttr[getters[el]](bi);\n                c = posAttr[getters[el]](ci);\n            } else {\n                a = posArr[ai + el];\n                b = posArr[bi + el];\n                c = posArr[ci + el];\n            }\n            let min = a;\n            if (b < min) min = b;\n            if (c < min) min = c;\n            let max = a;\n            if (b > max) max = b;\n            if (c > max) max = c;\n            // Increase the bounds size by float32 epsilon to avoid precision errors when\n            // converting to 32 bit float. Scale the epsilon by the size of the numbers being\n            // worked with.\n            const halfExtents = (max - min) / 2;\n            const el2 = el * 2;\n            triangleBounds[tri6 + el2 + 0] = min + halfExtents;\n            triangleBounds[tri6 + el2 + 1] = halfExtents + (Math.abs(min) + halfExtents) * _Constants_js__WEBPACK_IMPORTED_MODULE_2__.FLOAT32_EPSILON;\n            if (min < fullBounds[el]) fullBounds[el] = min;\n            if (max > fullBounds[el + 3]) fullBounds[el + 3] = max;\n        }\n    }\n    return triangleBounds;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9jb3JlL2J1aWxkL2NvbXB1dGVCb3VuZHNVdGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBa0Q7QUFDaUI7QUFDbEI7QUFFakQsMEdBQTBHO0FBQzFHLDBHQUEwRztBQUMxRywyRUFBMkU7QUFDcEUsU0FBU0csVUFBV0MsY0FBYyxFQUFFQyxNQUFNLEVBQUVDLEtBQUssRUFBRUMsTUFBTSxFQUFFQyxpQkFBaUIsSUFBSTtJQUV0RixJQUFJQyxPQUFPQztJQUNYLElBQUlDLE9BQU9EO0lBQ1gsSUFBSUUsT0FBT0Y7SUFDWCxJQUFJRyxPQUFPLENBQUVIO0lBQ2IsSUFBSUksT0FBTyxDQUFFSjtJQUNiLElBQUlLLE9BQU8sQ0FBRUw7SUFFYixJQUFJTSxRQUFRTjtJQUNaLElBQUlPLFFBQVFQO0lBQ1osSUFBSVEsUUFBUVI7SUFDWixJQUFJUyxRQUFRLENBQUVUO0lBQ2QsSUFBSVUsUUFBUSxDQUFFVjtJQUNkLElBQUlXLFFBQVEsQ0FBRVg7SUFFZCxNQUFNWSxrQkFBa0JkLG1CQUFtQjtJQUMzQyxJQUFNLElBQUllLElBQUlsQixTQUFTLEdBQUdtQixNQUFNLENBQUVuQixTQUFTQyxLQUFJLElBQU0sR0FBR2lCLElBQUlDLEtBQUtELEtBQUssRUFBSTtRQUV6RSxNQUFNRSxLQUFLckIsY0FBYyxDQUFFbUIsSUFBSSxFQUFHO1FBQ2xDLE1BQU1HLEtBQUt0QixjQUFjLENBQUVtQixJQUFJLEVBQUc7UUFDbEMsTUFBTUksS0FBS0YsS0FBS0M7UUFDaEIsTUFBTUUsS0FBS0gsS0FBS0M7UUFDaEIsSUFBS0MsS0FBS2xCLE1BQU9BLE9BQU9rQjtRQUN4QixJQUFLQyxLQUFLZixNQUFPQSxPQUFPZTtRQUN4QixJQUFLTixtQkFBbUJHLEtBQUtULE9BQVFBLFFBQVFTO1FBQzdDLElBQUtILG1CQUFtQkcsS0FBS04sT0FBUUEsUUFBUU07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dWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9ub2RlX21vZHVsZXMvdGhyZWUtbWVzaC1idmgvc3JjL2NvcmUvYnVpbGQvY29tcHV0ZUJvdW5kc1V0aWxzLmpzPzAyZTEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgRkxPQVQzMl9FUFNJTE9OIH0gZnJvbSAnLi4vQ29uc3RhbnRzLmpzJztcbmltcG9ydCB7IG1ha2VFbXB0eUJvdW5kcyB9IGZyb20gJy4uLy4uL3V0aWxzL0FycmF5Qm94VXRpbGl0aWVzLmpzJztcbmltcG9ydCB7IGdldFRyaUNvdW50IH0gZnJvbSAnLi9nZW9tZXRyeVV0aWxzLmpzJztcblxuLy8gY29tcHV0ZXMgdGhlIHVuaW9uIG9mIHRoZSBib3VuZHMgb2YgYWxsIG9mIHRoZSBnaXZlbiB0cmlhbmdsZXMgYW5kIHB1dHMgdGhlIHJlc3VsdGluZyBib3ggaW4gdGFyZ2V0LiBJZlxuLy8gY2VudHJvaWRUYXJnZXQgaXMgcHJvdmlkZWQgdGhlbiBhIGJvdW5kaW5nIGJveCBpcyBjb21wdXRlZCBmb3IgdGhlIGNlbnRyb2lkcyBvZiB0aGUgdHJpYW5nbGVzLCBhcyB3ZWxsLlxuLy8gVGhlc2UgYXJlIGNvbXB1dGVkIHRvZ2V0aGVyIHRvIGF2b2lkIHJlZHVuZGFudCBhY2Nlc3NlcyB0byBib3VuZHMgYXJyYXkuXG5leHBvcnQgZnVuY3Rpb24gZ2V0Qm91bmRzKCB0cmlhbmdsZUJvdW5kcywgb2Zmc2V0LCBjb3VudCwgdGFyZ2V0LCBjZW50cm9pZFRhcmdldCA9IG51bGwgKSB7XG5cblx0bGV0IG1pbnggPSBJbmZpbml0eTtcblx0bGV0IG1pbnkgPSBJbmZpbml0eTtcblx0bGV0IG1pbnogPSBJbmZpbml0eTtcblx0bGV0IG1heHggPSAtIEluZmluaXR5O1xuXHRsZXQgbWF4eSA9IC0gSW5maW5pdHk7XG5cdGxldCBtYXh6ID0gLSBJbmZpbml0eTtcblxuXHRsZXQgY21pbnggPSBJbmZpbml0eTtcblx0bGV0IGNtaW55ID0gSW5maW5pdHk7XG5cdGxldCBjbWlueiA9IEluZmluaXR5O1xuXHRsZXQgY21heHggPSAtIEluZmluaXR5O1xuXHRsZXQgY21heHkgPSAtIEluZmluaXR5O1xuXHRsZXQgY21heHogPSAtIEluZmluaXR5O1xuXG5cdGNvbnN0IGluY2x1ZGVDZW50cm9pZCA9IGNlbnRyb2lkVGFyZ2V0ICE9PSBudWxsO1xuXHRmb3IgKCBsZXQgaSA9IG9mZnNldCAqIDYsIGVuZCA9ICggb2Zmc2V0ICsgY291bnQgKSAqIDY7IGkgPCBlbmQ7IGkgKz0gNiApIHtcblxuXHRcdGNvbnN0IGN4ID0gdHJpYW5nbGVCb3VuZHNbIGkgKyAwIF07XG5cdFx0Y29uc3QgaHggPSB0cmlhbmdsZUJvdW5kc1sgaSArIDEgXTtcblx0XHRjb25zdCBseCA9IGN4IC0gaHg7XG5cdFx0Y29uc3QgcnggPSBjeCArIGh4O1xuXHRcdGlmICggbHggPCBtaW54ICkgbWlueCA9IGx4O1xuXHRcdGlmICggcnggPiBtYXh4ICkgbWF4eCA9IHJ4O1xuXHRcdGlmICggaW5jbHVkZUNlbnRyb2lkICYmIGN4IDwgY21pbnggKSBjbWlueCA9IGN4O1xuXHRcdGlmICggaW5jbHVkZUNlbnRyb2lkICYmIGN4ID4gY21heHggKSBjbWF4eCA9IGN4O1xuXG5cdFx0Y29uc3QgY3kgPSB0cmlhbmdsZUJvdW5kc1sgaSArIDIgXTtcblx0XHRjb25zdCBoeSA9IHRyaWFuZ2xlQm91bmRzWyBpICsgMyBdO1xuXHRcdGNvbnN0IGx5ID0gY3kgLSBoeTtcblx0XHRjb25zdCByeSA9IGN5ICsgaHk7XG5cdFx0aWYgKCBseSA8IG1pbnkgKSBtaW55ID0gbHk7XG5cdFx0aWYgKCByeSA+IG1heHkgKSBtYXh5ID0gcnk7XG5cdFx0aWYgKCBpbmNsdWRlQ2VudHJvaWQgJiYgY3kgPCBjbWlueSApIGNtaW55ID0gY3k7XG5cdFx0aWYgKCBpbmNsdWRlQ2VudHJvaWQgJiYgY3kgPiBjbWF4eSApIGNtYXh5ID0gY3k7XG5cblx0XHRjb25zdCBjeiA9IHRyaWFuZ2xlQm91bmRzWyBpICsgNCBdO1xuXHRcdGNvbnN0IGh6ID0gdHJpYW5nbGVCb3VuZHNbIGkgKyA1IF07XG5cdFx0Y29uc3QgbHogPSBjeiAtIGh6O1xuXHRcdGNvbnN0IHJ6ID0gY3ogKyBoejtcblx0XHRpZiAoIGx6IDwgbWlueiApIG1pbnogPSBsejtcblx0XHRpZiAoIHJ6ID4gbWF4eiApIG1heHogPSByejtcblx0XHRpZiAoIGluY2x1ZGVDZW50cm9pZCAmJiBjeiA8IGNtaW56ICkgY21pbnogPSBjejtcblx0XHRpZiAoIGluY2x1ZGVDZW50cm9pZCAmJiBjeiA+IGNtYXh6ICkgY21heHogPSBjejtcblxuXHR9XG5cblx0dGFyZ2V0WyAwIF0gPSBtaW54O1xuXHR0YXJnZXRbIDEgXSA9IG1pbnk7XG5cdHRhcmdldFsgMiBdID0gbWluejtcblxuXHR0YXJnZXRbIDMgXSA9IG1heHg7XG5cdHRhcmdldFsgNCBdID0gbWF4eTtcblx0dGFyZ2V0WyA1IF0gPSBtYXh6O1xuXG5cdGlmICggaW5jbHVkZUNlbnRyb2lkICkge1xuXG5cdFx0Y2VudHJvaWRUYXJnZXRbIDAgXSA9IGNtaW54O1xuXHRcdGNlbnRyb2lkVGFyZ2V0WyAxIF0gPSBjbWlueTtcblx0XHRjZW50cm9pZFRhcmdldFsgMiBdID0gY21pbno7XG5cblx0XHRjZW50cm9pZFRhcmdldFsgMyBdID0gY21heHg7XG5cdFx0Y2VudHJvaWRUYXJnZXRbIDQgXSA9IGNtYXh5O1xuXHRcdGNlbnRyb2lkVGFyZ2V0WyA1IF0gPSBjbWF4ejtcblxuXHR9XG5cbn1cblxuLy8gQSBzdGFuZCBhbG9uZSBmdW5jdGlvbiBmb3IgcmV0cmlldmluZyB0aGUgY2VudHJvaWQgYm91bmRzLlxuZXhwb3J0IGZ1bmN0aW9uIGdldENlbnRyb2lkQm91bmRzKCB0cmlhbmdsZUJvdW5kcywgb2Zmc2V0LCBjb3VudCwgY2VudHJvaWRUYXJnZXQgKSB7XG5cblx0bGV0IGNtaW54ID0gSW5maW5pdHk7XG5cdGxldCBjbWlueSA9IEluZmluaXR5O1xuXHRsZXQgY21pbnogPSBJbmZpbml0eTtcblx0bGV0IGNtYXh4ID0gLSBJbmZpbml0eTtcblx0bGV0IGNtYXh5ID0gLSBJbmZpbml0eTtcblx0bGV0IGNtYXh6ID0gLSBJbmZpbml0eTtcblxuXHRmb3IgKCBsZXQgaSA9IG9mZnNldCAqIDYsIGVuZCA9ICggb2Zmc2V0ICsgY291bnQgKSAqIDY7IGkgPCBlbmQ7IGkgKz0gNiApIHtcblxuXHRcdGNvbnN0IGN4ID0gdHJpYW5nbGVCb3VuZHNbIGkgKyAwIF07XG5cdFx0aWYgKCBjeCA8IGNtaW54ICkgY21pbnggPSBjeDtcblx0XHRpZiAoIGN4ID4gY21heHggKSBjbWF4eCA9IGN4O1xuXG5cdFx0Y29uc3QgY3kgPSB0cmlhbmdsZUJvdW5kc1sgaSArIDIgXTtcblx0XHRpZiAoIGN5IDwgY21pbnkgKSBjbWlueSA9IGN5O1xuXHRcdGlmICggY3kgPiBjbWF4eSApIGNtYXh5ID0gY3k7XG5cblx0XHRjb25zdCBjeiA9IHRyaWFuZ2xlQm91bmRzWyBpICsgNCBdO1xuXHRcdGlmICggY3ogPCBjbWlueiApIGNtaW56ID0gY3o7XG5cdFx0aWYgKCBjeiA+IGNtYXh6ICkgY21heHogPSBjejtcblxuXHR9XG5cblx0Y2VudHJvaWRUYXJnZXRbIDAgXSA9IGNtaW54O1xuXHRjZW50cm9pZFRhcmdldFsgMSBdID0gY21pbnk7XG5cdGNlbnRyb2lkVGFyZ2V0WyAyIF0gPSBjbWluejtcblxuXHRjZW50cm9pZFRhcmdldFsgMyBdID0gY21heHg7XG5cdGNlbnRyb2lkVGFyZ2V0WyA0IF0gPSBjbWF4eTtcblx0Y2VudHJvaWRUYXJnZXRbIDUgXSA9IGNtYXh6O1xuXG59XG5cblxuLy8gcHJlY29tcHV0ZXMgdGhlIGJvdW5kaW5nIGJveCBmb3IgZWFjaCB0cmlhbmdsZTsgcmVxdWlyZWQgZm9yIHF1aWNrbHkgY2FsY3VsYXRpbmcgdHJlZSBzcGxpdHMuXG4vLyByZXN1bHQgaXMgYW4gYXJyYXkgb2Ygc2l6ZSB0cmlzLmxlbmd0aCAqIDYgd2hlcmUgdHJpYW5nbGUgaSBtYXBzIHRvIGFcbi8vIFt4X2NlbnRlciwgeF9kZWx0YSwgeV9jZW50ZXIsIHlfZGVsdGEsIHpfY2VudGVyLCB6X2RlbHRhXSB0dXBsZSBzdGFydGluZyBhdCBpbmRleCBpICogNixcbi8vIHJlcHJlc2VudGluZyB0aGUgY2VudGVyIGFuZCBoYWxmLWV4dGVudCBpbiBlYWNoIGRpbWVuc2lvbiBvZiB0cmlhbmdsZSBpXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZVRyaWFuZ2xlQm91bmRzKCBnZW8sIGZ1bGxCb3VuZHMgKSB7XG5cblx0Ly8gY2xlYXIgdGhlIGJvdW5kcyB0byBlbXB0eVxuXHRtYWtlRW1wdHlCb3VuZHMoIGZ1bGxCb3VuZHMgKTtcblxuXHRjb25zdCBwb3NBdHRyID0gZ2VvLmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdGNvbnN0IGluZGV4ID0gZ2VvLmluZGV4ID8gZ2VvLmluZGV4LmFycmF5IDogbnVsbDtcblx0Y29uc3QgdHJpQ291bnQgPSBnZXRUcmlDb3VudCggZ2VvICk7XG5cdGNvbnN0IHRyaWFuZ2xlQm91bmRzID0gbmV3IEZsb2F0MzJBcnJheSggdHJpQ291bnQgKiA2ICk7XG5cdGNvbnN0IG5vcm1hbGl6ZWQgPSBwb3NBdHRyLm5vcm1hbGl6ZWQ7XG5cblx0Ly8gdXNlZCBmb3Igbm9uLW5vcm1hbGl6ZWQgcG9zaXRpb25zXG5cdGNvbnN0IHBvc0FyciA9IHBvc0F0dHIuYXJyYXk7XG5cblx0Ly8gc3VwcG9ydCBmb3IgYW4gaW50ZXJsZWF2ZWQgcG9zaXRpb24gYnVmZmVyXG5cdGNvbnN0IGJ1ZmZlck9mZnNldCA9IHBvc0F0dHIub2Zmc2V0IHx8IDA7XG5cdGxldCBzdHJpZGUgPSAzO1xuXHRpZiAoIHBvc0F0dHIuaXNJbnRlcmxlYXZlZEJ1ZmZlckF0dHJpYnV0ZSApIHtcblxuXHRcdHN0cmlkZSA9IHBvc0F0dHIuZGF0YS5zdHJpZGU7XG5cblx0fVxuXG5cdC8vIHVzZWQgZm9yIG5vcm1hbGl6ZWQgcG9zaXRpb25zXG5cdGNvbnN0IGdldHRlcnMgPSBbICdnZXRYJywgJ2dldFknLCAnZ2V0WicgXTtcblxuXHRmb3IgKCBsZXQgdHJpID0gMDsgdHJpIDwgdHJpQ291bnQ7IHRyaSArKyApIHtcblxuXHRcdGNvbnN0IHRyaTMgPSB0cmkgKiAzO1xuXHRcdGNvbnN0IHRyaTYgPSB0cmkgKiA2O1xuXG5cdFx0bGV0IGFpID0gdHJpMyArIDA7XG5cdFx0bGV0IGJpID0gdHJpMyArIDE7XG5cdFx0bGV0IGNpID0gdHJpMyArIDI7XG5cblx0XHRpZiAoIGluZGV4ICkge1xuXG5cdFx0XHRhaSA9IGluZGV4WyBhaSBdO1xuXHRcdFx0YmkgPSBpbmRleFsgYmkgXTtcblx0XHRcdGNpID0gaW5kZXhbIGNpIF07XG5cblx0XHR9XG5cblx0XHQvLyB3ZSBhZGQgdGhlIHN0cmlkZSBhbmQgb2Zmc2V0IGhlcmUgc2luY2Ugd2UgYWNjZXNzIHRoZSBhcnJheSBkaXJlY3RseVxuXHRcdC8vIGJlbG93IGZvciB0aGUgc2FrZSBvZiBwZXJmb3JtYW5jZVxuXHRcdGlmICggISBub3JtYWxpemVkICkge1xuXG5cdFx0XHRhaSA9IGFpICogc3RyaWRlICsgYnVmZmVyT2Zmc2V0O1xuXHRcdFx0YmkgPSBiaSAqIHN0cmlkZSArIGJ1ZmZlck9mZnNldDtcblx0XHRcdGNpID0gY2kgKiBzdHJpZGUgKyBidWZmZXJPZmZzZXQ7XG5cblx0XHR9XG5cblx0XHRmb3IgKCBsZXQgZWwgPSAwOyBlbCA8IDM7IGVsICsrICkge1xuXG5cdFx0XHRsZXQgYSwgYiwgYztcblxuXHRcdFx0aWYgKCBub3JtYWxpemVkICkge1xuXG5cdFx0XHRcdGEgPSBwb3NBdHRyWyBnZXR0ZXJzWyBlbCBdIF0oIGFpICk7XG5cdFx0XHRcdGIgPSBwb3NBdHRyWyBnZXR0ZXJzWyBlbCBdIF0oIGJpICk7XG5cdFx0XHRcdGMgPSBwb3NBdHRyWyBnZXR0ZXJzWyBlbCBdIF0oIGNpICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0YSA9IHBvc0FyclsgYWkgKyBlbCBdO1xuXHRcdFx0XHRiID0gcG9zQXJyWyBiaSArIGVsIF07XG5cdFx0XHRcdGMgPSBwb3NBcnJbIGNpICsgZWwgXTtcblxuXHRcdFx0fVxuXG5cdFx0XHRsZXQgbWluID0gYTtcblx0XHRcdGlmICggYiA8IG1pbiApIG1pbiA9IGI7XG5cdFx0XHRpZiAoIGMgPCBtaW4gKSBtaW4gPSBjO1xuXG5cdFx0XHRsZXQgbWF4ID0gYTtcblx0XHRcdGlmICggYiA+IG1heCApIG1heCA9IGI7XG5cdFx0XHRpZiAoIGMgPiBtYXggKSBtYXggPSBjO1xuXG5cdFx0XHQvLyBJbmNyZWFzZSB0aGUgYm91bmRzIHNpemUgYnkgZmxvYXQzMiBlcHNpbG9uIHRvIGF2b2lkIHByZWNpc2lvbiBlcnJvcnMgd2hlblxuXHRcdFx0Ly8gY29udmVydGluZyB0byAzMiBiaXQgZmxvYXQuIFNjYWxlIHRoZSBlcHNpbG9uIGJ5IHRoZSBzaXplIG9mIHRoZSBudW1iZXJzIGJlaW5nXG5cdFx0XHQvLyB3b3JrZWQgd2l0aC5cblx0XHRcdGNvbnN0IGhhbGZFeHRlbnRzID0gKCBtYXggLSBtaW4gKSAvIDI7XG5cdFx0XHRjb25zdCBlbDIgPSBlbCAqIDI7XG5cdFx0XHR0cmlhbmdsZUJvdW5kc1sgdHJpNiArIGVsMiArIDAgXSA9IG1pbiArIGhhbGZFeHRlbnRzO1xuXHRcdFx0dHJpYW5nbGVCb3VuZHNbIHRyaTYgKyBlbDIgKyAxIF0gPSBoYWxmRXh0ZW50cyArICggTWF0aC5hYnMoIG1pbiApICsgaGFsZkV4dGVudHMgKSAqIEZMT0FUMzJfRVBTSUxPTjtcblxuXHRcdFx0aWYgKCBtaW4gPCBmdWxsQm91bmRzWyBlbCBdICkgZnVsbEJvdW5kc1sgZWwgXSA9IG1pbjtcblx0XHRcdGlmICggbWF4ID4gZnVsbEJvdW5kc1sgZWwgKyAzIF0gKSBmdWxsQm91bmRzWyBlbCArIDMgXSA9IG1heDtcblxuXHRcdH1cblxuXHR9XG5cblx0cmV0dXJuIHRyaWFuZ2xlQm91bmRzO1xuXG59XG4iXSwibmFtZXMiOlsiRkxPQVQzMl9FUFNJTE9OIiwibWFrZUVtcHR5Qm91bmRzIiwiZ2V0VHJpQ291bnQiLCJnZXRCb3VuZHMiLCJ0cmlhbmdsZUJvdW5kcyIsIm9mZnNldCIsImNvdW50IiwidGFyZ2V0IiwiY2VudHJvaWRUYXJnZXQiLCJtaW54IiwiSW5maW5pdHkiLCJtaW55IiwibWlueiIsIm1heHgiLCJtYXh5IiwibWF4eiIsImNtaW54IiwiY21pbnkiLCJjbWlueiIsImNtYXh4IiwiY21heHkiLCJjbWF4eiIsImluY2x1ZGVDZW50cm9pZCIsImkiLCJlbmQiLCJjeCIsImh4IiwibHgiLCJyeCIsImN5IiwiaHkiLCJseSIsInJ5IiwiY3oiLCJoeiIsImx6IiwicnoiLCJnZXRDZW50cm9pZEJvdW5kcyIsImNvbXB1dGVUcmlhbmdsZUJvdW5kcyIsImdlbyIsImZ1bGxCb3VuZHMiLCJwb3NBdHRyIiwiYXR0cmlidXRlcyIsInBvc2l0aW9uIiwiaW5kZXgiLCJhcnJheSIsInRyaUNvdW50IiwiRmxvYXQzMkFycmF5Iiwibm9ybWFsaXplZCIsInBvc0FyciIsImJ1ZmZlck9mZnNldCIsInN0cmlkZSIsImlzSW50ZXJsZWF2ZWRCdWZmZXJBdHRyaWJ1dGUiLCJkYXRhIiwiZ2V0dGVycyIsInRyaSIsInRyaTMiLCJ0cmk2IiwiYWkiLCJiaSIsImNpIiwiZWwiLCJhIiwiYiIsImMiLCJtaW4iLCJtYXgiLCJoYWxmRXh0ZW50cyIsImVsMiIsIk1hdGgiLCJhYnMiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/build/computeBoundsUtils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/build/geometryUtils.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/build/geometryUtils.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ensureIndex: () => (/* binding */ ensureIndex),\n/* harmony export */   getFullGeometryRange: () => (/* binding */ getFullGeometryRange),\n/* harmony export */   getIndexArray: () => (/* binding */ getIndexArray),\n/* harmony export */   getRootIndexRanges: () => (/* binding */ getRootIndexRanges),\n/* harmony export */   getTriCount: () => (/* binding */ getTriCount),\n/* harmony export */   getVertexCount: () => (/* binding */ getVertexCount),\n/* harmony export */   hasGroupGaps: () => (/* binding */ hasGroupGaps)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n\nfunction getVertexCount(geo) {\n    return geo.index ? geo.index.count : geo.attributes.position.count;\n}\nfunction getTriCount(geo) {\n    return getVertexCount(geo) / 3;\n}\nfunction getIndexArray(vertexCount, BufferConstructor = ArrayBuffer) {\n    if (vertexCount > 65535) {\n        return new Uint32Array(new BufferConstructor(4 * vertexCount));\n    } else {\n        return new Uint16Array(new BufferConstructor(2 * vertexCount));\n    }\n}\n// ensures that an index is present on the geometry\nfunction ensureIndex(geo, options) {\n    if (!geo.index) {\n        const vertexCount = geo.attributes.position.count;\n        const BufferConstructor = options.useSharedArrayBuffer ? SharedArrayBuffer : ArrayBuffer;\n        const index = getIndexArray(vertexCount, BufferConstructor);\n        geo.setIndex(new three__WEBPACK_IMPORTED_MODULE_0__.BufferAttribute(index, 1));\n        for(let i = 0; i < vertexCount; i++){\n            index[i] = i;\n        }\n    }\n}\n// Computes the set of { offset, count } ranges which need independent BVH roots. Each\n// region in the geometry index that belongs to a different set of material groups requires\n// a separate BVH root, so that triangles indices belonging to one group never get swapped\n// with triangle indices belongs to another group. For example, if the groups were like this:\n//\n// [-------------------------------------------------------------]\n// |__________________|\n//   g0 = [0, 20]  |______________________||_____________________|\n//                      g1 = [16, 40]           g2 = [41, 60]\n//\n// we would need four BVH roots: [0, 15], [16, 20], [21, 40], [41, 60].\nfunction getFullGeometryRange(geo) {\n    const triCount = getTriCount(geo);\n    const drawRange = geo.drawRange;\n    const start = drawRange.start / 3;\n    const end = (drawRange.start + drawRange.count) / 3;\n    const offset = Math.max(0, start);\n    const count = Math.min(triCount, end) - offset;\n    return [\n        {\n            offset: Math.floor(offset),\n            count: Math.floor(count)\n        }\n    ];\n}\nfunction getRootIndexRanges(geo) {\n    if (!geo.groups || !geo.groups.length) {\n        return getFullGeometryRange(geo);\n    }\n    const ranges = [];\n    const rangeBoundaries = new Set();\n    const drawRange = geo.drawRange;\n    const drawRangeStart = drawRange.start / 3;\n    const drawRangeEnd = (drawRange.start + drawRange.count) / 3;\n    for (const group of geo.groups){\n        const groupStart = group.start / 3;\n        const groupEnd = (group.start + group.count) / 3;\n        rangeBoundaries.add(Math.max(drawRangeStart, groupStart));\n        rangeBoundaries.add(Math.min(drawRangeEnd, groupEnd));\n    }\n    // note that if you don't pass in a comparator, it sorts them lexicographically as strings :-(\n    const sortedBoundaries = Array.from(rangeBoundaries.values()).sort((a, b)=>a - b);\n    for(let i = 0; i < sortedBoundaries.length - 1; i++){\n        const start = sortedBoundaries[i];\n        const end = sortedBoundaries[i + 1];\n        ranges.push({\n            offset: Math.floor(start),\n            count: Math.floor(end - start)\n        });\n    }\n    return ranges;\n}\nfunction hasGroupGaps(geometry) {\n    if (geometry.groups.length === 0) {\n        return false;\n    }\n    const vertexCount = getTriCount(geometry);\n    const groups = getRootIndexRanges(geometry).sort((a, b)=>a.offset - b.offset);\n    const finalGroup = groups[groups.length - 1];\n    finalGroup.count = Math.min(vertexCount - finalGroup.offset, finalGroup.count);\n    let total = 0;\n    groups.forEach(({ count })=>total += count);\n    return vertexCount !== total;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9jb3JlL2J1aWxkL2dlb21ldHJ5VXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7Ozs7QUFBd0M7QUFFakMsU0FBU0MsZUFBZ0JDLEdBQUc7SUFFbEMsT0FBT0EsSUFBSUMsS0FBSyxHQUFHRCxJQUFJQyxLQUFLLENBQUNDLEtBQUssR0FBR0YsSUFBSUcsVUFBVSxDQUFDQyxRQUFRLENBQUNGLEtBQUs7QUFFbkU7QUFFTyxTQUFTRyxZQUFhTCxHQUFHO0lBRS9CLE9BQU9ELGVBQWdCQyxPQUFRO0FBRWhDO0FBRU8sU0FBU00sY0FBZUMsV0FBVyxFQUFFQyxvQkFBb0JDLFdBQVc7SUFFMUUsSUFBS0YsY0FBYyxPQUFRO1FBRTFCLE9BQU8sSUFBSUcsWUFBYSxJQUFJRixrQkFBbUIsSUFBSUQ7SUFFcEQsT0FBTztRQUVOLE9BQU8sSUFBSUksWUFBYSxJQUFJSCxrQkFBbUIsSUFBSUQ7SUFFcEQ7QUFFRDtBQUVBLG1EQUFtRDtBQUM1QyxTQUFTSyxZQUFhWixHQUFHLEVBQUVhLE9BQU87SUFFeEMsSUFBSyxDQUFFYixJQUFJQyxLQUFLLEVBQUc7UUFFbEIsTUFBTU0sY0FBY1AsSUFBSUcsVUFBVSxDQUFDQyxRQUFRLENBQUNGLEtBQUs7UUFDakQsTUFBTU0sb0JBQW9CSyxRQUFRQyxvQkFBb0IsR0FBR0Msb0JBQW9CTjtRQUM3RSxNQUFNUixRQUFRSyxjQUFlQyxhQUFhQztRQUMxQ1IsSUFBSWdCLFFBQVEsQ0FBRSxJQUFJbEIsa0RBQWVBLENBQUVHLE9BQU87UUFFMUMsSUFBTSxJQUFJZ0IsSUFBSSxHQUFHQSxJQUFJVixhQUFhVSxJQUFPO1lBRXhDaEIsS0FBSyxDQUFFZ0IsRUFBRyxHQUFHQTtRQUVkO0lBRUQ7QUFFRDtBQUVBLHNGQUFzRjtBQUN0RiwyRkFBMkY7QUFDM0YsMEZBQTBGO0FBQzFGLDZGQUE2RjtBQUM3RixFQUFFO0FBQ0Ysa0VBQWtFO0FBQ2xFLHVCQUF1QjtBQUN2QixrRUFBa0U7QUFDbEUsNkRBQTZEO0FBQzdELEVBQUU7QUFDRix1RUFBdUU7QUFDaEUsU0FBU0MscUJBQXNCbEIsR0FBRztJQUV4QyxNQUFNbUIsV0FBV2QsWUFBYUw7SUFDOUIsTUFBTW9CLFlBQVlwQixJQUFJb0IsU0FBUztJQUMvQixNQUFNQyxRQUFRRCxVQUFVQyxLQUFLLEdBQUc7SUFDaEMsTUFBTUMsTUFBTSxDQUFFRixVQUFVQyxLQUFLLEdBQUdELFVBQVVsQixLQUFLLElBQUs7SUFFcEQsTUFBTXFCLFNBQVNDLEtBQUtDLEdBQUcsQ0FBRSxHQUFHSjtJQUM1QixNQUFNbkIsUUFBUXNCLEtBQUtFLEdBQUcsQ0FBRVAsVUFBVUcsT0FBUUM7SUFDMUMsT0FBTztRQUFFO1lBQ1JBLFFBQVFDLEtBQUtHLEtBQUssQ0FBRUo7WUFDcEJyQixPQUFPc0IsS0FBS0csS0FBSyxDQUFFekI7UUFDcEI7S0FBRztBQUVKO0FBRU8sU0FBUzBCLG1CQUFvQjVCLEdBQUc7SUFFdEMsSUFBSyxDQUFFQSxJQUFJNkIsTUFBTSxJQUFJLENBQUU3QixJQUFJNkIsTUFBTSxDQUFDQyxNQUFNLEVBQUc7UUFFMUMsT0FBT1oscUJBQXNCbEI7SUFFOUI7SUFFQSxNQUFNK0IsU0FBUyxFQUFFO0lBQ2pCLE1BQU1DLGtCQUFrQixJQUFJQztJQUU1QixNQUFNYixZQUFZcEIsSUFBSW9CLFNBQVM7SUFDL0IsTUFBTWMsaUJBQWlCZCxVQUFVQyxLQUFLLEdBQUc7SUFDekMsTUFBTWMsZUFBZSxDQUFFZixVQUFVQyxLQUFLLEdBQUdELFVBQVVsQixLQUFLLElBQUs7SUFDN0QsS0FBTSxNQUFNa0MsU0FBU3BDLElBQUk2QixNQUFNLENBQUc7UUFFakMsTUFBTVEsYUFBYUQsTUFBTWYsS0FBSyxHQUFHO1FBQ2pDLE1BQU1pQixXQUFXLENBQUVGLE1BQU1mLEtBQUssR0FBR2UsTUFBTWxDLEtBQUssSUFBSztRQUNqRDhCLGdCQUFnQk8sR0FBRyxDQUFFZixLQUFLQyxHQUFHLENBQUVTLGdCQUFnQkc7UUFDL0NMLGdCQUFnQk8sR0FBRyxDQUFFZixLQUFLRSxHQUFHLENBQUVTLGNBQWNHO0lBRTlDO0lBR0EsOEZBQThGO0lBQzlGLE1BQU1FLG1CQUFtQkMsTUFBTUMsSUFBSSxDQUFFVixnQkFBZ0JXLE1BQU0sSUFBS0MsSUFBSSxDQUFFLENBQUVDLEdBQUdDLElBQU9ELElBQUlDO0lBQ3RGLElBQU0sSUFBSTdCLElBQUksR0FBR0EsSUFBSXVCLGlCQUFpQlYsTUFBTSxHQUFHLEdBQUdiLElBQU87UUFFeEQsTUFBTUksUUFBUW1CLGdCQUFnQixDQUFFdkIsRUFBRztRQUNuQyxNQUFNSyxNQUFNa0IsZ0JBQWdCLENBQUV2QixJQUFJLEVBQUc7UUFFckNjLE9BQU9nQixJQUFJLENBQUU7WUFDWnhCLFFBQVFDLEtBQUtHLEtBQUssQ0FBRU47WUFDcEJuQixPQUFPc0IsS0FBS0csS0FBSyxDQUFFTCxNQUFNRDtRQUMxQjtJQUVEO0lBRUEsT0FBT1U7QUFFUjtBQUVPLFNBQVNpQixhQUFjQyxRQUFRO0lBRXJDLElBQUtBLFNBQVNwQixNQUFNLENBQUNDLE1BQU0sS0FBSyxHQUFJO1FBRW5DLE9BQU87SUFFUjtJQUVBLE1BQU12QixjQUFjRixZQUFhNEM7SUFDakMsTUFBTXBCLFNBQVNELG1CQUFvQnFCLFVBQ2pDTCxJQUFJLENBQUUsQ0FBRUMsR0FBR0MsSUFBT0QsRUFBRXRCLE1BQU0sR0FBR3VCLEVBQUV2QixNQUFNO0lBRXZDLE1BQU0yQixhQUFhckIsTUFBTSxDQUFFQSxPQUFPQyxNQUFNLEdBQUcsRUFBRztJQUM5Q29CLFdBQVdoRCxLQUFLLEdBQUdzQixLQUFLRSxHQUFHLENBQUVuQixjQUFjMkMsV0FBVzNCLE1BQU0sRUFBRTJCLFdBQVdoRCxLQUFLO0lBRTlFLElBQUlpRCxRQUFRO0lBQ1p0QixPQUFPdUIsT0FBTyxDQUFFLENBQUUsRUFBRWxELEtBQUssRUFBRSxHQUFNaUQsU0FBU2pEO0lBQzFDLE9BQU9LLGdCQUFnQjRDO0FBRXhCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmliZS0zZC1jb2RlLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvY29yZS9idWlsZC9nZW9tZXRyeVV0aWxzLmpzP2Q1ZWQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQnVmZmVyQXR0cmlidXRlIH0gZnJvbSAndGhyZWUnO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VmVydGV4Q291bnQoIGdlbyApIHtcblxuXHRyZXR1cm4gZ2VvLmluZGV4ID8gZ2VvLmluZGV4LmNvdW50IDogZ2VvLmF0dHJpYnV0ZXMucG9zaXRpb24uY291bnQ7XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFRyaUNvdW50KCBnZW8gKSB7XG5cblx0cmV0dXJuIGdldFZlcnRleENvdW50KCBnZW8gKSAvIDM7XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldEluZGV4QXJyYXkoIHZlcnRleENvdW50LCBCdWZmZXJDb25zdHJ1Y3RvciA9IEFycmF5QnVmZmVyICkge1xuXG5cdGlmICggdmVydGV4Q291bnQgPiA2NTUzNSApIHtcblxuXHRcdHJldHVybiBuZXcgVWludDMyQXJyYXkoIG5ldyBCdWZmZXJDb25zdHJ1Y3RvciggNCAqIHZlcnRleENvdW50ICkgKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0cmV0dXJuIG5ldyBVaW50MTZBcnJheSggbmV3IEJ1ZmZlckNvbnN0cnVjdG9yKCAyICogdmVydGV4Q291bnQgKSApO1xuXG5cdH1cblxufVxuXG4vLyBlbnN1cmVzIHRoYXQgYW4gaW5kZXggaXMgcHJlc2VudCBvbiB0aGUgZ2VvbWV0cnlcbmV4cG9ydCBmdW5jdGlvbiBlbnN1cmVJbmRleCggZ2VvLCBvcHRpb25zICkge1xuXG5cdGlmICggISBnZW8uaW5kZXggKSB7XG5cblx0XHRjb25zdCB2ZXJ0ZXhDb3VudCA9IGdlby5hdHRyaWJ1dGVzLnBvc2l0aW9uLmNvdW50O1xuXHRcdGNvbnN0IEJ1ZmZlckNvbnN0cnVjdG9yID0gb3B0aW9ucy51c2VTaGFyZWRBcnJheUJ1ZmZlciA/IFNoYXJlZEFycmF5QnVmZmVyIDogQXJyYXlCdWZmZXI7XG5cdFx0Y29uc3QgaW5kZXggPSBnZXRJbmRleEFycmF5KCB2ZXJ0ZXhDb3VudCwgQnVmZmVyQ29uc3RydWN0b3IgKTtcblx0XHRnZW8uc2V0SW5kZXgoIG5ldyBCdWZmZXJBdHRyaWJ1dGUoIGluZGV4LCAxICkgKTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IHZlcnRleENvdW50OyBpICsrICkge1xuXG5cdFx0XHRpbmRleFsgaSBdID0gaTtcblxuXHRcdH1cblxuXHR9XG5cbn1cblxuLy8gQ29tcHV0ZXMgdGhlIHNldCBvZiB7IG9mZnNldCwgY291bnQgfSByYW5nZXMgd2hpY2ggbmVlZCBpbmRlcGVuZGVudCBCVkggcm9vdHMuIEVhY2hcbi8vIHJlZ2lvbiBpbiB0aGUgZ2VvbWV0cnkgaW5kZXggdGhhdCBiZWxvbmdzIHRvIGEgZGlmZmVyZW50IHNldCBvZiBtYXRlcmlhbCBncm91cHMgcmVxdWlyZXNcbi8vIGEgc2VwYXJhdGUgQlZIIHJvb3QsIHNvIHRoYXQgdHJpYW5nbGVzIGluZGljZXMgYmVsb25naW5nIHRvIG9uZSBncm91cCBuZXZlciBnZXQgc3dhcHBlZFxuLy8gd2l0aCB0cmlhbmdsZSBpbmRpY2VzIGJlbG9uZ3MgdG8gYW5vdGhlciBncm91cC4gRm9yIGV4YW1wbGUsIGlmIHRoZSBncm91cHMgd2VyZSBsaWtlIHRoaXM6XG4vL1xuLy8gWy0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS0tLS1dXG4vLyB8X19fX19fX19fX19fX19fX19ffFxuLy8gICBnMCA9IFswLCAyMF0gIHxfX19fX19fX19fX19fX19fX19fX19ffHxfX19fX19fX19fX19fX19fX19fX198XG4vLyAgICAgICAgICAgICAgICAgICAgICBnMSA9IFsxNiwgNDBdICAgICAgICAgICBnMiA9IFs0MSwgNjBdXG4vL1xuLy8gd2Ugd291bGQgbmVlZCBmb3VyIEJWSCByb290czogWzAsIDE1XSwgWzE2LCAyMF0sIFsyMSwgNDBdLCBbNDEsIDYwXS5cbmV4cG9ydCBmdW5jdGlvbiBnZXRGdWxsR2VvbWV0cnlSYW5nZSggZ2VvICkge1xuXG5cdGNvbnN0IHRyaUNvdW50ID0gZ2V0VHJpQ291bnQoIGdlbyApO1xuXHRjb25zdCBkcmF3UmFuZ2UgPSBnZW8uZHJhd1JhbmdlO1xuXHRjb25zdCBzdGFydCA9IGRyYXdSYW5nZS5zdGFydCAvIDM7XG5cdGNvbnN0IGVuZCA9ICggZHJhd1JhbmdlLnN0YXJ0ICsgZHJhd1JhbmdlLmNvdW50ICkgLyAzO1xuXG5cdGNvbnN0IG9mZnNldCA9IE1hdGgubWF4KCAwLCBzdGFydCApO1xuXHRjb25zdCBjb3VudCA9IE1hdGgubWluKCB0cmlDb3VudCwgZW5kICkgLSBvZmZzZXQ7XG5cdHJldHVybiBbIHtcblx0XHRvZmZzZXQ6IE1hdGguZmxvb3IoIG9mZnNldCApLFxuXHRcdGNvdW50OiBNYXRoLmZsb29yKCBjb3VudCApLFxuXHR9IF07XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGdldFJvb3RJbmRleFJhbmdlcyggZ2VvICkge1xuXG5cdGlmICggISBnZW8uZ3JvdXBzIHx8ICEgZ2VvLmdyb3Vwcy5sZW5ndGggKSB7XG5cblx0XHRyZXR1cm4gZ2V0RnVsbEdlb21ldHJ5UmFuZ2UoIGdlbyApO1xuXG5cdH1cblxuXHRjb25zdCByYW5nZXMgPSBbXTtcblx0Y29uc3QgcmFuZ2VCb3VuZGFyaWVzID0gbmV3IFNldCgpO1xuXG5cdGNvbnN0IGRyYXdSYW5nZSA9IGdlby5kcmF3UmFuZ2U7XG5cdGNvbnN0IGRyYXdSYW5nZVN0YXJ0ID0gZHJhd1JhbmdlLnN0YXJ0IC8gMztcblx0Y29uc3QgZHJhd1JhbmdlRW5kID0gKCBkcmF3UmFuZ2Uuc3RhcnQgKyBkcmF3UmFuZ2UuY291bnQgKSAvIDM7XG5cdGZvciAoIGNvbnN0IGdyb3VwIG9mIGdlby5ncm91cHMgKSB7XG5cblx0XHRjb25zdCBncm91cFN0YXJ0ID0gZ3JvdXAuc3RhcnQgLyAzO1xuXHRcdGNvbnN0IGdyb3VwRW5kID0gKCBncm91cC5zdGFydCArIGdyb3VwLmNvdW50ICkgLyAzO1xuXHRcdHJhbmdlQm91bmRhcmllcy5hZGQoIE1hdGgubWF4KCBkcmF3UmFuZ2VTdGFydCwgZ3JvdXBTdGFydCApICk7XG5cdFx0cmFuZ2VCb3VuZGFyaWVzLmFkZCggTWF0aC5taW4oIGRyYXdSYW5nZUVuZCwgZ3JvdXBFbmQgKSApO1xuXG5cdH1cblxuXG5cdC8vIG5vdGUgdGhhdCBpZiB5b3UgZG9uJ3QgcGFzcyBpbiBhIGNvbXBhcmF0b3IsIGl0IHNvcnRzIHRoZW0gbGV4aWNvZ3JhcGhpY2FsbHkgYXMgc3RyaW5ncyA6LShcblx0Y29uc3Qgc29ydGVkQm91bmRhcmllcyA9IEFycmF5LmZyb20oIHJhbmdlQm91bmRhcmllcy52YWx1ZXMoKSApLnNvcnQoICggYSwgYiApID0+IGEgLSBiICk7XG5cdGZvciAoIGxldCBpID0gMDsgaSA8IHNvcnRlZEJvdW5kYXJpZXMubGVuZ3RoIC0gMTsgaSArKyApIHtcblxuXHRcdGNvbnN0IHN0YXJ0ID0gc29ydGVkQm91bmRhcmllc1sgaSBdO1xuXHRcdGNvbnN0IGVuZCA9IHNvcnRlZEJvdW5kYXJpZXNbIGkgKyAxIF07XG5cblx0XHRyYW5nZXMucHVzaCgge1xuXHRcdFx0b2Zmc2V0OiBNYXRoLmZsb29yKCBzdGFydCApLFxuXHRcdFx0Y291bnQ6IE1hdGguZmxvb3IoIGVuZCAtIHN0YXJ0ICksXG5cdFx0fSApO1xuXG5cdH1cblxuXHRyZXR1cm4gcmFuZ2VzO1xuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBoYXNHcm91cEdhcHMoIGdlb21ldHJ5ICkge1xuXG5cdGlmICggZ2VvbWV0cnkuZ3JvdXBzLmxlbmd0aCA9PT0gMCApIHtcblxuXHRcdHJldHVybiBmYWxzZTtcblxuXHR9XG5cblx0Y29uc3QgdmVydGV4Q291bnQgPSBnZXRUcmlDb3VudCggZ2VvbWV0cnkgKTtcblx0Y29uc3QgZ3JvdXBzID0gZ2V0Um9vdEluZGV4UmFuZ2VzKCBnZW9tZXRyeSApXG5cdFx0LnNvcnQoICggYSwgYiApID0+IGEub2Zmc2V0IC0gYi5vZmZzZXQgKTtcblxuXHRjb25zdCBmaW5hbEdyb3VwID0gZ3JvdXBzWyBncm91cHMubGVuZ3RoIC0gMSBdO1xuXHRmaW5hbEdyb3VwLmNvdW50ID0gTWF0aC5taW4oIHZlcnRleENvdW50IC0gZmluYWxHcm91cC5vZmZzZXQsIGZpbmFsR3JvdXAuY291bnQgKTtcblxuXHRsZXQgdG90YWwgPSAwO1xuXHRncm91cHMuZm9yRWFjaCggKCB7IGNvdW50IH0gKSA9PiB0b3RhbCArPSBjb3VudCApO1xuXHRyZXR1cm4gdmVydGV4Q291bnQgIT09IHRvdGFsO1xuXG59XG4iXSwibmFtZXMiOlsiQnVmZmVyQXR0cmlidXRlIiwiZ2V0VmVydGV4Q291bnQiLCJnZW8iLCJpbmRleCIsImNvdW50IiwiYXR0cmlidXRlcyIsInBvc2l0aW9uIiwiZ2V0VHJpQ291bnQiLCJnZXRJbmRleEFycmF5IiwidmVydGV4Q291bnQiLCJCdWZmZXJDb25zdHJ1Y3RvciIsIkFycmF5QnVmZmVyIiwiVWludDMyQXJyYXkiLCJVaW50MTZBcnJheSIsImVuc3VyZUluZGV4Iiwib3B0aW9ucyIsInVzZVNoYXJlZEFycmF5QnVmZmVyIiwiU2hhcmVkQXJyYXlCdWZmZXIiLCJzZXRJbmRleCIsImkiLCJnZXRGdWxsR2VvbWV0cnlSYW5nZSIsInRyaUNvdW50IiwiZHJhd1JhbmdlIiwic3RhcnQiLCJlbmQiLCJvZmZzZXQiLCJNYXRoIiwibWF4IiwibWluIiwiZmxvb3IiLCJnZXRSb290SW5kZXhSYW5nZXMiLCJncm91cHMiLCJsZW5ndGgiLCJyYW5nZXMiLCJyYW5nZUJvdW5kYXJpZXMiLCJTZXQiLCJkcmF3UmFuZ2VTdGFydCIsImRyYXdSYW5nZUVuZCIsImdyb3VwIiwiZ3JvdXBTdGFydCIsImdyb3VwRW5kIiwiYWRkIiwic29ydGVkQm91bmRhcmllcyIsIkFycmF5IiwiZnJvbSIsInZhbHVlcyIsInNvcnQiLCJhIiwiYiIsInB1c2giLCJoYXNHcm91cEdhcHMiLCJnZW9tZXRyeSIsImZpbmFsR3JvdXAiLCJ0b3RhbCIsImZvckVhY2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/build/geometryUtils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/build/sortUtils.generated.js":
/*!**********************************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/build/sortUtils.generated.js ***!
  \**********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   partition: () => (/* binding */ partition)\n/* harmony export */ });\n/********************************************************/ /* This file is generated from \"sortUtils.template.js\". */ /********************************************************/ // reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nfunction partition(indirectBuffer, index, triangleBounds, offset, count, split) {\n    let left = offset;\n    let right = offset + count - 1;\n    const pos = split.pos;\n    const axisOffset = split.axis * 2;\n    // hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n    while(true){\n        while(left <= right && triangleBounds[left * 6 + axisOffset] < pos){\n            left++;\n        }\n        // if a triangle center lies on the partition plane it is considered to be on the right side\n        while(left <= right && triangleBounds[right * 6 + axisOffset] >= pos){\n            right--;\n        }\n        if (left < right) {\n            // we need to swap all of the information associated with the triangles at index\n            // left and right; that's the verts in the geometry index, the bounds,\n            // and perhaps the SAH planes\n            for(let i = 0; i < 3; i++){\n                let t0 = index[left * 3 + i];\n                index[left * 3 + i] = index[right * 3 + i];\n                index[right * 3 + i] = t0;\n            }\n            // swap bounds\n            for(let i = 0; i < 6; i++){\n                let tb = triangleBounds[left * 6 + i];\n                triangleBounds[left * 6 + i] = triangleBounds[right * 6 + i];\n                triangleBounds[right * 6 + i] = tb;\n            }\n            left++;\n            right--;\n        } else {\n            return left;\n        }\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9jb3JlL2J1aWxkL3NvcnRVdGlscy5nZW5lcmF0ZWQuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLHdEQUF3RCxHQUN4RCx3REFBd0QsR0FDeEQsd0RBQXdELEdBQ3hELHdHQUF3RztBQUN4RywwR0FBMEc7QUFDMUcsd0dBQXdHO0FBQ3hHLFNBQVNBLFVBQVdDLGNBQWMsRUFBRUMsS0FBSyxFQUFFQyxjQUFjLEVBQUVDLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxLQUFLO0lBRTlFLElBQUlDLE9BQU9IO0lBQ1gsSUFBSUksUUFBUUosU0FBU0MsUUFBUTtJQUM3QixNQUFNSSxNQUFNSCxNQUFNRyxHQUFHO0lBQ3JCLE1BQU1DLGFBQWFKLE1BQU1LLElBQUksR0FBRztJQUVoQyw4RkFBOEY7SUFDOUYsTUFBUSxLQUFPO1FBRWQsTUFBUUosUUFBUUMsU0FBU0wsY0FBYyxDQUFFSSxPQUFPLElBQUlHLFdBQVksR0FBR0QsSUFBTTtZQUV4RUY7UUFFRDtRQUVBLDRGQUE0RjtRQUM1RixNQUFRQSxRQUFRQyxTQUFTTCxjQUFjLENBQUVLLFFBQVEsSUFBSUUsV0FBWSxJQUFJRCxJQUFNO1lBRTFFRDtRQUVEO1FBRUEsSUFBS0QsT0FBT0MsT0FBUTtZQUVuQixnRkFBZ0Y7WUFDaEYsc0VBQXNFO1lBQ3RFLDZCQUE2QjtZQUU3QixJQUFNLElBQUlJLElBQUksR0FBR0EsSUFBSSxHQUFHQSxJQUFPO2dCQUU5QixJQUFJQyxLQUFLWCxLQUFLLENBQUVLLE9BQU8sSUFBSUssRUFBRztnQkFDOUJWLEtBQUssQ0FBRUssT0FBTyxJQUFJSyxFQUFHLEdBQUdWLEtBQUssQ0FBRU0sUUFBUSxJQUFJSSxFQUFHO2dCQUM5Q1YsS0FBSyxDQUFFTSxRQUFRLElBQUlJLEVBQUcsR0FBR0M7WUFFMUI7WUFHQSxjQUFjO1lBQ2QsSUFBTSxJQUFJRCxJQUFJLEdBQUdBLElBQUksR0FBR0EsSUFBTztnQkFFOUIsSUFBSUUsS0FBS1gsY0FBYyxDQUFFSSxPQUFPLElBQUlLLEVBQUc7Z0JBQ3ZDVCxjQUFjLENBQUVJLE9BQU8sSUFBSUssRUFBRyxHQUFHVCxjQUFjLENBQUVLLFFBQVEsSUFBSUksRUFBRztnQkFDaEVULGNBQWMsQ0FBRUssUUFBUSxJQUFJSSxFQUFHLEdBQUdFO1lBRW5DO1lBRUFQO1lBQ0FDO1FBRUQsT0FBTztZQUVOLE9BQU9EO1FBRVI7SUFFRDtBQUVEO0FBRXFCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmliZS0zZC1jb2RlLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvY29yZS9idWlsZC9zb3J0VXRpbHMuZ2VuZXJhdGVkLmpzPzQyZDMiXSwic291cmNlc0NvbnRlbnQiOlsiLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBmcm9tIFwic29ydFV0aWxzLnRlbXBsYXRlLmpzXCIuICovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vLyByZW9yZGVycyBgdHJpc2Agc3VjaCB0aGF0IGZvciBgY291bnRgIGVsZW1lbnRzIGFmdGVyIGBvZmZzZXRgLCBlbGVtZW50cyBvbiB0aGUgbGVmdCBzaWRlIG9mIHRoZSBzcGxpdFxuLy8gd2lsbCBiZSBvbiB0aGUgbGVmdCBhbmQgZWxlbWVudHMgb24gdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIHNwbGl0IHdpbGwgYmUgb24gdGhlIHJpZ2h0LiByZXR1cm5zIHRoZSBpbmRleFxuLy8gb2YgdGhlIGZpcnN0IGVsZW1lbnQgb24gdGhlIHJpZ2h0IHNpZGUsIG9yIG9mZnNldCArIGNvdW50IGlmIHRoZXJlIGFyZSBubyBlbGVtZW50cyBvbiB0aGUgcmlnaHQgc2lkZS5cbmZ1bmN0aW9uIHBhcnRpdGlvbiggaW5kaXJlY3RCdWZmZXIsIGluZGV4LCB0cmlhbmdsZUJvdW5kcywgb2Zmc2V0LCBjb3VudCwgc3BsaXQgKSB7XG5cblx0bGV0IGxlZnQgPSBvZmZzZXQ7XG5cdGxldCByaWdodCA9IG9mZnNldCArIGNvdW50IC0gMTtcblx0Y29uc3QgcG9zID0gc3BsaXQucG9zO1xuXHRjb25zdCBheGlzT2Zmc2V0ID0gc3BsaXQuYXhpcyAqIDI7XG5cblx0Ly8gaG9hcmUgcGFydGl0aW9uaW5nLCBzZWUgZS5nLiBodHRwczovL2VuLndpa2lwZWRpYS5vcmcvd2lraS9RdWlja3NvcnQjSG9hcmVfcGFydGl0aW9uX3NjaGVtZVxuXHR3aGlsZSAoIHRydWUgKSB7XG5cblx0XHR3aGlsZSAoIGxlZnQgPD0gcmlnaHQgJiYgdHJpYW5nbGVCb3VuZHNbIGxlZnQgKiA2ICsgYXhpc09mZnNldCBdIDwgcG9zICkge1xuXG5cdFx0XHRsZWZ0ICsrO1xuXG5cdFx0fVxuXG5cdFx0Ly8gaWYgYSB0cmlhbmdsZSBjZW50ZXIgbGllcyBvbiB0aGUgcGFydGl0aW9uIHBsYW5lIGl0IGlzIGNvbnNpZGVyZWQgdG8gYmUgb24gdGhlIHJpZ2h0IHNpZGVcblx0XHR3aGlsZSAoIGxlZnQgPD0gcmlnaHQgJiYgdHJpYW5nbGVCb3VuZHNbIHJpZ2h0ICogNiArIGF4aXNPZmZzZXQgXSA+PSBwb3MgKSB7XG5cblx0XHRcdHJpZ2h0IC0tO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBsZWZ0IDwgcmlnaHQgKSB7XG5cblx0XHRcdC8vIHdlIG5lZWQgdG8gc3dhcCBhbGwgb2YgdGhlIGluZm9ybWF0aW9uIGFzc29jaWF0ZWQgd2l0aCB0aGUgdHJpYW5nbGVzIGF0IGluZGV4XG5cdFx0XHQvLyBsZWZ0IGFuZCByaWdodDsgdGhhdCdzIHRoZSB2ZXJ0cyBpbiB0aGUgZ2VvbWV0cnkgaW5kZXgsIHRoZSBib3VuZHMsXG5cdFx0XHQvLyBhbmQgcGVyaGFwcyB0aGUgU0FIIHBsYW5lc1xuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRcdGxldCB0MCA9IGluZGV4WyBsZWZ0ICogMyArIGkgXTtcblx0XHRcdFx0aW5kZXhbIGxlZnQgKiAzICsgaSBdID0gaW5kZXhbIHJpZ2h0ICogMyArIGkgXTtcblx0XHRcdFx0aW5kZXhbIHJpZ2h0ICogMyArIGkgXSA9IHQwO1xuXG5cdFx0XHR9XG5cblxuXHRcdFx0Ly8gc3dhcCBib3VuZHNcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cblx0XHRcdFx0bGV0IHRiID0gdHJpYW5nbGVCb3VuZHNbIGxlZnQgKiA2ICsgaSBdO1xuXHRcdFx0XHR0cmlhbmdsZUJvdW5kc1sgbGVmdCAqIDYgKyBpIF0gPSB0cmlhbmdsZUJvdW5kc1sgcmlnaHQgKiA2ICsgaSBdO1xuXHRcdFx0XHR0cmlhbmdsZUJvdW5kc1sgcmlnaHQgKiA2ICsgaSBdID0gdGI7XG5cblx0XHRcdH1cblxuXHRcdFx0bGVmdCArKztcblx0XHRcdHJpZ2h0IC0tO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmV0dXJuIGxlZnQ7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IHBhcnRpdGlvbiB9O1xuIl0sIm5hbWVzIjpbInBhcnRpdGlvbiIsImluZGlyZWN0QnVmZmVyIiwiaW5kZXgiLCJ0cmlhbmdsZUJvdW5kcyIsIm9mZnNldCIsImNvdW50Iiwic3BsaXQiLCJsZWZ0IiwicmlnaHQiLCJwb3MiLCJheGlzT2Zmc2V0IiwiYXhpcyIsImkiLCJ0MCIsInRiIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/build/sortUtils.generated.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/build/sortUtils_indirect.generated.js":
/*!*******************************************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/build/sortUtils_indirect.generated.js ***!
  \*******************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   partition_indirect: () => (/* binding */ partition_indirect)\n/* harmony export */ });\n/********************************************************/ /* This file is generated from \"sortUtils.template.js\". */ /********************************************************/ // reorders `tris` such that for `count` elements after `offset`, elements on the left side of the split\n// will be on the left and elements on the right side of the split will be on the right. returns the index\n// of the first element on the right side, or offset + count if there are no elements on the right side.\nfunction partition_indirect(indirectBuffer, index, triangleBounds, offset, count, split) {\n    let left = offset;\n    let right = offset + count - 1;\n    const pos = split.pos;\n    const axisOffset = split.axis * 2;\n    // hoare partitioning, see e.g. https://en.wikipedia.org/wiki/Quicksort#Hoare_partition_scheme\n    while(true){\n        while(left <= right && triangleBounds[left * 6 + axisOffset] < pos){\n            left++;\n        }\n        // if a triangle center lies on the partition plane it is considered to be on the right side\n        while(left <= right && triangleBounds[right * 6 + axisOffset] >= pos){\n            right--;\n        }\n        if (left < right) {\n            // we need to swap all of the information associated with the triangles at index\n            // left and right; that's the verts in the geometry index, the bounds,\n            // and perhaps the SAH planes\n            let t = indirectBuffer[left];\n            indirectBuffer[left] = indirectBuffer[right];\n            indirectBuffer[right] = t;\n            // swap bounds\n            for(let i = 0; i < 6; i++){\n                let tb = triangleBounds[left * 6 + i];\n                triangleBounds[left * 6 + i] = triangleBounds[right * 6 + i];\n                triangleBounds[right * 6 + i] = tb;\n            }\n            left++;\n            right--;\n        } else {\n            return left;\n        }\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9jb3JlL2J1aWxkL3NvcnRVdGlsc19pbmRpcmVjdC5nZW5lcmF0ZWQuanMiLCJtYXBwaW5ncyI6Ijs7OztBQUFBLHdEQUF3RCxHQUN4RCx3REFBd0QsR0FDeEQsd0RBQXdELEdBQ3hELHdHQUF3RztBQUN4RywwR0FBMEc7QUFDMUcsd0dBQXdHO0FBQ3hHLFNBQVNBLG1CQUFvQkMsY0FBYyxFQUFFQyxLQUFLLEVBQUVDLGNBQWMsRUFBRUMsTUFBTSxFQUFFQyxLQUFLLEVBQUVDLEtBQUs7SUFFdkYsSUFBSUMsT0FBT0g7SUFDWCxJQUFJSSxRQUFRSixTQUFTQyxRQUFRO0lBQzdCLE1BQU1JLE1BQU1ILE1BQU1HLEdBQUc7SUFDckIsTUFBTUMsYUFBYUosTUFBTUssSUFBSSxHQUFHO0lBRWhDLDhGQUE4RjtJQUM5RixNQUFRLEtBQU87UUFFZCxNQUFRSixRQUFRQyxTQUFTTCxjQUFjLENBQUVJLE9BQU8sSUFBSUcsV0FBWSxHQUFHRCxJQUFNO1lBRXhFRjtRQUVEO1FBRUEsNEZBQTRGO1FBQzVGLE1BQVFBLFFBQVFDLFNBQVNMLGNBQWMsQ0FBRUssUUFBUSxJQUFJRSxXQUFZLElBQUlELElBQU07WUFFMUVEO1FBRUQ7UUFFQSxJQUFLRCxPQUFPQyxPQUFRO1lBRW5CLGdGQUFnRjtZQUNoRixzRUFBc0U7WUFDdEUsNkJBQTZCO1lBQzdCLElBQUlJLElBQUlYLGNBQWMsQ0FBRU0sS0FBTTtZQUM5Qk4sY0FBYyxDQUFFTSxLQUFNLEdBQUdOLGNBQWMsQ0FBRU8sTUFBTztZQUNoRFAsY0FBYyxDQUFFTyxNQUFPLEdBQUdJO1lBRzFCLGNBQWM7WUFDZCxJQUFNLElBQUlDLElBQUksR0FBR0EsSUFBSSxHQUFHQSxJQUFPO2dCQUU5QixJQUFJQyxLQUFLWCxjQUFjLENBQUVJLE9BQU8sSUFBSU0sRUFBRztnQkFDdkNWLGNBQWMsQ0FBRUksT0FBTyxJQUFJTSxFQUFHLEdBQUdWLGNBQWMsQ0FBRUssUUFBUSxJQUFJSyxFQUFHO2dCQUNoRVYsY0FBYyxDQUFFSyxRQUFRLElBQUlLLEVBQUcsR0FBR0M7WUFFbkM7WUFFQVA7WUFDQUM7UUFFRCxPQUFPO1lBRU4sT0FBT0Q7UUFFUjtJQUVEO0FBRUQ7QUFFOEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aWJlLTNkLWNvZGUvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9jb3JlL2J1aWxkL3NvcnRVdGlsc19pbmRpcmVjdC5nZW5lcmF0ZWQuanM/YWZiNSJdLCJzb3VyY2VzQ29udGVudCI6WyIvKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGZyb20gXCJzb3J0VXRpbHMudGVtcGxhdGUuanNcIi4gKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8vIHJlb3JkZXJzIGB0cmlzYCBzdWNoIHRoYXQgZm9yIGBjb3VudGAgZWxlbWVudHMgYWZ0ZXIgYG9mZnNldGAsIGVsZW1lbnRzIG9uIHRoZSBsZWZ0IHNpZGUgb2YgdGhlIHNwbGl0XG4vLyB3aWxsIGJlIG9uIHRoZSBsZWZ0IGFuZCBlbGVtZW50cyBvbiB0aGUgcmlnaHQgc2lkZSBvZiB0aGUgc3BsaXQgd2lsbCBiZSBvbiB0aGUgcmlnaHQuIHJldHVybnMgdGhlIGluZGV4XG4vLyBvZiB0aGUgZmlyc3QgZWxlbWVudCBvbiB0aGUgcmlnaHQgc2lkZSwgb3Igb2Zmc2V0ICsgY291bnQgaWYgdGhlcmUgYXJlIG5vIGVsZW1lbnRzIG9uIHRoZSByaWdodCBzaWRlLlxuZnVuY3Rpb24gcGFydGl0aW9uX2luZGlyZWN0KCBpbmRpcmVjdEJ1ZmZlciwgaW5kZXgsIHRyaWFuZ2xlQm91bmRzLCBvZmZzZXQsIGNvdW50LCBzcGxpdCApIHtcblxuXHRsZXQgbGVmdCA9IG9mZnNldDtcblx0bGV0IHJpZ2h0ID0gb2Zmc2V0ICsgY291bnQgLSAxO1xuXHRjb25zdCBwb3MgPSBzcGxpdC5wb3M7XG5cdGNvbnN0IGF4aXNPZmZzZXQgPSBzcGxpdC5heGlzICogMjtcblxuXHQvLyBob2FyZSBwYXJ0aXRpb25pbmcsIHNlZSBlLmcuIGh0dHBzOi8vZW4ud2lraXBlZGlhLm9yZy93aWtpL1F1aWNrc29ydCNIb2FyZV9wYXJ0aXRpb25fc2NoZW1lXG5cdHdoaWxlICggdHJ1ZSApIHtcblxuXHRcdHdoaWxlICggbGVmdCA8PSByaWdodCAmJiB0cmlhbmdsZUJvdW5kc1sgbGVmdCAqIDYgKyBheGlzT2Zmc2V0IF0gPCBwb3MgKSB7XG5cblx0XHRcdGxlZnQgKys7XG5cblx0XHR9XG5cblx0XHQvLyBpZiBhIHRyaWFuZ2xlIGNlbnRlciBsaWVzIG9uIHRoZSBwYXJ0aXRpb24gcGxhbmUgaXQgaXMgY29uc2lkZXJlZCB0byBiZSBvbiB0aGUgcmlnaHQgc2lkZVxuXHRcdHdoaWxlICggbGVmdCA8PSByaWdodCAmJiB0cmlhbmdsZUJvdW5kc1sgcmlnaHQgKiA2ICsgYXhpc09mZnNldCBdID49IHBvcyApIHtcblxuXHRcdFx0cmlnaHQgLS07XG5cblx0XHR9XG5cblx0XHRpZiAoIGxlZnQgPCByaWdodCApIHtcblxuXHRcdFx0Ly8gd2UgbmVlZCB0byBzd2FwIGFsbCBvZiB0aGUgaW5mb3JtYXRpb24gYXNzb2NpYXRlZCB3aXRoIHRoZSB0cmlhbmdsZXMgYXQgaW5kZXhcblx0XHRcdC8vIGxlZnQgYW5kIHJpZ2h0OyB0aGF0J3MgdGhlIHZlcnRzIGluIHRoZSBnZW9tZXRyeSBpbmRleCwgdGhlIGJvdW5kcyxcblx0XHRcdC8vIGFuZCBwZXJoYXBzIHRoZSBTQUggcGxhbmVzXG5cdFx0XHRsZXQgdCA9IGluZGlyZWN0QnVmZmVyWyBsZWZ0IF07XG5cdFx0XHRpbmRpcmVjdEJ1ZmZlclsgbGVmdCBdID0gaW5kaXJlY3RCdWZmZXJbIHJpZ2h0IF07XG5cdFx0XHRpbmRpcmVjdEJ1ZmZlclsgcmlnaHQgXSA9IHQ7XG5cblxuXHRcdFx0Ly8gc3dhcCBib3VuZHNcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDY7IGkgKysgKSB7XG5cblx0XHRcdFx0bGV0IHRiID0gdHJpYW5nbGVCb3VuZHNbIGxlZnQgKiA2ICsgaSBdO1xuXHRcdFx0XHR0cmlhbmdsZUJvdW5kc1sgbGVmdCAqIDYgKyBpIF0gPSB0cmlhbmdsZUJvdW5kc1sgcmlnaHQgKiA2ICsgaSBdO1xuXHRcdFx0XHR0cmlhbmdsZUJvdW5kc1sgcmlnaHQgKiA2ICsgaSBdID0gdGI7XG5cblx0XHRcdH1cblxuXHRcdFx0bGVmdCArKztcblx0XHRcdHJpZ2h0IC0tO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmV0dXJuIGxlZnQ7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IHBhcnRpdGlvbl9pbmRpcmVjdCB9O1xuIl0sIm5hbWVzIjpbInBhcnRpdGlvbl9pbmRpcmVjdCIsImluZGlyZWN0QnVmZmVyIiwiaW5kZXgiLCJ0cmlhbmdsZUJvdW5kcyIsIm9mZnNldCIsImNvdW50Iiwic3BsaXQiLCJsZWZ0IiwicmlnaHQiLCJwb3MiLCJheGlzT2Zmc2V0IiwiYXhpcyIsInQiLCJpIiwidGIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/build/sortUtils_indirect.generated.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/build/splitUtils.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/build/splitUtils.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getOptimalSplit: () => (/* binding */ getOptimalSplit)\n/* harmony export */ });\n/* harmony import */ var _utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/ArrayBoxUtilities.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js\");\n/* harmony import */ var _Constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Constants.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/Constants.js\");\n\n\nconst BIN_COUNT = 32;\nconst binsSort = (a, b)=>a.candidate - b.candidate;\nconst sahBins = new Array(BIN_COUNT).fill().map(()=>{\n    return {\n        count: 0,\n        bounds: new Float32Array(6),\n        rightCacheBounds: new Float32Array(6),\n        leftCacheBounds: new Float32Array(6),\n        candidate: 0\n    };\n});\nconst leftBounds = new Float32Array(6);\nfunction getOptimalSplit(nodeBoundingData, centroidBoundingData, triangleBounds, offset, count, strategy) {\n    let axis = -1;\n    let pos = 0;\n    // Center\n    if (strategy === _Constants_js__WEBPACK_IMPORTED_MODULE_0__.CENTER) {\n        axis = (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_1__.getLongestEdgeIndex)(centroidBoundingData);\n        if (axis !== -1) {\n            pos = (centroidBoundingData[axis] + centroidBoundingData[axis + 3]) / 2;\n        }\n    } else if (strategy === _Constants_js__WEBPACK_IMPORTED_MODULE_0__.AVERAGE) {\n        axis = (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_1__.getLongestEdgeIndex)(nodeBoundingData);\n        if (axis !== -1) {\n            pos = getAverage(triangleBounds, offset, count, axis);\n        }\n    } else if (strategy === _Constants_js__WEBPACK_IMPORTED_MODULE_0__.SAH) {\n        const rootSurfaceArea = (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_1__.computeSurfaceArea)(nodeBoundingData);\n        let bestCost = _Constants_js__WEBPACK_IMPORTED_MODULE_0__.TRIANGLE_INTERSECT_COST * count;\n        // iterate over all axes\n        const cStart = offset * 6;\n        const cEnd = (offset + count) * 6;\n        for(let a = 0; a < 3; a++){\n            const axisLeft = centroidBoundingData[a];\n            const axisRight = centroidBoundingData[a + 3];\n            const axisLength = axisRight - axisLeft;\n            const binWidth = axisLength / BIN_COUNT;\n            // If we have fewer triangles than we're planning to split then just check all\n            // the triangle positions because it will be faster.\n            if (count < BIN_COUNT / 4) {\n                // initialize the bin candidates\n                const truncatedBins = [\n                    ...sahBins\n                ];\n                truncatedBins.length = count;\n                // set the candidates\n                let b = 0;\n                for(let c = cStart; c < cEnd; c += 6, b++){\n                    const bin = truncatedBins[b];\n                    bin.candidate = triangleBounds[c + 2 * a];\n                    bin.count = 0;\n                    const { bounds, leftCacheBounds, rightCacheBounds } = bin;\n                    for(let d = 0; d < 3; d++){\n                        rightCacheBounds[d] = Infinity;\n                        rightCacheBounds[d + 3] = -Infinity;\n                        leftCacheBounds[d] = Infinity;\n                        leftCacheBounds[d + 3] = -Infinity;\n                        bounds[d] = Infinity;\n                        bounds[d + 3] = -Infinity;\n                    }\n                    (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_1__.expandByTriangleBounds)(c, triangleBounds, bounds);\n                }\n                truncatedBins.sort(binsSort);\n                // remove redundant splits\n                let splitCount = count;\n                for(let bi = 0; bi < splitCount; bi++){\n                    const bin = truncatedBins[bi];\n                    while(bi + 1 < splitCount && truncatedBins[bi + 1].candidate === bin.candidate){\n                        truncatedBins.splice(bi + 1, 1);\n                        splitCount--;\n                    }\n                }\n                // find the appropriate bin for each triangle and expand the bounds.\n                for(let c = cStart; c < cEnd; c += 6){\n                    const center = triangleBounds[c + 2 * a];\n                    for(let bi = 0; bi < splitCount; bi++){\n                        const bin = truncatedBins[bi];\n                        if (center >= bin.candidate) {\n                            (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_1__.expandByTriangleBounds)(c, triangleBounds, bin.rightCacheBounds);\n                        } else {\n                            (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_1__.expandByTriangleBounds)(c, triangleBounds, bin.leftCacheBounds);\n                            bin.count++;\n                        }\n                    }\n                }\n                // expand all the bounds\n                for(let bi = 0; bi < splitCount; bi++){\n                    const bin = truncatedBins[bi];\n                    const leftCount = bin.count;\n                    const rightCount = count - bin.count;\n                    // check the cost of this split\n                    const leftBounds = bin.leftCacheBounds;\n                    const rightBounds = bin.rightCacheBounds;\n                    let leftProb = 0;\n                    if (leftCount !== 0) {\n                        leftProb = (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_1__.computeSurfaceArea)(leftBounds) / rootSurfaceArea;\n                    }\n                    let rightProb = 0;\n                    if (rightCount !== 0) {\n                        rightProb = (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_1__.computeSurfaceArea)(rightBounds) / rootSurfaceArea;\n                    }\n                    const cost = _Constants_js__WEBPACK_IMPORTED_MODULE_0__.TRAVERSAL_COST + _Constants_js__WEBPACK_IMPORTED_MODULE_0__.TRIANGLE_INTERSECT_COST * (leftProb * leftCount + rightProb * rightCount);\n                    if (cost < bestCost) {\n                        axis = a;\n                        bestCost = cost;\n                        pos = bin.candidate;\n                    }\n                }\n            } else {\n                // reset the bins\n                for(let i = 0; i < BIN_COUNT; i++){\n                    const bin = sahBins[i];\n                    bin.count = 0;\n                    bin.candidate = axisLeft + binWidth + i * binWidth;\n                    const bounds = bin.bounds;\n                    for(let d = 0; d < 3; d++){\n                        bounds[d] = Infinity;\n                        bounds[d + 3] = -Infinity;\n                    }\n                }\n                // iterate over all center positions\n                for(let c = cStart; c < cEnd; c += 6){\n                    const triCenter = triangleBounds[c + 2 * a];\n                    const relativeCenter = triCenter - axisLeft;\n                    // in the partition function if the centroid lies on the split plane then it is\n                    // considered to be on the right side of the split\n                    let binIndex = ~~(relativeCenter / binWidth);\n                    if (binIndex >= BIN_COUNT) binIndex = BIN_COUNT - 1;\n                    const bin = sahBins[binIndex];\n                    bin.count++;\n                    (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_1__.expandByTriangleBounds)(c, triangleBounds, bin.bounds);\n                }\n                // cache the unioned bounds from right to left so we don't have to regenerate them each time\n                const lastBin = sahBins[BIN_COUNT - 1];\n                (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_1__.copyBounds)(lastBin.bounds, lastBin.rightCacheBounds);\n                for(let i = BIN_COUNT - 2; i >= 0; i--){\n                    const bin = sahBins[i];\n                    const nextBin = sahBins[i + 1];\n                    (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_1__.unionBounds)(bin.bounds, nextBin.rightCacheBounds, bin.rightCacheBounds);\n                }\n                let leftCount = 0;\n                for(let i = 0; i < BIN_COUNT - 1; i++){\n                    const bin = sahBins[i];\n                    const binCount = bin.count;\n                    const bounds = bin.bounds;\n                    const nextBin = sahBins[i + 1];\n                    const rightBounds = nextBin.rightCacheBounds;\n                    // don't do anything with the bounds if the new bounds have no triangles\n                    if (binCount !== 0) {\n                        if (leftCount === 0) {\n                            (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_1__.copyBounds)(bounds, leftBounds);\n                        } else {\n                            (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_1__.unionBounds)(bounds, leftBounds, leftBounds);\n                        }\n                    }\n                    leftCount += binCount;\n                    // check the cost of this split\n                    let leftProb = 0;\n                    let rightProb = 0;\n                    if (leftCount !== 0) {\n                        leftProb = (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_1__.computeSurfaceArea)(leftBounds) / rootSurfaceArea;\n                    }\n                    const rightCount = count - leftCount;\n                    if (rightCount !== 0) {\n                        rightProb = (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_1__.computeSurfaceArea)(rightBounds) / rootSurfaceArea;\n                    }\n                    const cost = _Constants_js__WEBPACK_IMPORTED_MODULE_0__.TRAVERSAL_COST + _Constants_js__WEBPACK_IMPORTED_MODULE_0__.TRIANGLE_INTERSECT_COST * (leftProb * leftCount + rightProb * rightCount);\n                    if (cost < bestCost) {\n                        axis = a;\n                        bestCost = cost;\n                        pos = bin.candidate;\n                    }\n                }\n            }\n        }\n    } else {\n        console.warn(`MeshBVH: Invalid build strategy value ${strategy} used.`);\n    }\n    return {\n        axis,\n        pos\n    };\n}\n// returns the average coordinate on the specified axis of the all the provided triangles\nfunction getAverage(triangleBounds, offset, count, axis) {\n    let avg = 0;\n    for(let i = offset, end = offset + count; i < end; i++){\n        avg += triangleBounds[i * 6 + axis * 2];\n    }\n    return avg / count;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9jb3JlL2J1aWxkL3NwbGl0VXRpbHMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7O0FBQTRJO0FBQzVDO0FBRWhHLE1BQU1VLFlBQVk7QUFDbEIsTUFBTUMsV0FBVyxDQUFFQyxHQUFHQyxJQUFPRCxFQUFFRSxTQUFTLEdBQUdELEVBQUVDLFNBQVM7QUFDdEQsTUFBTUMsVUFBVSxJQUFJQyxNQUFPTixXQUFZTyxJQUFJLEdBQUdDLEdBQUcsQ0FBRTtJQUVsRCxPQUFPO1FBRU5DLE9BQU87UUFDUEMsUUFBUSxJQUFJQyxhQUFjO1FBQzFCQyxrQkFBa0IsSUFBSUQsYUFBYztRQUNwQ0UsaUJBQWlCLElBQUlGLGFBQWM7UUFDbkNQLFdBQVc7SUFFWjtBQUVEO0FBQ0EsTUFBTVUsYUFBYSxJQUFJSCxhQUFjO0FBRTlCLFNBQVNJLGdCQUFpQkMsZ0JBQWdCLEVBQUVDLG9CQUFvQixFQUFFQyxjQUFjLEVBQUVDLE1BQU0sRUFBRVYsS0FBSyxFQUFFVyxRQUFRO0lBRS9HLElBQUlDLE9BQU8sQ0FBRTtJQUNiLElBQUlDLE1BQU07SUFFVixTQUFTO0lBQ1QsSUFBS0YsYUFBYXpCLGlEQUFNQSxFQUFHO1FBRTFCMEIsT0FBTy9CLGdGQUFtQkEsQ0FBRTJCO1FBQzVCLElBQUtJLFNBQVMsQ0FBRSxHQUFJO1lBRW5CQyxNQUFNLENBQUVMLG9CQUFvQixDQUFFSSxLQUFNLEdBQUdKLG9CQUFvQixDQUFFSSxPQUFPLEVBQUcsSUFBSztRQUU3RTtJQUVELE9BQU8sSUFBS0QsYUFBYXhCLGtEQUFPQSxFQUFHO1FBRWxDeUIsT0FBTy9CLGdGQUFtQkEsQ0FBRTBCO1FBQzVCLElBQUtLLFNBQVMsQ0FBRSxHQUFJO1lBRW5CQyxNQUFNQyxXQUFZTCxnQkFBZ0JDLFFBQVFWLE9BQU9ZO1FBRWxEO0lBRUQsT0FBTyxJQUFLRCxhQUFhdkIsOENBQUdBLEVBQUc7UUFFOUIs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cGFjazovL3ZpYmUtM2QtY29kZS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9ub2RlX21vZHVsZXMvdGhyZWUtbWVzaC1idmgvc3JjL2NvcmUvYnVpbGQvc3BsaXRVdGlscy5qcz8zNDEzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGdldExvbmdlc3RFZGdlSW5kZXgsIGNvbXB1dGVTdXJmYWNlQXJlYSwgY29weUJvdW5kcywgdW5pb25Cb3VuZHMsIGV4cGFuZEJ5VHJpYW5nbGVCb3VuZHMgfSBmcm9tICcuLi8uLi91dGlscy9BcnJheUJveFV0aWxpdGllcy5qcyc7XG5pbXBvcnQgeyBDRU5URVIsIEFWRVJBR0UsIFNBSCwgVFJJQU5HTEVfSU5URVJTRUNUX0NPU1QsIFRSQVZFUlNBTF9DT1NUIH0gZnJvbSAnLi4vQ29uc3RhbnRzLmpzJztcblxuY29uc3QgQklOX0NPVU5UID0gMzI7XG5jb25zdCBiaW5zU29ydCA9ICggYSwgYiApID0+IGEuY2FuZGlkYXRlIC0gYi5jYW5kaWRhdGU7XG5jb25zdCBzYWhCaW5zID0gbmV3IEFycmF5KCBCSU5fQ09VTlQgKS5maWxsKCkubWFwKCAoKSA9PiB7XG5cblx0cmV0dXJuIHtcblxuXHRcdGNvdW50OiAwLFxuXHRcdGJvdW5kczogbmV3IEZsb2F0MzJBcnJheSggNiApLFxuXHRcdHJpZ2h0Q2FjaGVCb3VuZHM6IG5ldyBGbG9hdDMyQXJyYXkoIDYgKSxcblx0XHRsZWZ0Q2FjaGVCb3VuZHM6IG5ldyBGbG9hdDMyQXJyYXkoIDYgKSxcblx0XHRjYW5kaWRhdGU6IDAsXG5cblx0fTtcblxufSApO1xuY29uc3QgbGVmdEJvdW5kcyA9IG5ldyBGbG9hdDMyQXJyYXkoIDYgKTtcblxuZXhwb3J0IGZ1bmN0aW9uIGdldE9wdGltYWxTcGxpdCggbm9kZUJvdW5kaW5nRGF0YSwgY2VudHJvaWRCb3VuZGluZ0RhdGEsIHRyaWFuZ2xlQm91bmRzLCBvZmZzZXQsIGNvdW50LCBzdHJhdGVneSApIHtcblxuXHRsZXQgYXhpcyA9IC0gMTtcblx0bGV0IHBvcyA9IDA7XG5cblx0Ly8gQ2VudGVyXG5cdGlmICggc3RyYXRlZ3kgPT09IENFTlRFUiApIHtcblxuXHRcdGF4aXMgPSBnZXRMb25nZXN0RWRnZUluZGV4KCBjZW50cm9pZEJvdW5kaW5nRGF0YSApO1xuXHRcdGlmICggYXhpcyAhPT0gLSAxICkge1xuXG5cdFx0XHRwb3MgPSAoIGNlbnRyb2lkQm91bmRpbmdEYXRhWyBheGlzIF0gKyBjZW50cm9pZEJvdW5kaW5nRGF0YVsgYXhpcyArIDMgXSApIC8gMjtcblxuXHRcdH1cblxuXHR9IGVsc2UgaWYgKCBzdHJhdGVneSA9PT0gQVZFUkFHRSApIHtcblxuXHRcdGF4aXMgPSBnZXRMb25nZXN0RWRnZUluZGV4KCBub2RlQm91bmRpbmdEYXRhICk7XG5cdFx0aWYgKCBheGlzICE9PSAtIDEgKSB7XG5cblx0XHRcdHBvcyA9IGdldEF2ZXJhZ2UoIHRyaWFuZ2xlQm91bmRzLCBvZmZzZXQsIGNvdW50LCBheGlzICk7XG5cblx0XHR9XG5cblx0fSBlbHNlIGlmICggc3RyYXRlZ3kgPT09IFNBSCApIHtcblxuXHRcdGNvbnN0IHJvb3RTdXJmYWNlQXJlYSA9IGNvbXB1dGVTdXJmYWNlQXJlYSggbm9kZUJvdW5kaW5nRGF0YSApO1xuXHRcdGxldCBiZXN0Q29zdCA9IFRSSUFOR0xFX0lOVEVSU0VDVF9DT1NUICogY291bnQ7XG5cblx0XHQvLyBpdGVyYXRlIG92ZXIgYWxsIGF4ZXNcblx0XHRjb25zdCBjU3RhcnQgPSBvZmZzZXQgKiA2O1xuXHRcdGNvbnN0IGNFbmQgPSAoIG9mZnNldCArIGNvdW50ICkgKiA2O1xuXHRcdGZvciAoIGxldCBhID0gMDsgYSA8IDM7IGEgKysgKSB7XG5cblx0XHRcdGNvbnN0IGF4aXNMZWZ0ID0gY2VudHJvaWRCb3VuZGluZ0RhdGFbIGEgXTtcblx0XHRcdGNvbnN0IGF4aXNSaWdodCA9IGNlbnRyb2lkQm91bmRpbmdEYXRhWyBhICsgMyBdO1xuXHRcdFx0Y29uc3QgYXhpc0xlbmd0aCA9IGF4aXNSaWdodCAtIGF4aXNMZWZ0O1xuXHRcdFx0Y29uc3QgYmluV2lkdGggPSBheGlzTGVuZ3RoIC8gQklOX0NPVU5UO1xuXG5cdFx0XHQvLyBJZiB3ZSBoYXZlIGZld2VyIHRyaWFuZ2xlcyB0aGFuIHdlJ3JlIHBsYW5uaW5nIHRvIHNwbGl0IHRoZW4ganVzdCBjaGVjayBhbGxcblx0XHRcdC8vIHRoZSB0cmlhbmdsZSBwb3NpdGlvbnMgYmVjYXVzZSBpdCB3aWxsIGJlIGZhc3Rlci5cblx0XHRcdGlmICggY291bnQgPCBCSU5fQ09VTlQgLyA0ICkge1xuXG5cdFx0XHRcdC8vIGluaXRpYWxpemUgdGhlIGJpbiBjYW5kaWRhdGVzXG5cdFx0XHRcdGNvbnN0IHRydW5jYXRlZEJpbnMgPSBbIC4uLnNhaEJpbnMgXTtcblx0XHRcdFx0dHJ1bmNhdGVkQmlucy5sZW5ndGggPSBjb3VudDtcblxuXHRcdFx0XHQvLyBzZXQgdGhlIGNhbmRpZGF0ZXNcblx0XHRcdFx0bGV0IGIgPSAwO1xuXHRcdFx0XHRmb3IgKCBsZXQgYyA9IGNTdGFydDsgYyA8IGNFbmQ7IGMgKz0gNiwgYiArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGJpbiA9IHRydW5jYXRlZEJpbnNbIGIgXTtcblx0XHRcdFx0XHRiaW4uY2FuZGlkYXRlID0gdHJpYW5nbGVCb3VuZHNbIGMgKyAyICogYSBdO1xuXHRcdFx0XHRcdGJpbi5jb3VudCA9IDA7XG5cblx0XHRcdFx0XHRjb25zdCB7XG5cdFx0XHRcdFx0XHRib3VuZHMsXG5cdFx0XHRcdFx0XHRsZWZ0Q2FjaGVCb3VuZHMsXG5cdFx0XHRcdFx0XHRyaWdodENhY2hlQm91bmRzLFxuXHRcdFx0XHRcdH0gPSBiaW47XG5cdFx0XHRcdFx0Zm9yICggbGV0IGQgPSAwOyBkIDwgMzsgZCArKyApIHtcblxuXHRcdFx0XHRcdFx0cmlnaHRDYWNoZUJvdW5kc1sgZCBdID0gSW5maW5pdHk7XG5cdFx0XHRcdFx0XHRyaWdodENhY2hlQm91bmRzWyBkICsgMyBdID0gLSBJbmZpbml0eTtcblxuXHRcdFx0XHRcdFx0bGVmdENhY2hlQm91bmRzWyBkIF0gPSBJbmZpbml0eTtcblx0XHRcdFx0XHRcdGxlZnRDYWNoZUJvdW5kc1sgZCArIDMgXSA9IC0gSW5maW5pdHk7XG5cblx0XHRcdFx0XHRcdGJvdW5kc1sgZCBdID0gSW5maW5pdHk7XG5cdFx0XHRcdFx0XHRib3VuZHNbIGQgKyAzIF0gPSAtIEluZmluaXR5O1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0ZXhwYW5kQnlUcmlhbmdsZUJvdW5kcyggYywgdHJpYW5nbGVCb3VuZHMsIGJvdW5kcyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHR0cnVuY2F0ZWRCaW5zLnNvcnQoIGJpbnNTb3J0ICk7XG5cblx0XHRcdFx0Ly8gcmVtb3ZlIHJlZHVuZGFudCBzcGxpdHNcblx0XHRcdFx0bGV0IHNwbGl0Q291bnQgPSBjb3VudDtcblx0XHRcdFx0Zm9yICggbGV0IGJpID0gMDsgYmkgPCBzcGxpdENvdW50OyBiaSArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGJpbiA9IHRydW5jYXRlZEJpbnNbIGJpIF07XG5cdFx0XHRcdFx0d2hpbGUgKCBiaSArIDEgPCBzcGxpdENvdW50ICYmIHRydW5jYXRlZEJpbnNbIGJpICsgMSBdLmNhbmRpZGF0ZSA9PT0gYmluLmNhbmRpZGF0ZSApIHtcblxuXHRcdFx0XHRcdFx0dHJ1bmNhdGVkQmlucy5zcGxpY2UoIGJpICsgMSwgMSApO1xuXHRcdFx0XHRcdFx0c3BsaXRDb3VudCAtLTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0Ly8gZmluZCB0aGUgYXBwcm9wcmlhdGUgYmluIGZvciBlYWNoIHRyaWFuZ2xlIGFuZCBleHBhbmQgdGhlIGJvdW5kcy5cblx0XHRcdFx0Zm9yICggbGV0IGMgPSBjU3RhcnQ7IGMgPCBjRW5kOyBjICs9IDYgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBjZW50ZXIgPSB0cmlhbmdsZUJvdW5kc1sgYyArIDIgKiBhIF07XG5cdFx0XHRcdFx0Zm9yICggbGV0IGJpID0gMDsgYmkgPCBzcGxpdENvdW50OyBiaSArKyApIHtcblxuXHRcdFx0XHRcdFx0Y29uc3QgYmluID0gdHJ1bmNhdGVkQmluc1sgYmkgXTtcblx0XHRcdFx0XHRcdGlmICggY2VudGVyID49IGJpbi5jYW5kaWRhdGUgKSB7XG5cblx0XHRcdFx0XHRcdFx0ZXhwYW5kQnlUcmlhbmdsZUJvdW5kcyggYywgdHJpYW5nbGVCb3VuZHMsIGJpbi5yaWdodENhY2hlQm91bmRzICk7XG5cblx0XHRcdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHRcdFx0ZXhwYW5kQnlUcmlhbmdsZUJvdW5kcyggYywgdHJpYW5nbGVCb3VuZHMsIGJpbi5sZWZ0Q2FjaGVCb3VuZHMgKTtcblx0XHRcdFx0XHRcdFx0YmluLmNvdW50ICsrO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGV4cGFuZCBhbGwgdGhlIGJvdW5kc1xuXHRcdFx0XHRmb3IgKCBsZXQgYmkgPSAwOyBiaSA8IHNwbGl0Q291bnQ7IGJpICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgYmluID0gdHJ1bmNhdGVkQmluc1sgYmkgXTtcblx0XHRcdFx0XHRjb25zdCBsZWZ0Q291bnQgPSBiaW4uY291bnQ7XG5cdFx0XHRcdFx0Y29uc3QgcmlnaHRDb3VudCA9IGNvdW50IC0gYmluLmNvdW50O1xuXG5cdFx0XHRcdFx0Ly8gY2hlY2sgdGhlIGNvc3Qgb2YgdGhpcyBzcGxpdFxuXHRcdFx0XHRcdGNvbnN0IGxlZnRCb3VuZHMgPSBiaW4ubGVmdENhY2hlQm91bmRzO1xuXHRcdFx0XHRcdGNvbnN0IHJpZ2h0Qm91bmRzID0gYmluLnJpZ2h0Q2FjaGVCb3VuZHM7XG5cblx0XHRcdFx0XHRsZXQgbGVmdFByb2IgPSAwO1xuXHRcdFx0XHRcdGlmICggbGVmdENvdW50ICE9PSAwICkge1xuXG5cdFx0XHRcdFx0XHRsZWZ0UHJvYiA9IGNvbXB1dGVTdXJmYWNlQXJlYSggbGVmdEJvdW5kcyApIC8gcm9vdFN1cmZhY2VBcmVhO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bGV0IHJpZ2h0UHJvYiA9IDA7XG5cdFx0XHRcdFx0aWYgKCByaWdodENvdW50ICE9PSAwICkge1xuXG5cdFx0XHRcdFx0XHRyaWdodFByb2IgPSBjb21wdXRlU3VyZmFjZUFyZWEoIHJpZ2h0Qm91bmRzICkgLyByb290U3VyZmFjZUFyZWE7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRjb25zdCBjb3N0ID0gVFJBVkVSU0FMX0NPU1QgKyBUUklBTkdMRV9JTlRFUlNFQ1RfQ09TVCAqIChcblx0XHRcdFx0XHRcdGxlZnRQcm9iICogbGVmdENvdW50ICsgcmlnaHRQcm9iICogcmlnaHRDb3VudFxuXHRcdFx0XHRcdCk7XG5cblx0XHRcdFx0XHRpZiAoIGNvc3QgPCBiZXN0Q29zdCApIHtcblxuXHRcdFx0XHRcdFx0YXhpcyA9IGE7XG5cdFx0XHRcdFx0XHRiZXN0Q29zdCA9IGNvc3Q7XG5cdFx0XHRcdFx0XHRwb3MgPSBiaW4uY2FuZGlkYXRlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHQvLyByZXNldCB0aGUgYmluc1xuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBCSU5fQ09VTlQ7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBiaW4gPSBzYWhCaW5zWyBpIF07XG5cdFx0XHRcdFx0YmluLmNvdW50ID0gMDtcblx0XHRcdFx0XHRiaW4uY2FuZGlkYXRlID0gYXhpc0xlZnQgKyBiaW5XaWR0aCArIGkgKiBiaW5XaWR0aDtcblxuXHRcdFx0XHRcdGNvbnN0IGJvdW5kcyA9IGJpbi5ib3VuZHM7XG5cdFx0XHRcdFx0Zm9yICggbGV0IGQgPSAwOyBkIDwgMzsgZCArKyApIHtcblxuXHRcdFx0XHRcdFx0Ym91bmRzWyBkIF0gPSBJbmZpbml0eTtcblx0XHRcdFx0XHRcdGJvdW5kc1sgZCArIDMgXSA9IC0gSW5maW5pdHk7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdC8vIGl0ZXJhdGUgb3ZlciBhbGwgY2VudGVyIHBvc2l0aW9uc1xuXHRcdFx0XHRmb3IgKCBsZXQgYyA9IGNTdGFydDsgYyA8IGNFbmQ7IGMgKz0gNiApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHRyaUNlbnRlciA9IHRyaWFuZ2xlQm91bmRzWyBjICsgMiAqIGEgXTtcblx0XHRcdFx0XHRjb25zdCByZWxhdGl2ZUNlbnRlciA9IHRyaUNlbnRlciAtIGF4aXNMZWZ0O1xuXG5cdFx0XHRcdFx0Ly8gaW4gdGhlIHBhcnRpdGlvbiBmdW5jdGlvbiBpZiB0aGUgY2VudHJvaWQgbGllcyBvbiB0aGUgc3BsaXQgcGxhbmUgdGhlbiBpdCBpc1xuXHRcdFx0XHRcdC8vIGNvbnNpZGVyZWQgdG8gYmUgb24gdGhlIHJpZ2h0IHNpZGUgb2YgdGhlIHNwbGl0XG5cdFx0XHRcdFx0bGV0IGJpbkluZGV4ID0gfiB+ICggcmVsYXRpdmVDZW50ZXIgLyBiaW5XaWR0aCApO1xuXHRcdFx0XHRcdGlmICggYmluSW5kZXggPj0gQklOX0NPVU5UICkgYmluSW5kZXggPSBCSU5fQ09VTlQgLSAxO1xuXG5cdFx0XHRcdFx0Y29uc3QgYmluID0gc2FoQmluc1sgYmluSW5kZXggXTtcblx0XHRcdFx0XHRiaW4uY291bnQgKys7XG5cblx0XHRcdFx0XHRleHBhbmRCeVRyaWFuZ2xlQm91bmRzKCBjLCB0cmlhbmdsZUJvdW5kcywgYmluLmJvdW5kcyApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHQvLyBjYWNoZSB0aGUgdW5pb25lZCBib3VuZHMgZnJvbSByaWdodCB0byBsZWZ0IHNvIHdlIGRvbid0IGhhdmUgdG8gcmVnZW5lcmF0ZSB0aGVtIGVhY2ggdGltZVxuXHRcdFx0XHRjb25zdCBsYXN0QmluID0gc2FoQmluc1sgQklOX0NPVU5UIC0gMSBdO1xuXHRcdFx0XHRjb3B5Qm91bmRzKCBsYXN0QmluLmJvdW5kcywgbGFzdEJpbi5yaWdodENhY2hlQm91bmRzICk7XG5cdFx0XHRcdGZvciAoIGxldCBpID0gQklOX0NPVU5UIC0gMjsgaSA+PSAwOyBpIC0tICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgYmluID0gc2FoQmluc1sgaSBdO1xuXHRcdFx0XHRcdGNvbnN0IG5leHRCaW4gPSBzYWhCaW5zWyBpICsgMSBdO1xuXHRcdFx0XHRcdHVuaW9uQm91bmRzKCBiaW4uYm91bmRzLCBuZXh0QmluLnJpZ2h0Q2FjaGVCb3VuZHMsIGJpbi5yaWdodENhY2hlQm91bmRzICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdGxldCBsZWZ0Q291bnQgPSAwO1xuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCBCSU5fQ09VTlQgLSAxOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgYmluID0gc2FoQmluc1sgaSBdO1xuXHRcdFx0XHRcdGNvbnN0IGJpbkNvdW50ID0gYmluLmNvdW50O1xuXHRcdFx0XHRcdGNvbnN0IGJvdW5kcyA9IGJpbi5ib3VuZHM7XG5cblx0XHRcdFx0XHRjb25zdCBuZXh0QmluID0gc2FoQmluc1sgaSArIDEgXTtcblx0XHRcdFx0XHRjb25zdCByaWdodEJvdW5kcyA9IG5leHRCaW4ucmlnaHRDYWNoZUJvdW5kcztcblxuXHRcdFx0XHRcdC8vIGRvbid0IGRvIGFueXRoaW5nIHdpdGggdGhlIGJvdW5kcyBpZiB0aGUgbmV3IGJvdW5kcyBoYXZlIG5vIHRyaWFuZ2xlc1xuXHRcdFx0XHRcdGlmICggYmluQ291bnQgIT09IDAgKSB7XG5cblx0XHRcdFx0XHRcdGlmICggbGVmdENvdW50ID09PSAwICkge1xuXG5cdFx0XHRcdFx0XHRcdGNvcHlCb3VuZHMoIGJvdW5kcywgbGVmdEJvdW5kcyApO1xuXG5cdFx0XHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0XHRcdHVuaW9uQm91bmRzKCBib3VuZHMsIGxlZnRCb3VuZHMsIGxlZnRCb3VuZHMgKTtcblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0bGVmdENvdW50ICs9IGJpbkNvdW50O1xuXG5cdFx0XHRcdFx0Ly8gY2hlY2sgdGhlIGNvc3Qgb2YgdGhpcyBzcGxpdFxuXHRcdFx0XHRcdGxldCBsZWZ0UHJvYiA9IDA7XG5cdFx0XHRcdFx0bGV0IHJpZ2h0UHJvYiA9IDA7XG5cblx0XHRcdFx0XHRpZiAoIGxlZnRDb3VudCAhPT0gMCApIHtcblxuXHRcdFx0XHRcdFx0bGVmdFByb2IgPSBjb21wdXRlU3VyZmFjZUFyZWEoIGxlZnRCb3VuZHMgKSAvIHJvb3RTdXJmYWNlQXJlYTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvbnN0IHJpZ2h0Q291bnQgPSBjb3VudCAtIGxlZnRDb3VudDtcblx0XHRcdFx0XHRpZiAoIHJpZ2h0Q291bnQgIT09IDAgKSB7XG5cblx0XHRcdFx0XHRcdHJpZ2h0UHJvYiA9IGNvbXB1dGVTdXJmYWNlQXJlYSggcmlnaHRCb3VuZHMgKSAvIHJvb3RTdXJmYWNlQXJlYTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdGNvbnN0IGNvc3QgPSBUUkFWRVJTQUxfQ09TVCArIFRSSUFOR0xFX0lOVEVSU0VDVF9DT1NUICogKFxuXHRcdFx0XHRcdFx0bGVmdFByb2IgKiBsZWZ0Q291bnQgKyByaWdodFByb2IgKiByaWdodENvdW50XG5cdFx0XHRcdFx0KTtcblxuXHRcdFx0XHRcdGlmICggY29zdCA8IGJlc3RDb3N0ICkge1xuXG5cdFx0XHRcdFx0XHRheGlzID0gYTtcblx0XHRcdFx0XHRcdGJlc3RDb3N0ID0gY29zdDtcblx0XHRcdFx0XHRcdHBvcyA9IGJpbi5jYW5kaWRhdGU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fSBlbHNlIHtcblxuXHRcdGNvbnNvbGUud2FybiggYE1lc2hCVkg6IEludmFsaWQgYnVpbGQgc3RyYXRlZ3kgdmFsdWUgJHsgc3RyYXRlZ3kgfSB1c2VkLmAgKTtcblxuXHR9XG5cblx0cmV0dXJuIHsgYXhpcywgcG9zIH07XG5cbn1cblxuLy8gcmV0dXJucyB0aGUgYXZlcmFnZSBjb29yZGluYXRlIG9uIHRoZSBzcGVjaWZpZWQgYXhpcyBvZiB0aGUgYWxsIHRoZSBwcm92aWRlZCB0cmlhbmdsZXNcbmZ1bmN0aW9uIGdldEF2ZXJhZ2UoIHRyaWFuZ2xlQm91bmRzLCBvZmZzZXQsIGNvdW50LCBheGlzICkge1xuXG5cdGxldCBhdmcgPSAwO1xuXHRmb3IgKCBsZXQgaSA9IG9mZnNldCwgZW5kID0gb2Zmc2V0ICsgY291bnQ7IGkgPCBlbmQ7IGkgKysgKSB7XG5cblx0XHRhdmcgKz0gdHJpYW5nbGVCb3VuZHNbIGkgKiA2ICsgYXhpcyAqIDIgXTtcblxuXHR9XG5cblx0cmV0dXJuIGF2ZyAvIGNvdW50O1xuXG59XG4iXSwibmFtZXMiOlsiZ2V0TG9uZ2VzdEVkZ2VJbmRleCIsImNvbXB1dGVTdXJmYWNlQXJlYSIsImNvcHlCb3VuZHMiLCJ1bmlvbkJvdW5kcyIsImV4cGFuZEJ5VHJpYW5nbGVCb3VuZHMiLCJDRU5URVIiLCJBVkVSQUdFIiwiU0FIIiwiVFJJQU5HTEVfSU5URVJTRUNUX0NPU1QiLCJUUkFWRVJTQUxfQ09TVCIsIkJJTl9DT1VOVCIsImJpbnNTb3J0IiwiYSIsImIiLCJjYW5kaWRhdGUiLCJzYWhCaW5zIiwiQXJyYXkiLCJmaWxsIiwibWFwIiwiY291bnQiLCJib3VuZHMiLCJGbG9hdDMyQXJyYXkiLCJyaWdodENhY2hlQm91bmRzIiwibGVmdENhY2hlQm91bmRzIiwibGVmdEJvdW5kcyIsImdldE9wdGltYWxTcGxpdCIsIm5vZGVCb3VuZGluZ0RhdGEiLCJjZW50cm9pZEJvdW5kaW5nRGF0YSIsInRyaWFuZ2xlQm91bmRzIiwib2Zmc2V0Iiwic3RyYXRlZ3kiLCJheGlzIiwicG9zIiwiZ2V0QXZlcmFnZSIsInJvb3RTdXJmYWNlQXJlYSIsImJlc3RDb3N0IiwiY1N0YXJ0IiwiY0VuZCIsImF4aXNMZWZ0IiwiYXhpc1JpZ2h0IiwiYXhpc0xlbmd0aCIsImJpbldpZHRoIiwidHJ1bmNhdGVkQmlucyIsImxlbmd0aCIsImMiLCJiaW4iLCJkIiwiSW5maW5pdHkiLCJzb3J0Iiwic3BsaXRDb3VudCIsImJpIiwic3BsaWNlIiwiY2VudGVyIiwibGVmdENvdW50IiwicmlnaHRDb3VudCIsInJpZ2h0Qm91bmRzIiwibGVmdFByb2IiLCJyaWdodFByb2IiLCJjb3N0IiwiaSIsInRyaUNlbnRlciIsInJlbGF0aXZlQ2VudGVyIiwiYmluSW5kZXgiLCJsYXN0QmluIiwibmV4dEJpbiIsImJpbkNvdW50IiwiY29uc29sZSIsIndhcm4iLCJhdmciLCJlbmQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/build/splitUtils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/bvhcast.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/bvhcast.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   bvhcast: () => (/* binding */ bvhcast)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../utils/BufferStack.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/utils/BufferStack.js\");\n/* harmony import */ var _utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/nodeBufferUtils.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/utils/nodeBufferUtils.js\");\n/* harmony import */ var _utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/ArrayBoxUtilities.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js\");\n/* harmony import */ var _utils_PrimitivePool_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/PrimitivePool.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/PrimitivePool.js\");\n\n\n\n\n\nconst _bufferStack1 = new _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_0__.BufferStack.constructor();\nconst _bufferStack2 = new _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_0__.BufferStack.constructor();\nconst _boxPool = new _utils_PrimitivePool_js__WEBPACK_IMPORTED_MODULE_1__.PrimitivePool(()=>new three__WEBPACK_IMPORTED_MODULE_2__.Box3());\nconst _leftBox1 = new three__WEBPACK_IMPORTED_MODULE_2__.Box3();\nconst _rightBox1 = new three__WEBPACK_IMPORTED_MODULE_2__.Box3();\nconst _leftBox2 = new three__WEBPACK_IMPORTED_MODULE_2__.Box3();\nconst _rightBox2 = new three__WEBPACK_IMPORTED_MODULE_2__.Box3();\nlet _active = false;\nfunction bvhcast(bvh, otherBvh, matrixToLocal, intersectsRanges) {\n    if (_active) {\n        throw new Error(\"MeshBVH: Recursive calls to bvhcast not supported.\");\n    }\n    _active = true;\n    const roots = bvh._roots;\n    const otherRoots = otherBvh._roots;\n    let result;\n    let offset1 = 0;\n    let offset2 = 0;\n    const invMat = new three__WEBPACK_IMPORTED_MODULE_2__.Matrix4().copy(matrixToLocal).invert();\n    // iterate over the first set of roots\n    for(let i = 0, il = roots.length; i < il; i++){\n        _bufferStack1.setBuffer(roots[i]);\n        offset2 = 0;\n        // prep the initial root box\n        const localBox = _boxPool.getPrimitive();\n        (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_3__.arrayToBox)((0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.BOUNDING_DATA_INDEX)(0), _bufferStack1.float32Array, localBox);\n        localBox.applyMatrix4(invMat);\n        // iterate over the second set of roots\n        for(let j = 0, jl = otherRoots.length; j < jl; j++){\n            _bufferStack2.setBuffer(otherRoots[i]);\n            result = _traverse(0, 0, matrixToLocal, invMat, intersectsRanges, offset1, offset2, 0, 0, localBox);\n            _bufferStack2.clearBuffer();\n            offset2 += otherRoots[j].length;\n            if (result) {\n                break;\n            }\n        }\n        // release stack info\n        _boxPool.releasePrimitive(localBox);\n        _bufferStack1.clearBuffer();\n        offset1 += roots[i].length;\n        if (result) {\n            break;\n        }\n    }\n    _active = false;\n    return result;\n}\nfunction _traverse(node1Index32, node2Index32, matrix2to1, matrix1to2, intersectsRangesFunc, // offsets for ids\nnode1IndexByteOffset = 0, node2IndexByteOffset = 0, // tree depth\ndepth1 = 0, depth2 = 0, currBox = null, reversed = false) {\n    // get the buffer stacks associated with the current indices\n    let bufferStack1, bufferStack2;\n    if (reversed) {\n        bufferStack1 = _bufferStack2;\n        bufferStack2 = _bufferStack1;\n    } else {\n        bufferStack1 = _bufferStack1;\n        bufferStack2 = _bufferStack2;\n    }\n    // get the local instances of the typed buffers\n    const float32Array1 = bufferStack1.float32Array, uint32Array1 = bufferStack1.uint32Array, uint16Array1 = bufferStack1.uint16Array, float32Array2 = bufferStack2.float32Array, uint32Array2 = bufferStack2.uint32Array, uint16Array2 = bufferStack2.uint16Array;\n    const node1Index16 = node1Index32 * 2;\n    const node2Index16 = node2Index32 * 2;\n    const isLeaf1 = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.IS_LEAF)(node1Index16, uint16Array1);\n    const isLeaf2 = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.IS_LEAF)(node2Index16, uint16Array2);\n    let result = false;\n    if (isLeaf2 && isLeaf1) {\n        // if both bounds are leaf nodes then fire the callback if the boxes intersect\n        if (reversed) {\n            result = intersectsRangesFunc((0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.OFFSET)(node2Index32, uint32Array2), (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.COUNT)(node2Index32 * 2, uint16Array2), (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.OFFSET)(node1Index32, uint32Array1), (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.COUNT)(node1Index32 * 2, uint16Array1), depth2, node2IndexByteOffset + node2Index32, depth1, node1IndexByteOffset + node1Index32);\n        } else {\n            result = intersectsRangesFunc((0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.OFFSET)(node1Index32, uint32Array1), (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.COUNT)(node1Index32 * 2, uint16Array1), (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.OFFSET)(node2Index32, uint32Array2), (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.COUNT)(node2Index32 * 2, uint16Array2), depth1, node1IndexByteOffset + node1Index32, depth2, node2IndexByteOffset + node2Index32);\n        }\n    } else if (isLeaf2) {\n        // SWAP\n        // If we've traversed to the leaf node on the other bvh then we need to swap over\n        // to traverse down the first one\n        // get the new box to use\n        const newBox = _boxPool.getPrimitive();\n        (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_3__.arrayToBox)((0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.BOUNDING_DATA_INDEX)(node2Index32), float32Array2, newBox);\n        newBox.applyMatrix4(matrix2to1);\n        // get the child bounds to check before traversal\n        const cl1 = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.LEFT_NODE)(node1Index32);\n        const cr1 = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.RIGHT_NODE)(node1Index32, uint32Array1);\n        (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_3__.arrayToBox)((0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.BOUNDING_DATA_INDEX)(cl1), float32Array1, _leftBox1);\n        (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_3__.arrayToBox)((0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.BOUNDING_DATA_INDEX)(cr1), float32Array1, _rightBox1);\n        // precompute the intersections otherwise the global boxes will be modified during traversal\n        const intersectCl1 = newBox.intersectsBox(_leftBox1);\n        const intersectCr1 = newBox.intersectsBox(_rightBox1);\n        result = intersectCl1 && _traverse(node2Index32, cl1, matrix1to2, matrix2to1, intersectsRangesFunc, node2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1, newBox, !reversed) || intersectCr1 && _traverse(node2Index32, cr1, matrix1to2, matrix2to1, intersectsRangesFunc, node2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1, newBox, !reversed);\n        _boxPool.releasePrimitive(newBox);\n    } else {\n        // if neither are leaves then we should swap if one of the children does not\n        // intersect with the current bounds\n        // get the child bounds to check\n        const cl2 = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.LEFT_NODE)(node2Index32);\n        const cr2 = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.RIGHT_NODE)(node2Index32, uint32Array2);\n        (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_3__.arrayToBox)((0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.BOUNDING_DATA_INDEX)(cl2), float32Array2, _leftBox2);\n        (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_3__.arrayToBox)((0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.BOUNDING_DATA_INDEX)(cr2), float32Array2, _rightBox2);\n        const leftIntersects = currBox.intersectsBox(_leftBox2);\n        const rightIntersects = currBox.intersectsBox(_rightBox2);\n        if (leftIntersects && rightIntersects) {\n            // continue to traverse both children if they both intersect\n            result = _traverse(node1Index32, cl2, matrix2to1, matrix1to2, intersectsRangesFunc, node1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1, currBox, reversed) || _traverse(node1Index32, cr2, matrix2to1, matrix1to2, intersectsRangesFunc, node1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1, currBox, reversed);\n        } else if (leftIntersects) {\n            if (isLeaf1) {\n                // if the current box is a leaf then just continue\n                result = _traverse(node1Index32, cl2, matrix2to1, matrix1to2, intersectsRangesFunc, node1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1, currBox, reversed);\n            } else {\n                // SWAP\n                // if only one box intersects then we have to swap to the other bvh to continue\n                const newBox = _boxPool.getPrimitive();\n                newBox.copy(_leftBox2).applyMatrix4(matrix2to1);\n                const cl1 = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.LEFT_NODE)(node1Index32);\n                const cr1 = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.RIGHT_NODE)(node1Index32, uint32Array1);\n                (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_3__.arrayToBox)((0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.BOUNDING_DATA_INDEX)(cl1), float32Array1, _leftBox1);\n                (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_3__.arrayToBox)((0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.BOUNDING_DATA_INDEX)(cr1), float32Array1, _rightBox1);\n                // precompute the intersections otherwise the global boxes will be modified during traversal\n                const intersectCl1 = newBox.intersectsBox(_leftBox1);\n                const intersectCr1 = newBox.intersectsBox(_rightBox1);\n                result = intersectCl1 && _traverse(cl2, cl1, matrix1to2, matrix2to1, intersectsRangesFunc, node2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1, newBox, !reversed) || intersectCr1 && _traverse(cl2, cr1, matrix1to2, matrix2to1, intersectsRangesFunc, node2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1, newBox, !reversed);\n                _boxPool.releasePrimitive(newBox);\n            }\n        } else if (rightIntersects) {\n            if (isLeaf1) {\n                // if the current box is a leaf then just continue\n                result = _traverse(node1Index32, cr2, matrix2to1, matrix1to2, intersectsRangesFunc, node1IndexByteOffset, node2IndexByteOffset, depth1, depth2 + 1, currBox, reversed);\n            } else {\n                // SWAP\n                // if only one box intersects then we have to swap to the other bvh to continue\n                const newBox = _boxPool.getPrimitive();\n                newBox.copy(_rightBox2).applyMatrix4(matrix2to1);\n                const cl1 = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.LEFT_NODE)(node1Index32);\n                const cr1 = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.RIGHT_NODE)(node1Index32, uint32Array1);\n                (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_3__.arrayToBox)((0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.BOUNDING_DATA_INDEX)(cl1), float32Array1, _leftBox1);\n                (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_3__.arrayToBox)((0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.BOUNDING_DATA_INDEX)(cr1), float32Array1, _rightBox1);\n                // precompute the intersections otherwise the global boxes will be modified during traversal\n                const intersectCl1 = newBox.intersectsBox(_leftBox1);\n                const intersectCr1 = newBox.intersectsBox(_rightBox1);\n                result = intersectCl1 && _traverse(cr2, cl1, matrix1to2, matrix2to1, intersectsRangesFunc, node2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1, newBox, !reversed) || intersectCr1 && _traverse(cr2, cr1, matrix1to2, matrix2to1, intersectsRangesFunc, node2IndexByteOffset, node1IndexByteOffset, depth2, depth1 + 1, newBox, !reversed);\n                _boxPool.releasePrimitive(newBox);\n            }\n        }\n    }\n    return result;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9jb3JlL2Nhc3QvYnZoY2FzdC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBc0M7QUFDZ0I7QUFDMkQ7QUFDbkQ7QUFDRDtBQUU3RCxNQUFNVyxnQkFBZ0IsSUFBSVQsOERBQVdBLENBQUNVLFdBQVc7QUFDakQsTUFBTUMsZ0JBQWdCLElBQUlYLDhEQUFXQSxDQUFDVSxXQUFXO0FBQ2pELE1BQU1FLFdBQVcsSUFBSUosa0VBQWFBLENBQUUsSUFBTSxJQUFJVix1Q0FBSUE7QUFDbEQsTUFBTWUsWUFBWSxJQUFJZix1Q0FBSUE7QUFDMUIsTUFBTWdCLGFBQWEsSUFBSWhCLHVDQUFJQTtBQUUzQixNQUFNaUIsWUFBWSxJQUFJakIsdUNBQUlBO0FBQzFCLE1BQU1rQixhQUFhLElBQUlsQix1Q0FBSUE7QUFFM0IsSUFBSW1CLFVBQVU7QUFFUCxTQUFTQyxRQUFTQyxHQUFHLEVBQUVDLFFBQVEsRUFBRUMsYUFBYSxFQUFFQyxnQkFBZ0I7SUFFdEUsSUFBS0wsU0FBVTtRQUVkLE1BQU0sSUFBSU0sTUFBTztJQUVsQjtJQUVBTixVQUFVO0lBRVYsTUFBTU8sUUFBUUwsSUFBSU0sTUFBTTtJQUN4QixNQUFNQyxhQUFhTixTQUFTSyxNQUFNO0lBQ2xDLElBQUlFO0lBQ0osSUFBSUMsVUFBVTtJQUNkLElBQUlDLFVBQVU7SUFDZCxNQUFNQyxTQUFTLElBQUkvQiwwQ0FBT0EsR0FBR2dDLElBQUksQ0FBRVYsZUFBZ0JXLE1BQU07SUFFekQsc0NBQXNDO0lBQ3RDLElBQU0sSUFBSUMsSUFBSSxHQUFHQyxLQUFLVixNQUFNVyxNQUFNLEVBQUVGLElBQUlDLElBQUlELElBQU87UUFFbER4QixjQUFjMkIsU0FBUyxDQUFFWixLQUFLLENBQUVTLEVBQUc7UUFDbkNKLFVBQVU7UUFFViw0QkFBNEI7UUFDNUIsTUFBTVEsV0FBV3pCLFNBQVMwQixZQUFZO1FB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SUFBS1gsU0FBVTtnQkFFZCxrREFBa0Q7Z0JBQ2xEMUMsU0FBU2dCLFVBQ1JHLGNBQWNnQyxLQUFLOUIsWUFBWUMsWUFBWUMsc0JBQzNDQyxzQkFBc0JDLHNCQUFzQkMsUUFBUUMsU0FBUyxHQUM3REMsU0FBU0M7WUFHWCxPQUFPO2dCQUVOLE9BQU87Z0JBQ1AsK0VBQStFO2dCQUMvRSxNQUFNZSxTQUFTM0QsU0FBUzBCLFlBQVk7Z0JBQ3BDaUMsT0FBT3hDLElBQUksQ0FBRWYsWUFBYXdCLFlBQVksQ0FBRVE7Z0JBRXhDLE1BQU13QixNQUFNcEUsb0VBQVNBLENBQUUwQztnQkFDdkIsTUFBTTJCLE1BQU1uRSxxRUFBVUEsQ0FBRXdDLGNBQWNjO2dCQUN0Q3JELHVFQUFVQSxDQUFFTiw4RUFBbUJBLENBQUV1RSxNQUFPYixlQUFlOUM7Z0JBQ3ZETix1RUFBVUEsQ0FBRU4sOEVBQW1CQSxDQUFFd0UsTUFBT2QsZUFBZTdDO2dCQUV2RCw0RkFBNEY7Z0JBQzVGLE1BQU00RCxlQUFlSCxPQUFPSSxhQUFhLENBQUU5RDtnQkFDM0MsTUFBTStELGVBQWVMLE9BQU9JLGFBQWEsQ0FBRTdEO2dCQUMzQ2EsU0FBUyxnQkFDUWdCLFVBQ2ZtQyxLQUFLTixLQUFLdkIsWUFBWUQsWUFBWUUsc0JBQ2xDRSxzQkFBc0JELHNCQUFzQkcsUUFBUUQsU0FBUyxHQUM3RGtCLFFBQVEsQ0FBRWYsYUFHWG9CLGdCQUFnQmpDLFVBQ2ZtQyxLQUFLTCxLQUFLeEIsWUFBWUQsWUFBWUUsc0JBQ2xDRSxzQkFBc0JELHNCQUFzQkcsUUFBUUQsU0FBUyxHQUM3RGtCLFFBQVEsQ0FBRWY7Z0JBSVo1QyxTQUFTaUMsZ0JBQWdCLENBQUUwQjtZQUU1QjtRQUVEO0lBRUQ7SUFFQSxPQUFPNUM7QUFFUiIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpYmUtM2QtY29kZS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9ub2RlX21vZHVsZXMvdGhyZWUtbWVzaC1idmgvc3JjL2NvcmUvY2FzdC9idmhjYXN0LmpzPzNjYjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQm94MywgTWF0cml4NCB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IEJ1ZmZlclN0YWNrIH0gZnJvbSAnLi4vdXRpbHMvQnVmZmVyU3RhY2suanMnO1xuaW1wb3J0IHsgQk9VTkRJTkdfREFUQV9JTkRFWCwgQ09VTlQsIElTX0xFQUYsIExFRlRfTk9ERSwgT0ZGU0VULCBSSUdIVF9OT0RFIH0gZnJvbSAnLi4vdXRpbHMvbm9kZUJ1ZmZlclV0aWxzLmpzJztcbmltcG9ydCB7IGFycmF5VG9Cb3ggfSBmcm9tICcuLi8uLi91dGlscy9BcnJheUJveFV0aWxpdGllcy5qcyc7XG5pbXBvcnQgeyBQcmltaXRpdmVQb29sIH0gZnJvbSAnLi4vLi4vdXRpbHMvUHJpbWl0aXZlUG9vbC5qcyc7XG5cbmNvbnN0IF9idWZmZXJTdGFjazEgPSBuZXcgQnVmZmVyU3RhY2suY29uc3RydWN0b3IoKTtcbmNvbnN0IF9idWZmZXJTdGFjazIgPSBuZXcgQnVmZmVyU3RhY2suY29uc3RydWN0b3IoKTtcbmNvbnN0IF9ib3hQb29sID0gbmV3IFByaW1pdGl2ZVBvb2woICgpID0+IG5ldyBCb3gzKCkgKTtcbmNvbnN0IF9sZWZ0Qm94MSA9IG5ldyBCb3gzKCk7XG5jb25zdCBfcmlnaHRCb3gxID0gbmV3IEJveDMoKTtcblxuY29uc3QgX2xlZnRCb3gyID0gbmV3IEJveDMoKTtcbmNvbnN0IF9yaWdodEJveDIgPSBuZXcgQm94MygpO1xuXG5sZXQgX2FjdGl2ZSA9IGZhbHNlO1xuXG5leHBvcnQgZnVuY3Rpb24gYnZoY2FzdCggYnZoLCBvdGhlckJ2aCwgbWF0cml4VG9Mb2NhbCwgaW50ZXJzZWN0c1JhbmdlcyApIHtcblxuXHRpZiAoIF9hY3RpdmUgKSB7XG5cblx0XHR0aHJvdyBuZXcgRXJyb3IoICdNZXNoQlZIOiBSZWN1cnNpdmUgY2FsbHMgdG8gYnZoY2FzdCBub3Qgc3VwcG9ydGVkLicgKTtcblxuXHR9XG5cblx0X2FjdGl2ZSA9IHRydWU7XG5cblx0Y29uc3Qgcm9vdHMgPSBidmguX3Jvb3RzO1xuXHRjb25zdCBvdGhlclJvb3RzID0gb3RoZXJCdmguX3Jvb3RzO1xuXHRsZXQgcmVzdWx0O1xuXHRsZXQgb2Zmc2V0MSA9IDA7XG5cdGxldCBvZmZzZXQyID0gMDtcblx0Y29uc3QgaW52TWF0ID0gbmV3IE1hdHJpeDQoKS5jb3B5KCBtYXRyaXhUb0xvY2FsICkuaW52ZXJ0KCk7XG5cblx0Ly8gaXRlcmF0ZSBvdmVyIHRoZSBmaXJzdCBzZXQgb2Ygcm9vdHNcblx0Zm9yICggbGV0IGkgPSAwLCBpbCA9IHJvb3RzLmxlbmd0aDsgaSA8IGlsOyBpICsrICkge1xuXG5cdFx0X2J1ZmZlclN0YWNrMS5zZXRCdWZmZXIoIHJvb3RzWyBpIF0gKTtcblx0XHRvZmZzZXQyID0gMDtcblxuXHRcdC8vIHByZXAgdGhlIGluaXRpYWwgcm9vdCBib3hcblx0XHRjb25zdCBsb2NhbEJveCA9IF9ib3hQb29sLmdldFByaW1pdGl2ZSgpO1xuXHRcdGFycmF5VG9Cb3goIEJPVU5ESU5HX0RBVEFfSU5ERVgoIDAgKSwgX2J1ZmZlclN0YWNrMS5mbG9hdDMyQXJyYXksIGxvY2FsQm94ICk7XG5cdFx0bG9jYWxCb3guYXBwbHlNYXRyaXg0KCBpbnZNYXQgKTtcblxuXHRcdC8vIGl0ZXJhdGUgb3ZlciB0aGUgc2Vjb25kIHNldCBvZiByb290c1xuXHRcdGZvciAoIGxldCBqID0gMCwgamwgPSBvdGhlclJvb3RzLmxlbmd0aDsgaiA8IGpsOyBqICsrICkge1xuXG5cdFx0XHRfYnVmZmVyU3RhY2syLnNldEJ1ZmZlciggb3RoZXJSb290c1sgaSBdICk7XG5cblx0XHRcdHJlc3VsdCA9IF90cmF2ZXJzZShcblx0XHRcdFx0MCwgMCwgbWF0cml4VG9Mb2NhbCwgaW52TWF0LCBpbnRlcnNlY3RzUmFuZ2VzLFxuXHRcdFx0XHRvZmZzZXQxLCBvZmZzZXQyLCAwLCAwLFxuXHRcdFx0XHRsb2NhbEJveCxcblx0XHRcdCk7XG5cblx0XHRcdF9idWZmZXJTdGFjazIuY2xlYXJCdWZmZXIoKTtcblx0XHRcdG9mZnNldDIgKz0gb3RoZXJSb290c1sgaiBdLmxlbmd0aDtcblxuXHRcdFx0aWYgKCByZXN1bHQgKSB7XG5cblx0XHRcdFx0YnJlYWs7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIHJlbGVhc2Ugc3RhY2sgaW5mb1xuXHRcdF9ib3hQb29sLnJlbGVhc2VQcmltaXRpdmUoIGxvY2FsQm94ICk7XG5cdFx0X2J1ZmZlclN0YWNrMS5jbGVhckJ1ZmZlcigpO1xuXHRcdG9mZnNldDEgKz0gcm9vdHNbIGkgXS5sZW5ndGg7XG5cblx0XHRpZiAoIHJlc3VsdCApIHtcblxuXHRcdFx0YnJlYWs7XG5cblx0XHR9XG5cblx0fVxuXG5cdF9hY3RpdmUgPSBmYWxzZTtcblx0cmV0dXJuIHJlc3VsdDtcblxufVxuXG5mdW5jdGlvbiBfdHJhdmVyc2UoXG5cdG5vZGUxSW5kZXgzMixcblx0bm9kZTJJbmRleDMyLFxuXHRtYXRyaXgydG8xLFxuXHRtYXRyaXgxdG8yLFxuXHRpbnRlcnNlY3RzUmFuZ2VzRnVuYyxcblxuXHQvLyBvZmZzZXRzIGZvciBpZHNcblx0bm9kZTFJbmRleEJ5dGVPZmZzZXQgPSAwLFxuXHRub2RlMkluZGV4Qnl0ZU9mZnNldCA9IDAsXG5cblx0Ly8gdHJlZSBkZXB0aFxuXHRkZXB0aDEgPSAwLFxuXHRkZXB0aDIgPSAwLFxuXG5cdGN1cnJCb3ggPSBudWxsLFxuXHRyZXZlcnNlZCA9IGZhbHNlLFxuXG4pIHtcblxuXHQvLyBnZXQgdGhlIGJ1ZmZlciBzdGFja3MgYXNzb2NpYXRlZCB3aXRoIHRoZSBjdXJyZW50IGluZGljZXNcblx0bGV0IGJ1ZmZlclN0YWNrMSwgYnVmZmVyU3RhY2syO1xuXHRpZiAoIHJldmVyc2VkICkge1xuXG5cdFx0YnVmZmVyU3RhY2sxID0gX2J1ZmZlclN0YWNrMjtcblx0XHRidWZmZXJTdGFjazIgPSBfYnVmZmVyU3RhY2sxO1xuXG5cdH0gZWxzZSB7XG5cblx0XHRidWZmZXJTdGFjazEgPSBfYnVmZmVyU3RhY2sxO1xuXHRcdGJ1ZmZlclN0YWNrMiA9IF9idWZmZXJTdGFjazI7XG5cblx0fVxuXG5cdC8vIGdldCB0aGUgbG9jYWwgaW5zdGFuY2VzIG9mIHRoZSB0eXBlZCBidWZmZXJzXG5cdGNvbnN0XG5cdFx0ZmxvYXQzMkFycmF5MSA9IGJ1ZmZlclN0YWNrMS5mbG9hdDMyQXJyYXksXG5cdFx0dWludDMyQXJyYXkxID0gYnVmZmVyU3RhY2sxLnVpbnQzMkFycmF5LFxuXHRcdHVpbnQxNkFycmF5MSA9IGJ1ZmZlclN0YWNrMS51aW50MTZBcnJheSxcblx0XHRmbG9hdDMyQXJyYXkyID0gYnVmZmVyU3RhY2syLmZsb2F0MzJBcnJheSxcblx0XHR1aW50MzJBcnJheTIgPSBidWZmZXJTdGFjazIudWludDMyQXJyYXksXG5cdFx0dWludDE2QXJyYXkyID0gYnVmZmVyU3RhY2syLnVpbnQxNkFycmF5O1xuXG5cdGNvbnN0IG5vZGUxSW5kZXgxNiA9IG5vZGUxSW5kZXgzMiAqIDI7XG5cdGNvbnN0IG5vZGUySW5kZXgxNiA9IG5vZGUySW5kZXgzMiAqIDI7XG5cdGNvbnN0IGlzTGVhZjEgPSBJU19MRUFGKCBub2RlMUluZGV4MTYsIHVpbnQxNkFycmF5MSApO1xuXHRjb25zdCBpc0xlYWYyID0gSVNfTEVBRiggbm9kZTJJbmRleDE2LCB1aW50MTZBcnJheTIgKTtcblx0bGV0IHJlc3VsdCA9IGZhbHNlO1xuXHRpZiAoIGlzTGVhZjIgJiYgaXNMZWFmMSApIHtcblxuXHRcdC8vIGlmIGJvdGggYm91bmRzIGFyZSBsZWFmIG5vZGVzIHRoZW4gZmlyZSB0aGUgY2FsbGJhY2sgaWYgdGhlIGJveGVzIGludGVyc2VjdFxuXHRcdGlmICggcmV2ZXJzZWQgKSB7XG5cblx0XHRcdHJlc3VsdCA9IGludGVyc2VjdHNSYW5nZXNGdW5jKFxuXHRcdFx0XHRPRkZTRVQoIG5vZGUySW5kZXgzMiwgdWludDMyQXJyYXkyICksIENPVU5UKCBub2RlMkluZGV4MzIgKiAyLCB1aW50MTZBcnJheTIgKSxcblx0XHRcdFx0T0ZGU0VUKCBub2RlMUluZGV4MzIsIHVpbnQzMkFycmF5MSApLCBDT1VOVCggbm9kZTFJbmRleDMyICogMiwgdWludDE2QXJyYXkxICksXG5cdFx0XHRcdGRlcHRoMiwgbm9kZTJJbmRleEJ5dGVPZmZzZXQgKyBub2RlMkluZGV4MzIsXG5cdFx0XHRcdGRlcHRoMSwgbm9kZTFJbmRleEJ5dGVPZmZzZXQgKyBub2RlMUluZGV4MzIsXG5cdFx0XHQpO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmVzdWx0ID0gaW50ZXJzZWN0c1Jhbmdlc0Z1bmMoXG5cdFx0XHRcdE9GRlNFVCggbm9kZTFJbmRleDMyLCB1aW50MzJBcnJheTEgKSwgQ09VTlQoIG5vZGUxSW5kZXgzMiAqIDIsIHVpbnQxNkFycmF5MSApLFxuXHRcdFx0XHRPRkZTRVQoIG5vZGUySW5kZXgzMiwgdWludDMyQXJyYXkyICksIENPVU5UKCBub2RlMkluZGV4MzIgKiAyLCB1aW50MTZBcnJheTIgKSxcblx0XHRcdFx0ZGVwdGgxLCBub2RlMUluZGV4Qnl0ZU9mZnNldCArIG5vZGUxSW5kZXgzMixcblx0XHRcdFx0ZGVwdGgyLCBub2RlMkluZGV4Qnl0ZU9mZnNldCArIG5vZGUySW5kZXgzMixcblx0XHRcdCk7XG5cblx0XHR9XG5cblx0fSBlbHNlIGlmICggaXNMZWFmMiApIHtcblxuXHRcdC8vIFNXQVBcblx0XHQvLyBJZiB3ZSd2ZSB0cmF2ZXJzZWQgdG8gdGhlIGxlYWYgbm9kZSBvbiB0aGUgb3RoZXIgYnZoIHRoZW4gd2UgbmVlZCB0byBzd2FwIG92ZXJcblx0XHQvLyB0byB0cmF2ZXJzZSBkb3duIHRoZSBmaXJzdCBvbmVcblxuXHRcdC8vIGdldCB0aGUgbmV3IGJveCB0byB1c2Vcblx0XHRjb25zdCBuZXdCb3ggPSBfYm94UG9vbC5nZXRQcmltaXRpdmUoKTtcblx0XHRhcnJheVRvQm94KCBCT1VORElOR19EQVRBX0lOREVYKCBub2RlMkluZGV4MzIgKSwgZmxvYXQzMkFycmF5MiwgbmV3Qm94ICk7XG5cdFx0bmV3Qm94LmFwcGx5TWF0cml4NCggbWF0cml4MnRvMSApO1xuXG5cdFx0Ly8gZ2V0IHRoZSBjaGlsZCBib3VuZHMgdG8gY2hlY2sgYmVmb3JlIHRyYXZlcnNhbFxuXHRcdGNvbnN0IGNsMSA9IExFRlRfTk9ERSggbm9kZTFJbmRleDMyICk7XG5cdFx0Y29uc3QgY3IxID0gUklHSFRfTk9ERSggbm9kZTFJbmRleDMyLCB1aW50MzJBcnJheTEgKTtcblx0XHRhcnJheVRvQm94KCBCT1VORElOR19EQVRBX0lOREVYKCBjbDEgKSwgZmxvYXQzMkFycmF5MSwgX2xlZnRCb3gxICk7XG5cdFx0YXJyYXlUb0JveCggQk9VTkRJTkdfREFUQV9JTkRFWCggY3IxICksIGZsb2F0MzJBcnJheTEsIF9yaWdodEJveDEgKTtcblxuXHRcdC8vIHByZWNvbXB1dGUgdGhlIGludGVyc2VjdGlvbnMgb3RoZXJ3aXNlIHRoZSBnbG9iYWwgYm94ZXMgd2lsbCBiZSBtb2RpZmllZCBkdXJpbmcgdHJhdmVyc2FsXG5cdFx0Y29uc3QgaW50ZXJzZWN0Q2wxID0gbmV3Qm94LmludGVyc2VjdHNCb3goIF9sZWZ0Qm94MSApO1xuXHRcdGNvbnN0IGludGVyc2VjdENyMSA9IG5ld0JveC5pbnRlcnNlY3RzQm94KCBfcmlnaHRCb3gxICk7XG5cdFx0cmVzdWx0ID0gKFxuXHRcdFx0aW50ZXJzZWN0Q2wxICYmIF90cmF2ZXJzZShcblx0XHRcdFx0bm9kZTJJbmRleDMyLCBjbDEsIG1hdHJpeDF0bzIsIG1hdHJpeDJ0bzEsIGludGVyc2VjdHNSYW5nZXNGdW5jLFxuXHRcdFx0XHRub2RlMkluZGV4Qnl0ZU9mZnNldCwgbm9kZTFJbmRleEJ5dGVPZmZzZXQsIGRlcHRoMiwgZGVwdGgxICsgMSxcblx0XHRcdFx0bmV3Qm94LCAhIHJldmVyc2VkLFxuXHRcdFx0KVxuXHRcdCkgfHwgKFxuXHRcdFx0aW50ZXJzZWN0Q3IxICYmIF90cmF2ZXJzZShcblx0XHRcdFx0bm9kZTJJbmRleDMyLCBjcjEsIG1hdHJpeDF0bzIsIG1hdHJpeDJ0bzEsIGludGVyc2VjdHNSYW5nZXNGdW5jLFxuXHRcdFx0XHRub2RlMkluZGV4Qnl0ZU9mZnNldCwgbm9kZTFJbmRleEJ5dGVPZmZzZXQsIGRlcHRoMiwgZGVwdGgxICsgMSxcblx0XHRcdFx0bmV3Qm94LCAhIHJldmVyc2VkLFxuXHRcdFx0KVxuXHRcdCk7XG5cblx0XHRfYm94UG9vbC5yZWxlYXNlUHJpbWl0aXZlKCBuZXdCb3ggKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gaWYgbmVpdGhlciBhcmUgbGVhdmVzIHRoZW4gd2Ugc2hvdWxkIHN3YXAgaWYgb25lIG9mIHRoZSBjaGlsZHJlbiBkb2VzIG5vdFxuXHRcdC8vIGludGVyc2VjdCB3aXRoIHRoZSBjdXJyZW50IGJvdW5kc1xuXG5cdFx0Ly8gZ2V0IHRoZSBjaGlsZCBib3VuZHMgdG8gY2hlY2tcblx0XHRjb25zdCBjbDIgPSBMRUZUX05PREUoIG5vZGUySW5kZXgzMiApO1xuXHRcdGNvbnN0IGNyMiA9IFJJR0hUX05PREUoIG5vZGUySW5kZXgzMiwgdWludDMyQXJyYXkyICk7XG5cdFx0YXJyYXlUb0JveCggQk9VTkRJTkdfREFUQV9JTkRFWCggY2wyICksIGZsb2F0MzJBcnJheTIsIF9sZWZ0Qm94MiApO1xuXHRcdGFycmF5VG9Cb3goIEJPVU5ESU5HX0RBVEFfSU5ERVgoIGNyMiApLCBmbG9hdDMyQXJyYXkyLCBfcmlnaHRCb3gyICk7XG5cblx0XHRjb25zdCBsZWZ0SW50ZXJzZWN0cyA9IGN1cnJCb3guaW50ZXJzZWN0c0JveCggX2xlZnRCb3gyICk7XG5cdFx0Y29uc3QgcmlnaHRJbnRlcnNlY3RzID0gY3VyckJveC5pbnRlcnNlY3RzQm94KCBfcmlnaHRCb3gyICk7XG5cdFx0aWYgKCBsZWZ0SW50ZXJzZWN0cyAmJiByaWdodEludGVyc2VjdHMgKSB7XG5cblx0XHRcdC8vIGNvbnRpbnVlIHRvIHRyYXZlcnNlIGJvdGggY2hpbGRyZW4gaWYgdGhleSBib3RoIGludGVyc2VjdFxuXHRcdFx0cmVzdWx0ID0gX3RyYXZlcnNlKFxuXHRcdFx0XHRub2RlMUluZGV4MzIsIGNsMiwgbWF0cml4MnRvMSwgbWF0cml4MXRvMiwgaW50ZXJzZWN0c1Jhbmdlc0Z1bmMsXG5cdFx0XHRcdG5vZGUxSW5kZXhCeXRlT2Zmc2V0LCBub2RlMkluZGV4Qnl0ZU9mZnNldCwgZGVwdGgxLCBkZXB0aDIgKyAxLFxuXHRcdFx0XHRjdXJyQm94LCByZXZlcnNlZCxcblx0XHRcdCkgfHwgX3RyYXZlcnNlKFxuXHRcdFx0XHRub2RlMUluZGV4MzIsIGNyMiwgbWF0cml4MnRvMSwgbWF0cml4MXRvMiwgaW50ZXJzZWN0c1Jhbmdlc0Z1bmMsXG5cdFx0XHRcdG5vZGUxSW5kZXhCeXRlT2Zmc2V0LCBub2RlMkluZGV4Qnl0ZU9mZnNldCwgZGVwdGgxLCBkZXB0aDIgKyAxLFxuXHRcdFx0XHRjdXJyQm94LCByZXZlcnNlZCxcblx0XHRcdCk7XG5cblx0XHR9IGVsc2UgaWYgKCBsZWZ0SW50ZXJzZWN0cyApIHtcblxuXHRcdFx0aWYgKCBpc0xlYWYxICkge1xuXG5cdFx0XHRcdC8vIGlmIHRoZSBjdXJyZW50IGJveCBpcyBhIGxlYWYgdGhlbiBqdXN0IGNvbnRpbnVlXG5cdFx0XHRcdHJlc3VsdCA9IF90cmF2ZXJzZShcblx0XHRcdFx0XHRub2RlMUluZGV4MzIsIGNsMiwgbWF0cml4MnRvMSwgbWF0cml4MXRvMiwgaW50ZXJzZWN0c1Jhbmdlc0Z1bmMsXG5cdFx0XHRcdFx0bm9kZTFJbmRleEJ5dGVPZmZzZXQsIG5vZGUySW5kZXhCeXRlT2Zmc2V0LCBkZXB0aDEsIGRlcHRoMiArIDEsXG5cdFx0XHRcdFx0Y3VyckJveCwgcmV2ZXJzZWQsXG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gU1dBUFxuXHRcdFx0XHQvLyBpZiBvbmx5IG9uZSBib3ggaW50ZXJzZWN0cyB0aGVuIHdlIGhhdmUgdG8gc3dhcCB0byB0aGUgb3RoZXIgYnZoIHRvIGNvbnRpbnVlXG5cdFx0XHRcdGNvbnN0IG5ld0JveCA9IF9ib3hQb29sLmdldFByaW1pdGl2ZSgpO1xuXHRcdFx0XHRuZXdCb3guY29weSggX2xlZnRCb3gyICkuYXBwbHlNYXRyaXg0KCBtYXRyaXgydG8xICk7XG5cblx0XHRcdFx0Y29uc3QgY2wxID0gTEVGVF9OT0RFKCBub2RlMUluZGV4MzIgKTtcblx0XHRcdFx0Y29uc3QgY3IxID0gUklHSFRfTk9ERSggbm9kZTFJbmRleDMyLCB1aW50MzJBcnJheTEgKTtcblx0XHRcdFx0YXJyYXlUb0JveCggQk9VTkRJTkdfREFUQV9JTkRFWCggY2wxICksIGZsb2F0MzJBcnJheTEsIF9sZWZ0Qm94MSApO1xuXHRcdFx0XHRhcnJheVRvQm94KCBCT1VORElOR19EQVRBX0lOREVYKCBjcjEgKSwgZmxvYXQzMkFycmF5MSwgX3JpZ2h0Qm94MSApO1xuXG5cdFx0XHRcdC8vIHByZWNvbXB1dGUgdGhlIGludGVyc2VjdGlvbnMgb3RoZXJ3aXNlIHRoZSBnbG9iYWwgYm94ZXMgd2lsbCBiZSBtb2RpZmllZCBkdXJpbmcgdHJhdmVyc2FsXG5cdFx0XHRcdGNvbnN0IGludGVyc2VjdENsMSA9IG5ld0JveC5pbnRlcnNlY3RzQm94KCBfbGVmdEJveDEgKTtcblx0XHRcdFx0Y29uc3QgaW50ZXJzZWN0Q3IxID0gbmV3Qm94LmludGVyc2VjdHNCb3goIF9yaWdodEJveDEgKTtcblx0XHRcdFx0cmVzdWx0ID0gKFxuXHRcdFx0XHRcdGludGVyc2VjdENsMSAmJiBfdHJhdmVyc2UoXG5cdFx0XHRcdFx0XHRjbDIsIGNsMSwgbWF0cml4MXRvMiwgbWF0cml4MnRvMSwgaW50ZXJzZWN0c1Jhbmdlc0Z1bmMsXG5cdFx0XHRcdFx0XHRub2RlMkluZGV4Qnl0ZU9mZnNldCwgbm9kZTFJbmRleEJ5dGVPZmZzZXQsIGRlcHRoMiwgZGVwdGgxICsgMSxcblx0XHRcdFx0XHRcdG5ld0JveCwgISByZXZlcnNlZCxcblx0XHRcdFx0XHQpXG5cdFx0XHRcdCkgfHwgKFxuXHRcdFx0XHRcdGludGVyc2VjdENyMSAmJiBfdHJhdmVyc2UoXG5cdFx0XHRcdFx0XHRjbDIsIGNyMSwgbWF0cml4MXRvMiwgbWF0cml4MnRvMSwgaW50ZXJzZWN0c1Jhbmdlc0Z1bmMsXG5cdFx0XHRcdFx0XHRub2RlMkluZGV4Qnl0ZU9mZnNldCwgbm9kZTFJbmRleEJ5dGVPZmZzZXQsIGRlcHRoMiwgZGVwdGgxICsgMSxcblx0XHRcdFx0XHRcdG5ld0JveCwgISByZXZlcnNlZCxcblx0XHRcdFx0XHQpXG5cdFx0XHRcdCk7XG5cblx0XHRcdFx0X2JveFBvb2wucmVsZWFzZVByaW1pdGl2ZSggbmV3Qm94ICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSBpZiAoIHJpZ2h0SW50ZXJzZWN0cyApIHtcblxuXHRcdFx0aWYgKCBpc0xlYWYxICkge1xuXG5cdFx0XHRcdC8vIGlmIHRoZSBjdXJyZW50IGJveCBpcyBhIGxlYWYgdGhlbiBqdXN0IGNvbnRpbnVlXG5cdFx0XHRcdHJlc3VsdCA9IF90cmF2ZXJzZShcblx0XHRcdFx0XHRub2RlMUluZGV4MzIsIGNyMiwgbWF0cml4MnRvMSwgbWF0cml4MXRvMiwgaW50ZXJzZWN0c1Jhbmdlc0Z1bmMsXG5cdFx0XHRcdFx0bm9kZTFJbmRleEJ5dGVPZmZzZXQsIG5vZGUySW5kZXhCeXRlT2Zmc2V0LCBkZXB0aDEsIGRlcHRoMiArIDEsXG5cdFx0XHRcdFx0Y3VyckJveCwgcmV2ZXJzZWQsXG5cdFx0XHRcdCk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0Ly8gU1dBUFxuXHRcdFx0XHQvLyBpZiBvbmx5IG9uZSBib3ggaW50ZXJzZWN0cyB0aGVuIHdlIGhhdmUgdG8gc3dhcCB0byB0aGUgb3RoZXIgYnZoIHRvIGNvbnRpbnVlXG5cdFx0XHRcdGNvbnN0IG5ld0JveCA9IF9ib3hQb29sLmdldFByaW1pdGl2ZSgpO1xuXHRcdFx0XHRuZXdCb3guY29weSggX3JpZ2h0Qm94MiApLmFwcGx5TWF0cml4NCggbWF0cml4MnRvMSApO1xuXG5cdFx0XHRcdGNvbnN0IGNsMSA9IExFRlRfTk9ERSggbm9kZTFJbmRleDMyICk7XG5cdFx0XHRcdGNvbnN0IGNyMSA9IFJJR0hUX05PREUoIG5vZGUxSW5kZXgzMiwgdWludDMyQXJyYXkxICk7XG5cdFx0XHRcdGFycmF5VG9Cb3goIEJPVU5ESU5HX0RBVEFfSU5ERVgoIGNsMSApLCBmbG9hdDMyQXJyYXkxLCBfbGVmdEJveDEgKTtcblx0XHRcdFx0YXJyYXlUb0JveCggQk9VTkRJTkdfREFUQV9JTkRFWCggY3IxICksIGZsb2F0MzJBcnJheTEsIF9yaWdodEJveDEgKTtcblxuXHRcdFx0XHQvLyBwcmVjb21wdXRlIHRoZSBpbnRlcnNlY3Rpb25zIG90aGVyd2lzZSB0aGUgZ2xvYmFsIGJveGVzIHdpbGwgYmUgbW9kaWZpZWQgZHVyaW5nIHRyYXZlcnNhbFxuXHRcdFx0XHRjb25zdCBpbnRlcnNlY3RDbDEgPSBuZXdCb3guaW50ZXJzZWN0c0JveCggX2xlZnRCb3gxICk7XG5cdFx0XHRcdGNvbnN0IGludGVyc2VjdENyMSA9IG5ld0JveC5pbnRlcnNlY3RzQm94KCBfcmlnaHRCb3gxICk7XG5cdFx0XHRcdHJlc3VsdCA9IChcblx0XHRcdFx0XHRpbnRlcnNlY3RDbDEgJiYgX3RyYXZlcnNlKFxuXHRcdFx0XHRcdFx0Y3IyLCBjbDEsIG1hdHJpeDF0bzIsIG1hdHJpeDJ0bzEsIGludGVyc2VjdHNSYW5nZXNGdW5jLFxuXHRcdFx0XHRcdFx0bm9kZTJJbmRleEJ5dGVPZmZzZXQsIG5vZGUxSW5kZXhCeXRlT2Zmc2V0LCBkZXB0aDIsIGRlcHRoMSArIDEsXG5cdFx0XHRcdFx0XHRuZXdCb3gsICEgcmV2ZXJzZWQsXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHQpIHx8IChcblx0XHRcdFx0XHRpbnRlcnNlY3RDcjEgJiYgX3RyYXZlcnNlKFxuXHRcdFx0XHRcdFx0Y3IyLCBjcjEsIG1hdHJpeDF0bzIsIG1hdHJpeDJ0bzEsIGludGVyc2VjdHNSYW5nZXNGdW5jLFxuXHRcdFx0XHRcdFx0bm9kZTJJbmRleEJ5dGVPZmZzZXQsIG5vZGUxSW5kZXhCeXRlT2Zmc2V0LCBkZXB0aDIsIGRlcHRoMSArIDEsXG5cdFx0XHRcdFx0XHRuZXdCb3gsICEgcmV2ZXJzZWQsXG5cdFx0XHRcdFx0KVxuXHRcdFx0XHQpO1xuXG5cdFx0XHRcdF9ib3hQb29sLnJlbGVhc2VQcmltaXRpdmUoIG5ld0JveCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0fVxuXG5cdHJldHVybiByZXN1bHQ7XG5cbn1cblxuIl0sIm5hbWVzIjpbIkJveDMiLCJNYXRyaXg0IiwiQnVmZmVyU3RhY2siLCJCT1VORElOR19EQVRBX0lOREVYIiwiQ09VTlQiLCJJU19MRUFGIiwiTEVGVF9OT0RFIiwiT0ZGU0VUIiwiUklHSFRfTk9ERSIsImFycmF5VG9Cb3giLCJQcmltaXRpdmVQb29sIiwiX2J1ZmZlclN0YWNrMSIsImNvbnN0cnVjdG9yIiwiX2J1ZmZlclN0YWNrMiIsIl9ib3hQb29sIiwiX2xlZnRCb3gxIiwiX3JpZ2h0Qm94MSIsIl9sZWZ0Qm94MiIsIl9yaWdodEJveDIiLCJfYWN0aXZlIiwiYnZoY2FzdCIsImJ2aCIsIm90aGVyQnZoIiwibWF0cml4VG9Mb2NhbCIsImludGVyc2VjdHNSYW5nZXMiLCJFcnJvciIsInJvb3RzIiwiX3Jvb3RzIiwib3RoZXJSb290cyIsInJlc3VsdCIsIm9mZnNldDEiLCJvZmZzZXQyIiwiaW52TWF0IiwiY29weSIsImludmVydCIsImkiLCJpbCIsImxlbmd0aCIsInNldEJ1ZmZlciIsImxvY2FsQm94IiwiZ2V0UHJpbWl0aXZlIiwiZmxvYXQzMkFycmF5IiwiYXBwbHlNYXRyaXg0IiwiaiIsImpsIiwiX3RyYXZlcnNlIiwiY2xlYXJCdWZmZXIiLCJyZWxlYXNlUHJpbWl0aXZlIiwibm9kZTFJbmRleDMyIiwibm9kZTJJbmRleDMyIiwibWF0cml4MnRvMSIsIm1hdHJpeDF0bzIiLCJpbnRlcnNlY3RzUmFuZ2VzRnVuYyIsIm5vZGUxSW5kZXhCeXRlT2Zmc2V0Iiwibm9kZTJJbmRleEJ5dGVPZmZzZXQiLCJkZXB0aDEiLCJkZXB0aDIiLCJjdXJyQm94IiwicmV2ZXJzZWQiLCJidWZmZXJTdGFjazEiLCJidWZmZXJTdGFjazIiLCJmbG9hdDMyQXJyYXkxIiwidWludDMyQXJyYXkxIiwidWludDMyQXJyYXkiLCJ1aW50MTZBcnJheTEiLCJ1aW50MTZBcnJheSIsImZsb2F0MzJBcnJheTIiLCJ1aW50MzJBcnJheTIiLCJ1aW50MTZBcnJheTIiLCJub2RlMUluZGV4MTYiLCJub2RlMkluZGV4MTYiLCJpc0xlYWYxIiwiaXNMZWFmMiIsIm5ld0JveCIsImNsMSIsImNyMSIsImludGVyc2VjdENsMSIsImludGVyc2VjdHNCb3giLCJpbnRlcnNlY3RDcjEiLCJjbDIiLCJjcjIiLCJsZWZ0SW50ZXJzZWN0cyIsInJpZ2h0SW50ZXJzZWN0cyJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/bvhcast.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry.generated.js":
/*!**********************************************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry.generated.js ***!
  \**********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closestPointToGeometry: () => (/* binding */ closestPointToGeometry)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var _math_OrientedBox_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/OrientedBox.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/math/OrientedBox.js\");\n/* harmony import */ var _utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/TriangleUtilities.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js\");\n/* harmony import */ var _build_geometryUtils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../build/geometryUtils.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/build/geometryUtils.js\");\n/* harmony import */ var _utils_ExtendedTrianglePool_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/ExtendedTrianglePool.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/ExtendedTrianglePool.js\");\n\n\n\n\n\n/*********************************************************************/ /* This file is generated from \"closestPointToGeometry.template.js\". */ /*********************************************************************/ const tempMatrix = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\nconst obb = /* @__PURE__ */ new _math_OrientedBox_js__WEBPACK_IMPORTED_MODULE_1__.OrientedBox();\nconst obb2 = /* @__PURE__ */ new _math_OrientedBox_js__WEBPACK_IMPORTED_MODULE_1__.OrientedBox();\nconst temp1 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst temp2 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst temp3 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst temp4 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nfunction closestPointToGeometry(bvh, otherGeometry, geometryToBvh, target1 = {}, target2 = {}, minThreshold = 0, maxThreshold = Infinity) {\n    if (!otherGeometry.boundingBox) {\n        otherGeometry.computeBoundingBox();\n    }\n    obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);\n    obb.needsUpdate = true;\n    const geometry = bvh.geometry;\n    const pos = geometry.attributes.position;\n    const index = geometry.index;\n    const otherPos = otherGeometry.attributes.position;\n    const otherIndex = otherGeometry.index;\n    const triangle = _utils_ExtendedTrianglePool_js__WEBPACK_IMPORTED_MODULE_2__.ExtendedTrianglePool.getPrimitive();\n    const triangle2 = _utils_ExtendedTrianglePool_js__WEBPACK_IMPORTED_MODULE_2__.ExtendedTrianglePool.getPrimitive();\n    let tempTarget1 = temp1;\n    let tempTargetDest1 = temp2;\n    let tempTarget2 = null;\n    let tempTargetDest2 = null;\n    if (target2) {\n        tempTarget2 = temp3;\n        tempTargetDest2 = temp4;\n    }\n    let closestDistance = Infinity;\n    let closestDistanceTriIndex = null;\n    let closestDistanceOtherTriIndex = null;\n    tempMatrix.copy(geometryToBvh).invert();\n    obb2.matrix.copy(tempMatrix);\n    bvh.shapecast({\n        boundsTraverseOrder: (box)=>{\n            return obb.distanceToBox(box);\n        },\n        intersectsBounds: (box, isLeaf, score)=>{\n            if (score < closestDistance && score < maxThreshold) {\n                // if we know the triangles of this bounds will be intersected next then\n                // save the bounds to use during triangle checks.\n                if (isLeaf) {\n                    obb2.min.copy(box.min);\n                    obb2.max.copy(box.max);\n                    obb2.needsUpdate = true;\n                }\n                return true;\n            }\n            return false;\n        },\n        intersectsRange: (offset, count)=>{\n            if (otherGeometry.boundsTree) {\n                // if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n                // the closest bounds in the other geometry to check.\n                const otherBvh = otherGeometry.boundsTree;\n                return otherBvh.shapecast({\n                    boundsTraverseOrder: (box)=>{\n                        return obb2.distanceToBox(box);\n                    },\n                    intersectsBounds: (box, isLeaf, score)=>{\n                        return score < closestDistance && score < maxThreshold;\n                    },\n                    intersectsRange: (otherOffset, otherCount)=>{\n                        for(let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2++){\n                            (0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_3__.setTriangle)(triangle2, 3 * i2, otherIndex, otherPos);\n                            triangle2.a.applyMatrix4(geometryToBvh);\n                            triangle2.b.applyMatrix4(geometryToBvh);\n                            triangle2.c.applyMatrix4(geometryToBvh);\n                            triangle2.needsUpdate = true;\n                            for(let i = offset, l = offset + count; i < l; i++){\n                                (0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_3__.setTriangle)(triangle, 3 * i, index, pos);\n                                triangle.needsUpdate = true;\n                                const dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n                                if (dist < closestDistance) {\n                                    tempTargetDest1.copy(tempTarget1);\n                                    if (tempTargetDest2) {\n                                        tempTargetDest2.copy(tempTarget2);\n                                    }\n                                    closestDistance = dist;\n                                    closestDistanceTriIndex = i;\n                                    closestDistanceOtherTriIndex = i2;\n                                }\n                                // stop traversal if we find a point that's under the given threshold\n                                if (dist < minThreshold) {\n                                    return true;\n                                }\n                            }\n                        }\n                    }\n                });\n            } else {\n                // If no bounds tree then we'll just check every triangle.\n                const triCount = (0,_build_geometryUtils_js__WEBPACK_IMPORTED_MODULE_4__.getTriCount)(otherGeometry);\n                for(let i2 = 0, l2 = triCount; i2 < l2; i2++){\n                    (0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_3__.setTriangle)(triangle2, 3 * i2, otherIndex, otherPos);\n                    triangle2.a.applyMatrix4(geometryToBvh);\n                    triangle2.b.applyMatrix4(geometryToBvh);\n                    triangle2.c.applyMatrix4(geometryToBvh);\n                    triangle2.needsUpdate = true;\n                    for(let i = offset, l = offset + count; i < l; i++){\n                        (0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_3__.setTriangle)(triangle, 3 * i, index, pos);\n                        triangle.needsUpdate = true;\n                        const dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n                        if (dist < closestDistance) {\n                            tempTargetDest1.copy(tempTarget1);\n                            if (tempTargetDest2) {\n                                tempTargetDest2.copy(tempTarget2);\n                            }\n                            closestDistance = dist;\n                            closestDistanceTriIndex = i;\n                            closestDistanceOtherTriIndex = i2;\n                        }\n                        // stop traversal if we find a point that's under the given threshold\n                        if (dist < minThreshold) {\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n    });\n    _utils_ExtendedTrianglePool_js__WEBPACK_IMPORTED_MODULE_2__.ExtendedTrianglePool.releasePrimitive(triangle);\n    _utils_ExtendedTrianglePool_js__WEBPACK_IMPORTED_MODULE_2__.ExtendedTrianglePool.releasePrimitive(triangle2);\n    if (closestDistance === Infinity) {\n        return null;\n    }\n    if (!target1.point) {\n        target1.point = tempTargetDest1.clone();\n    } else {\n        target1.point.copy(tempTargetDest1);\n    }\n    target1.distance = closestDistance, target1.faceIndex = closestDistanceTriIndex;\n    if (target2) {\n        if (!target2.point) target2.point = tempTargetDest2.clone();\n        else target2.point.copy(tempTargetDest2);\n        target2.point.applyMatrix4(tempMatrix);\n        tempTargetDest1.applyMatrix4(tempMatrix);\n        target2.distance = tempTargetDest1.sub(target2.point).length();\n        target2.faceIndex = closestDistanceOtherTriIndex;\n    }\n    return target1;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9jb3JlL2Nhc3QvY2xvc2VzdFBvaW50VG9HZW9tZXRyeS5nZW5lcmF0ZWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXlDO0FBQ2U7QUFDTztBQUNQO0FBQ21CO0FBRTNFLHFFQUFxRSxHQUNyRSxxRUFBcUUsR0FDckUscUVBQXFFLEdBRXJFLE1BQU1NLGFBQWEsYUFBYSxHQUFHLElBQUlOLDBDQUFPQTtBQUM5QyxNQUFNTyxNQUFNLGFBQWEsR0FBRyxJQUFJTCw2REFBV0E7QUFDM0MsTUFBTU0sT0FBTyxhQUFhLEdBQUcsSUFBSU4sNkRBQVdBO0FBQzVDLE1BQU1PLFFBQVEsYUFBYSxHQUFHLElBQUlSLDBDQUFPQTtBQUN6QyxNQUFNUyxRQUFRLGFBQWEsR0FBRyxJQUFJVCwwQ0FBT0E7QUFDekMsTUFBTVUsUUFBUSxhQUFhLEdBQUcsSUFBSVYsMENBQU9BO0FBQ3pDLE1BQU1XLFFBQVEsYUFBYSxHQUFHLElBQUlYLDBDQUFPQTtBQUV6QyxTQUFTWSx1QkFDUkMsR0FBRyxFQUNIQyxhQUFhLEVBQ2JDLGFBQWEsRUFDYkMsVUFBVSxDQUFFLENBQUMsRUFDYkMsVUFBVSxDQUFFLENBQUMsRUFDYkMsZUFBZSxDQUFDLEVBQ2hCQyxlQUFlQyxRQUFRO0lBR3ZCLElBQUssQ0FBRU4sY0FBY08sV0FBVyxFQUFHO1FBRWxDUCxjQUFjUSxrQkFBa0I7SUFFakM7SUFFQWhCLElBQUlpQixHQUFHLENBQUVULGNBQWNPLFdBQVcsQ0FBQ0csR0FBRyxFQUFFVixjQUFjTyxXQUFXLENBQUNJLEdBQUcsRUFBRVY7SUFDdkVULElBQUlvQixXQUFXLEdBQUc7SUFFbEIsTUFBTUMsV0FBV2QsSUFBSWMsUUFBUTtJQUM3QixNQUFNQyxNQUFNRCxTQUFTRSxVQUFVLENBQUNDLFFBQVE7SUFDeEMsTUFBTUMsUUFBUUosU0FBU0ksS0FBSztJQUM1QixNQUFN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b0MsS0FBSztJQUV0QyxPQUFPO1FBRU4xRCxRQUFReUQsS0FBSyxDQUFDN0IsSUFBSSxDQUFFTjtJQUVyQjtJQUVBdEIsUUFBUTJELFFBQVEsR0FBR2xDLGlCQUNuQnpCLFFBQVE0RCxTQUFTLEdBQUdsQztJQUVwQixJQUFLekIsU0FBVTtRQUVkLElBQUssQ0FBRUEsUUFBUXdELEtBQUssRUFBR3hELFFBQVF3RCxLQUFLLEdBQUdqQyxnQkFBZ0JrQyxLQUFLO2FBQ3ZEekQsUUFBUXdELEtBQUssQ0FBQzdCLElBQUksQ0FBRUo7UUFDekJ2QixRQUFRd0QsS0FBSyxDQUFDVCxZQUFZLENBQUUzRDtRQUM1QmlDLGdCQUFnQjBCLFlBQVksQ0FBRTNEO1FBQzlCWSxRQUFRMEQsUUFBUSxHQUFHckMsZ0JBQWdCdUMsR0FBRyxDQUFFNUQsUUFBUXdELEtBQUssRUFBR0ssTUFBTTtRQUM5RDdELFFBQVEyRCxTQUFTLEdBQUdqQztJQUVyQjtJQUVBLE9BQU8zQjtBQUVSO0FBRWtDIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmliZS0zZC1jb2RlLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvY29yZS9jYXN0L2Nsb3Nlc3RQb2ludFRvR2VvbWV0cnkuZ2VuZXJhdGVkLmpzPzI1ODAiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgTWF0cml4NCwgVmVjdG9yMyB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IE9yaWVudGVkQm94IH0gZnJvbSAnLi4vLi4vbWF0aC9PcmllbnRlZEJveC5qcyc7XG5pbXBvcnQgeyBzZXRUcmlhbmdsZSB9IGZyb20gJy4uLy4uL3V0aWxzL1RyaWFuZ2xlVXRpbGl0aWVzLmpzJztcbmltcG9ydCB7IGdldFRyaUNvdW50IH0gZnJvbSAnLi4vYnVpbGQvZ2VvbWV0cnlVdGlscy5qcyc7XG5pbXBvcnQgeyBFeHRlbmRlZFRyaWFuZ2xlUG9vbCB9IGZyb20gJy4uLy4uL3V0aWxzL0V4dGVuZGVkVHJpYW5nbGVQb29sLmpzJztcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgZnJvbSBcImNsb3Nlc3RQb2ludFRvR2VvbWV0cnkudGVtcGxhdGUuanNcIi4gKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbmNvbnN0IHRlbXBNYXRyaXggPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hdHJpeDQoKTtcbmNvbnN0IG9iYiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgT3JpZW50ZWRCb3goKTtcbmNvbnN0IG9iYjIgPSAvKiBAX19QVVJFX18gKi8gbmV3IE9yaWVudGVkQm94KCk7XG5jb25zdCB0ZW1wMSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgdGVtcDIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IHRlbXAzID0gLyogQF9fUFVSRV9fICovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCB0ZW1wNCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVmVjdG9yMygpO1xuXG5mdW5jdGlvbiBjbG9zZXN0UG9pbnRUb0dlb21ldHJ5KFxuXHRidmgsXG5cdG90aGVyR2VvbWV0cnksXG5cdGdlb21ldHJ5VG9CdmgsXG5cdHRhcmdldDEgPSB7IH0sXG5cdHRhcmdldDIgPSB7IH0sXG5cdG1pblRocmVzaG9sZCA9IDAsXG5cdG1heFRocmVzaG9sZCA9IEluZmluaXR5LFxuKSB7XG5cblx0aWYgKCAhIG90aGVyR2VvbWV0cnkuYm91bmRpbmdCb3ggKSB7XG5cblx0XHRvdGhlckdlb21ldHJ5LmNvbXB1dGVCb3VuZGluZ0JveCgpO1xuXG5cdH1cblxuXHRvYmIuc2V0KCBvdGhlckdlb21ldHJ5LmJvdW5kaW5nQm94Lm1pbiwgb3RoZXJHZW9tZXRyeS5ib3VuZGluZ0JveC5tYXgsIGdlb21ldHJ5VG9CdmggKTtcblx0b2JiLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRjb25zdCBnZW9tZXRyeSA9IGJ2aC5nZW9tZXRyeTtcblx0Y29uc3QgcG9zID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0Y29uc3QgaW5kZXggPSBnZW9tZXRyeS5pbmRleDtcblx0Y29uc3Qgb3RoZXJQb3MgPSBvdGhlckdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdGNvbnN0IG90aGVySW5kZXggPSBvdGhlckdlb21ldHJ5LmluZGV4O1xuXHRjb25zdCB0cmlhbmdsZSA9IEV4dGVuZGVkVHJpYW5nbGVQb29sLmdldFByaW1pdGl2ZSgpO1xuXHRjb25zdCB0cmlhbmdsZTIgPSBFeHRlbmRlZFRyaWFuZ2xlUG9vbC5nZXRQcmltaXRpdmUoKTtcblxuXHRsZXQgdGVtcFRhcmdldDEgPSB0ZW1wMTtcblx0bGV0IHRlbXBUYXJnZXREZXN0MSA9IHRlbXAyO1xuXHRsZXQgdGVtcFRhcmdldDIgPSBudWxsO1xuXHRsZXQgdGVtcFRhcmdldERlc3QyID0gbnVsbDtcblxuXHRpZiAoIHRhcmdldDIgKSB7XG5cblx0XHR0ZW1wVGFyZ2V0MiA9IHRlbXAzO1xuXHRcdHRlbXBUYXJnZXREZXN0MiA9IHRlbXA0O1xuXG5cdH1cblxuXHRsZXQgY2xvc2VzdERpc3RhbmNlID0gSW5maW5pdHk7XG5cdGxldCBjbG9zZXN0RGlzdGFuY2VUcmlJbmRleCA9IG51bGw7XG5cdGxldCBjbG9zZXN0RGlzdGFuY2VPdGhlclRyaUluZGV4ID0gbnVsbDtcblx0dGVtcE1hdHJpeC5jb3B5KCBnZW9tZXRyeVRvQnZoICkuaW52ZXJ0KCk7XG5cdG9iYjIubWF0cml4LmNvcHkoIHRlbXBNYXRyaXggKTtcblx0YnZoLnNoYXBlY2FzdChcblx0XHR7XG5cblx0XHRcdGJvdW5kc1RyYXZlcnNlT3JkZXI6IGJveCA9PiB7XG5cblx0XHRcdFx0cmV0dXJuIG9iYi5kaXN0YW5jZVRvQm94KCBib3ggKTtcblxuXHRcdFx0fSxcblxuXHRcdFx0aW50ZXJzZWN0c0JvdW5kczogKCBib3gsIGlzTGVhZiwgc2NvcmUgKSA9PiB7XG5cblx0XHRcdFx0aWYgKCBzY29yZSA8IGNsb3Nlc3REaXN0YW5jZSAmJiBzY29yZSA8IG1heFRocmVzaG9sZCApIHtcblxuXHRcdFx0XHRcdC8vIGlmIHdlIGtub3cgdGhlIHRyaWFuZ2xlcyBvZiB0aGlzIGJvdW5kcyB3aWxsIGJlIGludGVyc2VjdGVkIG5leHQgdGhlblxuXHRcdFx0XHRcdC8vIHNhdmUgdGhlIGJvdW5kcyB0byB1c2UgZHVyaW5nIHRyaWFuZ2xlIGNoZWNrcy5cblx0XHRcdFx0XHRpZiAoIGlzTGVhZiApIHtcblxuXHRcdFx0XHRcdFx0b2JiMi5taW4uY29weSggYm94Lm1pbiApO1xuXHRcdFx0XHRcdFx0b2JiMi5tYXguY29weSggYm94Lm1heCApO1xuXHRcdFx0XHRcdFx0b2JiMi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHR9LFxuXG5cdFx0XHRpbnRlcnNlY3RzUmFuZ2U6ICggb2Zmc2V0LCBjb3VudCApID0+IHtcblxuXHRcdFx0XHRpZiAoIG90aGVyR2VvbWV0cnkuYm91bmRzVHJlZSApIHtcblxuXHRcdFx0XHRcdC8vIGlmIHRoZSBvdGhlciBnZW9tZXRyeSBoYXMgYSBidmggdGhlbiB1c2UgdGhlIGFjY2VsZXJhdGVkIHBhdGggd2hlcmUgd2UgdXNlIHNoYXBlY2FzdCB0byBmaW5kXG5cdFx0XHRcdFx0Ly8gdGhlIGNsb3Nlc3QgYm91bmRzIGluIHRoZSBvdGhlciBnZW9tZXRyeSB0byBjaGVjay5cblx0XHRcdFx0XHRjb25zdCBvdGhlckJ2aCA9IG90aGVyR2VvbWV0cnkuYm91bmRzVHJlZTtcblx0XHRcdFx0XHRyZXR1cm4gb3RoZXJCdmguc2hhcGVjYXN0KCB7XG5cdFx0XHRcdFx0XHRib3VuZHNUcmF2ZXJzZU9yZGVyOiBib3ggPT4ge1xuXG5cdFx0XHRcdFx0XHRcdHJldHVybiBvYmIyLmRpc3RhbmNlVG9Cb3goIGJveCApO1xuXG5cdFx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3RzQm91bmRzOiAoIGJveCwgaXNMZWFmLCBzY29yZSApID0+IHtcblxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gc2NvcmUgPCBjbG9zZXN0RGlzdGFuY2UgJiYgc2NvcmUgPCBtYXhUaHJlc2hvbGQ7XG5cblx0XHRcdFx0XHRcdH0sXG5cblx0XHRcdFx0XHRcdGludGVyc2VjdHNSYW5nZTogKCBvdGhlck9mZnNldCwgb3RoZXJDb3VudCApID0+IHtcblxuXHRcdFx0XHRcdFx0XHRmb3IgKCBsZXQgaTIgPSBvdGhlck9mZnNldCwgbDIgPSBvdGhlck9mZnNldCArIG90aGVyQ291bnQ7IGkyIDwgbDI7IGkyICsrICkge1xuXG5cblx0XHRcdFx0XHRcdFx0XHRzZXRUcmlhbmdsZSggdHJpYW5nbGUyLCAzICogaTIsIG90aGVySW5kZXgsIG90aGVyUG9zICk7XG5cblx0XHRcdFx0XHRcdFx0XHR0cmlhbmdsZTIuYS5hcHBseU1hdHJpeDQoIGdlb21ldHJ5VG9CdmggKTtcblx0XHRcdFx0XHRcdFx0XHR0cmlhbmdsZTIuYi5hcHBseU1hdHJpeDQoIGdlb21ldHJ5VG9CdmggKTtcblx0XHRcdFx0XHRcdFx0XHR0cmlhbmdsZTIuYy5hcHBseU1hdHJpeDQoIGdlb21ldHJ5VG9CdmggKTtcblx0XHRcdFx0XHRcdFx0XHR0cmlhbmdsZTIubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdFx0Zm9yICggbGV0IGkgPSBvZmZzZXQsIGwgPSBvZmZzZXQgKyBjb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblxuXHRcdFx0XHRcdFx0XHRcdFx0c2V0VHJpYW5nbGUoIHRyaWFuZ2xlLCAzICogaSwgaW5kZXgsIHBvcyApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR0cmlhbmdsZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGNvbnN0IGRpc3QgPSB0cmlhbmdsZS5kaXN0YW5jZVRvVHJpYW5nbGUoIHRyaWFuZ2xlMiwgdGVtcFRhcmdldDEsIHRlbXBUYXJnZXQyICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRpc3QgPCBjbG9zZXN0RGlzdGFuY2UgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0dGVtcFRhcmdldERlc3QxLmNvcHkoIHRlbXBUYXJnZXQxICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB0ZW1wVGFyZ2V0RGVzdDIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0ZW1wVGFyZ2V0RGVzdDIuY29weSggdGVtcFRhcmdldDIgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2xvc2VzdERpc3RhbmNlID0gZGlzdDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2xvc2VzdERpc3RhbmNlVHJpSW5kZXggPSBpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRjbG9zZXN0RGlzdGFuY2VPdGhlclRyaUluZGV4ID0gaTI7XG5cblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gc3RvcCB0cmF2ZXJzYWwgaWYgd2UgZmluZCBhIHBvaW50IHRoYXQncyB1bmRlciB0aGUgZ2l2ZW4gdGhyZXNob2xkXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRpc3QgPCBtaW5UaHJlc2hvbGQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBJZiBubyBib3VuZHMgdHJlZSB0aGVuIHdlJ2xsIGp1c3QgY2hlY2sgZXZlcnkgdHJpYW5nbGUuXG5cdFx0XHRcdFx0Y29uc3QgdHJpQ291bnQgPSBnZXRUcmlDb3VudCggb3RoZXJHZW9tZXRyeSApO1xuXHRcdFx0XHRcdGZvciAoIGxldCBpMiA9IDAsIGwyID0gdHJpQ291bnQ7IGkyIDwgbDI7IGkyICsrICkge1xuXG5cdFx0XHRcdFx0XHRzZXRUcmlhbmdsZSggdHJpYW5nbGUyLCAzICogaTIsIG90aGVySW5kZXgsIG90aGVyUG9zICk7XG5cdFx0XHRcdFx0XHR0cmlhbmdsZTIuYS5hcHBseU1hdHJpeDQoIGdlb21ldHJ5VG9CdmggKTtcblx0XHRcdFx0XHRcdHRyaWFuZ2xlMi5iLmFwcGx5TWF0cml4NCggZ2VvbWV0cnlUb0J2aCApO1xuXHRcdFx0XHRcdFx0dHJpYW5nbGUyLmMuYXBwbHlNYXRyaXg0KCBnZW9tZXRyeVRvQnZoICk7XG5cdFx0XHRcdFx0XHR0cmlhbmdsZTIubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IG9mZnNldCwgbCA9IG9mZnNldCArIGNvdW50OyBpIDwgbDsgaSArKyApIHtcblxuXG5cdFx0XHRcdFx0XHRcdHNldFRyaWFuZ2xlKCB0cmlhbmdsZSwgMyAqIGksIGluZGV4LCBwb3MgKTtcblxuXHRcdFx0XHRcdFx0XHR0cmlhbmdsZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHRcdFx0Y29uc3QgZGlzdCA9IHRyaWFuZ2xlLmRpc3RhbmNlVG9UcmlhbmdsZSggdHJpYW5nbGUyLCB0ZW1wVGFyZ2V0MSwgdGVtcFRhcmdldDIgKTtcblx0XHRcdFx0XHRcdFx0aWYgKCBkaXN0IDwgY2xvc2VzdERpc3RhbmNlICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0dGVtcFRhcmdldERlc3QxLmNvcHkoIHRlbXBUYXJnZXQxICk7XG5cblx0XHRcdFx0XHRcdFx0XHRpZiAoIHRlbXBUYXJnZXREZXN0MiApIHtcblxuXHRcdFx0XHRcdFx0XHRcdFx0dGVtcFRhcmdldERlc3QyLmNvcHkoIHRlbXBUYXJnZXQyICk7XG5cblx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRjbG9zZXN0RGlzdGFuY2UgPSBkaXN0O1xuXHRcdFx0XHRcdFx0XHRcdGNsb3Nlc3REaXN0YW5jZVRyaUluZGV4ID0gaTtcblx0XHRcdFx0XHRcdFx0XHRjbG9zZXN0RGlzdGFuY2VPdGhlclRyaUluZGV4ID0gaTI7XG5cblx0XHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0XHRcdC8vIHN0b3AgdHJhdmVyc2FsIGlmIHdlIGZpbmQgYSBwb2ludCB0aGF0J3MgdW5kZXIgdGhlIGdpdmVuIHRocmVzaG9sZFxuXHRcdFx0XHRcdFx0XHRpZiAoIGRpc3QgPCBtaW5UaHJlc2hvbGQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH0sXG5cblx0XHR9XG5cblx0KTtcblxuXHRFeHRlbmRlZFRyaWFuZ2xlUG9vbC5yZWxlYXNlUHJpbWl0aXZlKCB0cmlhbmdsZSApO1xuXHRFeHRlbmRlZFRyaWFuZ2xlUG9vbC5yZWxlYXNlUHJpbWl0aXZlKCB0cmlhbmdsZTIgKTtcblxuXHRpZiAoIGNsb3Nlc3REaXN0YW5jZSA9PT0gSW5maW5pdHkgKSB7XG5cblx0XHRyZXR1cm4gbnVsbDtcblxuXHR9XG5cblx0aWYgKCAhIHRhcmdldDEucG9pbnQgKSB7XG5cblx0XHR0YXJnZXQxLnBvaW50ID0gdGVtcFRhcmdldERlc3QxLmNsb25lKCk7XG5cblx0fSBlbHNlIHtcblxuXHRcdHRhcmdldDEucG9pbnQuY29weSggdGVtcFRhcmdldERlc3QxICk7XG5cblx0fVxuXG5cdHRhcmdldDEuZGlzdGFuY2UgPSBjbG9zZXN0RGlzdGFuY2UsXG5cdHRhcmdldDEuZmFjZUluZGV4ID0gY2xvc2VzdERpc3RhbmNlVHJpSW5kZXg7XG5cblx0aWYgKCB0YXJnZXQyICkge1xuXG5cdFx0aWYgKCAhIHRhcmdldDIucG9pbnQgKSB0YXJnZXQyLnBvaW50ID0gdGVtcFRhcmdldERlc3QyLmNsb25lKCk7XG5cdFx0ZWxzZSB0YXJnZXQyLnBvaW50LmNvcHkoIHRlbXBUYXJnZXREZXN0MiApO1xuXHRcdHRhcmdldDIucG9pbnQuYXBwbHlNYXRyaXg0KCB0ZW1wTWF0cml4ICk7XG5cdFx0dGVtcFRhcmdldERlc3QxLmFwcGx5TWF0cml4NCggdGVtcE1hdHJpeCApO1xuXHRcdHRhcmdldDIuZGlzdGFuY2UgPSB0ZW1wVGFyZ2V0RGVzdDEuc3ViKCB0YXJnZXQyLnBvaW50ICkubGVuZ3RoKCk7XG5cdFx0dGFyZ2V0Mi5mYWNlSW5kZXggPSBjbG9zZXN0RGlzdGFuY2VPdGhlclRyaUluZGV4O1xuXG5cdH1cblxuXHRyZXR1cm4gdGFyZ2V0MTtcblxufVxuXG5leHBvcnQgeyBjbG9zZXN0UG9pbnRUb0dlb21ldHJ5IH07XG4iXSwibmFtZXMiOlsiTWF0cml4NCIsIlZlY3RvcjMiLCJPcmllbnRlZEJveCIsInNldFRyaWFuZ2xlIiwiZ2V0VHJpQ291bnQiLCJFeHRlbmRlZFRyaWFuZ2xlUG9vbCIsInRlbXBNYXRyaXgiLCJvYmIiLCJvYmIyIiwidGVtcDEiLCJ0ZW1wMiIsInRlbXAzIiwidGVtcDQiLCJjbG9zZXN0UG9pbnRUb0dlb21ldHJ5IiwiYnZoIiwib3RoZXJHZW9tZXRyeSIsImdlb21ldHJ5VG9CdmgiLCJ0YXJnZXQxIiwidGFyZ2V0MiIsIm1pblRocmVzaG9sZCIsIm1heFRocmVzaG9sZCIsIkluZmluaXR5IiwiYm91bmRpbmdCb3giLCJjb21wdXRlQm91bmRpbmdCb3giLCJzZXQiLCJtaW4iLCJtYXgiLCJuZWVkc1VwZGF0ZSIsImdlb21ldHJ5IiwicG9zIiwiYXR0cmlidXRlcyIsInBvc2l0aW9uIiwiaW5kZXgiLCJvdGhlclBvcyIsIm90aGVySW5kZXgiLCJ0cmlhbmdsZSIsImdldFByaW1pdGl2ZSIsInRyaWFuZ2xlMiIsInRlbXBUYXJnZXQxIiwidGVtcFRhcmdldERlc3QxIiwidGVtcFRhcmdldDIiLCJ0ZW1wVGFyZ2V0RGVzdDIiLCJjbG9zZXN0RGlzdGFuY2UiLCJjbG9zZXN0RGlzdGFuY2VUcmlJbmRleCIsImNsb3Nlc3REaXN0YW5jZU90aGVyVHJpSW5kZXgiLCJjb3B5IiwiaW52ZXJ0IiwibWF0cml4Iiwic2hhcGVjYXN0IiwiYm91bmRzVHJhdmVyc2VPcmRlciIsImJveCIsImRpc3RhbmNlVG9Cb3giLCJpbnRlcnNlY3RzQm91bmRzIiwiaXNMZWFmIiwic2NvcmUiLCJpbnRlcnNlY3RzUmFuZ2UiLCJvZmZzZXQiLCJjb3VudCIsImJvdW5kc1RyZWUiLCJvdGhlckJ2aCIsIm90aGVyT2Zmc2V0Iiwib3RoZXJDb3VudCIsImkyIiwibDIiLCJhIiwiYXBwbHlNYXRyaXg0IiwiYiIsImMiLCJpIiwibCIsImRpc3QiLCJkaXN0YW5jZVRvVHJpYW5nbGUiLCJ0cmlDb3VudCIsInJlbGVhc2VQcmltaXRpdmUiLCJwb2ludCIsImNsb25lIiwiZGlzdGFuY2UiLCJmYWNlSW5kZXgiLCJzdWIiLCJsZW5ndGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry.generated.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry_indirect.generated.js":
/*!*******************************************************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry_indirect.generated.js ***!
  \*******************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closestPointToGeometry_indirect: () => (/* binding */ closestPointToGeometry_indirect)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var _math_OrientedBox_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/OrientedBox.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/math/OrientedBox.js\");\n/* harmony import */ var _utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../../utils/TriangleUtilities.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js\");\n/* harmony import */ var _build_geometryUtils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../build/geometryUtils.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/build/geometryUtils.js\");\n/* harmony import */ var _utils_ExtendedTrianglePool_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../utils/ExtendedTrianglePool.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/ExtendedTrianglePool.js\");\n\n\n\n\n\n/*********************************************************************/ /* This file is generated from \"closestPointToGeometry.template.js\". */ /*********************************************************************/ const tempMatrix = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\nconst obb = /* @__PURE__ */ new _math_OrientedBox_js__WEBPACK_IMPORTED_MODULE_1__.OrientedBox();\nconst obb2 = /* @__PURE__ */ new _math_OrientedBox_js__WEBPACK_IMPORTED_MODULE_1__.OrientedBox();\nconst temp1 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst temp2 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst temp3 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst temp4 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nfunction closestPointToGeometry_indirect(bvh, otherGeometry, geometryToBvh, target1 = {}, target2 = {}, minThreshold = 0, maxThreshold = Infinity) {\n    if (!otherGeometry.boundingBox) {\n        otherGeometry.computeBoundingBox();\n    }\n    obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);\n    obb.needsUpdate = true;\n    const geometry = bvh.geometry;\n    const pos = geometry.attributes.position;\n    const index = geometry.index;\n    const otherPos = otherGeometry.attributes.position;\n    const otherIndex = otherGeometry.index;\n    const triangle = _utils_ExtendedTrianglePool_js__WEBPACK_IMPORTED_MODULE_2__.ExtendedTrianglePool.getPrimitive();\n    const triangle2 = _utils_ExtendedTrianglePool_js__WEBPACK_IMPORTED_MODULE_2__.ExtendedTrianglePool.getPrimitive();\n    let tempTarget1 = temp1;\n    let tempTargetDest1 = temp2;\n    let tempTarget2 = null;\n    let tempTargetDest2 = null;\n    if (target2) {\n        tempTarget2 = temp3;\n        tempTargetDest2 = temp4;\n    }\n    let closestDistance = Infinity;\n    let closestDistanceTriIndex = null;\n    let closestDistanceOtherTriIndex = null;\n    tempMatrix.copy(geometryToBvh).invert();\n    obb2.matrix.copy(tempMatrix);\n    bvh.shapecast({\n        boundsTraverseOrder: (box)=>{\n            return obb.distanceToBox(box);\n        },\n        intersectsBounds: (box, isLeaf, score)=>{\n            if (score < closestDistance && score < maxThreshold) {\n                // if we know the triangles of this bounds will be intersected next then\n                // save the bounds to use during triangle checks.\n                if (isLeaf) {\n                    obb2.min.copy(box.min);\n                    obb2.max.copy(box.max);\n                    obb2.needsUpdate = true;\n                }\n                return true;\n            }\n            return false;\n        },\n        intersectsRange: (offset, count)=>{\n            if (otherGeometry.boundsTree) {\n                // if the other geometry has a bvh then use the accelerated path where we use shapecast to find\n                // the closest bounds in the other geometry to check.\n                const otherBvh = otherGeometry.boundsTree;\n                return otherBvh.shapecast({\n                    boundsTraverseOrder: (box)=>{\n                        return obb2.distanceToBox(box);\n                    },\n                    intersectsBounds: (box, isLeaf, score)=>{\n                        return score < closestDistance && score < maxThreshold;\n                    },\n                    intersectsRange: (otherOffset, otherCount)=>{\n                        for(let i2 = otherOffset, l2 = otherOffset + otherCount; i2 < l2; i2++){\n                            const ti2 = otherBvh.resolveTriangleIndex(i2);\n                            (0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_3__.setTriangle)(triangle2, 3 * ti2, otherIndex, otherPos);\n                            triangle2.a.applyMatrix4(geometryToBvh);\n                            triangle2.b.applyMatrix4(geometryToBvh);\n                            triangle2.c.applyMatrix4(geometryToBvh);\n                            triangle2.needsUpdate = true;\n                            for(let i = offset, l = offset + count; i < l; i++){\n                                const ti = bvh.resolveTriangleIndex(i);\n                                (0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_3__.setTriangle)(triangle, 3 * ti, index, pos);\n                                triangle.needsUpdate = true;\n                                const dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n                                if (dist < closestDistance) {\n                                    tempTargetDest1.copy(tempTarget1);\n                                    if (tempTargetDest2) {\n                                        tempTargetDest2.copy(tempTarget2);\n                                    }\n                                    closestDistance = dist;\n                                    closestDistanceTriIndex = i;\n                                    closestDistanceOtherTriIndex = i2;\n                                }\n                                // stop traversal if we find a point that's under the given threshold\n                                if (dist < minThreshold) {\n                                    return true;\n                                }\n                            }\n                        }\n                    }\n                });\n            } else {\n                // If no bounds tree then we'll just check every triangle.\n                const triCount = (0,_build_geometryUtils_js__WEBPACK_IMPORTED_MODULE_4__.getTriCount)(otherGeometry);\n                for(let i2 = 0, l2 = triCount; i2 < l2; i2++){\n                    (0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_3__.setTriangle)(triangle2, 3 * i2, otherIndex, otherPos);\n                    triangle2.a.applyMatrix4(geometryToBvh);\n                    triangle2.b.applyMatrix4(geometryToBvh);\n                    triangle2.c.applyMatrix4(geometryToBvh);\n                    triangle2.needsUpdate = true;\n                    for(let i = offset, l = offset + count; i < l; i++){\n                        const ti = bvh.resolveTriangleIndex(i);\n                        (0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_3__.setTriangle)(triangle, 3 * ti, index, pos);\n                        triangle.needsUpdate = true;\n                        const dist = triangle.distanceToTriangle(triangle2, tempTarget1, tempTarget2);\n                        if (dist < closestDistance) {\n                            tempTargetDest1.copy(tempTarget1);\n                            if (tempTargetDest2) {\n                                tempTargetDest2.copy(tempTarget2);\n                            }\n                            closestDistance = dist;\n                            closestDistanceTriIndex = i;\n                            closestDistanceOtherTriIndex = i2;\n                        }\n                        // stop traversal if we find a point that's under the given threshold\n                        if (dist < minThreshold) {\n                            return true;\n                        }\n                    }\n                }\n            }\n        }\n    });\n    _utils_ExtendedTrianglePool_js__WEBPACK_IMPORTED_MODULE_2__.ExtendedTrianglePool.releasePrimitive(triangle);\n    _utils_ExtendedTrianglePool_js__WEBPACK_IMPORTED_MODULE_2__.ExtendedTrianglePool.releasePrimitive(triangle2);\n    if (closestDistance === Infinity) {\n        return null;\n    }\n    if (!target1.point) {\n        target1.point = tempTargetDest1.clone();\n    } else {\n        target1.point.copy(tempTargetDest1);\n    }\n    target1.distance = closestDistance, target1.faceIndex = closestDistanceTriIndex;\n    if (target2) {\n        if (!target2.point) target2.point = tempTargetDest2.clone();\n        else target2.point.copy(tempTargetDest2);\n        target2.point.applyMatrix4(tempMatrix);\n        tempTargetDest1.applyMatrix4(tempMatrix);\n        target2.distance = tempTargetDest1.sub(target2.point).length();\n        target2.faceIndex = closestDistanceOtherTriIndex;\n    }\n    return target1;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9jb3JlL2Nhc3QvY2xvc2VzdFBvaW50VG9HZW9tZXRyeV9pbmRpcmVjdC5nZW5lcmF0ZWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQXlDO0FBQ2U7QUFDTztBQUNQO0FBQ21CO0FBRTNFLHFFQUFxRSxHQUNyRSxxRUFBcUUsR0FDckUscUVBQXFFLEdBRXJFLE1BQU1NLGFBQWEsYUFBYSxHQUFHLElBQUlOLDBDQUFPQTtBQUM5QyxNQUFNTyxNQUFNLGFBQWEsR0FBRyxJQUFJTCw2REFBV0E7QUFDM0MsTUFBTU0sT0FBTyxhQUFhLEdBQUcsSUFBSU4sNkRBQVdBO0FBQzVDLE1BQU1PLFFBQVEsYUFBYSxHQUFHLElBQUlSLDBDQUFPQTtBQUN6QyxNQUFNUyxRQUFRLGFBQWEsR0FBRyxJQUFJVCwwQ0FBT0E7QUFDekMsTUFBTVUsUUFBUSxhQUFhLEdBQUcsSUFBSVYsMENBQU9BO0FBQ3pDLE1BQU1XLFFBQVEsYUFBYSxHQUFHLElBQUlYLDBDQUFPQTtBQUV6QyxTQUFTWSxnQ0FDUkMsR0FBRyxFQUNIQyxhQUFhLEVBQ2JDLGFBQWEsRUFDYkMsVUFBVSxDQUFFLENBQUMsRUFDYkMsVUFBVSxDQUFFLENBQUMsRUFDYkMsZUFBZSxDQUFDLEVBQ2hCQyxlQUFlQyxRQUFRO0lBR3ZCLElBQUssQ0FBRU4sY0FBY08sV0FBVyxFQUFHO1FBRWxDUCxjQUFjUSxrQkFBa0I7SUFFakM7SUFFQWhCLElBQUlpQixHQUFHLENBQUVULGNBQWNPLFdBQVcsQ0FBQ0csR0FBRyxFQUFFVixjQUFjTyxXQUFXLENBQUNJLEdBQUcsRUFBRVY7SUFDdkVULElBQUlvQixXQUFXLEdBQUc7SUFFbEIsTUFBTUMsV0FBV2QsSUFBSWMsUUFBUTtJQUM3QixNQUFNQyxNQUFNRCxTQUFTRSxVQUFVLENBQUNDLFFBQVE7SUFDeEMsTUFBTUMsUUFBUUosU0FBU0ksS0FBSztJ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QUN1RSxnQkFBZ0IsQ0FBRXZDO0lBRXZDLElBQUtLLG9CQUFvQnJCLFVBQVc7UUFFbkMsT0FBTztJQUVSO0lBRUEsSUFBSyxDQUFFSixRQUFRNEQsS0FBSyxFQUFHO1FBRXRCNUQsUUFBUTRELEtBQUssR0FBR3RDLGdCQUFnQnVDLEtBQUs7SUFFdEMsT0FBTztRQUVON0QsUUFBUTRELEtBQUssQ0FBQ2hDLElBQUksQ0FBRU47SUFFckI7SUFFQXRCLFFBQVE4RCxRQUFRLEdBQUdyQyxpQkFDbkJ6QixRQUFRK0QsU0FBUyxHQUFHckM7SUFFcEIsSUFBS3pCLFNBQVU7UUFFZCxJQUFLLENBQUVBLFFBQVEyRCxLQUFLLEVBQUczRCxRQUFRMkQsS0FBSyxHQUFHcEMsZ0JBQWdCcUMsS0FBSzthQUN2RDVELFFBQVEyRCxLQUFLLENBQUNoQyxJQUFJLENBQUVKO1FBQ3pCdkIsUUFBUTJELEtBQUssQ0FBQ1YsWUFBWSxDQUFFN0Q7UUFDNUJpQyxnQkFBZ0I0QixZQUFZLENBQUU3RDtRQUM5QlksUUFBUTZELFFBQVEsR0FBR3hDLGdCQUFnQjBDLEdBQUcsQ0FBRS9ELFFBQVEyRCxLQUFLLEVBQUdLLE1BQU07UUFDOURoRSxRQUFROEQsU0FBUyxHQUFHcEM7SUFFckI7SUFFQSxPQUFPM0I7QUFFUjtBQUUyQyIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpYmUtM2QtY29kZS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9ub2RlX21vZHVsZXMvdGhyZWUtbWVzaC1idmgvc3JjL2NvcmUvY2FzdC9jbG9zZXN0UG9pbnRUb0dlb21ldHJ5X2luZGlyZWN0LmdlbmVyYXRlZC5qcz9mNTczIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IE1hdHJpeDQsIFZlY3RvcjMgfSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBPcmllbnRlZEJveCB9IGZyb20gJy4uLy4uL21hdGgvT3JpZW50ZWRCb3guanMnO1xuaW1wb3J0IHsgc2V0VHJpYW5nbGUgfSBmcm9tICcuLi8uLi91dGlscy9UcmlhbmdsZVV0aWxpdGllcy5qcyc7XG5pbXBvcnQgeyBnZXRUcmlDb3VudCB9IGZyb20gJy4uL2J1aWxkL2dlb21ldHJ5VXRpbHMuanMnO1xuaW1wb3J0IHsgRXh0ZW5kZWRUcmlhbmdsZVBvb2wgfSBmcm9tICcuLi8uLi91dGlscy9FeHRlbmRlZFRyaWFuZ2xlUG9vbC5qcyc7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGZyb20gXCJjbG9zZXN0UG9pbnRUb0dlb21ldHJ5LnRlbXBsYXRlLmpzXCIuICovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5jb25zdCB0ZW1wTWF0cml4ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXRyaXg0KCk7XG5jb25zdCBvYmIgPSAvKiBAX19QVVJFX18gKi8gbmV3IE9yaWVudGVkQm94KCk7XG5jb25zdCBvYmIyID0gLyogQF9fUFVSRV9fICovIG5ldyBPcmllbnRlZEJveCgpO1xuY29uc3QgdGVtcDEgPSAvKiBAX19QVVJFX18gKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IHRlbXAyID0gLyogQF9fUFVSRV9fICovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCB0ZW1wMyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgdGVtcDQgPSAvKiBAX19QVVJFX18gKi8gbmV3IFZlY3RvcjMoKTtcblxuZnVuY3Rpb24gY2xvc2VzdFBvaW50VG9HZW9tZXRyeV9pbmRpcmVjdChcblx0YnZoLFxuXHRvdGhlckdlb21ldHJ5LFxuXHRnZW9tZXRyeVRvQnZoLFxuXHR0YXJnZXQxID0geyB9LFxuXHR0YXJnZXQyID0geyB9LFxuXHRtaW5UaHJlc2hvbGQgPSAwLFxuXHRtYXhUaHJlc2hvbGQgPSBJbmZpbml0eSxcbikge1xuXG5cdGlmICggISBvdGhlckdlb21ldHJ5LmJvdW5kaW5nQm94ICkge1xuXG5cdFx0b3RoZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3goKTtcblxuXHR9XG5cblx0b2JiLnNldCggb3RoZXJHZW9tZXRyeS5ib3VuZGluZ0JveC5taW4sIG90aGVyR2VvbWV0cnkuYm91bmRpbmdCb3gubWF4LCBnZW9tZXRyeVRvQnZoICk7XG5cdG9iYi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0Y29uc3QgZ2VvbWV0cnkgPSBidmguZ2VvbWV0cnk7XG5cdGNvbnN0IHBvcyA9IGdlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cdGNvbnN0IGluZGV4ID0gZ2VvbWV0cnkuaW5kZXg7XG5cdGNvbnN0IG90aGVyUG9zID0gb3RoZXJHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRjb25zdCBvdGhlckluZGV4ID0gb3RoZXJHZW9tZXRyeS5pbmRleDtcblx0Y29uc3QgdHJpYW5nbGUgPSBFeHRlbmRlZFRyaWFuZ2xlUG9vbC5nZXRQcmltaXRpdmUoKTtcblx0Y29uc3QgdHJpYW5nbGUyID0gRXh0ZW5kZWRUcmlhbmdsZVBvb2wuZ2V0UHJpbWl0aXZlKCk7XG5cblx0bGV0IHRlbXBUYXJnZXQxID0gdGVtcDE7XG5cdGxldCB0ZW1wVGFyZ2V0RGVzdDEgPSB0ZW1wMjtcblx0bGV0IHRlbXBUYXJnZXQyID0gbnVsbDtcblx0bGV0IHRlbXBUYXJnZXREZXN0MiA9IG51bGw7XG5cblx0aWYgKCB0YXJnZXQyICkge1xuXG5cdFx0dGVtcFRhcmdldDIgPSB0ZW1wMztcblx0XHR0ZW1wVGFyZ2V0RGVzdDIgPSB0ZW1wNDtcblxuXHR9XG5cblx0bGV0IGNsb3Nlc3REaXN0YW5jZSA9IEluZmluaXR5O1xuXHRsZXQgY2xvc2VzdERpc3RhbmNlVHJpSW5kZXggPSBudWxsO1xuXHRsZXQgY2xvc2VzdERpc3RhbmNlT3RoZXJUcmlJbmRleCA9IG51bGw7XG5cdHRlbXBNYXRyaXguY29weSggZ2VvbWV0cnlUb0J2aCApLmludmVydCgpO1xuXHRvYmIyLm1hdHJpeC5jb3B5KCB0ZW1wTWF0cml4ICk7XG5cdGJ2aC5zaGFwZWNhc3QoXG5cdFx0e1xuXG5cdFx0XHRib3VuZHNUcmF2ZXJzZU9yZGVyOiBib3ggPT4ge1xuXG5cdFx0XHRcdHJldHVybiBvYmIuZGlzdGFuY2VUb0JveCggYm94ICk7XG5cblx0XHRcdH0sXG5cblx0XHRcdGludGVyc2VjdHNCb3VuZHM6ICggYm94LCBpc0xlYWYsIHNjb3JlICkgPT4ge1xuXG5cdFx0XHRcdGlmICggc2NvcmUgPCBjbG9zZXN0RGlzdGFuY2UgJiYgc2NvcmUgPCBtYXhUaHJlc2hvbGQgKSB7XG5cblx0XHRcdFx0XHQvLyBpZiB3ZSBrbm93IHRoZSB0cmlhbmdsZXMgb2YgdGhpcyBib3VuZHMgd2lsbCBiZSBpbnRlcnNlY3RlZCBuZXh0IHRoZW5cblx0XHRcdFx0XHQvLyBzYXZlIHRoZSBib3VuZHMgdG8gdXNlIGR1cmluZyB0cmlhbmdsZSBjaGVja3MuXG5cdFx0XHRcdFx0aWYgKCBpc0xlYWYgKSB7XG5cblx0XHRcdFx0XHRcdG9iYjIubWluLmNvcHkoIGJveC5taW4gKTtcblx0XHRcdFx0XHRcdG9iYjIubWF4LmNvcHkoIGJveC5tYXggKTtcblx0XHRcdFx0XHRcdG9iYjIubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0fSxcblxuXHRcdFx0aW50ZXJzZWN0c1JhbmdlOiAoIG9mZnNldCwgY291bnQgKSA9PiB7XG5cblx0XHRcdFx0aWYgKCBvdGhlckdlb21ldHJ5LmJvdW5kc1RyZWUgKSB7XG5cblx0XHRcdFx0XHQvLyBpZiB0aGUgb3RoZXIgZ2VvbWV0cnkgaGFzIGEgYnZoIHRoZW4gdXNlIHRoZSBhY2NlbGVyYXRlZCBwYXRoIHdoZXJlIHdlIHVzZSBzaGFwZWNhc3QgdG8gZmluZFxuXHRcdFx0XHRcdC8vIHRoZSBjbG9zZXN0IGJvdW5kcyBpbiB0aGUgb3RoZXIgZ2VvbWV0cnkgdG8gY2hlY2suXG5cdFx0XHRcdFx0Y29uc3Qgb3RoZXJCdmggPSBvdGhlckdlb21ldHJ5LmJvdW5kc1RyZWU7XG5cdFx0XHRcdFx0cmV0dXJuIG90aGVyQnZoLnNoYXBlY2FzdCgge1xuXHRcdFx0XHRcdFx0Ym91bmRzVHJhdmVyc2VPcmRlcjogYm94ID0+IHtcblxuXHRcdFx0XHRcdFx0XHRyZXR1cm4gb2JiMi5kaXN0YW5jZVRvQm94KCBib3ggKTtcblxuXHRcdFx0XHRcdFx0fSxcblxuXHRcdFx0XHRcdFx0aW50ZXJzZWN0c0JvdW5kczogKCBib3gsIGlzTGVhZiwgc2NvcmUgKSA9PiB7XG5cblx0XHRcdFx0XHRcdFx0cmV0dXJuIHNjb3JlIDwgY2xvc2VzdERpc3RhbmNlICYmIHNjb3JlIDwgbWF4VGhyZXNob2xkO1xuXG5cdFx0XHRcdFx0XHR9LFxuXG5cdFx0XHRcdFx0XHRpbnRlcnNlY3RzUmFuZ2U6ICggb3RoZXJPZmZzZXQsIG90aGVyQ291bnQgKSA9PiB7XG5cblx0XHRcdFx0XHRcdFx0Zm9yICggbGV0IGkyID0gb3RoZXJPZmZzZXQsIGwyID0gb3RoZXJPZmZzZXQgKyBvdGhlckNvdW50OyBpMiA8IGwyOyBpMiArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRcdGNvbnN0IHRpMiA9IG90aGVyQnZoLnJlc29sdmVUcmlhbmdsZUluZGV4KCBpMiApO1xuXHRcdFx0XHRcdFx0XHRcdHNldFRyaWFuZ2xlKCB0cmlhbmdsZTIsIDMgKiB0aTIsIG90aGVySW5kZXgsIG90aGVyUG9zICk7XG5cblx0XHRcdFx0XHRcdFx0XHR0cmlhbmdsZTIuYS5hcHBseU1hdHJpeDQoIGdlb21ldHJ5VG9CdmggKTtcblx0XHRcdFx0XHRcdFx0XHR0cmlhbmdsZTIuYi5hcHBseU1hdHJpeDQoIGdlb21ldHJ5VG9CdmggKTtcblx0XHRcdFx0XHRcdFx0XHR0cmlhbmdsZTIuYy5hcHBseU1hdHJpeDQoIGdlb21ldHJ5VG9CdmggKTtcblx0XHRcdFx0XHRcdFx0XHR0cmlhbmdsZTIubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdFx0Zm9yICggbGV0IGkgPSBvZmZzZXQsIGwgPSBvZmZzZXQgKyBjb3VudDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGNvbnN0IHRpID0gYnZoLnJlc29sdmVUcmlhbmdsZUluZGV4KCBpICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRzZXRUcmlhbmdsZSggdHJpYW5nbGUsIDMgKiB0aSwgaW5kZXgsIHBvcyApO1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR0cmlhbmdsZS5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHRcdFx0XHRcdGNvbnN0IGRpc3QgPSB0cmlhbmdsZS5kaXN0YW5jZVRvVHJpYW5nbGUoIHRyaWFuZ2xlMiwgdGVtcFRhcmdldDEsIHRlbXBUYXJnZXQyICk7XG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRpc3QgPCBjbG9zZXN0RGlzdGFuY2UgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0dGVtcFRhcmdldERlc3QxLmNvcHkoIHRlbXBUYXJnZXQxICk7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0aWYgKCB0ZW1wVGFyZ2V0RGVzdDIgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0XHR0ZW1wVGFyZ2V0RGVzdDIuY29weSggdGVtcFRhcmdldDIgKTtcblxuXHRcdFx0XHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2xvc2VzdERpc3RhbmNlID0gZGlzdDtcblx0XHRcdFx0XHRcdFx0XHRcdFx0Y2xvc2VzdERpc3RhbmNlVHJpSW5kZXggPSBpO1xuXHRcdFx0XHRcdFx0XHRcdFx0XHRjbG9zZXN0RGlzdGFuY2VPdGhlclRyaUluZGV4ID0gaTI7XG5cblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdFx0Ly8gc3RvcCB0cmF2ZXJzYWwgaWYgd2UgZmluZCBhIHBvaW50IHRoYXQncyB1bmRlciB0aGUgZ2l2ZW4gdGhyZXNob2xkXG5cdFx0XHRcdFx0XHRcdFx0XHRpZiAoIGRpc3QgPCBtaW5UaHJlc2hvbGQgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdH0sXG5cdFx0XHRcdFx0fSApO1xuXG5cdFx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0XHQvLyBJZiBubyBib3VuZHMgdHJlZSB0aGVuIHdlJ2xsIGp1c3QgY2hlY2sgZXZlcnkgdHJpYW5nbGUuXG5cdFx0XHRcdFx0Y29uc3QgdHJpQ291bnQgPSBnZXRUcmlDb3VudCggb3RoZXJHZW9tZXRyeSApO1xuXHRcdFx0XHRcdGZvciAoIGxldCBpMiA9IDAsIGwyID0gdHJpQ291bnQ7IGkyIDwgbDI7IGkyICsrICkge1xuXG5cdFx0XHRcdFx0XHRzZXRUcmlhbmdsZSggdHJpYW5nbGUyLCAzICogaTIsIG90aGVySW5kZXgsIG90aGVyUG9zICk7XG5cdFx0XHRcdFx0XHR0cmlhbmdsZTIuYS5hcHBseU1hdHJpeDQoIGdlb21ldHJ5VG9CdmggKTtcblx0XHRcdFx0XHRcdHRyaWFuZ2xlMi5iLmFwcGx5TWF0cml4NCggZ2VvbWV0cnlUb0J2aCApO1xuXHRcdFx0XHRcdFx0dHJpYW5nbGUyLmMuYXBwbHlNYXRyaXg0KCBnZW9tZXRyeVRvQnZoICk7XG5cdFx0XHRcdFx0XHR0cmlhbmdsZTIubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0XHRmb3IgKCBsZXQgaSA9IG9mZnNldCwgbCA9IG9mZnNldCArIGNvdW50OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0XHRcdFx0XHRjb25zdCB0aSA9IGJ2aC5yZXNvbHZlVHJpYW5nbGVJbmRleCggaSApO1xuXHRcdFx0XHRcdFx0XHRzZXRUcmlhbmdsZSggdHJpYW5nbGUsIDMgKiB0aSwgaW5kZXgsIHBvcyApO1xuXG5cdFx0XHRcdFx0XHRcdHRyaWFuZ2xlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRcdFx0XHRjb25zdCBkaXN0ID0gdHJpYW5nbGUuZGlzdGFuY2VUb1RyaWFuZ2xlKCB0cmlhbmdsZTIsIHRlbXBUYXJnZXQxLCB0ZW1wVGFyZ2V0MiApO1xuXHRcdFx0XHRcdFx0XHRpZiAoIGRpc3QgPCBjbG9zZXN0RGlzdGFuY2UgKSB7XG5cblx0XHRcdFx0XHRcdFx0XHR0ZW1wVGFyZ2V0RGVzdDEuY29weSggdGVtcFRhcmdldDEgKTtcblxuXHRcdFx0XHRcdFx0XHRcdGlmICggdGVtcFRhcmdldERlc3QyICkge1xuXG5cdFx0XHRcdFx0XHRcdFx0XHR0ZW1wVGFyZ2V0RGVzdDIuY29weSggdGVtcFRhcmdldDIgKTtcblxuXHRcdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0XHRcdGNsb3Nlc3REaXN0YW5jZSA9IGRpc3Q7XG5cdFx0XHRcdFx0XHRcdFx0Y2xvc2VzdERpc3RhbmNlVHJpSW5kZXggPSBpO1xuXHRcdFx0XHRcdFx0XHRcdGNsb3Nlc3REaXN0YW5jZU90aGVyVHJpSW5kZXggPSBpMjtcblxuXHRcdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHRcdFx0Ly8gc3RvcCB0cmF2ZXJzYWwgaWYgd2UgZmluZCBhIHBvaW50IHRoYXQncyB1bmRlciB0aGUgZ2l2ZW4gdGhyZXNob2xkXG5cdFx0XHRcdFx0XHRcdGlmICggZGlzdCA8IG1pblRocmVzaG9sZCApIHtcblxuXHRcdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHRcdFx0XHRcdH1cblxuXHRcdFx0XHRcdFx0fVxuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSxcblxuXHRcdH1cblxuXHQpO1xuXG5cdEV4dGVuZGVkVHJpYW5nbGVQb29sLnJlbGVhc2VQcmltaXRpdmUoIHRyaWFuZ2xlICk7XG5cdEV4dGVuZGVkVHJpYW5nbGVQb29sLnJlbGVhc2VQcmltaXRpdmUoIHRyaWFuZ2xlMiApO1xuXG5cdGlmICggY2xvc2VzdERpc3RhbmNlID09PSBJbmZpbml0eSApIHtcblxuXHRcdHJldHVybiBudWxsO1xuXG5cdH1cblxuXHRpZiAoICEgdGFyZ2V0MS5wb2ludCApIHtcblxuXHRcdHRhcmdldDEucG9pbnQgPSB0ZW1wVGFyZ2V0RGVzdDEuY2xvbmUoKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0dGFyZ2V0MS5wb2ludC5jb3B5KCB0ZW1wVGFyZ2V0RGVzdDEgKTtcblxuXHR9XG5cblx0dGFyZ2V0MS5kaXN0YW5jZSA9IGNsb3Nlc3REaXN0YW5jZSxcblx0dGFyZ2V0MS5mYWNlSW5kZXggPSBjbG9zZXN0RGlzdGFuY2VUcmlJbmRleDtcblxuXHRpZiAoIHRhcmdldDIgKSB7XG5cblx0XHRpZiAoICEgdGFyZ2V0Mi5wb2ludCApIHRhcmdldDIucG9pbnQgPSB0ZW1wVGFyZ2V0RGVzdDIuY2xvbmUoKTtcblx0XHRlbHNlIHRhcmdldDIucG9pbnQuY29weSggdGVtcFRhcmdldERlc3QyICk7XG5cdFx0dGFyZ2V0Mi5wb2ludC5hcHBseU1hdHJpeDQoIHRlbXBNYXRyaXggKTtcblx0XHR0ZW1wVGFyZ2V0RGVzdDEuYXBwbHlNYXRyaXg0KCB0ZW1wTWF0cml4ICk7XG5cdFx0dGFyZ2V0Mi5kaXN0YW5jZSA9IHRlbXBUYXJnZXREZXN0MS5zdWIoIHRhcmdldDIucG9pbnQgKS5sZW5ndGgoKTtcblx0XHR0YXJnZXQyLmZhY2VJbmRleCA9IGNsb3Nlc3REaXN0YW5jZU90aGVyVHJpSW5kZXg7XG5cblx0fVxuXG5cdHJldHVybiB0YXJnZXQxO1xuXG59XG5cbmV4cG9ydCB7IGNsb3Nlc3RQb2ludFRvR2VvbWV0cnlfaW5kaXJlY3QgfTtcbiJdLCJuYW1lcyI6WyJNYXRyaXg0IiwiVmVjdG9yMyIsIk9yaWVudGVkQm94Iiwic2V0VHJpYW5nbGUiLCJnZXRUcmlDb3VudCIsIkV4dGVuZGVkVHJpYW5nbGVQb29sIiwidGVtcE1hdHJpeCIsIm9iYiIsIm9iYjIiLCJ0ZW1wMSIsInRlbXAyIiwidGVtcDMiLCJ0ZW1wNCIsImNsb3Nlc3RQb2ludFRvR2VvbWV0cnlfaW5kaXJlY3QiLCJidmgiLCJvdGhlckdlb21ldHJ5IiwiZ2VvbWV0cnlUb0J2aCIsInRhcmdldDEiLCJ0YXJnZXQyIiwibWluVGhyZXNob2xkIiwibWF4VGhyZXNob2xkIiwiSW5maW5pdHkiLCJib3VuZGluZ0JveCIsImNvbXB1dGVCb3VuZGluZ0JveCIsInNldCIsIm1pbiIsIm1heCIsIm5lZWRzVXBkYXRlIiwiZ2VvbWV0cnkiLCJwb3MiLCJhdHRyaWJ1dGVzIiwicG9zaXRpb24iLCJpbmRleCIsIm90aGVyUG9zIiwib3RoZXJJbmRleCIsInRyaWFuZ2xlIiwiZ2V0UHJpbWl0aXZlIiwidHJpYW5nbGUyIiwidGVtcFRhcmdldDEiLCJ0ZW1wVGFyZ2V0RGVzdDEiLCJ0ZW1wVGFyZ2V0MiIsInRlbXBUYXJnZXREZXN0MiIsImNsb3Nlc3REaXN0YW5jZSIsImNsb3Nlc3REaXN0YW5jZVRyaUluZGV4IiwiY2xvc2VzdERpc3RhbmNlT3RoZXJUcmlJbmRleCIsImNvcHkiLCJpbnZlcnQiLCJtYXRyaXgiLCJzaGFwZWNhc3QiLCJib3VuZHNUcmF2ZXJzZU9yZGVyIiwiYm94IiwiZGlzdGFuY2VUb0JveCIsImludGVyc2VjdHNCb3VuZHMiLCJpc0xlYWYiLCJzY29yZSIsImludGVyc2VjdHNSYW5nZSIsIm9mZnNldCIsImNvdW50IiwiYm91bmRzVHJlZSIsIm90aGVyQnZoIiwib3RoZXJPZmZzZXQiLCJvdGhlckNvdW50IiwiaTIiLCJsMiIsInRpMiIsInJlc29sdmVUcmlhbmdsZUluZGV4IiwiYSIsImFwcGx5TWF0cml4NCIsImIiLCJjIiwiaSIsImwiLCJ0aSIsImRpc3QiLCJkaXN0YW5jZVRvVHJpYW5nbGUiLCJ0cmlDb3VudCIsInJlbGVhc2VQcmltaXRpdmUiLCJwb2ludCIsImNsb25lIiwiZGlzdGFuY2UiLCJmYWNlSW5kZXgiLCJzdWIiLCJsZW5ndGgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/closestPointToGeometry_indirect.generated.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/closestPointToPoint.js":
/*!*********************************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/closestPointToPoint.js ***!
  \*********************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closestPointToPoint: () => (/* binding */ closestPointToPoint)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n\nconst temp = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst temp1 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nfunction closestPointToPoint(bvh, point, target = {}, minThreshold = 0, maxThreshold = Infinity) {\n    // early out if under minThreshold\n    // skip checking if over maxThreshold\n    // set minThreshold = maxThreshold to quickly check if a point is within a threshold\n    // returns Infinity if no value found\n    const minThresholdSq = minThreshold * minThreshold;\n    const maxThresholdSq = maxThreshold * maxThreshold;\n    let closestDistanceSq = Infinity;\n    let closestDistanceTriIndex = null;\n    bvh.shapecast({\n        boundsTraverseOrder: (box)=>{\n            temp.copy(point).clamp(box.min, box.max);\n            return temp.distanceToSquared(point);\n        },\n        intersectsBounds: (box, isLeaf, score)=>{\n            return score < closestDistanceSq && score < maxThresholdSq;\n        },\n        intersectsTriangle: (tri, triIndex)=>{\n            tri.closestPointToPoint(point, temp);\n            const distSq = point.distanceToSquared(temp);\n            if (distSq < closestDistanceSq) {\n                temp1.copy(temp);\n                closestDistanceSq = distSq;\n                closestDistanceTriIndex = triIndex;\n            }\n            if (distSq < minThresholdSq) {\n                return true;\n            } else {\n                return false;\n            }\n        }\n    });\n    if (closestDistanceSq === Infinity) return null;\n    const closestDistance = Math.sqrt(closestDistanceSq);\n    if (!target.point) target.point = temp1.clone();\n    else target.point.copy(temp1);\n    target.distance = closestDistance, target.faceIndex = closestDistanceTriIndex;\n    return target;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9jb3JlL2Nhc3QvY2xvc2VzdFBvaW50VG9Qb2ludC5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUFnQztBQUVoQyxNQUFNQyxPQUFPLGFBQWEsR0FBRyxJQUFJRCwwQ0FBT0E7QUFDeEMsTUFBTUUsUUFBUSxhQUFhLEdBQUcsSUFBSUYsMENBQU9BO0FBRWxDLFNBQVNHLG9CQUNmQyxHQUFHLEVBQ0hDLEtBQUssRUFDTEMsU0FBUyxDQUFFLENBQUMsRUFDWkMsZUFBZSxDQUFDLEVBQ2hCQyxlQUFlQyxRQUFRO0lBR3ZCLGtDQUFrQztJQUNsQyxxQ0FBcUM7SUFDckMsb0ZBQW9GO0lBQ3BGLHFDQUFxQztJQUNyQyxNQUFNQyxpQkFBaUJILGVBQWVBO0lBQ3RDLE1BQU1JLGlCQUFpQkgsZUFBZUE7SUFDdEMsSUFBSUksb0JBQW9CSDtJQUN4QixJQUFJSSwwQkFBMEI7SUFDOUJULElBQUlVLFNBQVMsQ0FFWjtRQUVDQyxxQkFBcUJDLENBQUFBO1lBRXBCZixLQUFLZ0IsSUFBSSxDQUFFWixPQUFRYSxLQUFLLENBQUVGLElBQUlHLEdBQUcsRUFBRUgsSUFBSUksR0FBRztZQUMxQyxPQUFPbkIsS0FBS29CLGlCQUFpQixDQUFFaEI7UUFFaEM7UUFFQWlCLGtCQUFrQixDQUFFTixLQUFLTyxRQUFRQztZQUVoQyxPQUFPQSxRQUFRWixxQkFBcUJZLFFBQVFiO1FBRTdDO1FBRUFjLG9CQUFvQixDQUFFQyxLQUFLQztZQUUxQkQsSUFBSXZCLG1CQUFtQixDQUFFRSxPQUFPSjtZQUNoQyxNQUFNMkIsU0FBU3ZCLE1BQU1nQixpQkFBaUIsQ0FBRXBCO1lBQ3hDLElBQUsyQixTQUFTaEIsbUJBQW9CO2dCQUVqQ1YsTUFBTWUsSUFBSSxDQUFFaEI7Z0JBQ1pXLG9CQUFvQmdCO2dCQUNwQmYsMEJBQTBCYztZQUUzQjtZQUVBLElBQUtDLFNBQVNsQixnQkFBaUI7Z0JBRTlCLE9BQU87WUFFUixPQUFPO2dCQUVOLE9BQU87WUFFUjtRQUVEO0lBRUQ7SUFJRCxJQUFLRSxzQkFBc0JILFVBQVcsT0FBTztJQUU3QyxNQUFNb0Isa0JBQWtCQyxLQUFLQyxJQUFJLENBQUVuQjtJQUVuQyxJQUFLLENBQUVOLE9BQU9ELEtBQUssRUFBR0MsT0FBT0QsS0FBSyxHQUFHSCxNQUFNOEIsS0FBSztTQUMzQzFCLE9BQU9ELEtBQUssQ0FBQ1ksSUFBSSxDQUFFZjtJQUN4QkksT0FBTzJCLFFBQVEsR0FBR0osaUJBQ2xCdkIsT0FBTzRCLFNBQVMsR0FBR3JCO0lBRW5CLE9BQU9QO0FBRVIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aWJlLTNkLWNvZGUvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9jb3JlL2Nhc3QvY2xvc2VzdFBvaW50VG9Qb2ludC5qcz8xZjEzIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICd0aHJlZSc7XG5cbmNvbnN0IHRlbXAgPSAvKiBAX19QVVJFX18gKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IHRlbXAxID0gLyogQF9fUFVSRV9fICovIG5ldyBWZWN0b3IzKCk7XG5cbmV4cG9ydCBmdW5jdGlvbiBjbG9zZXN0UG9pbnRUb1BvaW50KFxuXHRidmgsXG5cdHBvaW50LFxuXHR0YXJnZXQgPSB7IH0sXG5cdG1pblRocmVzaG9sZCA9IDAsXG5cdG1heFRocmVzaG9sZCA9IEluZmluaXR5LFxuKSB7XG5cblx0Ly8gZWFybHkgb3V0IGlmIHVuZGVyIG1pblRocmVzaG9sZFxuXHQvLyBza2lwIGNoZWNraW5nIGlmIG92ZXIgbWF4VGhyZXNob2xkXG5cdC8vIHNldCBtaW5UaHJlc2hvbGQgPSBtYXhUaHJlc2hvbGQgdG8gcXVpY2tseSBjaGVjayBpZiBhIHBvaW50IGlzIHdpdGhpbiBhIHRocmVzaG9sZFxuXHQvLyByZXR1cm5zIEluZmluaXR5IGlmIG5vIHZhbHVlIGZvdW5kXG5cdGNvbnN0IG1pblRocmVzaG9sZFNxID0gbWluVGhyZXNob2xkICogbWluVGhyZXNob2xkO1xuXHRjb25zdCBtYXhUaHJlc2hvbGRTcSA9IG1heFRocmVzaG9sZCAqIG1heFRocmVzaG9sZDtcblx0bGV0IGNsb3Nlc3REaXN0YW5jZVNxID0gSW5maW5pdHk7XG5cdGxldCBjbG9zZXN0RGlzdGFuY2VUcmlJbmRleCA9IG51bGw7XG5cdGJ2aC5zaGFwZWNhc3QoXG5cblx0XHR7XG5cblx0XHRcdGJvdW5kc1RyYXZlcnNlT3JkZXI6IGJveCA9PiB7XG5cblx0XHRcdFx0dGVtcC5jb3B5KCBwb2ludCApLmNsYW1wKCBib3gubWluLCBib3gubWF4ICk7XG5cdFx0XHRcdHJldHVybiB0ZW1wLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludCApO1xuXG5cdFx0XHR9LFxuXG5cdFx0XHRpbnRlcnNlY3RzQm91bmRzOiAoIGJveCwgaXNMZWFmLCBzY29yZSApID0+IHtcblxuXHRcdFx0XHRyZXR1cm4gc2NvcmUgPCBjbG9zZXN0RGlzdGFuY2VTcSAmJiBzY29yZSA8IG1heFRocmVzaG9sZFNxO1xuXG5cdFx0XHR9LFxuXG5cdFx0XHRpbnRlcnNlY3RzVHJpYW5nbGU6ICggdHJpLCB0cmlJbmRleCApID0+IHtcblxuXHRcdFx0XHR0cmkuY2xvc2VzdFBvaW50VG9Qb2ludCggcG9pbnQsIHRlbXAgKTtcblx0XHRcdFx0Y29uc3QgZGlzdFNxID0gcG9pbnQuZGlzdGFuY2VUb1NxdWFyZWQoIHRlbXAgKTtcblx0XHRcdFx0aWYgKCBkaXN0U3EgPCBjbG9zZXN0RGlzdGFuY2VTcSApIHtcblxuXHRcdFx0XHRcdHRlbXAxLmNvcHkoIHRlbXAgKTtcblx0XHRcdFx0XHRjbG9zZXN0RGlzdGFuY2VTcSA9IGRpc3RTcTtcblx0XHRcdFx0XHRjbG9zZXN0RGlzdGFuY2VUcmlJbmRleCA9IHRyaUluZGV4O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRpZiAoIGRpc3RTcSA8IG1pblRocmVzaG9sZFNxICkge1xuXG5cdFx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0sXG5cblx0XHR9XG5cblx0KTtcblxuXHRpZiAoIGNsb3Nlc3REaXN0YW5jZVNxID09PSBJbmZpbml0eSApIHJldHVybiBudWxsO1xuXG5cdGNvbnN0IGNsb3Nlc3REaXN0YW5jZSA9IE1hdGguc3FydCggY2xvc2VzdERpc3RhbmNlU3EgKTtcblxuXHRpZiAoICEgdGFyZ2V0LnBvaW50ICkgdGFyZ2V0LnBvaW50ID0gdGVtcDEuY2xvbmUoKTtcblx0ZWxzZSB0YXJnZXQucG9pbnQuY29weSggdGVtcDEgKTtcblx0dGFyZ2V0LmRpc3RhbmNlID0gY2xvc2VzdERpc3RhbmNlLFxuXHR0YXJnZXQuZmFjZUluZGV4ID0gY2xvc2VzdERpc3RhbmNlVHJpSW5kZXg7XG5cblx0cmV0dXJuIHRhcmdldDtcblxufVxuIl0sIm5hbWVzIjpbIlZlY3RvcjMiLCJ0ZW1wIiwidGVtcDEiLCJjbG9zZXN0UG9pbnRUb1BvaW50IiwiYnZoIiwicG9pbnQiLCJ0YXJnZXQiLCJtaW5UaHJlc2hvbGQiLCJtYXhUaHJlc2hvbGQiLCJJbmZpbml0eSIsIm1pblRocmVzaG9sZFNxIiwibWF4VGhyZXNob2xkU3EiLCJjbG9zZXN0RGlzdGFuY2VTcSIsImNsb3Nlc3REaXN0YW5jZVRyaUluZGV4Iiwic2hhcGVjYXN0IiwiYm91bmRzVHJhdmVyc2VPcmRlciIsImJveCIsImNvcHkiLCJjbGFtcCIsIm1pbiIsIm1heCIsImRpc3RhbmNlVG9TcXVhcmVkIiwiaW50ZXJzZWN0c0JvdW5kcyIsImlzTGVhZiIsInNjb3JlIiwiaW50ZXJzZWN0c1RyaWFuZ2xlIiwidHJpIiwidHJpSW5kZXgiLCJkaXN0U3EiLCJjbG9zZXN0RGlzdGFuY2UiLCJNYXRoIiwic3FydCIsImNsb25lIiwiZGlzdGFuY2UiLCJmYWNlSW5kZXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/closestPointToPoint.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/intersectsGeometry.generated.js":
/*!******************************************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/intersectsGeometry.generated.js ***!
  \******************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   intersectsGeometry: () => (/* binding */ intersectsGeometry)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var _math_OrientedBox_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../math/OrientedBox.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/math/OrientedBox.js\");\n/* harmony import */ var _math_ExtendedTriangle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/ExtendedTriangle.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/math/ExtendedTriangle.js\");\n/* harmony import */ var _utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utils/TriangleUtilities.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js\");\n/* harmony import */ var _utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utils/ArrayBoxUtilities.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js\");\n/* harmony import */ var _utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/nodeBufferUtils.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/utils/nodeBufferUtils.js\");\n/* harmony import */ var _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/BufferStack.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/utils/BufferStack.js\");\n\n\n\n\n\n\n\n/*****************************************************************/ /* This file is generated from \"intersectsGeometry.template.js\". */ /*****************************************************************/ /* eslint-disable indent */ const boundingBox = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Box3();\nconst triangle = /* @__PURE__ */ new _math_ExtendedTriangle_js__WEBPACK_IMPORTED_MODULE_1__.ExtendedTriangle();\nconst triangle2 = /* @__PURE__ */ new _math_ExtendedTriangle_js__WEBPACK_IMPORTED_MODULE_1__.ExtendedTriangle();\nconst invertedMat = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\nconst obb = /* @__PURE__ */ new _math_OrientedBox_js__WEBPACK_IMPORTED_MODULE_2__.OrientedBox();\nconst obb2 = /* @__PURE__ */ new _math_OrientedBox_js__WEBPACK_IMPORTED_MODULE_2__.OrientedBox();\nfunction intersectsGeometry(bvh, root, otherGeometry, geometryToBvh) {\n    _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_3__.BufferStack.setBuffer(bvh._roots[root]);\n    const result = _intersectsGeometry(0, bvh, otherGeometry, geometryToBvh);\n    _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_3__.BufferStack.clearBuffer();\n    return result;\n}\nfunction _intersectsGeometry(nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null) {\n    const { float32Array, uint16Array, uint32Array } = _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_3__.BufferStack;\n    let nodeIndex16 = nodeIndex32 * 2;\n    if (cachedObb === null) {\n        if (!otherGeometry.boundingBox) {\n            otherGeometry.computeBoundingBox();\n        }\n        obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);\n        cachedObb = obb;\n    }\n    const isLeaf = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.IS_LEAF)(nodeIndex16, uint16Array);\n    if (isLeaf) {\n        const thisGeometry = bvh.geometry;\n        const thisIndex = thisGeometry.index;\n        const thisPos = thisGeometry.attributes.position;\n        const index = otherGeometry.index;\n        const pos = otherGeometry.attributes.position;\n        const offset = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.OFFSET)(nodeIndex32, uint32Array);\n        const count = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.COUNT)(nodeIndex16, uint16Array);\n        // get the inverse of the geometry matrix so we can transform our triangles into the\n        // geometry space we're trying to test. We assume there are fewer triangles being checked\n        // here.\n        invertedMat.copy(geometryToBvh).invert();\n        if (otherGeometry.boundsTree) {\n            // if there's a bounds tree\n            (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_5__.arrayToBox)((0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.BOUNDING_DATA_INDEX)(nodeIndex32), float32Array, obb2);\n            obb2.matrix.copy(invertedMat);\n            obb2.needsUpdate = true;\n            // TODO: use a triangle iteration function here\n            const res = otherGeometry.boundsTree.shapecast({\n                intersectsBounds: (box)=>obb2.intersectsBox(box),\n                intersectsTriangle: (tri)=>{\n                    tri.a.applyMatrix4(geometryToBvh);\n                    tri.b.applyMatrix4(geometryToBvh);\n                    tri.c.applyMatrix4(geometryToBvh);\n                    tri.needsUpdate = true;\n                    for(let i = offset * 3, l = (count + offset) * 3; i < l; i += 3){\n                        // this triangle needs to be transformed into the current BVH coordinate frame\n                        (0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_6__.setTriangle)(triangle2, i, thisIndex, thisPos);\n                        triangle2.needsUpdate = true;\n                        if (tri.intersectsTriangle(triangle2)) {\n                            return true;\n                        }\n                    }\n                    return false;\n                }\n            });\n            return res;\n        } else {\n            // if we're just dealing with raw geometry\n            for(let i = offset * 3, l = (count + offset) * 3; i < l; i += 3){\n                // this triangle needs to be transformed into the current BVH coordinate frame\n                (0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_6__.setTriangle)(triangle, i, thisIndex, thisPos);\n                triangle.a.applyMatrix4(invertedMat);\n                triangle.b.applyMatrix4(invertedMat);\n                triangle.c.applyMatrix4(invertedMat);\n                triangle.needsUpdate = true;\n                for(let i2 = 0, l2 = index.count; i2 < l2; i2 += 3){\n                    (0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_6__.setTriangle)(triangle2, i2, index, pos);\n                    triangle2.needsUpdate = true;\n                    if (triangle.intersectsTriangle(triangle2)) {\n                        return true;\n                    }\n                }\n            }\n        }\n    } else {\n        const left = nodeIndex32 + 8;\n        const right = uint32Array[nodeIndex32 + 6];\n        (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_5__.arrayToBox)((0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.BOUNDING_DATA_INDEX)(left), float32Array, boundingBox);\n        const leftIntersection = cachedObb.intersectsBox(boundingBox) && _intersectsGeometry(left, bvh, otherGeometry, geometryToBvh, cachedObb);\n        if (leftIntersection) return true;\n        (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_5__.arrayToBox)((0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.BOUNDING_DATA_INDEX)(right), float32Array, boundingBox);\n        const rightIntersection = cachedObb.intersectsBox(boundingBox) && _intersectsGeometry(right, bvh, otherGeometry, geometryToBvh, cachedObb);\n        if (rightIntersection) return true;\n        return false;\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9jb3JlL2Nhc3QvaW50ZXJzZWN0c0dlb21ldHJ5LmdlbmVyYXRlZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFzQztBQUNrQjtBQUNVO0FBQ0g7QUFDRDtBQUM0QjtBQUNwQztBQUV0RCxpRUFBaUUsR0FDakUsaUVBQWlFLEdBQ2pFLGlFQUFpRSxHQUNqRSx5QkFBeUIsR0FFekIsTUFBTVcsY0FBYyxhQUFhLEdBQUcsSUFBSVgsdUNBQUlBO0FBQzVDLE1BQU1ZLFdBQVcsYUFBYSxHQUFHLElBQUlULHVFQUFnQkE7QUFDckQsTUFBTVUsWUFBWSxhQUFhLEdBQUcsSUFBSVYsdUVBQWdCQTtBQUN0RCxNQUFNVyxjQUFjLGFBQWEsR0FBRyxJQUFJYiwwQ0FBT0E7QUFFL0MsTUFBTWMsTUFBTSxhQUFhLEdBQUcsSUFBSWIsNkRBQVdBO0FBQzNDLE1BQU1jLE9BQU8sYUFBYSxHQUFHLElBQUlkLDZEQUFXQTtBQUU1QyxTQUFTZSxtQkFBb0JDLEdBQUcsRUFBRUMsSUFBSSxFQUFFQyxhQUFhLEVBQUVDLGFBQWE7SUFFbkVYLDhEQUFXQSxDQUFDWSxTQUFTLENBQUVKLElBQUlLLE1BQU0sQ0FBRUosS0FBTTtJQUN6QyxNQUFNSyxTQUFTQyxvQkFBcUIsR0FBR1AsS0FBS0UsZUFBZUM7SUFDM0RYLDhEQUFXQSxDQUFDZ0IsV0FBVztJQUV2QixPQUFPRjtBQUVSO0FBRUEsU0FBU0Msb0JBQXFCRSxXQUFXLEVBQUVULEdBQUcsRUFBRUUsYUFBYSxFQUFFQyxhQUFhLEVBQUVPLFlBQVksSUFBSTtJQUU3RixNQUFNLEVBQUVDLFlBQVksRUFBRUMsV0FBVyxFQUFFQyxXQUFXLEVBQUUsR0FBR3JCLDhEQUFXQTtJQUM5RCxJQUFJc0IsY0FBY0wsY0FBYztJQUVoQyxJQUFLQyxjQUFjLE1BQU87UUFFekIsSUFBSyxDQUFFUixjQUFjVCxXQUFXLEVB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QWMsRUFBRztRQUU1Q3RCLHVFQUFVQSxDQUFFSSw4RUFBbUJBLENBQUUyRCxPQUFRdkMsY0FBY2xCO1FBQ3ZELE1BQU0yRCxtQkFDTDFDLFVBQVU2QixhQUFhLENBQUU5QyxnQkFDekJjLG9CQUFxQjJDLE1BQU1sRCxLQUFLRSxlQUFlQyxlQUFlTztRQUUvRCxJQUFLMEMsa0JBQW1CLE9BQU87UUFFL0JqRSx1RUFBVUEsQ0FBRUksOEVBQW1CQSxDQUFFNEQsUUFBU3hDLGNBQWNsQjtRQUN4RCxNQUFNNEQsb0JBQ0wzQyxVQUFVNkIsYUFBYSxDQUFFOUMsZ0JBQ3pCYyxvQkFBcUI0QyxPQUFPbkQsS0FBS0UsZUFBZUMsZUFBZU87UUFFaEUsSUFBSzJDLG1CQUFvQixPQUFPO1FBRWhDLE9BQU87SUFFUjtBQUVEO0FBRThCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmliZS0zZC1jb2RlLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvY29yZS9jYXN0L2ludGVyc2VjdHNHZW9tZXRyeS5nZW5lcmF0ZWQuanM/NWMxNyJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBCb3gzLCBNYXRyaXg0IH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgT3JpZW50ZWRCb3ggfSBmcm9tICcuLi8uLi9tYXRoL09yaWVudGVkQm94LmpzJztcbmltcG9ydCB7IEV4dGVuZGVkVHJpYW5nbGUgfSBmcm9tICcuLi8uLi9tYXRoL0V4dGVuZGVkVHJpYW5nbGUuanMnO1xuaW1wb3J0IHsgc2V0VHJpYW5nbGUgfSBmcm9tICcuLi8uLi91dGlscy9UcmlhbmdsZVV0aWxpdGllcy5qcyc7XG5pbXBvcnQgeyBhcnJheVRvQm94IH0gZnJvbSAnLi4vLi4vdXRpbHMvQXJyYXlCb3hVdGlsaXRpZXMuanMnO1xuaW1wb3J0IHsgSVNfTEVBRiwgT0ZGU0VULCBDT1VOVCwgQk9VTkRJTkdfREFUQV9JTkRFWCB9IGZyb20gJy4uL3V0aWxzL25vZGVCdWZmZXJVdGlscy5qcyc7XG5pbXBvcnQgeyBCdWZmZXJTdGFjayB9IGZyb20gJy4uL3V0aWxzL0J1ZmZlclN0YWNrLmpzJztcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBmcm9tIFwiaW50ZXJzZWN0c0dlb21ldHJ5LnRlbXBsYXRlLmpzXCIuICovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiBlc2xpbnQtZGlzYWJsZSBpbmRlbnQgKi9cblxuY29uc3QgYm91bmRpbmdCb3ggPSAvKiBAX19QVVJFX18gKi8gbmV3IEJveDMoKTtcbmNvbnN0IHRyaWFuZ2xlID0gLyogQF9fUFVSRV9fICovIG5ldyBFeHRlbmRlZFRyaWFuZ2xlKCk7XG5jb25zdCB0cmlhbmdsZTIgPSAvKiBAX19QVVJFX18gKi8gbmV3IEV4dGVuZGVkVHJpYW5nbGUoKTtcbmNvbnN0IGludmVydGVkTWF0ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXRyaXg0KCk7XG5cbmNvbnN0IG9iYiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgT3JpZW50ZWRCb3goKTtcbmNvbnN0IG9iYjIgPSAvKiBAX19QVVJFX18gKi8gbmV3IE9yaWVudGVkQm94KCk7XG5cbmZ1bmN0aW9uIGludGVyc2VjdHNHZW9tZXRyeSggYnZoLCByb290LCBvdGhlckdlb21ldHJ5LCBnZW9tZXRyeVRvQnZoICkge1xuXG5cdEJ1ZmZlclN0YWNrLnNldEJ1ZmZlciggYnZoLl9yb290c1sgcm9vdCBdICk7XG5cdGNvbnN0IHJlc3VsdCA9IF9pbnRlcnNlY3RzR2VvbWV0cnkoIDAsIGJ2aCwgb3RoZXJHZW9tZXRyeSwgZ2VvbWV0cnlUb0J2aCApO1xuXHRCdWZmZXJTdGFjay5jbGVhckJ1ZmZlcigpO1xuXG5cdHJldHVybiByZXN1bHQ7XG5cbn1cblxuZnVuY3Rpb24gX2ludGVyc2VjdHNHZW9tZXRyeSggbm9kZUluZGV4MzIsIGJ2aCwgb3RoZXJHZW9tZXRyeSwgZ2VvbWV0cnlUb0J2aCwgY2FjaGVkT2JiID0gbnVsbCApIHtcblxuXHRjb25zdCB7IGZsb2F0MzJBcnJheSwgdWludDE2QXJyYXksIHVpbnQzMkFycmF5IH0gPSBCdWZmZXJTdGFjaztcblx0bGV0IG5vZGVJbmRleDE2ID0gbm9kZUluZGV4MzIgKiAyO1xuXG5cdGlmICggY2FjaGVkT2JiID09PSBudWxsICkge1xuXG5cdFx0aWYgKCAhIG90aGVyR2VvbWV0cnkuYm91bmRpbmdCb3ggKSB7XG5cblx0XHRcdG90aGVyR2VvbWV0cnkuY29tcHV0ZUJvdW5kaW5nQm94KCk7XG5cblx0XHR9XG5cblx0XHRvYmIuc2V0KCBvdGhlckdlb21ldHJ5LmJvdW5kaW5nQm94Lm1pbiwgb3RoZXJHZW9tZXRyeS5ib3VuZGluZ0JveC5tYXgsIGdlb21ldHJ5VG9CdmggKTtcblx0XHRjYWNoZWRPYmIgPSBvYmI7XG5cblx0fVxuXG5cdGNvbnN0IGlzTGVhZiA9IElTX0xFQUYoIG5vZGVJbmRleDE2LCB1aW50MTZBcnJheSApO1xuXHRpZiAoIGlzTGVhZiApIHtcblxuXHRcdGNvbnN0IHRoaXNHZW9tZXRyeSA9IGJ2aC5nZW9tZXRyeTtcblx0XHRjb25zdCB0aGlzSW5kZXggPSB0aGlzR2VvbWV0cnkuaW5kZXg7XG5cdFx0Y29uc3QgdGhpc1BvcyA9IHRoaXNHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG5cdFx0Y29uc3QgaW5kZXggPSBvdGhlckdlb21ldHJ5LmluZGV4O1xuXHRcdGNvbnN0IHBvcyA9IG90aGVyR2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuXHRcdGNvbnN0IG9mZnNldCA9IE9GRlNFVCggbm9kZUluZGV4MzIsIHVpbnQzMkFycmF5ICk7XG5cdFx0Y29uc3QgY291bnQgPSBDT1VOVCggbm9kZUluZGV4MTYsIHVpbnQxNkFycmF5ICk7XG5cblx0XHQvLyBnZXQgdGhlIGludmVyc2Ugb2YgdGhlIGdlb21ldHJ5IG1hdHJpeCBzbyB3ZSBjYW4gdHJhbnNmb3JtIG91ciB0cmlhbmdsZXMgaW50byB0aGVcblx0XHQvLyBnZW9tZXRyeSBzcGFjZSB3ZSdyZSB0cnlpbmcgdG8gdGVzdC4gV2UgYXNzdW1lIHRoZXJlIGFyZSBmZXdlciB0cmlhbmdsZXMgYmVpbmcgY2hlY2tlZFxuXHRcdC8vIGhlcmUuXG5cdFx0aW52ZXJ0ZWRNYXQuY29weSggZ2VvbWV0cnlUb0J2aCApLmludmVydCgpO1xuXG5cdFx0aWYgKCBvdGhlckdlb21ldHJ5LmJvdW5kc1RyZWUgKSB7XG5cblx0XHRcdC8vIGlmIHRoZXJlJ3MgYSBib3VuZHMgdHJlZVxuXHRcdFx0YXJyYXlUb0JveCggQk9VTkRJTkdfREFUQV9JTkRFWCggbm9kZUluZGV4MzIgKSwgZmxvYXQzMkFycmF5LCBvYmIyICk7XG5cdFx0XHRvYmIyLm1hdHJpeC5jb3B5KCBpbnZlcnRlZE1hdCApO1xuXHRcdFx0b2JiMi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdC8vIFRPRE86IHVzZSBhIHRyaWFuZ2xlIGl0ZXJhdGlvbiBmdW5jdGlvbiBoZXJlXG5cdFx0XHRjb25zdCByZXMgPSBvdGhlckdlb21ldHJ5LmJvdW5kc1RyZWUuc2hhcGVjYXN0KCB7XG5cblx0XHRcdFx0aW50ZXJzZWN0c0JvdW5kczogYm94ID0+IG9iYjIuaW50ZXJzZWN0c0JveCggYm94ICksXG5cblx0XHRcdFx0aW50ZXJzZWN0c1RyaWFuZ2xlOiB0cmkgPT4ge1xuXG5cdFx0XHRcdFx0dHJpLmEuYXBwbHlNYXRyaXg0KCBnZW9tZXRyeVRvQnZoICk7XG5cdFx0XHRcdFx0dHJpLmIuYXBwbHlNYXRyaXg0KCBnZW9tZXRyeVRvQnZoICk7XG5cdFx0XHRcdFx0dHJpLmMuYXBwbHlNYXRyaXg0KCBnZW9tZXRyeVRvQnZoICk7XG5cdFx0XHRcdFx0dHJpLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkgPSBvZmZzZXQgKiAzLCBsID0gKCBjb3VudCArIG9mZnNldCApICogMzsgaSA8IGw7IGkgKz0gMyApIHtcblxuXHRcdFx0XHRcdFx0Ly8gdGhpcyB0cmlhbmdsZSBuZWVkcyB0byBiZSB0cmFuc2Zvcm1lZCBpbnRvIHRoZSBjdXJyZW50IEJWSCBjb29yZGluYXRlIGZyYW1lXG5cdFx0XHRcdFx0XHRzZXRUcmlhbmdsZSggdHJpYW5nbGUyLCBpLCB0aGlzSW5kZXgsIHRoaXNQb3MgKTtcblx0XHRcdFx0XHRcdHRyaWFuZ2xlMi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRpZiAoIHRyaS5pbnRlcnNlY3RzVHJpYW5nbGUoIHRyaWFuZ2xlMiApICkge1xuXG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0cmV0dXJuIHJlcztcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIGlmIHdlJ3JlIGp1c3QgZGVhbGluZyB3aXRoIHJhdyBnZW9tZXRyeVxuXG5cdFx0XHRmb3IgKCBsZXQgaSA9IG9mZnNldCAqIDMsIGwgPSAoIGNvdW50ICsgb2Zmc2V0ICkgKiAzOyBpIDwgbDsgaSArPSAzICkge1xuXG5cdFx0XHRcdC8vIHRoaXMgdHJpYW5nbGUgbmVlZHMgdG8gYmUgdHJhbnNmb3JtZWQgaW50byB0aGUgY3VycmVudCBCVkggY29vcmRpbmF0ZSBmcmFtZVxuXHRcdFx0XHRzZXRUcmlhbmdsZSggdHJpYW5nbGUsIGksIHRoaXNJbmRleCwgdGhpc1BvcyApO1xuXG5cblx0XHRcdFx0dHJpYW5nbGUuYS5hcHBseU1hdHJpeDQoIGludmVydGVkTWF0ICk7XG5cdFx0XHRcdHRyaWFuZ2xlLmIuYXBwbHlNYXRyaXg0KCBpbnZlcnRlZE1hdCApO1xuXHRcdFx0XHR0cmlhbmdsZS5jLmFwcGx5TWF0cml4NCggaW52ZXJ0ZWRNYXQgKTtcblx0XHRcdFx0dHJpYW5nbGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdGZvciAoIGxldCBpMiA9IDAsIGwyID0gaW5kZXguY291bnQ7IGkyIDwgbDI7IGkyICs9IDMgKSB7XG5cblx0XHRcdFx0XHRzZXRUcmlhbmdsZSggdHJpYW5nbGUyLCBpMiwgaW5kZXgsIHBvcyApO1xuXHRcdFx0XHRcdHRyaWFuZ2xlMi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cblx0XHRcdFx0XHRpZiAoIHRyaWFuZ2xlLmludGVyc2VjdHNUcmlhbmdsZSggdHJpYW5nbGUyICkgKSB7XG5cblx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH1cblxuXG5cdFx0XHR9XG5cblxuXHRcdH1cblxuXHR9IGVsc2Uge1xuXG5cdFx0Y29uc3QgbGVmdCA9IG5vZGVJbmRleDMyICsgODtcblx0XHRjb25zdCByaWdodCA9IHVpbnQzMkFycmF5WyBub2RlSW5kZXgzMiArIDYgXTtcblxuXHRcdGFycmF5VG9Cb3goIEJPVU5ESU5HX0RBVEFfSU5ERVgoIGxlZnQgKSwgZmxvYXQzMkFycmF5LCBib3VuZGluZ0JveCApO1xuXHRcdGNvbnN0IGxlZnRJbnRlcnNlY3Rpb24gPVxuXHRcdFx0Y2FjaGVkT2JiLmludGVyc2VjdHNCb3goIGJvdW5kaW5nQm94ICkgJiZcblx0XHRcdF9pbnRlcnNlY3RzR2VvbWV0cnkoIGxlZnQsIGJ2aCwgb3RoZXJHZW9tZXRyeSwgZ2VvbWV0cnlUb0J2aCwgY2FjaGVkT2JiICk7XG5cblx0XHRpZiAoIGxlZnRJbnRlcnNlY3Rpb24gKSByZXR1cm4gdHJ1ZTtcblxuXHRcdGFycmF5VG9Cb3goIEJPVU5ESU5HX0RBVEFfSU5ERVgoIHJpZ2h0ICksIGZsb2F0MzJBcnJheSwgYm91bmRpbmdCb3ggKTtcblx0XHRjb25zdCByaWdodEludGVyc2VjdGlvbiA9XG5cdFx0XHRjYWNoZWRPYmIuaW50ZXJzZWN0c0JveCggYm91bmRpbmdCb3ggKSAmJlxuXHRcdFx0X2ludGVyc2VjdHNHZW9tZXRyeSggcmlnaHQsIGJ2aCwgb3RoZXJHZW9tZXRyeSwgZ2VvbWV0cnlUb0J2aCwgY2FjaGVkT2JiICk7XG5cblx0XHRpZiAoIHJpZ2h0SW50ZXJzZWN0aW9uICkgcmV0dXJuIHRydWU7XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IGludGVyc2VjdHNHZW9tZXRyeSB9O1xuIl0sIm5hbWVzIjpbIkJveDMiLCJNYXRyaXg0IiwiT3JpZW50ZWRCb3giLCJFeHRlbmRlZFRyaWFuZ2xlIiwic2V0VHJpYW5nbGUiLCJhcnJheVRvQm94IiwiSVNfTEVBRiIsIk9GRlNFVCIsIkNPVU5UIiwiQk9VTkRJTkdfREFUQV9JTkRFWCIsIkJ1ZmZlclN0YWNrIiwiYm91bmRpbmdCb3giLCJ0cmlhbmdsZSIsInRyaWFuZ2xlMiIsImludmVydGVkTWF0Iiwib2JiIiwib2JiMiIsImludGVyc2VjdHNHZW9tZXRyeSIsImJ2aCIsInJvb3QiLCJvdGhlckdlb21ldHJ5IiwiZ2VvbWV0cnlUb0J2aCIsInNldEJ1ZmZlciIsIl9yb290cyIsInJlc3VsdCIsIl9pbnRlcnNlY3RzR2VvbWV0cnkiLCJjbGVhckJ1ZmZlciIsIm5vZGVJbmRleDMyIiwiY2FjaGVkT2JiIiwiZmxvYXQzMkFycmF5IiwidWludDE2QXJyYXkiLCJ1aW50MzJBcnJheSIsIm5vZGVJbmRleDE2IiwiY29tcHV0ZUJvdW5kaW5nQm94Iiwic2V0IiwibWluIiwibWF4IiwiaXNMZWFmIiwidGhpc0dlb21ldHJ5IiwiZ2VvbWV0cnkiLCJ0aGlzSW5kZXgiLCJpbmRleCIsInRoaXNQb3MiLCJhdHRyaWJ1dGVzIiwicG9zaXRpb24iLCJwb3MiLCJvZmZzZXQiLCJjb3VudCIsImNvcHkiLCJpbnZlcnQiLCJib3VuZHNUcmVlIiwibWF0cml4IiwibmVlZHNVcGRhdGUiLCJyZXMiLCJzaGFwZWNhc3QiLCJpbnRlcnNlY3RzQm91bmRzIiwiYm94IiwiaW50ZXJzZWN0c0JveCIsImludGVyc2VjdHNUcmlhbmdsZSIsInRyaSIsImEiLCJhcHBseU1hdHJpeDQiLCJiIiwiYyIsImkiLCJsIiwiaTIiLCJsMiIsImxlZnQiLCJyaWdodCIsImxlZnRJbnRlcnNlY3Rpb24iLCJyaWdodEludGVyc2VjdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/intersectsGeometry.generated.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/intersectsGeometry_indirect.generated.js":
/*!***************************************************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/intersectsGeometry_indirect.generated.js ***!
  \***************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   intersectsGeometry_indirect: () => (/* binding */ intersectsGeometry_indirect)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var _math_OrientedBox_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../../math/OrientedBox.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/math/OrientedBox.js\");\n/* harmony import */ var _math_ExtendedTriangle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../math/ExtendedTriangle.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/math/ExtendedTriangle.js\");\n/* harmony import */ var _utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! ../../utils/TriangleUtilities.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js\");\n/* harmony import */ var _utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../../utils/ArrayBoxUtilities.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js\");\n/* harmony import */ var _utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/nodeBufferUtils.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/utils/nodeBufferUtils.js\");\n/* harmony import */ var _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/BufferStack.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/utils/BufferStack.js\");\n\n\n\n\n\n\n\n/*****************************************************************/ /* This file is generated from \"intersectsGeometry.template.js\". */ /*****************************************************************/ /* eslint-disable indent */ const boundingBox = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Box3();\nconst triangle = /* @__PURE__ */ new _math_ExtendedTriangle_js__WEBPACK_IMPORTED_MODULE_1__.ExtendedTriangle();\nconst triangle2 = /* @__PURE__ */ new _math_ExtendedTriangle_js__WEBPACK_IMPORTED_MODULE_1__.ExtendedTriangle();\nconst invertedMat = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\nconst obb = /* @__PURE__ */ new _math_OrientedBox_js__WEBPACK_IMPORTED_MODULE_2__.OrientedBox();\nconst obb2 = /* @__PURE__ */ new _math_OrientedBox_js__WEBPACK_IMPORTED_MODULE_2__.OrientedBox();\nfunction intersectsGeometry_indirect(bvh, root, otherGeometry, geometryToBvh) {\n    _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_3__.BufferStack.setBuffer(bvh._roots[root]);\n    const result = _intersectsGeometry(0, bvh, otherGeometry, geometryToBvh);\n    _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_3__.BufferStack.clearBuffer();\n    return result;\n}\nfunction _intersectsGeometry(nodeIndex32, bvh, otherGeometry, geometryToBvh, cachedObb = null) {\n    const { float32Array, uint16Array, uint32Array } = _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_3__.BufferStack;\n    let nodeIndex16 = nodeIndex32 * 2;\n    if (cachedObb === null) {\n        if (!otherGeometry.boundingBox) {\n            otherGeometry.computeBoundingBox();\n        }\n        obb.set(otherGeometry.boundingBox.min, otherGeometry.boundingBox.max, geometryToBvh);\n        cachedObb = obb;\n    }\n    const isLeaf = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.IS_LEAF)(nodeIndex16, uint16Array);\n    if (isLeaf) {\n        const thisGeometry = bvh.geometry;\n        const thisIndex = thisGeometry.index;\n        const thisPos = thisGeometry.attributes.position;\n        const index = otherGeometry.index;\n        const pos = otherGeometry.attributes.position;\n        const offset = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.OFFSET)(nodeIndex32, uint32Array);\n        const count = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.COUNT)(nodeIndex16, uint16Array);\n        // get the inverse of the geometry matrix so we can transform our triangles into the\n        // geometry space we're trying to test. We assume there are fewer triangles being checked\n        // here.\n        invertedMat.copy(geometryToBvh).invert();\n        if (otherGeometry.boundsTree) {\n            // if there's a bounds tree\n            (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_5__.arrayToBox)((0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.BOUNDING_DATA_INDEX)(nodeIndex32), float32Array, obb2);\n            obb2.matrix.copy(invertedMat);\n            obb2.needsUpdate = true;\n            // TODO: use a triangle iteration function here\n            const res = otherGeometry.boundsTree.shapecast({\n                intersectsBounds: (box)=>obb2.intersectsBox(box),\n                intersectsTriangle: (tri)=>{\n                    tri.a.applyMatrix4(geometryToBvh);\n                    tri.b.applyMatrix4(geometryToBvh);\n                    tri.c.applyMatrix4(geometryToBvh);\n                    tri.needsUpdate = true;\n                    for(let i = offset, l = count + offset; i < l; i++){\n                        // this triangle needs to be transformed into the current BVH coordinate frame\n                        (0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_6__.setTriangle)(triangle2, 3 * bvh.resolveTriangleIndex(i), thisIndex, thisPos);\n                        triangle2.needsUpdate = true;\n                        if (tri.intersectsTriangle(triangle2)) {\n                            return true;\n                        }\n                    }\n                    return false;\n                }\n            });\n            return res;\n        } else {\n            // if we're just dealing with raw geometry\n            for(let i = offset, l = count + offset; i < l; i++){\n                // this triangle needs to be transformed into the current BVH coordinate frame\n                const ti = bvh.resolveTriangleIndex(i);\n                (0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_6__.setTriangle)(triangle, 3 * ti, thisIndex, thisPos);\n                triangle.a.applyMatrix4(invertedMat);\n                triangle.b.applyMatrix4(invertedMat);\n                triangle.c.applyMatrix4(invertedMat);\n                triangle.needsUpdate = true;\n                for(let i2 = 0, l2 = index.count; i2 < l2; i2 += 3){\n                    (0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_6__.setTriangle)(triangle2, i2, index, pos);\n                    triangle2.needsUpdate = true;\n                    if (triangle.intersectsTriangle(triangle2)) {\n                        return true;\n                    }\n                }\n            }\n        }\n    } else {\n        const left = nodeIndex32 + 8;\n        const right = uint32Array[nodeIndex32 + 6];\n        (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_5__.arrayToBox)((0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.BOUNDING_DATA_INDEX)(left), float32Array, boundingBox);\n        const leftIntersection = cachedObb.intersectsBox(boundingBox) && _intersectsGeometry(left, bvh, otherGeometry, geometryToBvh, cachedObb);\n        if (leftIntersection) return true;\n        (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_5__.arrayToBox)((0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_4__.BOUNDING_DATA_INDEX)(right), float32Array, boundingBox);\n        const rightIntersection = cachedObb.intersectsBox(boundingBox) && _intersectsGeometry(right, bvh, otherGeometry, geometryToBvh, cachedObb);\n        if (rightIntersection) return true;\n        return false;\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9jb3JlL2Nhc3QvaW50ZXJzZWN0c0dlb21ldHJ5X2luZGlyZWN0LmdlbmVyYXRlZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7OztBQUFzQztBQUNrQjtBQUNVO0FBQ0g7QUFDRDtBQUM0QjtBQUNwQztBQUV0RCxpRUFBaUUsR0FDakUsaUVBQWlFLEdBQ2pFLGlFQUFpRSxHQUNqRSx5QkFBeUIsR0FFekIsTUFBTVcsY0FBYyxhQUFhLEdBQUcsSUFBSVgsdUNBQUlBO0FBQzVDLE1BQU1ZLFdBQVcsYUFBYSxHQUFHLElBQUlULHVFQUFnQkE7QUFDckQsTUFBTVUsWUFBWSxhQUFhLEdBQUcsSUFBSVYsdUVBQWdCQTtBQUN0RCxNQUFNVyxjQUFjLGFBQWEsR0FBRyxJQUFJYiwwQ0FBT0E7QUFFL0MsTUFBTWMsTUFBTSxhQUFhLEdBQUcsSUFBSWIsNkRBQVdBO0FBQzNDLE1BQU1jLE9BQU8sYUFBYSxHQUFHLElBQUlkLDZEQUFXQTtBQUU1QyxTQUFTZSw0QkFBNkJDLEdBQUcsRUFBRUMsSUFBSSxFQUFFQyxhQUFhLEVBQUVDLGFBQWE7SUFFNUVYLDhEQUFXQSxDQUFDWSxTQUFTLENBQUVKLElBQUlLLE1BQU0sQ0FBRUosS0FBTTtJQUN6QyxNQUFNSyxTQUFTQyxvQkFBcUIsR0FBR1AsS0FBS0UsZUFBZUM7SUFDM0RYLDhEQUFXQSxDQUFDZ0IsV0FBVztJQUV2QixPQUFPRjtBQUVSO0FBRUEsU0FBU0Msb0JBQXFCRSxXQUFXLEVBQUVULEdBQUcsRUFBRUUsYUFBYSxFQUFFQyxhQUFhLEVBQUVPLFlBQVksSUFBSTtJQUU3RixNQUFNLEVBQUVDLFlBQVksRUFBRUMsV0FBVyxFQUFFQyxXQUFXLEVBQUUsR0FBR3JCLDhEQUFXQTtJQUM5RCxJQUFJc0IsY0FBY0wsY0FBYztJQUVoQyxJQUFLQyxjQUFjLE1BQU87UUFFekIsSUFBSyxDQUFFUixjQUFj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QixNQUFNNEMsUUFBUXhDLFdBQVcsQ0FBRUosY0FBYyxFQUFHO1FBRTVDdEIsdUVBQVVBLENBQUVJLDhFQUFtQkEsQ0FBRTZELE9BQVF6QyxjQUFjbEI7UUFDdkQsTUFBTTZELG1CQUNMNUMsVUFBVTZCLGFBQWEsQ0FBRTlDLGdCQUN6QmMsb0JBQXFCNkMsTUFBTXBELEtBQUtFLGVBQWVDLGVBQWVPO1FBRS9ELElBQUs0QyxrQkFBbUIsT0FBTztRQUUvQm5FLHVFQUFVQSxDQUFFSSw4RUFBbUJBLENBQUU4RCxRQUFTMUMsY0FBY2xCO1FBQ3hELE1BQU04RCxvQkFDTDdDLFVBQVU2QixhQUFhLENBQUU5QyxnQkFDekJjLG9CQUFxQjhDLE9BQU9yRCxLQUFLRSxlQUFlQyxlQUFlTztRQUVoRSxJQUFLNkMsbUJBQW9CLE9BQU87UUFFaEMsT0FBTztJQUVSO0FBRUQ7QUFFdUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aWJlLTNkLWNvZGUvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9jb3JlL2Nhc3QvaW50ZXJzZWN0c0dlb21ldHJ5X2luZGlyZWN0LmdlbmVyYXRlZC5qcz82NjhlIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IEJveDMsIE1hdHJpeDQgfSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBPcmllbnRlZEJveCB9IGZyb20gJy4uLy4uL21hdGgvT3JpZW50ZWRCb3guanMnO1xuaW1wb3J0IHsgRXh0ZW5kZWRUcmlhbmdsZSB9IGZyb20gJy4uLy4uL21hdGgvRXh0ZW5kZWRUcmlhbmdsZS5qcyc7XG5pbXBvcnQgeyBzZXRUcmlhbmdsZSB9IGZyb20gJy4uLy4uL3V0aWxzL1RyaWFuZ2xlVXRpbGl0aWVzLmpzJztcbmltcG9ydCB7IGFycmF5VG9Cb3ggfSBmcm9tICcuLi8uLi91dGlscy9BcnJheUJveFV0aWxpdGllcy5qcyc7XG5pbXBvcnQgeyBJU19MRUFGLCBPRkZTRVQsIENPVU5ULCBCT1VORElOR19EQVRBX0lOREVYIH0gZnJvbSAnLi4vdXRpbHMvbm9kZUJ1ZmZlclV0aWxzLmpzJztcbmltcG9ydCB7IEJ1ZmZlclN0YWNrIH0gZnJvbSAnLi4vdXRpbHMvQnVmZmVyU3RhY2suanMnO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGZyb20gXCJpbnRlcnNlY3RzR2VvbWV0cnkudGVtcGxhdGUuanNcIi4gKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qIGVzbGludC1kaXNhYmxlIGluZGVudCAqL1xuXG5jb25zdCBib3VuZGluZ0JveCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgQm94MygpO1xuY29uc3QgdHJpYW5nbGUgPSAvKiBAX19QVVJFX18gKi8gbmV3IEV4dGVuZGVkVHJpYW5nbGUoKTtcbmNvbnN0IHRyaWFuZ2xlMiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRXh0ZW5kZWRUcmlhbmdsZSgpO1xuY29uc3QgaW52ZXJ0ZWRNYXQgPSAvKiBAX19QVVJFX18gKi8gbmV3IE1hdHJpeDQoKTtcblxuY29uc3Qgb2JiID0gLyogQF9fUFVSRV9fICovIG5ldyBPcmllbnRlZEJveCgpO1xuY29uc3Qgb2JiMiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgT3JpZW50ZWRCb3goKTtcblxuZnVuY3Rpb24gaW50ZXJzZWN0c0dlb21ldHJ5X2luZGlyZWN0KCBidmgsIHJvb3QsIG90aGVyR2VvbWV0cnksIGdlb21ldHJ5VG9CdmggKSB7XG5cblx0QnVmZmVyU3RhY2suc2V0QnVmZmVyKCBidmguX3Jvb3RzWyByb290IF0gKTtcblx0Y29uc3QgcmVzdWx0ID0gX2ludGVyc2VjdHNHZW9tZXRyeSggMCwgYnZoLCBvdGhlckdlb21ldHJ5LCBnZW9tZXRyeVRvQnZoICk7XG5cdEJ1ZmZlclN0YWNrLmNsZWFyQnVmZmVyKCk7XG5cblx0cmV0dXJuIHJlc3VsdDtcblxufVxuXG5mdW5jdGlvbiBfaW50ZXJzZWN0c0dlb21ldHJ5KCBub2RlSW5kZXgzMiwgYnZoLCBvdGhlckdlb21ldHJ5LCBnZW9tZXRyeVRvQnZoLCBjYWNoZWRPYmIgPSBudWxsICkge1xuXG5cdGNvbnN0IHsgZmxvYXQzMkFycmF5LCB1aW50MTZBcnJheSwgdWludDMyQXJyYXkgfSA9IEJ1ZmZlclN0YWNrO1xuXHRsZXQgbm9kZUluZGV4MTYgPSBub2RlSW5kZXgzMiAqIDI7XG5cblx0aWYgKCBjYWNoZWRPYmIgPT09IG51bGwgKSB7XG5cblx0XHRpZiAoICEgb3RoZXJHZW9tZXRyeS5ib3VuZGluZ0JveCApIHtcblxuXHRcdFx0b3RoZXJHZW9tZXRyeS5jb21wdXRlQm91bmRpbmdCb3goKTtcblxuXHRcdH1cblxuXHRcdG9iYi5zZXQoIG90aGVyR2VvbWV0cnkuYm91bmRpbmdCb3gubWluLCBvdGhlckdlb21ldHJ5LmJvdW5kaW5nQm94Lm1heCwgZ2VvbWV0cnlUb0J2aCApO1xuXHRcdGNhY2hlZE9iYiA9IG9iYjtcblxuXHR9XG5cblx0Y29uc3QgaXNMZWFmID0gSVNfTEVBRiggbm9kZUluZGV4MTYsIHVpbnQxNkFycmF5ICk7XG5cdGlmICggaXNMZWFmICkge1xuXG5cdFx0Y29uc3QgdGhpc0dlb21ldHJ5ID0gYnZoLmdlb21ldHJ5O1xuXHRcdGNvbnN0IHRoaXNJbmRleCA9IHRoaXNHZW9tZXRyeS5pbmRleDtcblx0XHRjb25zdCB0aGlzUG9zID0gdGhpc0dlb21ldHJ5LmF0dHJpYnV0ZXMucG9zaXRpb247XG5cblx0XHRjb25zdCBpbmRleCA9IG90aGVyR2VvbWV0cnkuaW5kZXg7XG5cdFx0Y29uc3QgcG9zID0gb3RoZXJHZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXG5cdFx0Y29uc3Qgb2Zmc2V0ID0gT0ZGU0VUKCBub2RlSW5kZXgzMiwgdWludDMyQXJyYXkgKTtcblx0XHRjb25zdCBjb3VudCA9IENPVU5UKCBub2RlSW5kZXgxNiwgdWludDE2QXJyYXkgKTtcblxuXHRcdC8vIGdldCB0aGUgaW52ZXJzZSBvZiB0aGUgZ2VvbWV0cnkgbWF0cml4IHNvIHdlIGNhbiB0cmFuc2Zvcm0gb3VyIHRyaWFuZ2xlcyBpbnRvIHRoZVxuXHRcdC8vIGdlb21ldHJ5IHNwYWNlIHdlJ3JlIHRyeWluZyB0byB0ZXN0LiBXZSBhc3N1bWUgdGhlcmUgYXJlIGZld2VyIHRyaWFuZ2xlcyBiZWluZyBjaGVja2VkXG5cdFx0Ly8gaGVyZS5cblx0XHRpbnZlcnRlZE1hdC5jb3B5KCBnZW9tZXRyeVRvQnZoICkuaW52ZXJ0KCk7XG5cblx0XHRpZiAoIG90aGVyR2VvbWV0cnkuYm91bmRzVHJlZSApIHtcblxuXHRcdFx0Ly8gaWYgdGhlcmUncyBhIGJvdW5kcyB0cmVlXG5cdFx0XHRhcnJheVRvQm94KCBCT1VORElOR19EQVRBX0lOREVYKCBub2RlSW5kZXgzMiApLCBmbG9hdDMyQXJyYXksIG9iYjIgKTtcblx0XHRcdG9iYjIubWF0cml4LmNvcHkoIGludmVydGVkTWF0ICk7XG5cdFx0XHRvYmIyLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0Ly8gVE9ETzogdXNlIGEgdHJpYW5nbGUgaXRlcmF0aW9uIGZ1bmN0aW9uIGhlcmVcblx0XHRcdGNvbnN0IHJlcyA9IG90aGVyR2VvbWV0cnkuYm91bmRzVHJlZS5zaGFwZWNhc3QoIHtcblxuXHRcdFx0XHRpbnRlcnNlY3RzQm91bmRzOiBib3ggPT4gb2JiMi5pbnRlcnNlY3RzQm94KCBib3ggKSxcblxuXHRcdFx0XHRpbnRlcnNlY3RzVHJpYW5nbGU6IHRyaSA9PiB7XG5cblx0XHRcdFx0XHR0cmkuYS5hcHBseU1hdHJpeDQoIGdlb21ldHJ5VG9CdmggKTtcblx0XHRcdFx0XHR0cmkuYi5hcHBseU1hdHJpeDQoIGdlb21ldHJ5VG9CdmggKTtcblx0XHRcdFx0XHR0cmkuYy5hcHBseU1hdHJpeDQoIGdlb21ldHJ5VG9CdmggKTtcblx0XHRcdFx0XHR0cmkubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0Zm9yICggbGV0IGkgPSBvZmZzZXQsIGwgPSBjb3VudCArIG9mZnNldDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRcdC8vIHRoaXMgdHJpYW5nbGUgbmVlZHMgdG8gYmUgdHJhbnNmb3JtZWQgaW50byB0aGUgY3VycmVudCBCVkggY29vcmRpbmF0ZSBmcmFtZVxuXHRcdFx0XHRcdFx0c2V0VHJpYW5nbGUoIHRyaWFuZ2xlMiwgMyAqIGJ2aC5yZXNvbHZlVHJpYW5nbGVJbmRleCggaSApLCB0aGlzSW5kZXgsIHRoaXNQb3MgKTtcblx0XHRcdFx0XHRcdHRyaWFuZ2xlMi5uZWVkc1VwZGF0ZSA9IHRydWU7XG5cdFx0XHRcdFx0XHRpZiAoIHRyaS5pbnRlcnNlY3RzVHJpYW5nbGUoIHRyaWFuZ2xlMiApICkge1xuXG5cdFx0XHRcdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHRcdFx0XHR9XG5cblx0XHRcdFx0XHR9XG5cblxuXHRcdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gKTtcblxuXHRcdFx0cmV0dXJuIHJlcztcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIGlmIHdlJ3JlIGp1c3QgZGVhbGluZyB3aXRoIHJhdyBnZW9tZXRyeVxuXHRcdFx0Zm9yICggbGV0IGkgPSBvZmZzZXQsIGwgPSBjb3VudCArIG9mZnNldDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Ly8gdGhpcyB0cmlhbmdsZSBuZWVkcyB0byBiZSB0cmFuc2Zvcm1lZCBpbnRvIHRoZSBjdXJyZW50IEJWSCBjb29yZGluYXRlIGZyYW1lXG5cdFx0XHRcdGNvbnN0IHRpID0gYnZoLnJlc29sdmVUcmlhbmdsZUluZGV4KCBpICk7XG5cdFx0XHRcdHNldFRyaWFuZ2xlKCB0cmlhbmdsZSwgMyAqIHRpLCB0aGlzSW5kZXgsIHRoaXNQb3MgKTtcblxuXG5cdFx0XHRcdHRyaWFuZ2xlLmEuYXBwbHlNYXRyaXg0KCBpbnZlcnRlZE1hdCApO1xuXHRcdFx0XHR0cmlhbmdsZS5iLmFwcGx5TWF0cml4NCggaW52ZXJ0ZWRNYXQgKTtcblx0XHRcdFx0dHJpYW5nbGUuYy5hcHBseU1hdHJpeDQoIGludmVydGVkTWF0ICk7XG5cdFx0XHRcdHRyaWFuZ2xlLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaTIgPSAwLCBsMiA9IGluZGV4LmNvdW50OyBpMiA8IGwyOyBpMiArPSAzICkge1xuXG5cdFx0XHRcdFx0c2V0VHJpYW5nbGUoIHRyaWFuZ2xlMiwgaTIsIGluZGV4LCBwb3MgKTtcblx0XHRcdFx0XHR0cmlhbmdsZTIubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0XHRcdFx0aWYgKCB0cmlhbmdsZS5pbnRlcnNlY3RzVHJpYW5nbGUoIHRyaWFuZ2xlMiApICkge1xuXG5cdFx0XHRcdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXG5cdFx0fVxuXG5cdH0gZWxzZSB7XG5cblx0XHRjb25zdCBsZWZ0ID0gbm9kZUluZGV4MzIgKyA4O1xuXHRcdGNvbnN0IHJpZ2h0ID0gdWludDMyQXJyYXlbIG5vZGVJbmRleDMyICsgNiBdO1xuXG5cdFx0YXJyYXlUb0JveCggQk9VTkRJTkdfREFUQV9JTkRFWCggbGVmdCApLCBmbG9hdDMyQXJyYXksIGJvdW5kaW5nQm94ICk7XG5cdFx0Y29uc3QgbGVmdEludGVyc2VjdGlvbiA9XG5cdFx0XHRjYWNoZWRPYmIuaW50ZXJzZWN0c0JveCggYm91bmRpbmdCb3ggKSAmJlxuXHRcdFx0X2ludGVyc2VjdHNHZW9tZXRyeSggbGVmdCwgYnZoLCBvdGhlckdlb21ldHJ5LCBnZW9tZXRyeVRvQnZoLCBjYWNoZWRPYmIgKTtcblxuXHRcdGlmICggbGVmdEludGVyc2VjdGlvbiApIHJldHVybiB0cnVlO1xuXG5cdFx0YXJyYXlUb0JveCggQk9VTkRJTkdfREFUQV9JTkRFWCggcmlnaHQgKSwgZmxvYXQzMkFycmF5LCBib3VuZGluZ0JveCApO1xuXHRcdGNvbnN0IHJpZ2h0SW50ZXJzZWN0aW9uID1cblx0XHRcdGNhY2hlZE9iYi5pbnRlcnNlY3RzQm94KCBib3VuZGluZ0JveCApICYmXG5cdFx0XHRfaW50ZXJzZWN0c0dlb21ldHJ5KCByaWdodCwgYnZoLCBvdGhlckdlb21ldHJ5LCBnZW9tZXRyeVRvQnZoLCBjYWNoZWRPYmIgKTtcblxuXHRcdGlmICggcmlnaHRJbnRlcnNlY3Rpb24gKSByZXR1cm4gdHJ1ZTtcblxuXHRcdHJldHVybiBmYWxzZTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgaW50ZXJzZWN0c0dlb21ldHJ5X2luZGlyZWN0IH07XG4iXSwibmFtZXMiOlsiQm94MyIsIk1hdHJpeDQiLCJPcmllbnRlZEJveCIsIkV4dGVuZGVkVHJpYW5nbGUiLCJzZXRUcmlhbmdsZSIsImFycmF5VG9Cb3giLCJJU19MRUFGIiwiT0ZGU0VUIiwiQ09VTlQiLCJCT1VORElOR19EQVRBX0lOREVYIiwiQnVmZmVyU3RhY2siLCJib3VuZGluZ0JveCIsInRyaWFuZ2xlIiwidHJpYW5nbGUyIiwiaW52ZXJ0ZWRNYXQiLCJvYmIiLCJvYmIyIiwiaW50ZXJzZWN0c0dlb21ldHJ5X2luZGlyZWN0IiwiYnZoIiwicm9vdCIsIm90aGVyR2VvbWV0cnkiLCJnZW9tZXRyeVRvQnZoIiwic2V0QnVmZmVyIiwiX3Jvb3RzIiwicmVzdWx0IiwiX2ludGVyc2VjdHNHZW9tZXRyeSIsImNsZWFyQnVmZmVyIiwibm9kZUluZGV4MzIiLCJjYWNoZWRPYmIiLCJmbG9hdDMyQXJyYXkiLCJ1aW50MTZBcnJheSIsInVpbnQzMkFycmF5Iiwibm9kZUluZGV4MTYiLCJjb21wdXRlQm91bmRpbmdCb3giLCJzZXQiLCJtaW4iLCJtYXgiLCJpc0xlYWYiLCJ0aGlzR2VvbWV0cnkiLCJnZW9tZXRyeSIsInRoaXNJbmRleCIsImluZGV4IiwidGhpc1BvcyIsImF0dHJpYnV0ZXMiLCJwb3NpdGlvbiIsInBvcyIsIm9mZnNldCIsImNvdW50IiwiY29weSIsImludmVydCIsImJvdW5kc1RyZWUiLCJtYXRyaXgiLCJuZWVkc1VwZGF0ZSIsInJlcyIsInNoYXBlY2FzdCIsImludGVyc2VjdHNCb3VuZHMiLCJib3giLCJpbnRlcnNlY3RzQm94IiwiaW50ZXJzZWN0c1RyaWFuZ2xlIiwidHJpIiwiYSIsImFwcGx5TWF0cml4NCIsImIiLCJjIiwiaSIsImwiLCJyZXNvbHZlVHJpYW5nbGVJbmRleCIsInRpIiwiaTIiLCJsMiIsImxlZnQiLCJyaWdodCIsImxlZnRJbnRlcnNlY3Rpb24iLCJyaWdodEludGVyc2VjdGlvbiJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/intersectsGeometry_indirect.generated.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/raycast.generated.js":
/*!*******************************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/raycast.generated.js ***!
  \*******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   raycast: () => (/* binding */ raycast)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var _utils_intersectUtils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/intersectUtils.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/utils/intersectUtils.js\");\n/* harmony import */ var _utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/nodeBufferUtils.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/utils/nodeBufferUtils.js\");\n/* harmony import */ var _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/BufferStack.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/utils/BufferStack.js\");\n/* harmony import */ var _utils_iterationUtils_generated_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/iterationUtils.generated.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/utils/iterationUtils.generated.js\");\n\n\n\n\n\n\n/******************************************************/ /* This file is generated from \"raycast.template.js\". */ /******************************************************/ const _boxIntersection = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nfunction raycast(bvh, root, side, ray, intersects) {\n    _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_1__.BufferStack.setBuffer(bvh._roots[root]);\n    _raycast(0, bvh, side, ray, intersects);\n    _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_1__.BufferStack.clearBuffer();\n}\nfunction _raycast(nodeIndex32, bvh, side, ray, intersects) {\n    const { float32Array, uint16Array, uint32Array } = _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_1__.BufferStack;\n    const nodeIndex16 = nodeIndex32 * 2;\n    const isLeaf = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.IS_LEAF)(nodeIndex16, uint16Array);\n    if (isLeaf) {\n        const offset = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.OFFSET)(nodeIndex32, uint32Array);\n        const count = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.COUNT)(nodeIndex16, uint16Array);\n        (0,_utils_iterationUtils_generated_js__WEBPACK_IMPORTED_MODULE_3__.intersectTris)(bvh, side, ray, offset, count, intersects);\n    } else {\n        const leftIndex = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.LEFT_NODE)(nodeIndex32);\n        if ((0,_utils_intersectUtils_js__WEBPACK_IMPORTED_MODULE_4__.intersectRay)(leftIndex, float32Array, ray, _boxIntersection)) {\n            _raycast(leftIndex, bvh, side, ray, intersects);\n        }\n        const rightIndex = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.RIGHT_NODE)(nodeIndex32, uint32Array);\n        if ((0,_utils_intersectUtils_js__WEBPACK_IMPORTED_MODULE_4__.intersectRay)(rightIndex, float32Array, ray, _boxIntersection)) {\n            _raycast(rightIndex, bvh, side, ray, intersects);\n        }\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9jb3JlL2Nhc3QvcmF5Y2FzdC5nZW5lcmF0ZWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWdDO0FBQzBCO0FBQ2tDO0FBQ3RDO0FBQ2U7QUFDZDtBQUV2RCxzREFBc0QsR0FDdEQsc0RBQXNELEdBQ3RELHNEQUFzRCxHQUV0RCxNQUFNUyxtQkFBbUIsYUFBYSxHQUFHLElBQUlULDBDQUFPQTtBQUNwRCxTQUFTVSxRQUFTQyxHQUFHLEVBQUVDLElBQUksRUFBRUMsSUFBSSxFQUFFQyxHQUFHLEVBQUVDLFVBQVU7SUFFakRSLDhEQUFXQSxDQUFDUyxTQUFTLENBQUVMLElBQUlNLE1BQU0sQ0FBRUwsS0FBTTtJQUN6Q00sU0FBVSxHQUFHUCxLQUFLRSxNQUFNQyxLQUFLQztJQUM3QlIsOERBQVdBLENBQUNZLFdBQVc7QUFFeEI7QUFFQSxTQUFTRCxTQUFVRSxXQUFXLEVBQUVULEdBQUcsRUFBRUUsSUFBSSxFQUFFQyxHQUFHLEVBQUVDLFVBQVU7SUFFekQsTUFBTSxFQUFFTSxZQUFZLEVBQUVDLFdBQVcsRUFBRUMsV0FBVyxFQUFFLEdBQUdoQiw4REFBV0E7SUFDOUQsTUFBTWlCLGNBQWNKLGNBQWM7SUFDbEMsTUFBTUssU0FBU3ZCLGtFQUFPQSxDQUFFc0IsYUFBYUY7SUFDckMsSUFBS0csUUFBUztRQUViLE1BQU1DLFNBQVN2QixpRUFBTUEsQ0FBRWlCLGFBQWFHO1FBQ3BDLE1BQU1JLFFBQVF2QixnRUFBS0EsQ0FBRW9CLGFBQWFGO1FBR2xDZCxpRkFBYUEsQ0FBRUcsS0FBS0UsTUFBTUMsS0FBS1ksUUFBUUMsT0FBT1o7SUFHL0MsT0FBTztRQUVOLE1BQU1hLFlBQVl2QixvRUFBU0EsQ0FBRWU7UUFDN0IsSUFBS25CLHNFQUFZQSxDQUFFMkIsV0FBV1AsY0FBY1AsS0FBS0wsbUJBQXFCO1lBRXJFUyxTQUFVVSxXQUFXakIsS0FBS0UsTUFBTUMsS0FBS0M7UUFFdEM7UUFFQSxNQUFNYyxhQUFhdkIscUVBQVVBLENBQUVjLGFBQWFHO1FBQzVDLElBQUt0QixzRUFBWUEsQ0FBRTRCLFlBQVlSLGNBQWNQLEtBQUtMLG1CQUFxQjtZQUV0RVMsU0FBVVcsWUFBWWxCLEtBQUtFLE1BQU1DLEtBQUtDO1FBRXZDO0lBRUQ7QUFFRDtBQUVtQiIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpYmUtM2QtY29kZS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9ub2RlX21vZHVsZXMvdGhyZWUtbWVzaC1idmgvc3JjL2NvcmUvY2FzdC9yYXljYXN0LmdlbmVyYXRlZC5qcz9iNjdkIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBpbnRlcnNlY3RSYXkgfSBmcm9tICcuLi91dGlscy9pbnRlcnNlY3RVdGlscy5qcyc7XG5pbXBvcnQgeyBJU19MRUFGLCBPRkZTRVQsIENPVU5ULCBMRUZUX05PREUsIFJJR0hUX05PREUgfSBmcm9tICcuLi91dGlscy9ub2RlQnVmZmVyVXRpbHMuanMnO1xuaW1wb3J0IHsgQnVmZmVyU3RhY2sgfSBmcm9tICcuLi91dGlscy9CdWZmZXJTdGFjay5qcyc7XG5pbXBvcnQgeyBpbnRlcnNlY3RUcmlzIH0gZnJvbSAnLi4vdXRpbHMvaXRlcmF0aW9uVXRpbHMuZ2VuZXJhdGVkLmpzJztcbmltcG9ydCAnLi4vdXRpbHMvaXRlcmF0aW9uVXRpbHNfaW5kaXJlY3QuZ2VuZXJhdGVkLmpzJztcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgZnJvbSBcInJheWNhc3QudGVtcGxhdGUuanNcIi4gKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbmNvbnN0IF9ib3hJbnRlcnNlY3Rpb24gPSAvKiBAX19QVVJFX18gKi8gbmV3IFZlY3RvcjMoKTtcbmZ1bmN0aW9uIHJheWNhc3QoIGJ2aCwgcm9vdCwgc2lkZSwgcmF5LCBpbnRlcnNlY3RzICkge1xuXG5cdEJ1ZmZlclN0YWNrLnNldEJ1ZmZlciggYnZoLl9yb290c1sgcm9vdCBdICk7XG5cdF9yYXljYXN0KCAwLCBidmgsIHNpZGUsIHJheSwgaW50ZXJzZWN0cyApO1xuXHRCdWZmZXJTdGFjay5jbGVhckJ1ZmZlcigpO1xuXG59XG5cbmZ1bmN0aW9uIF9yYXljYXN0KCBub2RlSW5kZXgzMiwgYnZoLCBzaWRlLCByYXksIGludGVyc2VjdHMgKSB7XG5cblx0Y29uc3QgeyBmbG9hdDMyQXJyYXksIHVpbnQxNkFycmF5LCB1aW50MzJBcnJheSB9ID0gQnVmZmVyU3RhY2s7XG5cdGNvbnN0IG5vZGVJbmRleDE2ID0gbm9kZUluZGV4MzIgKiAyO1xuXHRjb25zdCBpc0xlYWYgPSBJU19MRUFGKCBub2RlSW5kZXgxNiwgdWludDE2QXJyYXkgKTtcblx0aWYgKCBpc0xlYWYgKSB7XG5cblx0XHRjb25zdCBvZmZzZXQgPSBPRkZTRVQoIG5vZGVJbmRleDMyLCB1aW50MzJBcnJheSApO1xuXHRcdGNvbnN0IGNvdW50ID0gQ09VTlQoIG5vZGVJbmRleDE2LCB1aW50MTZBcnJheSApO1xuXG5cblx0XHRpbnRlcnNlY3RUcmlzKCBidmgsIHNpZGUsIHJheSwgb2Zmc2V0LCBjb3VudCwgaW50ZXJzZWN0cyApO1xuXG5cblx0fSBlbHNlIHtcblxuXHRcdGNvbnN0IGxlZnRJbmRleCA9IExFRlRfTk9ERSggbm9kZUluZGV4MzIgKTtcblx0XHRpZiAoIGludGVyc2VjdFJheSggbGVmdEluZGV4LCBmbG9hdDMyQXJyYXksIHJheSwgX2JveEludGVyc2VjdGlvbiApICkge1xuXG5cdFx0XHRfcmF5Y2FzdCggbGVmdEluZGV4LCBidmgsIHNpZGUsIHJheSwgaW50ZXJzZWN0cyApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgcmlnaHRJbmRleCA9IFJJR0hUX05PREUoIG5vZGVJbmRleDMyLCB1aW50MzJBcnJheSApO1xuXHRcdGlmICggaW50ZXJzZWN0UmF5KCByaWdodEluZGV4LCBmbG9hdDMyQXJyYXksIHJheSwgX2JveEludGVyc2VjdGlvbiApICkge1xuXG5cdFx0XHRfcmF5Y2FzdCggcmlnaHRJbmRleCwgYnZoLCBzaWRlLCByYXksIGludGVyc2VjdHMgKTtcblxuXHRcdH1cblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgcmF5Y2FzdCB9O1xuIl0sIm5hbWVzIjpbIlZlY3RvcjMiLCJpbnRlcnNlY3RSYXkiLCJJU19MRUFGIiwiT0ZGU0VUIiwiQ09VTlQiLCJMRUZUX05PREUiLCJSSUdIVF9OT0RFIiwiQnVmZmVyU3RhY2siLCJpbnRlcnNlY3RUcmlzIiwiX2JveEludGVyc2VjdGlvbiIsInJheWNhc3QiLCJidmgiLCJyb290Iiwic2lkZSIsInJheSIsImludGVyc2VjdHMiLCJzZXRCdWZmZXIiLCJfcm9vdHMiLCJfcmF5Y2FzdCIsImNsZWFyQnVmZmVyIiwibm9kZUluZGV4MzIiLCJmbG9hdDMyQXJyYXkiLCJ1aW50MTZBcnJheSIsInVpbnQzMkFycmF5Iiwibm9kZUluZGV4MTYiLCJpc0xlYWYiLCJvZmZzZXQiLCJjb3VudCIsImxlZnRJbmRleCIsInJpZ2h0SW5kZXgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/raycast.generated.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/raycastFirst.generated.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/raycastFirst.generated.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   raycastFirst: () => (/* binding */ raycastFirst)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var _utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/nodeBufferUtils.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/utils/nodeBufferUtils.js\");\n/* harmony import */ var _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/BufferStack.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/utils/BufferStack.js\");\n/* harmony import */ var _utils_intersectUtils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/intersectUtils.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/utils/intersectUtils.js\");\n/* harmony import */ var _utils_iterationUtils_generated_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/iterationUtils.generated.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/utils/iterationUtils.generated.js\");\n\n\n\n\n\n\n/***********************************************************/ /* This file is generated from \"raycastFirst.template.js\". */ /***********************************************************/ const _boxIntersection = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst _xyzFields = [\n    \"x\",\n    \"y\",\n    \"z\"\n];\nfunction raycastFirst(bvh, root, side, ray) {\n    _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_1__.BufferStack.setBuffer(bvh._roots[root]);\n    const result = _raycastFirst(0, bvh, side, ray);\n    _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_1__.BufferStack.clearBuffer();\n    return result;\n}\nfunction _raycastFirst(nodeIndex32, bvh, side, ray) {\n    const { float32Array, uint16Array, uint32Array } = _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_1__.BufferStack;\n    let nodeIndex16 = nodeIndex32 * 2;\n    const isLeaf = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.IS_LEAF)(nodeIndex16, uint16Array);\n    if (isLeaf) {\n        const offset = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.OFFSET)(nodeIndex32, uint32Array);\n        const count = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.COUNT)(nodeIndex16, uint16Array);\n        return (0,_utils_iterationUtils_generated_js__WEBPACK_IMPORTED_MODULE_3__.intersectClosestTri)(bvh, side, ray, offset, count);\n    } else {\n        // consider the position of the split plane with respect to the oncoming ray; whichever direction\n        // the ray is coming from, look for an intersection among that side of the tree first\n        const splitAxis = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.SPLIT_AXIS)(nodeIndex32, uint32Array);\n        const xyzAxis = _xyzFields[splitAxis];\n        const rayDir = ray.direction[xyzAxis];\n        const leftToRight = rayDir >= 0;\n        // c1 is the child to check first\n        let c1, c2;\n        if (leftToRight) {\n            c1 = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.LEFT_NODE)(nodeIndex32);\n            c2 = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.RIGHT_NODE)(nodeIndex32, uint32Array);\n        } else {\n            c1 = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.RIGHT_NODE)(nodeIndex32, uint32Array);\n            c2 = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.LEFT_NODE)(nodeIndex32);\n        }\n        const c1Intersection = (0,_utils_intersectUtils_js__WEBPACK_IMPORTED_MODULE_4__.intersectRay)(c1, float32Array, ray, _boxIntersection);\n        const c1Result = c1Intersection ? _raycastFirst(c1, bvh, side, ray) : null;\n        // if we got an intersection in the first node and it's closer than the second node's bounding\n        // box, we don't need to consider the second node because it couldn't possibly be a better result\n        if (c1Result) {\n            // check if the point is within the second bounds\n            // \"point\" is in the local frame of the bvh\n            const point = c1Result.point[xyzAxis];\n            const isOutside = leftToRight ? point <= float32Array[c2 + splitAxis] : point >= float32Array[c2 + splitAxis + 3]; // max bounding data\n            if (isOutside) {\n                return c1Result;\n            }\n        }\n        // either there was no intersection in the first node, or there could still be a closer\n        // intersection in the second, so check the second node and then take the better of the two\n        const c2Intersection = (0,_utils_intersectUtils_js__WEBPACK_IMPORTED_MODULE_4__.intersectRay)(c2, float32Array, ray, _boxIntersection);\n        const c2Result = c2Intersection ? _raycastFirst(c2, bvh, side, ray) : null;\n        if (c1Result && c2Result) {\n            return c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n        } else {\n            return c1Result || c2Result || null;\n        }\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9jb3JlL2Nhc3QvcmF5Y2FzdEZpcnN0LmdlbmVyYXRlZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBZ0M7QUFDd0U7QUFDbEQ7QUFDSTtBQUNpQjtBQUNwQjtBQUV2RCwyREFBMkQsR0FDM0QsMkRBQTJELEdBQzNELDJEQUEyRCxHQUMzRCxNQUFNVSxtQkFBbUIsYUFBYSxHQUFHLElBQUlWLDBDQUFPQTtBQUNwRCxNQUFNVyxhQUFhO0lBQUU7SUFBSztJQUFLO0NBQUs7QUFDcEMsU0FBU0MsYUFBY0MsR0FBRyxFQUFFQyxJQUFJLEVBQUVDLElBQUksRUFBRUMsR0FBRztJQUUxQ1QsOERBQVdBLENBQUNVLFNBQVMsQ0FBRUosSUFBSUssTUFBTSxDQUFFSixLQUFNO0lBQ3pDLE1BQU1LLFNBQVNDLGNBQWUsR0FBR1AsS0FBS0UsTUFBTUM7SUFDNUNULDhEQUFXQSxDQUFDYyxXQUFXO0lBRXZCLE9BQU9GO0FBRVI7QUFFQSxTQUFTQyxjQUFlRSxXQUFXLEVBQUVULEdBQUcsRUFBRUUsSUFBSSxFQUFFQyxHQUFHO0lBRWxELE1BQU0sRUFBRU8sWUFBWSxFQUFFQyxXQUFXLEVBQUVDLFdBQVcsRUFBRSxHQUFHbEIsOERBQVdBO0lBQzlELElBQUltQixjQUFjSixjQUFjO0lBRWhDLE1BQU1LLFNBQVMxQixrRUFBT0EsQ0FBRXlCLGFBQWFGO0lBQ3JDLElBQUtHLFFBQVM7UUFFYixNQUFNQyxTQUFTMUIsaUVBQU1BLENBQUVvQixhQUFhRztRQUNwQyxNQUFNSSxRQUFRMUIsZ0VBQUtBLENBQUV1QixhQUFhRjtRQUdsQyxPQUFPZix1RkFBbUJBLENBQUVJLEtBQUtFLE1BQU1DLEtBQUtZLFFBQVFDO0lBR3JELE9BQU87UUFFTixpR0FBaUc7UUFDakcscUZBQXFGO1FBQ3JGLE1BQU1DLFlBQVkxQixxRUFBVUEsQ0FBRWtCLGFBQWFHO1FBQzNDLE1BQU1NLFVBQVVwQixVQUFVLENBQUVtQixVQUFXO1FBQ3ZDLE1BQU1FLFNBQVNoQixJQUFJaUIsU0FBUyxDQUFFRixRQUFTO1FBQ3ZDLE1BQU1HLGNBQWNGLFVBQVU7UUFFOUIsaUNBQWlDO1FBQ2pDLElBQUlHLElBQUlDO1FBQ1IsSUFBS0YsYUFBYztZQUVsQkMsS0FBSzlCLG9FQUFTQSxDQUFFaUI7WUFDaEJjLEtBQUs5QixxRUFBVUEsQ0FBRWdCLGFBQWFHO1FBRS9CLE9BQU87WUFFTlUsS0FBSzdCLHFFQUFVQSxDQUFFZ0IsYUFBYUc7WUFDOUJXLEtBQUsvQixvRUFBU0EsQ0FBRWlCO1FBRWpCO1FBRUEsTUFBTWUsaUJBQWlCN0Isc0VBQVlBLENBQUUyQixJQUFJWixjQUFjUCxLQUFLTjtRQUM1RCxNQUFNNEIsV0FBV0QsaUJBQWlCakIsY0FBZWUsSUFBSXRCLEtBQUtFLE1BQU1DLE9BQVE7UUFFeEUsOEZBQThGO1FBQzlGLGlHQUFpRztRQUNqRyxJQUFLc0IsVUFBVztZQUVmLGlEQUFpRDtZQUNqRCwyQ0FBMkM7WUFDM0MsTUFBTUMsUUFBUUQsU0FBU0MsS0FBSyxDQUFFUixRQUFTO1lBQ3ZDLE1BQU1TLFlBQVlOLGNBQ2pCSyxTQUFTaEIsWUFBWSxDQUFFYSxLQUFLTixVQUFXLEdBQ3ZDUyxTQUFTaEIsWUFBWSxDQUFFYSxLQUFLTixZQUFZLEVBQUcsRUFBRSxvQkFBb0I7WUFFbEUsSUFBS1UsV0FBWTtnQkFFaEIsT0FBT0Y7WUFFUjtRQUVEO1FBRUEsdUZBQXVGO1FBQ3ZGLDJGQUEyRjtRQUMzRixNQUFNRyxpQkFBaUJqQyxzRUFBWUEsQ0FBRTRCLElBQUliLGNBQWNQLEtBQUtOO1FBQzVELE1BQU1nQyxXQUFXRCxpQkFBaUJyQixjQUFlZ0IsSUFBSXZCLEtBQUtFLE1BQU1DLE9BQVE7UUFFeEUsSUFBS3NCLFlBQVlJLFVBQVc7WUFFM0IsT0FBT0osU0FBU0ssUUFBUSxJQUFJRCxTQUFTQyxRQUFRLEdBQUdMLFdBQVdJO1FBRTVELE9BQU87WUFFTixPQUFPSixZQUFZSSxZQUFZO1FBRWhDO0lBRUQ7QUFFRDtBQUV3QiIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpYmUtM2QtY29kZS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9ub2RlX21vZHVsZXMvdGhyZWUtbWVzaC1idmgvc3JjL2NvcmUvY2FzdC9yYXljYXN0Rmlyc3QuZ2VuZXJhdGVkLmpzP2IwYzciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVmVjdG9yMyB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IElTX0xFQUYsIE9GRlNFVCwgQ09VTlQsIFNQTElUX0FYSVMsIExFRlRfTk9ERSwgUklHSFRfTk9ERSB9IGZyb20gJy4uL3V0aWxzL25vZGVCdWZmZXJVdGlscy5qcyc7XG5pbXBvcnQgeyBCdWZmZXJTdGFjayB9IGZyb20gJy4uL3V0aWxzL0J1ZmZlclN0YWNrLmpzJztcbmltcG9ydCB7IGludGVyc2VjdFJheSB9IGZyb20gJy4uL3V0aWxzL2ludGVyc2VjdFV0aWxzLmpzJztcbmltcG9ydCB7IGludGVyc2VjdENsb3Nlc3RUcmkgfSBmcm9tICcuLi91dGlscy9pdGVyYXRpb25VdGlscy5nZW5lcmF0ZWQuanMnO1xuaW1wb3J0ICcuLi91dGlscy9pdGVyYXRpb25VdGlsc19pbmRpcmVjdC5nZW5lcmF0ZWQuanMnO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGZyb20gXCJyYXljYXN0Rmlyc3QudGVtcGxhdGUuanNcIi4gKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbmNvbnN0IF9ib3hJbnRlcnNlY3Rpb24gPSAvKiBAX19QVVJFX18gKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF94eXpGaWVsZHMgPSBbICd4JywgJ3knLCAneicgXTtcbmZ1bmN0aW9uIHJheWNhc3RGaXJzdCggYnZoLCByb290LCBzaWRlLCByYXkgKSB7XG5cblx0QnVmZmVyU3RhY2suc2V0QnVmZmVyKCBidmguX3Jvb3RzWyByb290IF0gKTtcblx0Y29uc3QgcmVzdWx0ID0gX3JheWNhc3RGaXJzdCggMCwgYnZoLCBzaWRlLCByYXkgKTtcblx0QnVmZmVyU3RhY2suY2xlYXJCdWZmZXIoKTtcblxuXHRyZXR1cm4gcmVzdWx0O1xuXG59XG5cbmZ1bmN0aW9uIF9yYXljYXN0Rmlyc3QoIG5vZGVJbmRleDMyLCBidmgsIHNpZGUsIHJheSApIHtcblxuXHRjb25zdCB7IGZsb2F0MzJBcnJheSwgdWludDE2QXJyYXksIHVpbnQzMkFycmF5IH0gPSBCdWZmZXJTdGFjaztcblx0bGV0IG5vZGVJbmRleDE2ID0gbm9kZUluZGV4MzIgKiAyO1xuXG5cdGNvbnN0IGlzTGVhZiA9IElTX0xFQUYoIG5vZGVJbmRleDE2LCB1aW50MTZBcnJheSApO1xuXHRpZiAoIGlzTGVhZiApIHtcblxuXHRcdGNvbnN0IG9mZnNldCA9IE9GRlNFVCggbm9kZUluZGV4MzIsIHVpbnQzMkFycmF5ICk7XG5cdFx0Y29uc3QgY291bnQgPSBDT1VOVCggbm9kZUluZGV4MTYsIHVpbnQxNkFycmF5ICk7XG5cblxuXHRcdHJldHVybiBpbnRlcnNlY3RDbG9zZXN0VHJpKCBidmgsIHNpZGUsIHJheSwgb2Zmc2V0LCBjb3VudCApO1xuXG5cblx0fSBlbHNlIHtcblxuXHRcdC8vIGNvbnNpZGVyIHRoZSBwb3NpdGlvbiBvZiB0aGUgc3BsaXQgcGxhbmUgd2l0aCByZXNwZWN0IHRvIHRoZSBvbmNvbWluZyByYXk7IHdoaWNoZXZlciBkaXJlY3Rpb25cblx0XHQvLyB0aGUgcmF5IGlzIGNvbWluZyBmcm9tLCBsb29rIGZvciBhbiBpbnRlcnNlY3Rpb24gYW1vbmcgdGhhdCBzaWRlIG9mIHRoZSB0cmVlIGZpcnN0XG5cdFx0Y29uc3Qgc3BsaXRBeGlzID0gU1BMSVRfQVhJUyggbm9kZUluZGV4MzIsIHVpbnQzMkFycmF5ICk7XG5cdFx0Y29uc3QgeHl6QXhpcyA9IF94eXpGaWVsZHNbIHNwbGl0QXhpcyBdO1xuXHRcdGNvbnN0IHJheURpciA9IHJheS5kaXJlY3Rpb25bIHh5ekF4aXMgXTtcblx0XHRjb25zdCBsZWZ0VG9SaWdodCA9IHJheURpciA+PSAwO1xuXG5cdFx0Ly8gYzEgaXMgdGhlIGNoaWxkIHRvIGNoZWNrIGZpcnN0XG5cdFx0bGV0IGMxLCBjMjtcblx0XHRpZiAoIGxlZnRUb1JpZ2h0ICkge1xuXG5cdFx0XHRjMSA9IExFRlRfTk9ERSggbm9kZUluZGV4MzIgKTtcblx0XHRcdGMyID0gUklHSFRfTk9ERSggbm9kZUluZGV4MzIsIHVpbnQzMkFycmF5ICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjMSA9IFJJR0hUX05PREUoIG5vZGVJbmRleDMyLCB1aW50MzJBcnJheSApO1xuXHRcdFx0YzIgPSBMRUZUX05PREUoIG5vZGVJbmRleDMyICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBjMUludGVyc2VjdGlvbiA9IGludGVyc2VjdFJheSggYzEsIGZsb2F0MzJBcnJheSwgcmF5LCBfYm94SW50ZXJzZWN0aW9uICk7XG5cdFx0Y29uc3QgYzFSZXN1bHQgPSBjMUludGVyc2VjdGlvbiA/IF9yYXljYXN0Rmlyc3QoIGMxLCBidmgsIHNpZGUsIHJheSApIDogbnVsbDtcblxuXHRcdC8vIGlmIHdlIGdvdCBhbiBpbnRlcnNlY3Rpb24gaW4gdGhlIGZpcnN0IG5vZGUgYW5kIGl0J3MgY2xvc2VyIHRoYW4gdGhlIHNlY29uZCBub2RlJ3MgYm91bmRpbmdcblx0XHQvLyBib3gsIHdlIGRvbid0IG5lZWQgdG8gY29uc2lkZXIgdGhlIHNlY29uZCBub2RlIGJlY2F1c2UgaXQgY291bGRuJ3QgcG9zc2libHkgYmUgYSBiZXR0ZXIgcmVzdWx0XG5cdFx0aWYgKCBjMVJlc3VsdCApIHtcblxuXHRcdFx0Ly8gY2hlY2sgaWYgdGhlIHBvaW50IGlzIHdpdGhpbiB0aGUgc2Vjb25kIGJvdW5kc1xuXHRcdFx0Ly8gXCJwb2ludFwiIGlzIGluIHRoZSBsb2NhbCBmcmFtZSBvZiB0aGUgYnZoXG5cdFx0XHRjb25zdCBwb2ludCA9IGMxUmVzdWx0LnBvaW50WyB4eXpBeGlzIF07XG5cdFx0XHRjb25zdCBpc091dHNpZGUgPSBsZWZ0VG9SaWdodCA/XG5cdFx0XHRcdHBvaW50IDw9IGZsb2F0MzJBcnJheVsgYzIgKyBzcGxpdEF4aXMgXSA6IC8vIG1pbiBib3VuZGluZyBkYXRhXG5cdFx0XHRcdHBvaW50ID49IGZsb2F0MzJBcnJheVsgYzIgKyBzcGxpdEF4aXMgKyAzIF07IC8vIG1heCBib3VuZGluZyBkYXRhXG5cblx0XHRcdGlmICggaXNPdXRzaWRlICkge1xuXG5cdFx0XHRcdHJldHVybiBjMVJlc3VsdDtcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gZWl0aGVyIHRoZXJlIHdhcyBubyBpbnRlcnNlY3Rpb24gaW4gdGhlIGZpcnN0IG5vZGUsIG9yIHRoZXJlIGNvdWxkIHN0aWxsIGJlIGEgY2xvc2VyXG5cdFx0Ly8gaW50ZXJzZWN0aW9uIGluIHRoZSBzZWNvbmQsIHNvIGNoZWNrIHRoZSBzZWNvbmQgbm9kZSBhbmQgdGhlbiB0YWtlIHRoZSBiZXR0ZXIgb2YgdGhlIHR3b1xuXHRcdGNvbnN0IGMySW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0UmF5KCBjMiwgZmxvYXQzMkFycmF5LCByYXksIF9ib3hJbnRlcnNlY3Rpb24gKTtcblx0XHRjb25zdCBjMlJlc3VsdCA9IGMySW50ZXJzZWN0aW9uID8gX3JheWNhc3RGaXJzdCggYzIsIGJ2aCwgc2lkZSwgcmF5ICkgOiBudWxsO1xuXG5cdFx0aWYgKCBjMVJlc3VsdCAmJiBjMlJlc3VsdCApIHtcblxuXHRcdFx0cmV0dXJuIGMxUmVzdWx0LmRpc3RhbmNlIDw9IGMyUmVzdWx0LmRpc3RhbmNlID8gYzFSZXN1bHQgOiBjMlJlc3VsdDtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdHJldHVybiBjMVJlc3VsdCB8fCBjMlJlc3VsdCB8fCBudWxsO1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG5leHBvcnQgeyByYXljYXN0Rmlyc3QgfTtcbiJdLCJuYW1lcyI6WyJWZWN0b3IzIiwiSVNfTEVBRiIsIk9GRlNFVCIsIkNPVU5UIiwiU1BMSVRfQVhJUyIsIkxFRlRfTk9ERSIsIlJJR0hUX05PREUiLCJCdWZmZXJTdGFjayIsImludGVyc2VjdFJheSIsImludGVyc2VjdENsb3Nlc3RUcmkiLCJfYm94SW50ZXJzZWN0aW9uIiwiX3h5ekZpZWxkcyIsInJheWNhc3RGaXJzdCIsImJ2aCIsInJvb3QiLCJzaWRlIiwicmF5Iiwic2V0QnVmZmVyIiwiX3Jvb3RzIiwicmVzdWx0IiwiX3JheWNhc3RGaXJzdCIsImNsZWFyQnVmZmVyIiwibm9kZUluZGV4MzIiLCJmbG9hdDMyQXJyYXkiLCJ1aW50MTZBcnJheSIsInVpbnQzMkFycmF5Iiwibm9kZUluZGV4MTYiLCJpc0xlYWYiLCJvZmZzZXQiLCJjb3VudCIsInNwbGl0QXhpcyIsInh5ekF4aXMiLCJyYXlEaXIiLCJkaXJlY3Rpb24iLCJsZWZ0VG9SaWdodCIsImMxIiwiYzIiLCJjMUludGVyc2VjdGlvbiIsImMxUmVzdWx0IiwicG9pbnQiLCJpc091dHNpZGUiLCJjMkludGVyc2VjdGlvbiIsImMyUmVzdWx0IiwiZGlzdGFuY2UiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/raycastFirst.generated.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/raycastFirst_indirect.generated.js":
/*!*********************************************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/raycastFirst_indirect.generated.js ***!
  \*********************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   raycastFirst_indirect: () => (/* binding */ raycastFirst_indirect)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var _utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/nodeBufferUtils.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/utils/nodeBufferUtils.js\");\n/* harmony import */ var _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/BufferStack.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/utils/BufferStack.js\");\n/* harmony import */ var _utils_intersectUtils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/intersectUtils.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/utils/intersectUtils.js\");\n/* harmony import */ var _utils_iterationUtils_indirect_generated_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/iterationUtils_indirect.generated.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/utils/iterationUtils_indirect.generated.js\");\n\n\n\n\n\n\n/***********************************************************/ /* This file is generated from \"raycastFirst.template.js\". */ /***********************************************************/ const _boxIntersection = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst _xyzFields = [\n    \"x\",\n    \"y\",\n    \"z\"\n];\nfunction raycastFirst_indirect(bvh, root, side, ray) {\n    _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_1__.BufferStack.setBuffer(bvh._roots[root]);\n    const result = _raycastFirst(0, bvh, side, ray);\n    _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_1__.BufferStack.clearBuffer();\n    return result;\n}\nfunction _raycastFirst(nodeIndex32, bvh, side, ray) {\n    const { float32Array, uint16Array, uint32Array } = _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_1__.BufferStack;\n    let nodeIndex16 = nodeIndex32 * 2;\n    const isLeaf = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.IS_LEAF)(nodeIndex16, uint16Array);\n    if (isLeaf) {\n        const offset = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.OFFSET)(nodeIndex32, uint32Array);\n        const count = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.COUNT)(nodeIndex16, uint16Array);\n        return (0,_utils_iterationUtils_indirect_generated_js__WEBPACK_IMPORTED_MODULE_3__.intersectClosestTri_indirect)(bvh, side, ray, offset, count);\n    } else {\n        // consider the position of the split plane with respect to the oncoming ray; whichever direction\n        // the ray is coming from, look for an intersection among that side of the tree first\n        const splitAxis = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.SPLIT_AXIS)(nodeIndex32, uint32Array);\n        const xyzAxis = _xyzFields[splitAxis];\n        const rayDir = ray.direction[xyzAxis];\n        const leftToRight = rayDir >= 0;\n        // c1 is the child to check first\n        let c1, c2;\n        if (leftToRight) {\n            c1 = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.LEFT_NODE)(nodeIndex32);\n            c2 = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.RIGHT_NODE)(nodeIndex32, uint32Array);\n        } else {\n            c1 = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.RIGHT_NODE)(nodeIndex32, uint32Array);\n            c2 = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.LEFT_NODE)(nodeIndex32);\n        }\n        const c1Intersection = (0,_utils_intersectUtils_js__WEBPACK_IMPORTED_MODULE_4__.intersectRay)(c1, float32Array, ray, _boxIntersection);\n        const c1Result = c1Intersection ? _raycastFirst(c1, bvh, side, ray) : null;\n        // if we got an intersection in the first node and it's closer than the second node's bounding\n        // box, we don't need to consider the second node because it couldn't possibly be a better result\n        if (c1Result) {\n            // check if the point is within the second bounds\n            // \"point\" is in the local frame of the bvh\n            const point = c1Result.point[xyzAxis];\n            const isOutside = leftToRight ? point <= float32Array[c2 + splitAxis] : point >= float32Array[c2 + splitAxis + 3]; // max bounding data\n            if (isOutside) {\n                return c1Result;\n            }\n        }\n        // either there was no intersection in the first node, or there could still be a closer\n        // intersection in the second, so check the second node and then take the better of the two\n        const c2Intersection = (0,_utils_intersectUtils_js__WEBPACK_IMPORTED_MODULE_4__.intersectRay)(c2, float32Array, ray, _boxIntersection);\n        const c2Result = c2Intersection ? _raycastFirst(c2, bvh, side, ray) : null;\n        if (c1Result && c2Result) {\n            return c1Result.distance <= c2Result.distance ? c1Result : c2Result;\n        } else {\n            return c1Result || c2Result || null;\n        }\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9jb3JlL2Nhc3QvcmF5Y2FzdEZpcnN0X2luZGlyZWN0LmdlbmVyYXRlZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7QUFBZ0M7QUFDd0U7QUFDbEQ7QUFDSTtBQUNaO0FBQytDO0FBRTdGLDJEQUEyRCxHQUMzRCwyREFBMkQsR0FDM0QsMkRBQTJELEdBQzNELE1BQU1VLG1CQUFtQixhQUFhLEdBQUcsSUFBSVYsMENBQU9BO0FBQ3BELE1BQU1XLGFBQWE7SUFBRTtJQUFLO0lBQUs7Q0FBSztBQUNwQyxTQUFTQyxzQkFBdUJDLEdBQUcsRUFBRUMsSUFBSSxFQUFFQyxJQUFJLEVBQUVDLEdBQUc7SUFFbkRULDhEQUFXQSxDQUFDVSxTQUFTLENBQUVKLElBQUlLLE1BQU0sQ0FBRUosS0FBTTtJQUN6QyxNQUFNSyxTQUFTQyxjQUFlLEdBQUdQLEtBQUtFLE1BQU1DO0lBQzVDVCw4REFBV0EsQ0FBQ2MsV0FBVztJQUV2QixPQUFPRjtBQUVSO0FBRUEsU0FBU0MsY0FBZUUsV0FBVyxFQUFFVCxHQUFHLEVBQUVFLElBQUksRUFBRUMsR0FBRztJQUVsRCxNQUFNLEVBQUVPLFlBQVksRUFBRUMsV0FBVyxFQUFFQyxXQUFXLEVBQUUsR0FBR2xCLDhEQUFXQTtJQUM5RCxJQUFJbUIsY0FBY0osY0FBYztJQUVoQyxNQUFNSyxTQUFTMUIsa0VBQU9BLENBQUV5QixhQUFhRjtJQUNyQyxJQUFLRyxRQUFTO1FBRWIsTUFBTUMsU0FBUzFCLGlFQUFNQSxDQUFFb0IsYUFBYUc7UUFDcEMsTUFBTUksUUFBUTFCLGdFQUFLQSxDQUFFdUIsYUFBYUY7UUFFbEMsT0FBT2YseUdBQTRCQSxDQUFFSSxLQUFLRSxNQUFNQyxLQUFLWSxRQUFRQztJQUc5RCxPQUFPO1FBRU4saUdBQWlHO1FBQ2pHLHFGQUFxRjtRQUNyRixNQUFNQyxZQUFZMUIscUVBQVVBLENBQUVrQixhQUFhRztRQUMzQyxNQUFNTSxVQUFVcEIsVUFBVSxDQUFFbUIsVUFBVztRQUN2QyxNQUFNRSxTQUFTaEIsSUFBSWlCLFNBQVMsQ0FBRUYsUUFBUztRQUN2QyxNQUFNRyxjQUFjRixVQUFVO1FBRTlCLGlDQUFpQztRQUNqQyxJQUFJRyxJQUFJQztRQUNSLElBQUtGLGFBQWM7WUFFbEJDLEtBQUs5QixvRUFBU0EsQ0FBRWlCO1lBQ2hCYyxLQUFLOUIscUVBQVVBLENBQUVnQixhQUFhRztRQUUvQixPQUFPO1lBRU5VLEtBQUs3QixxRUFBVUEsQ0FBRWdCLGFBQWFHO1lBQzlCVyxLQUFLL0Isb0VBQVNBLENBQUVpQjtRQUVqQjtRQUVBLE1BQU1lLGlCQUFpQjdCLHNFQUFZQSxDQUFFMkIsSUFBSVosY0FBY1AsS0FBS047UUFDNUQsTUFBTTRCLFdBQVdELGlCQUFpQmpCLGNBQWVlLElBQUl0QixLQUFLRSxNQUFNQyxPQUFRO1FBRXhFLDhGQUE4RjtRQUM5RixpR0FBaUc7UUFDakcsSUFBS3NCLFVBQVc7WUFFZixpREFBaUQ7WUFDakQsMkNBQTJDO1lBQzNDLE1BQU1DLFFBQVFELFNBQVNDLEtBQUssQ0FBRVIsUUFBUztZQUN2QyxNQUFNUyxZQUFZTixjQUNqQkssU0FBU2hCLFlBQVksQ0FBRWEsS0FBS04sVUFBVyxHQUN2Q1MsU0FBU2hCLFlBQVksQ0FBRWEsS0FBS04sWUFBWSxFQUFHLEVBQUUsb0JBQW9CO1lBRWxFLElBQUtVLFdBQVk7Z0JBRWhCLE9BQU9GO1lBRVI7UUFFRDtRQUVBLHVGQUF1RjtRQUN2RiwyRkFBMkY7UUFDM0YsTUFBTUcsaUJBQWlCakMsc0VBQVlBLENBQUU0QixJQUFJYixjQUFjUCxLQUFLTjtRQUM1RCxNQUFNZ0MsV0FBV0QsaUJBQWlCckIsY0FBZWdCLElBQUl2QixLQUFLRSxNQUFNQyxPQUFRO1FBRXhFLElBQUtzQixZQUFZSSxVQUFXO1lBRTNCLE9BQU9KLFNBQVNLLFFBQVEsSUFBSUQsU0FBU0MsUUFBUSxHQUFHTCxXQUFXSTtRQUU1RCxPQUFPO1lBRU4sT0FBT0osWUFBWUksWUFBWTtRQUVoQztJQUVEO0FBRUQ7QUFFaUMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aWJlLTNkLWNvZGUvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9jb3JlL2Nhc3QvcmF5Y2FzdEZpcnN0X2luZGlyZWN0LmdlbmVyYXRlZC5qcz83ZDQ3Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFZlY3RvcjMgfSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBJU19MRUFGLCBPRkZTRVQsIENPVU5ULCBTUExJVF9BWElTLCBMRUZUX05PREUsIFJJR0hUX05PREUgfSBmcm9tICcuLi91dGlscy9ub2RlQnVmZmVyVXRpbHMuanMnO1xuaW1wb3J0IHsgQnVmZmVyU3RhY2sgfSBmcm9tICcuLi91dGlscy9CdWZmZXJTdGFjay5qcyc7XG5pbXBvcnQgeyBpbnRlcnNlY3RSYXkgfSBmcm9tICcuLi91dGlscy9pbnRlcnNlY3RVdGlscy5qcyc7XG5pbXBvcnQgJy4uL3V0aWxzL2l0ZXJhdGlvblV0aWxzLmdlbmVyYXRlZC5qcyc7XG5pbXBvcnQgeyBpbnRlcnNlY3RDbG9zZXN0VHJpX2luZGlyZWN0IH0gZnJvbSAnLi4vdXRpbHMvaXRlcmF0aW9uVXRpbHNfaW5kaXJlY3QuZ2VuZXJhdGVkLmpzJztcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBmcm9tIFwicmF5Y2FzdEZpcnN0LnRlbXBsYXRlLmpzXCIuICovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5jb25zdCBfYm94SW50ZXJzZWN0aW9uID0gLyogQF9fUFVSRV9fICovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfeHl6RmllbGRzID0gWyAneCcsICd5JywgJ3onIF07XG5mdW5jdGlvbiByYXljYXN0Rmlyc3RfaW5kaXJlY3QoIGJ2aCwgcm9vdCwgc2lkZSwgcmF5ICkge1xuXG5cdEJ1ZmZlclN0YWNrLnNldEJ1ZmZlciggYnZoLl9yb290c1sgcm9vdCBdICk7XG5cdGNvbnN0IHJlc3VsdCA9IF9yYXljYXN0Rmlyc3QoIDAsIGJ2aCwgc2lkZSwgcmF5ICk7XG5cdEJ1ZmZlclN0YWNrLmNsZWFyQnVmZmVyKCk7XG5cblx0cmV0dXJuIHJlc3VsdDtcblxufVxuXG5mdW5jdGlvbiBfcmF5Y2FzdEZpcnN0KCBub2RlSW5kZXgzMiwgYnZoLCBzaWRlLCByYXkgKSB7XG5cblx0Y29uc3QgeyBmbG9hdDMyQXJyYXksIHVpbnQxNkFycmF5LCB1aW50MzJBcnJheSB9ID0gQnVmZmVyU3RhY2s7XG5cdGxldCBub2RlSW5kZXgxNiA9IG5vZGVJbmRleDMyICogMjtcblxuXHRjb25zdCBpc0xlYWYgPSBJU19MRUFGKCBub2RlSW5kZXgxNiwgdWludDE2QXJyYXkgKTtcblx0aWYgKCBpc0xlYWYgKSB7XG5cblx0XHRjb25zdCBvZmZzZXQgPSBPRkZTRVQoIG5vZGVJbmRleDMyLCB1aW50MzJBcnJheSApO1xuXHRcdGNvbnN0IGNvdW50ID0gQ09VTlQoIG5vZGVJbmRleDE2LCB1aW50MTZBcnJheSApO1xuXG5cdFx0cmV0dXJuIGludGVyc2VjdENsb3Nlc3RUcmlfaW5kaXJlY3QoIGJ2aCwgc2lkZSwgcmF5LCBvZmZzZXQsIGNvdW50ICk7XG5cblxuXHR9IGVsc2Uge1xuXG5cdFx0Ly8gY29uc2lkZXIgdGhlIHBvc2l0aW9uIG9mIHRoZSBzcGxpdCBwbGFuZSB3aXRoIHJlc3BlY3QgdG8gdGhlIG9uY29taW5nIHJheTsgd2hpY2hldmVyIGRpcmVjdGlvblxuXHRcdC8vIHRoZSByYXkgaXMgY29taW5nIGZyb20sIGxvb2sgZm9yIGFuIGludGVyc2VjdGlvbiBhbW9uZyB0aGF0IHNpZGUgb2YgdGhlIHRyZWUgZmlyc3Rcblx0XHRjb25zdCBzcGxpdEF4aXMgPSBTUExJVF9BWElTKCBub2RlSW5kZXgzMiwgdWludDMyQXJyYXkgKTtcblx0XHRjb25zdCB4eXpBeGlzID0gX3h5ekZpZWxkc1sgc3BsaXRBeGlzIF07XG5cdFx0Y29uc3QgcmF5RGlyID0gcmF5LmRpcmVjdGlvblsgeHl6QXhpcyBdO1xuXHRcdGNvbnN0IGxlZnRUb1JpZ2h0ID0gcmF5RGlyID49IDA7XG5cblx0XHQvLyBjMSBpcyB0aGUgY2hpbGQgdG8gY2hlY2sgZmlyc3Rcblx0XHRsZXQgYzEsIGMyO1xuXHRcdGlmICggbGVmdFRvUmlnaHQgKSB7XG5cblx0XHRcdGMxID0gTEVGVF9OT0RFKCBub2RlSW5kZXgzMiApO1xuXHRcdFx0YzIgPSBSSUdIVF9OT0RFKCBub2RlSW5kZXgzMiwgdWludDMyQXJyYXkgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGMxID0gUklHSFRfTk9ERSggbm9kZUluZGV4MzIsIHVpbnQzMkFycmF5ICk7XG5cdFx0XHRjMiA9IExFRlRfTk9ERSggbm9kZUluZGV4MzIgKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IGMxSW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0UmF5KCBjMSwgZmxvYXQzMkFycmF5LCByYXksIF9ib3hJbnRlcnNlY3Rpb24gKTtcblx0XHRjb25zdCBjMVJlc3VsdCA9IGMxSW50ZXJzZWN0aW9uID8gX3JheWNhc3RGaXJzdCggYzEsIGJ2aCwgc2lkZSwgcmF5ICkgOiBudWxsO1xuXG5cdFx0Ly8gaWYgd2UgZ290IGFuIGludGVyc2VjdGlvbiBpbiB0aGUgZmlyc3Qgbm9kZSBhbmQgaXQncyBjbG9zZXIgdGhhbiB0aGUgc2Vjb25kIG5vZGUncyBib3VuZGluZ1xuXHRcdC8vIGJveCwgd2UgZG9uJ3QgbmVlZCB0byBjb25zaWRlciB0aGUgc2Vjb25kIG5vZGUgYmVjYXVzZSBpdCBjb3VsZG4ndCBwb3NzaWJseSBiZSBhIGJldHRlciByZXN1bHRcblx0XHRpZiAoIGMxUmVzdWx0ICkge1xuXG5cdFx0XHQvLyBjaGVjayBpZiB0aGUgcG9pbnQgaXMgd2l0aGluIHRoZSBzZWNvbmQgYm91bmRzXG5cdFx0XHQvLyBcInBvaW50XCIgaXMgaW4gdGhlIGxvY2FsIGZyYW1lIG9mIHRoZSBidmhcblx0XHRcdGNvbnN0IHBvaW50ID0gYzFSZXN1bHQucG9pbnRbIHh5ekF4aXMgXTtcblx0XHRcdGNvbnN0IGlzT3V0c2lkZSA9IGxlZnRUb1JpZ2h0ID9cblx0XHRcdFx0cG9pbnQgPD0gZmxvYXQzMkFycmF5WyBjMiArIHNwbGl0QXhpcyBdIDogLy8gbWluIGJvdW5kaW5nIGRhdGFcblx0XHRcdFx0cG9pbnQgPj0gZmxvYXQzMkFycmF5WyBjMiArIHNwbGl0QXhpcyArIDMgXTsgLy8gbWF4IGJvdW5kaW5nIGRhdGFcblxuXHRcdFx0aWYgKCBpc091dHNpZGUgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGMxUmVzdWx0O1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBlaXRoZXIgdGhlcmUgd2FzIG5vIGludGVyc2VjdGlvbiBpbiB0aGUgZmlyc3Qgbm9kZSwgb3IgdGhlcmUgY291bGQgc3RpbGwgYmUgYSBjbG9zZXJcblx0XHQvLyBpbnRlcnNlY3Rpb24gaW4gdGhlIHNlY29uZCwgc28gY2hlY2sgdGhlIHNlY29uZCBub2RlIGFuZCB0aGVuIHRha2UgdGhlIGJldHRlciBvZiB0aGUgdHdvXG5cdFx0Y29uc3QgYzJJbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3RSYXkoIGMyLCBmbG9hdDMyQXJyYXksIHJheSwgX2JveEludGVyc2VjdGlvbiApO1xuXHRcdGNvbnN0IGMyUmVzdWx0ID0gYzJJbnRlcnNlY3Rpb24gPyBfcmF5Y2FzdEZpcnN0KCBjMiwgYnZoLCBzaWRlLCByYXkgKSA6IG51bGw7XG5cblx0XHRpZiAoIGMxUmVzdWx0ICYmIGMyUmVzdWx0ICkge1xuXG5cdFx0XHRyZXR1cm4gYzFSZXN1bHQuZGlzdGFuY2UgPD0gYzJSZXN1bHQuZGlzdGFuY2UgPyBjMVJlc3VsdCA6IGMyUmVzdWx0O1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0cmV0dXJuIGMxUmVzdWx0IHx8IGMyUmVzdWx0IHx8IG51bGw7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IHJheWNhc3RGaXJzdF9pbmRpcmVjdCB9O1xuIl0sIm5hbWVzIjpbIlZlY3RvcjMiLCJJU19MRUFGIiwiT0ZGU0VUIiwiQ09VTlQiLCJTUExJVF9BWElTIiwiTEVGVF9OT0RFIiwiUklHSFRfTk9ERSIsIkJ1ZmZlclN0YWNrIiwiaW50ZXJzZWN0UmF5IiwiaW50ZXJzZWN0Q2xvc2VzdFRyaV9pbmRpcmVjdCIsIl9ib3hJbnRlcnNlY3Rpb24iLCJfeHl6RmllbGRzIiwicmF5Y2FzdEZpcnN0X2luZGlyZWN0IiwiYnZoIiwicm9vdCIsInNpZGUiLCJyYXkiLCJzZXRCdWZmZXIiLCJfcm9vdHMiLCJyZXN1bHQiLCJfcmF5Y2FzdEZpcnN0IiwiY2xlYXJCdWZmZXIiLCJub2RlSW5kZXgzMiIsImZsb2F0MzJBcnJheSIsInVpbnQxNkFycmF5IiwidWludDMyQXJyYXkiLCJub2RlSW5kZXgxNiIsImlzTGVhZiIsIm9mZnNldCIsImNvdW50Iiwic3BsaXRBeGlzIiwieHl6QXhpcyIsInJheURpciIsImRpcmVjdGlvbiIsImxlZnRUb1JpZ2h0IiwiYzEiLCJjMiIsImMxSW50ZXJzZWN0aW9uIiwiYzFSZXN1bHQiLCJwb2ludCIsImlzT3V0c2lkZSIsImMySW50ZXJzZWN0aW9uIiwiYzJSZXN1bHQiLCJkaXN0YW5jZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/raycastFirst_indirect.generated.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/raycast_indirect.generated.js":
/*!****************************************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/raycast_indirect.generated.js ***!
  \****************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   raycast_indirect: () => (/* binding */ raycast_indirect)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var _utils_intersectUtils_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../utils/intersectUtils.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/utils/intersectUtils.js\");\n/* harmony import */ var _utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/nodeBufferUtils.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/utils/nodeBufferUtils.js\");\n/* harmony import */ var _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../utils/BufferStack.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/utils/BufferStack.js\");\n/* harmony import */ var _utils_iterationUtils_indirect_generated_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/iterationUtils_indirect.generated.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/utils/iterationUtils_indirect.generated.js\");\n\n\n\n\n\n\n/******************************************************/ /* This file is generated from \"raycast.template.js\". */ /******************************************************/ const _boxIntersection = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nfunction raycast_indirect(bvh, root, side, ray, intersects) {\n    _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_1__.BufferStack.setBuffer(bvh._roots[root]);\n    _raycast(0, bvh, side, ray, intersects);\n    _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_1__.BufferStack.clearBuffer();\n}\nfunction _raycast(nodeIndex32, bvh, side, ray, intersects) {\n    const { float32Array, uint16Array, uint32Array } = _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_1__.BufferStack;\n    const nodeIndex16 = nodeIndex32 * 2;\n    const isLeaf = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.IS_LEAF)(nodeIndex16, uint16Array);\n    if (isLeaf) {\n        const offset = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.OFFSET)(nodeIndex32, uint32Array);\n        const count = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.COUNT)(nodeIndex16, uint16Array);\n        (0,_utils_iterationUtils_indirect_generated_js__WEBPACK_IMPORTED_MODULE_3__.intersectTris_indirect)(bvh, side, ray, offset, count, intersects);\n    } else {\n        const leftIndex = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.LEFT_NODE)(nodeIndex32);\n        if ((0,_utils_intersectUtils_js__WEBPACK_IMPORTED_MODULE_4__.intersectRay)(leftIndex, float32Array, ray, _boxIntersection)) {\n            _raycast(leftIndex, bvh, side, ray, intersects);\n        }\n        const rightIndex = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_2__.RIGHT_NODE)(nodeIndex32, uint32Array);\n        if ((0,_utils_intersectUtils_js__WEBPACK_IMPORTED_MODULE_4__.intersectRay)(rightIndex, float32Array, ray, _boxIntersection)) {\n            _raycast(rightIndex, bvh, side, ray, intersects);\n        }\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9jb3JlL2Nhc3QvcmF5Y2FzdF9pbmRpcmVjdC5nZW5lcmF0ZWQuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQWdDO0FBQzBCO0FBQ2tDO0FBQ3RDO0FBQ1I7QUFDeUM7QUFFdkYsc0RBQXNELEdBQ3RELHNEQUFzRCxHQUN0RCxzREFBc0QsR0FFdEQsTUFBTVMsbUJBQW1CLGFBQWEsR0FBRyxJQUFJVCwwQ0FBT0E7QUFDcEQsU0FBU1UsaUJBQWtCQyxHQUFHLEVBQUVDLElBQUksRUFBRUMsSUFBSSxFQUFFQyxHQUFHLEVBQUVDLFVBQVU7SUFFMURSLDhEQUFXQSxDQUFDUyxTQUFTLENBQUVMLElBQUlNLE1BQU0sQ0FBRUwsS0FBTTtJQUN6Q00sU0FBVSxHQUFHUCxLQUFLRSxNQUFNQyxLQUFLQztJQUM3QlIsOERBQVdBLENBQUNZLFdBQVc7QUFFeEI7QUFFQSxTQUFTRCxTQUFVRSxXQUFXLEVBQUVULEdBQUcsRUFBRUUsSUFBSSxFQUFFQyxHQUFHLEVBQUVDLFVBQVU7SUFFekQsTUFBTSxFQUFFTSxZQUFZLEVBQUVDLFdBQVcsRUFBRUMsV0FBVyxFQUFFLEdBQUdoQiw4REFBV0E7SUFDOUQsTUFBTWlCLGNBQWNKLGNBQWM7SUFDbEMsTUFBTUssU0FBU3ZCLGtFQUFPQSxDQUFFc0IsYUFBYUY7SUFDckMsSUFBS0csUUFBUztRQUViLE1BQU1DLFNBQVN2QixpRUFBTUEsQ0FBRWlCLGFBQWFHO1FBQ3BDLE1BQU1JLFFBQVF2QixnRUFBS0EsQ0FBRW9CLGFBQWFGO1FBRWxDZCxtR0FBc0JBLENBQUVHLEtBQUtFLE1BQU1DLEtBQUtZLFFBQVFDLE9BQU9aO0lBR3hELE9BQU87UUFFTixNQUFNYSxZQUFZdkIsb0VBQVNBLENBQUVlO1FBQzdCLElBQUtuQixzRUFBWUEsQ0FBRTJCLFdBQVdQLGNBQWNQLEtBQUtMLG1CQUFxQjtZQUVyRVMsU0FBVVUsV0FBV2pCLEtBQUtFLE1BQU1DLEtBQUtDO1FBRXRDO1FBRUEsTUFBTWMsYUFBYXZCLHFFQUFVQSxDQUFFYyxhQUFhRztRQUM1QyxJQUFLdEIsc0VBQVlBLENBQUU0QixZQUFZUixjQUFjUCxLQUFLTCxtQkFBcUI7WUFFdEVTLFNBQVVXLFlBQVlsQixLQUFLRSxNQUFNQyxLQUFLQztRQUV2QztJQUVEO0FBRUQ7QUFFNEIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aWJlLTNkLWNvZGUvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9jb3JlL2Nhc3QvcmF5Y2FzdF9pbmRpcmVjdC5nZW5lcmF0ZWQuanM/OGRmNiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgaW50ZXJzZWN0UmF5IH0gZnJvbSAnLi4vdXRpbHMvaW50ZXJzZWN0VXRpbHMuanMnO1xuaW1wb3J0IHsgSVNfTEVBRiwgT0ZGU0VULCBDT1VOVCwgTEVGVF9OT0RFLCBSSUdIVF9OT0RFIH0gZnJvbSAnLi4vdXRpbHMvbm9kZUJ1ZmZlclV0aWxzLmpzJztcbmltcG9ydCB7IEJ1ZmZlclN0YWNrIH0gZnJvbSAnLi4vdXRpbHMvQnVmZmVyU3RhY2suanMnO1xuaW1wb3J0ICcuLi91dGlscy9pdGVyYXRpb25VdGlscy5nZW5lcmF0ZWQuanMnO1xuaW1wb3J0IHsgaW50ZXJzZWN0VHJpc19pbmRpcmVjdCB9IGZyb20gJy4uL3V0aWxzL2l0ZXJhdGlvblV0aWxzX2luZGlyZWN0LmdlbmVyYXRlZC5qcyc7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGZyb20gXCJyYXljYXN0LnRlbXBsYXRlLmpzXCIuICovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuXG5jb25zdCBfYm94SW50ZXJzZWN0aW9uID0gLyogQF9fUFVSRV9fICovIG5ldyBWZWN0b3IzKCk7XG5mdW5jdGlvbiByYXljYXN0X2luZGlyZWN0KCBidmgsIHJvb3QsIHNpZGUsIHJheSwgaW50ZXJzZWN0cyApIHtcblxuXHRCdWZmZXJTdGFjay5zZXRCdWZmZXIoIGJ2aC5fcm9vdHNbIHJvb3QgXSApO1xuXHRfcmF5Y2FzdCggMCwgYnZoLCBzaWRlLCByYXksIGludGVyc2VjdHMgKTtcblx0QnVmZmVyU3RhY2suY2xlYXJCdWZmZXIoKTtcblxufVxuXG5mdW5jdGlvbiBfcmF5Y2FzdCggbm9kZUluZGV4MzIsIGJ2aCwgc2lkZSwgcmF5LCBpbnRlcnNlY3RzICkge1xuXG5cdGNvbnN0IHsgZmxvYXQzMkFycmF5LCB1aW50MTZBcnJheSwgdWludDMyQXJyYXkgfSA9IEJ1ZmZlclN0YWNrO1xuXHRjb25zdCBub2RlSW5kZXgxNiA9IG5vZGVJbmRleDMyICogMjtcblx0Y29uc3QgaXNMZWFmID0gSVNfTEVBRiggbm9kZUluZGV4MTYsIHVpbnQxNkFycmF5ICk7XG5cdGlmICggaXNMZWFmICkge1xuXG5cdFx0Y29uc3Qgb2Zmc2V0ID0gT0ZGU0VUKCBub2RlSW5kZXgzMiwgdWludDMyQXJyYXkgKTtcblx0XHRjb25zdCBjb3VudCA9IENPVU5UKCBub2RlSW5kZXgxNiwgdWludDE2QXJyYXkgKTtcblxuXHRcdGludGVyc2VjdFRyaXNfaW5kaXJlY3QoIGJ2aCwgc2lkZSwgcmF5LCBvZmZzZXQsIGNvdW50LCBpbnRlcnNlY3RzICk7XG5cblxuXHR9IGVsc2Uge1xuXG5cdFx0Y29uc3QgbGVmdEluZGV4ID0gTEVGVF9OT0RFKCBub2RlSW5kZXgzMiApO1xuXHRcdGlmICggaW50ZXJzZWN0UmF5KCBsZWZ0SW5kZXgsIGZsb2F0MzJBcnJheSwgcmF5LCBfYm94SW50ZXJzZWN0aW9uICkgKSB7XG5cblx0XHRcdF9yYXljYXN0KCBsZWZ0SW5kZXgsIGJ2aCwgc2lkZSwgcmF5LCBpbnRlcnNlY3RzICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCByaWdodEluZGV4ID0gUklHSFRfTk9ERSggbm9kZUluZGV4MzIsIHVpbnQzMkFycmF5ICk7XG5cdFx0aWYgKCBpbnRlcnNlY3RSYXkoIHJpZ2h0SW5kZXgsIGZsb2F0MzJBcnJheSwgcmF5LCBfYm94SW50ZXJzZWN0aW9uICkgKSB7XG5cblx0XHRcdF9yYXljYXN0KCByaWdodEluZGV4LCBidmgsIHNpZGUsIHJheSwgaW50ZXJzZWN0cyApO1xuXG5cdFx0fVxuXG5cdH1cblxufVxuXG5leHBvcnQgeyByYXljYXN0X2luZGlyZWN0IH07XG4iXSwibmFtZXMiOlsiVmVjdG9yMyIsImludGVyc2VjdFJheSIsIklTX0xFQUYiLCJPRkZTRVQiLCJDT1VOVCIsIkxFRlRfTk9ERSIsIlJJR0hUX05PREUiLCJCdWZmZXJTdGFjayIsImludGVyc2VjdFRyaXNfaW5kaXJlY3QiLCJfYm94SW50ZXJzZWN0aW9uIiwicmF5Y2FzdF9pbmRpcmVjdCIsImJ2aCIsInJvb3QiLCJzaWRlIiwicmF5IiwiaW50ZXJzZWN0cyIsInNldEJ1ZmZlciIsIl9yb290cyIsIl9yYXljYXN0IiwiY2xlYXJCdWZmZXIiLCJub2RlSW5kZXgzMiIsImZsb2F0MzJBcnJheSIsInVpbnQxNkFycmF5IiwidWludDMyQXJyYXkiLCJub2RlSW5kZXgxNiIsImlzTGVhZiIsIm9mZnNldCIsImNvdW50IiwibGVmdEluZGV4IiwicmlnaHRJbmRleCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/raycast_indirect.generated.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/refit.generated.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/refit.generated.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   refit: () => (/* binding */ refit)\n/* harmony export */ });\n/* harmony import */ var _Constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Constants.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/Constants.js\");\n\n/****************************************************/ /* This file is generated from \"refit.template.js\". */ /****************************************************/ function refit(bvh, nodeIndices = null) {\n    if (nodeIndices && Array.isArray(nodeIndices)) {\n        nodeIndices = new Set(nodeIndices);\n    }\n    const geometry = bvh.geometry;\n    const indexArr = geometry.index ? geometry.index.array : null;\n    const posAttr = geometry.attributes.position;\n    let buffer, uint32Array, uint16Array, float32Array;\n    let byteOffset = 0;\n    const roots = bvh._roots;\n    for(let i = 0, l = roots.length; i < l; i++){\n        buffer = roots[i];\n        uint32Array = new Uint32Array(buffer);\n        uint16Array = new Uint16Array(buffer);\n        float32Array = new Float32Array(buffer);\n        _traverse(0, byteOffset);\n        byteOffset += buffer.byteLength;\n    }\n    function _traverse(node32Index, byteOffset, force = false) {\n        const node16Index = node32Index * 2;\n        const isLeaf = uint16Array[node16Index + 15] === _Constants_js__WEBPACK_IMPORTED_MODULE_0__.IS_LEAFNODE_FLAG;\n        if (isLeaf) {\n            const offset = uint32Array[node32Index + 6];\n            const count = uint16Array[node16Index + 14];\n            let minx = Infinity;\n            let miny = Infinity;\n            let minz = Infinity;\n            let maxx = -Infinity;\n            let maxy = -Infinity;\n            let maxz = -Infinity;\n            for(let i = 3 * offset, l = 3 * (offset + count); i < l; i++){\n                let index = indexArr[i];\n                const x = posAttr.getX(index);\n                const y = posAttr.getY(index);\n                const z = posAttr.getZ(index);\n                if (x < minx) minx = x;\n                if (x > maxx) maxx = x;\n                if (y < miny) miny = y;\n                if (y > maxy) maxy = y;\n                if (z < minz) minz = z;\n                if (z > maxz) maxz = z;\n            }\n            if (float32Array[node32Index + 0] !== minx || float32Array[node32Index + 1] !== miny || float32Array[node32Index + 2] !== minz || float32Array[node32Index + 3] !== maxx || float32Array[node32Index + 4] !== maxy || float32Array[node32Index + 5] !== maxz) {\n                float32Array[node32Index + 0] = minx;\n                float32Array[node32Index + 1] = miny;\n                float32Array[node32Index + 2] = minz;\n                float32Array[node32Index + 3] = maxx;\n                float32Array[node32Index + 4] = maxy;\n                float32Array[node32Index + 5] = maxz;\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            const left = node32Index + 8;\n            const right = uint32Array[node32Index + 6];\n            // the identifying node indices provided by the shapecast function include offsets of all\n            // root buffers to guarantee they're unique between roots so offset left and right indices here.\n            const offsetLeft = left + byteOffset;\n            const offsetRight = right + byteOffset;\n            let forceChildren = force;\n            let includesLeft = false;\n            let includesRight = false;\n            if (nodeIndices) {\n                // if we see that neither the left or right child are included in the set that need to be updated\n                // then we assume that all children need to be updated.\n                if (!forceChildren) {\n                    includesLeft = nodeIndices.has(offsetLeft);\n                    includesRight = nodeIndices.has(offsetRight);\n                    forceChildren = !includesLeft && !includesRight;\n                }\n            } else {\n                includesLeft = true;\n                includesRight = true;\n            }\n            const traverseLeft = forceChildren || includesLeft;\n            const traverseRight = forceChildren || includesRight;\n            let leftChange = false;\n            if (traverseLeft) {\n                leftChange = _traverse(left, byteOffset, forceChildren);\n            }\n            let rightChange = false;\n            if (traverseRight) {\n                rightChange = _traverse(right, byteOffset, forceChildren);\n            }\n            const didChange = leftChange || rightChange;\n            if (didChange) {\n                for(let i = 0; i < 3; i++){\n                    const lefti = left + i;\n                    const righti = right + i;\n                    const minLeftValue = float32Array[lefti];\n                    const maxLeftValue = float32Array[lefti + 3];\n                    const minRightValue = float32Array[righti];\n                    const maxRightValue = float32Array[righti + 3];\n                    float32Array[node32Index + i] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n                    float32Array[node32Index + i + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n                }\n            }\n            return didChange;\n        }\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9jb3JlL2Nhc3QvcmVmaXQuZ2VuZXJhdGVkLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQW1EO0FBRW5ELG9EQUFvRCxHQUNwRCxvREFBb0QsR0FDcEQsb0RBQW9ELEdBRXBELFNBQVNDLE1BQU9DLEdBQUcsRUFBRUMsY0FBYyxJQUFJO0lBRXRDLElBQUtBLGVBQWVDLE1BQU1DLE9BQU8sQ0FBRUYsY0FBZ0I7UUFFbERBLGNBQWMsSUFBSUcsSUFBS0g7SUFFeEI7SUFFQSxNQUFNSSxXQUFXTCxJQUFJSyxRQUFRO0lBQzdCLE1BQU1DLFdBQVdELFNBQVNFLEtBQUssR0FBR0YsU0FBU0UsS0FBSyxDQUFDQyxLQUFLLEdBQUc7SUFDekQsTUFBTUMsVUFBVUosU0FBU0ssVUFBVSxDQUFDQyxRQUFRO0lBRTVDLElBQUlDLFFBQVFDLGFBQWFDLGFBQWFDO0lBQ3RDLElBQUlDLGFBQWE7SUFDakIsTUFBTUMsUUFBUWpCLElBQUlrQixNQUFNO0lBQ3hCLElBQU0sSUFBSUMsSUFBSSxHQUFHQyxJQUFJSCxNQUFNSSxNQUFNLEVBQUVGLElBQUlDLEdBQUdELElBQU87UUFFaERQLFNBQVNLLEtBQUssQ0FBRUUsRUFBRztRQUNuQk4sY0FBYyxJQUFJUyxZQUFhVjtRQUMvQkUsY0FBYyxJQUFJUyxZQUFhWDtRQUMvQkcsZUFBZSxJQUFJUyxhQUFjWjtRQUVqQ2EsVUFBVyxHQUFHVDtRQUNkQSxjQUFjSixPQUFPYyxVQUFVO0lBRWhDO0lBRUEsU0FBU0QsVUFBV0UsV0FBVyxFQUFFWCxVQUFVLEVBQUVZLFFBQVEsS0FBSztRQUV6RCxNQUFNQyxjQUFjRixjQUFjO1FBQ2xDLE1BQU1HLFNBQVNoQixXQUFXLENBQUVlLGNBQWMsR0FBSSxLQUFLL0IsMkRBQWdCQTtRQUNuRSxJQUFLZ0MsUUFBUztZQUViLE1BQU1DLFNBQVNsQixXQUFXLENBQUVjLGNBQWMsRUFB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d0MsUUFBUWIsT0FBTzNCO29CQUNyQixNQUFNeUMsU0FBU2IsUUFBUTVCO29CQUN2QixNQUFNMEMsZUFBZTlDLFlBQVksQ0FBRTRDLE1BQU87b0JBQzFDLE1BQU1HLGVBQWUvQyxZQUFZLENBQUU0QyxRQUFRLEVBQUc7b0JBQzlDLE1BQU1JLGdCQUFnQmhELFlBQVksQ0FBRTZDLE9BQVE7b0JBQzVDLE1BQU1JLGdCQUFnQmpELFlBQVksQ0FBRTZDLFNBQVMsRUFBRztvQkFFaEQ3QyxZQUFZLENBQUVZLGNBQWNSLEVBQUcsR0FBRzBDLGVBQWVFLGdCQUFnQkYsZUFBZUU7b0JBQ2hGaEQsWUFBWSxDQUFFWSxjQUFjUixJQUFJLEVBQUcsR0FBRzJDLGVBQWVFLGdCQUFnQkYsZUFBZUU7Z0JBRXJGO1lBRUQ7WUFFQSxPQUFPTjtRQUVSO0lBRUQ7QUFFRDtBQUVpQiIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpYmUtM2QtY29kZS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9ub2RlX21vZHVsZXMvdGhyZWUtbWVzaC1idmgvc3JjL2NvcmUvY2FzdC9yZWZpdC5nZW5lcmF0ZWQuanM/Yjg5ZiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJU19MRUFGTk9ERV9GTEFHIH0gZnJvbSAnLi4vQ29uc3RhbnRzLmpzJztcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGZyb20gXCJyZWZpdC50ZW1wbGF0ZS5qc1wiLiAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbmZ1bmN0aW9uIHJlZml0KCBidmgsIG5vZGVJbmRpY2VzID0gbnVsbCApIHtcblxuXHRpZiAoIG5vZGVJbmRpY2VzICYmIEFycmF5LmlzQXJyYXkoIG5vZGVJbmRpY2VzICkgKSB7XG5cblx0XHRub2RlSW5kaWNlcyA9IG5ldyBTZXQoIG5vZGVJbmRpY2VzICk7XG5cblx0fVxuXG5cdGNvbnN0IGdlb21ldHJ5ID0gYnZoLmdlb21ldHJ5O1xuXHRjb25zdCBpbmRleEFyciA9IGdlb21ldHJ5LmluZGV4ID8gZ2VvbWV0cnkuaW5kZXguYXJyYXkgOiBudWxsO1xuXHRjb25zdCBwb3NBdHRyID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuXHRsZXQgYnVmZmVyLCB1aW50MzJBcnJheSwgdWludDE2QXJyYXksIGZsb2F0MzJBcnJheTtcblx0bGV0IGJ5dGVPZmZzZXQgPSAwO1xuXHRjb25zdCByb290cyA9IGJ2aC5fcm9vdHM7XG5cdGZvciAoIGxldCBpID0gMCwgbCA9IHJvb3RzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRidWZmZXIgPSByb290c1sgaSBdO1xuXHRcdHVpbnQzMkFycmF5ID0gbmV3IFVpbnQzMkFycmF5KCBidWZmZXIgKTtcblx0XHR1aW50MTZBcnJheSA9IG5ldyBVaW50MTZBcnJheSggYnVmZmVyICk7XG5cdFx0ZmxvYXQzMkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggYnVmZmVyICk7XG5cblx0XHRfdHJhdmVyc2UoIDAsIGJ5dGVPZmZzZXQgKTtcblx0XHRieXRlT2Zmc2V0ICs9IGJ1ZmZlci5ieXRlTGVuZ3RoO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBfdHJhdmVyc2UoIG5vZGUzMkluZGV4LCBieXRlT2Zmc2V0LCBmb3JjZSA9IGZhbHNlICkge1xuXG5cdFx0Y29uc3Qgbm9kZTE2SW5kZXggPSBub2RlMzJJbmRleCAqIDI7XG5cdFx0Y29uc3QgaXNMZWFmID0gdWludDE2QXJyYXlbIG5vZGUxNkluZGV4ICsgMTUgXSA9PT0gSVNfTEVBRk5PREVfRkxBRztcblx0XHRpZiAoIGlzTGVhZiApIHtcblxuXHRcdFx0Y29uc3Qgb2Zmc2V0ID0gdWludDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgNiBdO1xuXHRcdFx0Y29uc3QgY291bnQgPSB1aW50MTZBcnJheVsgbm9kZTE2SW5kZXggKyAxNCBdO1xuXG5cdFx0XHRsZXQgbWlueCA9IEluZmluaXR5O1xuXHRcdFx0bGV0IG1pbnkgPSBJbmZpbml0eTtcblx0XHRcdGxldCBtaW56ID0gSW5maW5pdHk7XG5cdFx0XHRsZXQgbWF4eCA9IC0gSW5maW5pdHk7XG5cdFx0XHRsZXQgbWF4eSA9IC0gSW5maW5pdHk7XG5cdFx0XHRsZXQgbWF4eiA9IC0gSW5maW5pdHk7XG5cblxuXHRcdFx0Zm9yICggbGV0IGkgPSAzICogb2Zmc2V0LCBsID0gMyAqICggb2Zmc2V0ICsgY291bnQgKTsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0bGV0IGluZGV4ID0gaW5kZXhBcnJbIGkgXTtcblx0XHRcdFx0Y29uc3QgeCA9IHBvc0F0dHIuZ2V0WCggaW5kZXggKTtcblx0XHRcdFx0Y29uc3QgeSA9IHBvc0F0dHIuZ2V0WSggaW5kZXggKTtcblx0XHRcdFx0Y29uc3QgeiA9IHBvc0F0dHIuZ2V0WiggaW5kZXggKTtcblxuXHRcdFx0XHRpZiAoIHggPCBtaW54ICkgbWlueCA9IHg7XG5cdFx0XHRcdGlmICggeCA+IG1heHggKSBtYXh4ID0geDtcblxuXHRcdFx0XHRpZiAoIHkgPCBtaW55ICkgbWlueSA9IHk7XG5cdFx0XHRcdGlmICggeSA+IG1heHkgKSBtYXh5ID0geTtcblxuXHRcdFx0XHRpZiAoIHogPCBtaW56ICkgbWlueiA9IHo7XG5cdFx0XHRcdGlmICggeiA+IG1heHogKSBtYXh6ID0gejtcblxuXHRcdFx0fVxuXG5cblx0XHRcdGlmIChcblx0XHRcdFx0ZmxvYXQzMkFycmF5WyBub2RlMzJJbmRleCArIDAgXSAhPT0gbWlueCB8fFxuXHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgMSBdICE9PSBtaW55IHx8XG5cdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyAyIF0gIT09IG1pbnogfHxcblxuXHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgMyBdICE9PSBtYXh4IHx8XG5cdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyA0IF0gIT09IG1heHkgfHxcblx0XHRcdFx0ZmxvYXQzMkFycmF5WyBub2RlMzJJbmRleCArIDUgXSAhPT0gbWF4elxuXHRcdFx0KSB7XG5cblx0XHRcdFx0ZmxvYXQzMkFycmF5WyBub2RlMzJJbmRleCArIDAgXSA9IG1pbng7XG5cdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyAxIF0gPSBtaW55O1xuXHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgMiBdID0gbWluejtcblxuXHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgMyBdID0gbWF4eDtcblx0XHRcdFx0ZmxvYXQzMkFycmF5WyBub2RlMzJJbmRleCArIDQgXSA9IG1heHk7XG5cdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyA1IF0gPSBtYXh6O1xuXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Y29uc3QgbGVmdCA9IG5vZGUzMkluZGV4ICsgODtcblx0XHRcdGNvbnN0IHJpZ2h0ID0gdWludDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgNiBdO1xuXG5cdFx0XHQvLyB0aGUgaWRlbnRpZnlpbmcgbm9kZSBpbmRpY2VzIHByb3ZpZGVkIGJ5IHRoZSBzaGFwZWNhc3QgZnVuY3Rpb24gaW5jbHVkZSBvZmZzZXRzIG9mIGFsbFxuXHRcdFx0Ly8gcm9vdCBidWZmZXJzIHRvIGd1YXJhbnRlZSB0aGV5J3JlIHVuaXF1ZSBiZXR3ZWVuIHJvb3RzIHNvIG9mZnNldCBsZWZ0IGFuZCByaWdodCBpbmRpY2VzIGhlcmUuXG5cdFx0XHRjb25zdCBvZmZzZXRMZWZ0ID0gbGVmdCArIGJ5dGVPZmZzZXQ7XG5cdFx0XHRjb25zdCBvZmZzZXRSaWdodCA9IHJpZ2h0ICsgYnl0ZU9mZnNldDtcblx0XHRcdGxldCBmb3JjZUNoaWxkcmVuID0gZm9yY2U7XG5cdFx0XHRsZXQgaW5jbHVkZXNMZWZ0ID0gZmFsc2U7XG5cdFx0XHRsZXQgaW5jbHVkZXNSaWdodCA9IGZhbHNlO1xuXG5cdFx0XHRpZiAoIG5vZGVJbmRpY2VzICkge1xuXG5cdFx0XHRcdC8vIGlmIHdlIHNlZSB0aGF0IG5laXRoZXIgdGhlIGxlZnQgb3IgcmlnaHQgY2hpbGQgYXJlIGluY2x1ZGVkIGluIHRoZSBzZXQgdGhhdCBuZWVkIHRvIGJlIHVwZGF0ZWRcblx0XHRcdFx0Ly8gdGhlbiB3ZSBhc3N1bWUgdGhhdCBhbGwgY2hpbGRyZW4gbmVlZCB0byBiZSB1cGRhdGVkLlxuXHRcdFx0XHRpZiAoICEgZm9yY2VDaGlsZHJlbiApIHtcblxuXHRcdFx0XHRcdGluY2x1ZGVzTGVmdCA9IG5vZGVJbmRpY2VzLmhhcyggb2Zmc2V0TGVmdCApO1xuXHRcdFx0XHRcdGluY2x1ZGVzUmlnaHQgPSBub2RlSW5kaWNlcy5oYXMoIG9mZnNldFJpZ2h0ICk7XG5cdFx0XHRcdFx0Zm9yY2VDaGlsZHJlbiA9ICEgaW5jbHVkZXNMZWZ0ICYmICEgaW5jbHVkZXNSaWdodDtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0aW5jbHVkZXNMZWZ0ID0gdHJ1ZTtcblx0XHRcdFx0aW5jbHVkZXNSaWdodCA9IHRydWU7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgdHJhdmVyc2VMZWZ0ID0gZm9yY2VDaGlsZHJlbiB8fCBpbmNsdWRlc0xlZnQ7XG5cdFx0XHRjb25zdCB0cmF2ZXJzZVJpZ2h0ID0gZm9yY2VDaGlsZHJlbiB8fCBpbmNsdWRlc1JpZ2h0O1xuXG5cdFx0XHRsZXQgbGVmdENoYW5nZSA9IGZhbHNlO1xuXHRcdFx0aWYgKCB0cmF2ZXJzZUxlZnQgKSB7XG5cblx0XHRcdFx0bGVmdENoYW5nZSA9IF90cmF2ZXJzZSggbGVmdCwgYnl0ZU9mZnNldCwgZm9yY2VDaGlsZHJlbiApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGxldCByaWdodENoYW5nZSA9IGZhbHNlO1xuXHRcdFx0aWYgKCB0cmF2ZXJzZVJpZ2h0ICkge1xuXG5cdFx0XHRcdHJpZ2h0Q2hhbmdlID0gX3RyYXZlcnNlKCByaWdodCwgYnl0ZU9mZnNldCwgZm9yY2VDaGlsZHJlbiApO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGRpZENoYW5nZSA9IGxlZnRDaGFuZ2UgfHwgcmlnaHRDaGFuZ2U7XG5cdFx0XHRpZiAoIGRpZENoYW5nZSApIHtcblxuXHRcdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgbGVmdGkgPSBsZWZ0ICsgaTtcblx0XHRcdFx0XHRjb25zdCByaWdodGkgPSByaWdodCArIGk7XG5cdFx0XHRcdFx0Y29uc3QgbWluTGVmdFZhbHVlID0gZmxvYXQzMkFycmF5WyBsZWZ0aSBdO1xuXHRcdFx0XHRcdGNvbnN0IG1heExlZnRWYWx1ZSA9IGZsb2F0MzJBcnJheVsgbGVmdGkgKyAzIF07XG5cdFx0XHRcdFx0Y29uc3QgbWluUmlnaHRWYWx1ZSA9IGZsb2F0MzJBcnJheVsgcmlnaHRpIF07XG5cdFx0XHRcdFx0Y29uc3QgbWF4UmlnaHRWYWx1ZSA9IGZsb2F0MzJBcnJheVsgcmlnaHRpICsgMyBdO1xuXG5cdFx0XHRcdFx0ZmxvYXQzMkFycmF5WyBub2RlMzJJbmRleCArIGkgXSA9IG1pbkxlZnRWYWx1ZSA8IG1pblJpZ2h0VmFsdWUgPyBtaW5MZWZ0VmFsdWUgOiBtaW5SaWdodFZhbHVlO1xuXHRcdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyBpICsgMyBdID0gbWF4TGVmdFZhbHVlID4gbWF4UmlnaHRWYWx1ZSA/IG1heExlZnRWYWx1ZSA6IG1heFJpZ2h0VmFsdWU7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiBkaWRDaGFuZ2U7XG5cblx0XHR9XG5cblx0fVxuXG59XG5cbmV4cG9ydCB7IHJlZml0IH07XG4iXSwibmFtZXMiOlsiSVNfTEVBRk5PREVfRkxBRyIsInJlZml0IiwiYnZoIiwibm9kZUluZGljZXMiLCJBcnJheSIsImlzQXJyYXkiLCJTZXQiLCJnZW9tZXRyeSIsImluZGV4QXJyIiwiaW5kZXgiLCJhcnJheSIsInBvc0F0dHIiLCJhdHRyaWJ1dGVzIiwicG9zaXRpb24iLCJidWZmZXIiLCJ1aW50MzJBcnJheSIsInVpbnQxNkFycmF5IiwiZmxvYXQzMkFycmF5IiwiYnl0ZU9mZnNldCIsInJvb3RzIiwiX3Jvb3RzIiwiaSIsImwiLCJsZW5ndGgiLCJVaW50MzJBcnJheSIsIlVpbnQxNkFycmF5IiwiRmxvYXQzMkFycmF5IiwiX3RyYXZlcnNlIiwiYnl0ZUxlbmd0aCIsIm5vZGUzMkluZGV4IiwiZm9yY2UiLCJub2RlMTZJbmRleCIsImlzTGVhZiIsIm9mZnNldCIsImNvdW50IiwibWlueCIsIkluZmluaXR5IiwibWlueSIsIm1pbnoiLCJtYXh4IiwibWF4eSIsIm1heHoiLCJ4IiwiZ2V0WCIsInkiLCJnZXRZIiwieiIsImdldFoiLCJsZWZ0IiwicmlnaHQiLCJvZmZzZXRMZWZ0Iiwib2Zmc2V0UmlnaHQiLCJmb3JjZUNoaWxkcmVuIiwiaW5jbHVkZXNMZWZ0IiwiaW5jbHVkZXNSaWdodCIsImhhcyIsInRyYXZlcnNlTGVmdCIsInRyYXZlcnNlUmlnaHQiLCJsZWZ0Q2hhbmdlIiwicmlnaHRDaGFuZ2UiLCJkaWRDaGFuZ2UiLCJsZWZ0aSIsInJpZ2h0aSIsIm1pbkxlZnRWYWx1ZSIsIm1heExlZnRWYWx1ZSIsIm1pblJpZ2h0VmFsdWUiLCJtYXhSaWdodFZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/refit.generated.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/refit_indirect.generated.js":
/*!**************************************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/refit_indirect.generated.js ***!
  \**************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   refit_indirect: () => (/* binding */ refit_indirect)\n/* harmony export */ });\n/* harmony import */ var _Constants_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../Constants.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/Constants.js\");\n\n/****************************************************/ /* This file is generated from \"refit.template.js\". */ /****************************************************/ function refit_indirect(bvh, nodeIndices = null) {\n    if (nodeIndices && Array.isArray(nodeIndices)) {\n        nodeIndices = new Set(nodeIndices);\n    }\n    const geometry = bvh.geometry;\n    const indexArr = geometry.index ? geometry.index.array : null;\n    const posAttr = geometry.attributes.position;\n    let buffer, uint32Array, uint16Array, float32Array;\n    let byteOffset = 0;\n    const roots = bvh._roots;\n    for(let i = 0, l = roots.length; i < l; i++){\n        buffer = roots[i];\n        uint32Array = new Uint32Array(buffer);\n        uint16Array = new Uint16Array(buffer);\n        float32Array = new Float32Array(buffer);\n        _traverse(0, byteOffset);\n        byteOffset += buffer.byteLength;\n    }\n    function _traverse(node32Index, byteOffset, force = false) {\n        const node16Index = node32Index * 2;\n        const isLeaf = uint16Array[node16Index + 15] === _Constants_js__WEBPACK_IMPORTED_MODULE_0__.IS_LEAFNODE_FLAG;\n        if (isLeaf) {\n            const offset = uint32Array[node32Index + 6];\n            const count = uint16Array[node16Index + 14];\n            let minx = Infinity;\n            let miny = Infinity;\n            let minz = Infinity;\n            let maxx = -Infinity;\n            let maxy = -Infinity;\n            let maxz = -Infinity;\n            for(let i = offset, l = offset + count; i < l; i++){\n                const t = 3 * bvh.resolveTriangleIndex(i);\n                for(let j = 0; j < 3; j++){\n                    let index = t + j;\n                    index = indexArr ? indexArr[index] : index;\n                    const x = posAttr.getX(index);\n                    const y = posAttr.getY(index);\n                    const z = posAttr.getZ(index);\n                    if (x < minx) minx = x;\n                    if (x > maxx) maxx = x;\n                    if (y < miny) miny = y;\n                    if (y > maxy) maxy = y;\n                    if (z < minz) minz = z;\n                    if (z > maxz) maxz = z;\n                }\n            }\n            if (float32Array[node32Index + 0] !== minx || float32Array[node32Index + 1] !== miny || float32Array[node32Index + 2] !== minz || float32Array[node32Index + 3] !== maxx || float32Array[node32Index + 4] !== maxy || float32Array[node32Index + 5] !== maxz) {\n                float32Array[node32Index + 0] = minx;\n                float32Array[node32Index + 1] = miny;\n                float32Array[node32Index + 2] = minz;\n                float32Array[node32Index + 3] = maxx;\n                float32Array[node32Index + 4] = maxy;\n                float32Array[node32Index + 5] = maxz;\n                return true;\n            } else {\n                return false;\n            }\n        } else {\n            const left = node32Index + 8;\n            const right = uint32Array[node32Index + 6];\n            // the identifying node indices provided by the shapecast function include offsets of all\n            // root buffers to guarantee they're unique between roots so offset left and right indices here.\n            const offsetLeft = left + byteOffset;\n            const offsetRight = right + byteOffset;\n            let forceChildren = force;\n            let includesLeft = false;\n            let includesRight = false;\n            if (nodeIndices) {\n                // if we see that neither the left or right child are included in the set that need to be updated\n                // then we assume that all children need to be updated.\n                if (!forceChildren) {\n                    includesLeft = nodeIndices.has(offsetLeft);\n                    includesRight = nodeIndices.has(offsetRight);\n                    forceChildren = !includesLeft && !includesRight;\n                }\n            } else {\n                includesLeft = true;\n                includesRight = true;\n            }\n            const traverseLeft = forceChildren || includesLeft;\n            const traverseRight = forceChildren || includesRight;\n            let leftChange = false;\n            if (traverseLeft) {\n                leftChange = _traverse(left, byteOffset, forceChildren);\n            }\n            let rightChange = false;\n            if (traverseRight) {\n                rightChange = _traverse(right, byteOffset, forceChildren);\n            }\n            const didChange = leftChange || rightChange;\n            if (didChange) {\n                for(let i = 0; i < 3; i++){\n                    const lefti = left + i;\n                    const righti = right + i;\n                    const minLeftValue = float32Array[lefti];\n                    const maxLeftValue = float32Array[lefti + 3];\n                    const minRightValue = float32Array[righti];\n                    const maxRightValue = float32Array[righti + 3];\n                    float32Array[node32Index + i] = minLeftValue < minRightValue ? minLeftValue : minRightValue;\n                    float32Array[node32Index + i + 3] = maxLeftValue > maxRightValue ? maxLeftValue : maxRightValue;\n                }\n            }\n            return didChange;\n        }\n    }\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9jb3JlL2Nhc3QvcmVmaXRfaW5kaXJlY3QuZ2VuZXJhdGVkLmpzIiwibWFwcGluZ3MiOiI7Ozs7O0FBQW1EO0FBRW5ELG9EQUFvRCxHQUNwRCxvREFBb0QsR0FDcEQsb0RBQW9ELEdBRXBELFNBQVNDLGVBQWdCQyxHQUFHLEVBQUVDLGNBQWMsSUFBSTtJQUUvQyxJQUFLQSxlQUFlQyxNQUFNQyxPQUFPLENBQUVGLGNBQWdCO1FBRWxEQSxjQUFjLElBQUlHLElBQUtIO0lBRXhCO0lBRUEsTUFBTUksV0FBV0wsSUFBSUssUUFBUTtJQUM3QixNQUFNQyxXQUFXRCxTQUFTRSxLQUFLLEdBQUdGLFNBQVNFLEtBQUssQ0FBQ0MsS0FBSyxHQUFHO0lBQ3pELE1BQU1DLFVBQVVKLFNBQVNLLFVBQVUsQ0FBQ0MsUUFBUTtJQUU1QyxJQUFJQyxRQUFRQyxhQUFhQyxhQUFhQztJQUN0QyxJQUFJQyxhQUFhO0lBQ2pCLE1BQU1DLFFBQVFqQixJQUFJa0IsTUFBTTtJQUN4QixJQUFNLElBQUlDLElBQUksR0FBR0MsSUFBSUgsTUFBTUksTUFBTSxFQUFFRixJQUFJQyxHQUFHRCxJQUFPO1FBRWhEUCxTQUFTSyxLQUFLLENBQUVFLEVBQUc7UUFDbkJOLGNBQWMsSUFBSVMsWUFBYVY7UUFDL0JFLGNBQWMsSUFBSVMsWUFBYVg7UUFDL0JHLGVBQWUsSUFBSVMsYUFBY1o7UUFFakNhLFVBQVcsR0FBR1Q7UUFDZEEsY0FBY0osT0FBT2MsVUFBVTtJQUVoQztJQUVBLFNBQVNELFVBQVdFLFdBQVcsRUFBRVgsVUFBVSxFQUFFWSxRQUFRLEtBQUs7UUFFekQsTUFBTUMsY0FBY0YsY0FBYztRQUNsQyxNQUFNRyxTQUFTaEIsV0FBVyxDQUFFZSxjQUFjLEdBQUksS0FBSy9CLDJEQUFnQkE7UUFDbkUsSUFBS2dDLFFBQVM7WUFFYixNQUFNQyxTQUFTbEIsV0FBVyxDQUFF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QUFXeUIsT0FBT2xDLFlBQVlxQztZQUU3QztZQUVBLE1BQU1RLFlBQVlGLGNBQWNDO1lBQ2hDLElBQUtDLFdBQVk7Z0JBRWhCLElBQU0sSUFBSTFDLElBQUksR0FBR0EsSUFBSSxHQUFHQSxJQUFPO29CQUU5QixNQUFNMkMsUUFBUWIsT0FBTzlCO29CQUNyQixNQUFNNEMsU0FBU2IsUUFBUS9CO29CQUN2QixNQUFNNkMsZUFBZWpELFlBQVksQ0FBRStDLE1BQU87b0JBQzFDLE1BQU1HLGVBQWVsRCxZQUFZLENBQUUrQyxRQUFRLEVBQUc7b0JBQzlDLE1BQU1JLGdCQUFnQm5ELFlBQVksQ0FBRWdELE9BQVE7b0JBQzVDLE1BQU1JLGdCQUFnQnBELFlBQVksQ0FBRWdELFNBQVMsRUFBRztvQkFFaERoRCxZQUFZLENBQUVZLGNBQWNSLEVBQUcsR0FBRzZDLGVBQWVFLGdCQUFnQkYsZUFBZUU7b0JBQ2hGbkQsWUFBWSxDQUFFWSxjQUFjUixJQUFJLEVBQUcsR0FBRzhDLGVBQWVFLGdCQUFnQkYsZUFBZUU7Z0JBRXJGO1lBRUQ7WUFFQSxPQUFPTjtRQUVSO0lBRUQ7QUFFRDtBQUUwQiIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpYmUtM2QtY29kZS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9ub2RlX21vZHVsZXMvdGhyZWUtbWVzaC1idmgvc3JjL2NvcmUvY2FzdC9yZWZpdF9pbmRpcmVjdC5nZW5lcmF0ZWQuanM/OTkwOSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBJU19MRUFGTk9ERV9GTEFHIH0gZnJvbSAnLi4vQ29uc3RhbnRzLmpzJztcblxuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG4vKiBUaGlzIGZpbGUgaXMgZ2VuZXJhdGVkIGZyb20gXCJyZWZpdC50ZW1wbGF0ZS5qc1wiLiAqL1xuLyoqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKiovXG5cbmZ1bmN0aW9uIHJlZml0X2luZGlyZWN0KCBidmgsIG5vZGVJbmRpY2VzID0gbnVsbCApIHtcblxuXHRpZiAoIG5vZGVJbmRpY2VzICYmIEFycmF5LmlzQXJyYXkoIG5vZGVJbmRpY2VzICkgKSB7XG5cblx0XHRub2RlSW5kaWNlcyA9IG5ldyBTZXQoIG5vZGVJbmRpY2VzICk7XG5cblx0fVxuXG5cdGNvbnN0IGdlb21ldHJ5ID0gYnZoLmdlb21ldHJ5O1xuXHRjb25zdCBpbmRleEFyciA9IGdlb21ldHJ5LmluZGV4ID8gZ2VvbWV0cnkuaW5kZXguYXJyYXkgOiBudWxsO1xuXHRjb25zdCBwb3NBdHRyID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblxuXHRsZXQgYnVmZmVyLCB1aW50MzJBcnJheSwgdWludDE2QXJyYXksIGZsb2F0MzJBcnJheTtcblx0bGV0IGJ5dGVPZmZzZXQgPSAwO1xuXHRjb25zdCByb290cyA9IGJ2aC5fcm9vdHM7XG5cdGZvciAoIGxldCBpID0gMCwgbCA9IHJvb3RzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRidWZmZXIgPSByb290c1sgaSBdO1xuXHRcdHVpbnQzMkFycmF5ID0gbmV3IFVpbnQzMkFycmF5KCBidWZmZXIgKTtcblx0XHR1aW50MTZBcnJheSA9IG5ldyBVaW50MTZBcnJheSggYnVmZmVyICk7XG5cdFx0ZmxvYXQzMkFycmF5ID0gbmV3IEZsb2F0MzJBcnJheSggYnVmZmVyICk7XG5cblx0XHRfdHJhdmVyc2UoIDAsIGJ5dGVPZmZzZXQgKTtcblx0XHRieXRlT2Zmc2V0ICs9IGJ1ZmZlci5ieXRlTGVuZ3RoO1xuXG5cdH1cblxuXHRmdW5jdGlvbiBfdHJhdmVyc2UoIG5vZGUzMkluZGV4LCBieXRlT2Zmc2V0LCBmb3JjZSA9IGZhbHNlICkge1xuXG5cdFx0Y29uc3Qgbm9kZTE2SW5kZXggPSBub2RlMzJJbmRleCAqIDI7XG5cdFx0Y29uc3QgaXNMZWFmID0gdWludDE2QXJyYXlbIG5vZGUxNkluZGV4ICsgMTUgXSA9PT0gSVNfTEVBRk5PREVfRkxBRztcblx0XHRpZiAoIGlzTGVhZiApIHtcblxuXHRcdFx0Y29uc3Qgb2Zmc2V0ID0gdWludDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgNiBdO1xuXHRcdFx0Y29uc3QgY291bnQgPSB1aW50MTZBcnJheVsgbm9kZTE2SW5kZXggKyAxNCBdO1xuXG5cdFx0XHRsZXQgbWlueCA9IEluZmluaXR5O1xuXHRcdFx0bGV0IG1pbnkgPSBJbmZpbml0eTtcblx0XHRcdGxldCBtaW56ID0gSW5maW5pdHk7XG5cdFx0XHRsZXQgbWF4eCA9IC0gSW5maW5pdHk7XG5cdFx0XHRsZXQgbWF4eSA9IC0gSW5maW5pdHk7XG5cdFx0XHRsZXQgbWF4eiA9IC0gSW5maW5pdHk7XG5cblx0XHRcdGZvciAoIGxldCBpID0gb2Zmc2V0LCBsID0gb2Zmc2V0ICsgY291bnQ7IGkgPCBsOyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHQgPSAzICogYnZoLnJlc29sdmVUcmlhbmdsZUluZGV4KCBpICk7XG5cdFx0XHRcdGZvciAoIGxldCBqID0gMDsgaiA8IDM7IGogKysgKSB7XG5cblx0XHRcdFx0XHRsZXQgaW5kZXggPSB0ICsgajtcblx0XHRcdFx0XHRpbmRleCA9IGluZGV4QXJyID8gaW5kZXhBcnJbIGluZGV4IF0gOiBpbmRleDtcblxuXHRcdFx0XHRcdGNvbnN0IHggPSBwb3NBdHRyLmdldFgoIGluZGV4ICk7XG5cdFx0XHRcdFx0Y29uc3QgeSA9IHBvc0F0dHIuZ2V0WSggaW5kZXggKTtcblx0XHRcdFx0XHRjb25zdCB6ID0gcG9zQXR0ci5nZXRaKCBpbmRleCApO1xuXG5cdFx0XHRcdFx0aWYgKCB4IDwgbWlueCApIG1pbnggPSB4O1xuXHRcdFx0XHRcdGlmICggeCA+IG1heHggKSBtYXh4ID0geDtcblxuXHRcdFx0XHRcdGlmICggeSA8IG1pbnkgKSBtaW55ID0geTtcblx0XHRcdFx0XHRpZiAoIHkgPiBtYXh5ICkgbWF4eSA9IHk7XG5cblx0XHRcdFx0XHRpZiAoIHogPCBtaW56ICkgbWlueiA9IHo7XG5cdFx0XHRcdFx0aWYgKCB6ID4gbWF4eiApIG1heHogPSB6O1xuXG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblxuXHRcdFx0aWYgKFxuXHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgMCBdICE9PSBtaW54IHx8XG5cdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyAxIF0gIT09IG1pbnkgfHxcblx0XHRcdFx0ZmxvYXQzMkFycmF5WyBub2RlMzJJbmRleCArIDIgXSAhPT0gbWlueiB8fFxuXG5cdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyAzIF0gIT09IG1heHggfHxcblx0XHRcdFx0ZmxvYXQzMkFycmF5WyBub2RlMzJJbmRleCArIDQgXSAhPT0gbWF4eSB8fFxuXHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgNSBdICE9PSBtYXh6XG5cdFx0XHQpIHtcblxuXHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgMCBdID0gbWlueDtcblx0XHRcdFx0ZmxvYXQzMkFycmF5WyBub2RlMzJJbmRleCArIDEgXSA9IG1pbnk7XG5cdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyAyIF0gPSBtaW56O1xuXG5cdFx0XHRcdGZsb2F0MzJBcnJheVsgbm9kZTMySW5kZXggKyAzIF0gPSBtYXh4O1xuXHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgNCBdID0gbWF4eTtcblx0XHRcdFx0ZmxvYXQzMkFycmF5WyBub2RlMzJJbmRleCArIDUgXSA9IG1heHo7XG5cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjb25zdCBsZWZ0ID0gbm9kZTMySW5kZXggKyA4O1xuXHRcdFx0Y29uc3QgcmlnaHQgPSB1aW50MzJBcnJheVsgbm9kZTMySW5kZXggKyA2IF07XG5cblx0XHRcdC8vIHRoZSBpZGVudGlmeWluZyBub2RlIGluZGljZXMgcHJvdmlkZWQgYnkgdGhlIHNoYXBlY2FzdCBmdW5jdGlvbiBpbmNsdWRlIG9mZnNldHMgb2YgYWxsXG5cdFx0XHQvLyByb290IGJ1ZmZlcnMgdG8gZ3VhcmFudGVlIHRoZXkncmUgdW5pcXVlIGJldHdlZW4gcm9vdHMgc28gb2Zmc2V0IGxlZnQgYW5kIHJpZ2h0IGluZGljZXMgaGVyZS5cblx0XHRcdGNvbnN0IG9mZnNldExlZnQgPSBsZWZ0ICsgYnl0ZU9mZnNldDtcblx0XHRcdGNvbnN0IG9mZnNldFJpZ2h0ID0gcmlnaHQgKyBieXRlT2Zmc2V0O1xuXHRcdFx0bGV0IGZvcmNlQ2hpbGRyZW4gPSBmb3JjZTtcblx0XHRcdGxldCBpbmNsdWRlc0xlZnQgPSBmYWxzZTtcblx0XHRcdGxldCBpbmNsdWRlc1JpZ2h0ID0gZmFsc2U7XG5cblx0XHRcdGlmICggbm9kZUluZGljZXMgKSB7XG5cblx0XHRcdFx0Ly8gaWYgd2Ugc2VlIHRoYXQgbmVpdGhlciB0aGUgbGVmdCBvciByaWdodCBjaGlsZCBhcmUgaW5jbHVkZWQgaW4gdGhlIHNldCB0aGF0IG5lZWQgdG8gYmUgdXBkYXRlZFxuXHRcdFx0XHQvLyB0aGVuIHdlIGFzc3VtZSB0aGF0IGFsbCBjaGlsZHJlbiBuZWVkIHRvIGJlIHVwZGF0ZWQuXG5cdFx0XHRcdGlmICggISBmb3JjZUNoaWxkcmVuICkge1xuXG5cdFx0XHRcdFx0aW5jbHVkZXNMZWZ0ID0gbm9kZUluZGljZXMuaGFzKCBvZmZzZXRMZWZ0ICk7XG5cdFx0XHRcdFx0aW5jbHVkZXNSaWdodCA9IG5vZGVJbmRpY2VzLmhhcyggb2Zmc2V0UmlnaHQgKTtcblx0XHRcdFx0XHRmb3JjZUNoaWxkcmVuID0gISBpbmNsdWRlc0xlZnQgJiYgISBpbmNsdWRlc1JpZ2h0O1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRpbmNsdWRlc0xlZnQgPSB0cnVlO1xuXHRcdFx0XHRpbmNsdWRlc1JpZ2h0ID0gdHJ1ZTtcblxuXHRcdFx0fVxuXG5cdFx0XHRjb25zdCB0cmF2ZXJzZUxlZnQgPSBmb3JjZUNoaWxkcmVuIHx8IGluY2x1ZGVzTGVmdDtcblx0XHRcdGNvbnN0IHRyYXZlcnNlUmlnaHQgPSBmb3JjZUNoaWxkcmVuIHx8IGluY2x1ZGVzUmlnaHQ7XG5cblx0XHRcdGxldCBsZWZ0Q2hhbmdlID0gZmFsc2U7XG5cdFx0XHRpZiAoIHRyYXZlcnNlTGVmdCApIHtcblxuXHRcdFx0XHRsZWZ0Q2hhbmdlID0gX3RyYXZlcnNlKCBsZWZ0LCBieXRlT2Zmc2V0LCBmb3JjZUNoaWxkcmVuICk7XG5cblx0XHRcdH1cblxuXHRcdFx0bGV0IHJpZ2h0Q2hhbmdlID0gZmFsc2U7XG5cdFx0XHRpZiAoIHRyYXZlcnNlUmlnaHQgKSB7XG5cblx0XHRcdFx0cmlnaHRDaGFuZ2UgPSBfdHJhdmVyc2UoIHJpZ2h0LCBieXRlT2Zmc2V0LCBmb3JjZUNoaWxkcmVuICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Y29uc3QgZGlkQ2hhbmdlID0gbGVmdENoYW5nZSB8fCByaWdodENoYW5nZTtcblx0XHRcdGlmICggZGlkQ2hhbmdlICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XG5cblx0XHRcdFx0XHRjb25zdCBsZWZ0aSA9IGxlZnQgKyBpO1xuXHRcdFx0XHRcdGNvbnN0IHJpZ2h0aSA9IHJpZ2h0ICsgaTtcblx0XHRcdFx0XHRjb25zdCBtaW5MZWZ0VmFsdWUgPSBmbG9hdDMyQXJyYXlbIGxlZnRpIF07XG5cdFx0XHRcdFx0Y29uc3QgbWF4TGVmdFZhbHVlID0gZmxvYXQzMkFycmF5WyBsZWZ0aSArIDMgXTtcblx0XHRcdFx0XHRjb25zdCBtaW5SaWdodFZhbHVlID0gZmxvYXQzMkFycmF5WyByaWdodGkgXTtcblx0XHRcdFx0XHRjb25zdCBtYXhSaWdodFZhbHVlID0gZmxvYXQzMkFycmF5WyByaWdodGkgKyAzIF07XG5cblx0XHRcdFx0XHRmbG9hdDMyQXJyYXlbIG5vZGUzMkluZGV4ICsgaSBdID0gbWluTGVmdFZhbHVlIDwgbWluUmlnaHRWYWx1ZSA/IG1pbkxlZnRWYWx1ZSA6IG1pblJpZ2h0VmFsdWU7XG5cdFx0XHRcdFx0ZmxvYXQzMkFycmF5WyBub2RlMzJJbmRleCArIGkgKyAzIF0gPSBtYXhMZWZ0VmFsdWUgPiBtYXhSaWdodFZhbHVlID8gbWF4TGVmdFZhbHVlIDogbWF4UmlnaHRWYWx1ZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0cmV0dXJuIGRpZENoYW5nZTtcblxuXHRcdH1cblxuXHR9XG5cbn1cblxuZXhwb3J0IHsgcmVmaXRfaW5kaXJlY3QgfTtcbiJdLCJuYW1lcyI6WyJJU19MRUFGTk9ERV9GTEFHIiwicmVmaXRfaW5kaXJlY3QiLCJidmgiLCJub2RlSW5kaWNlcyIsIkFycmF5IiwiaXNBcnJheSIsIlNldCIsImdlb21ldHJ5IiwiaW5kZXhBcnIiLCJpbmRleCIsImFycmF5IiwicG9zQXR0ciIsImF0dHJpYnV0ZXMiLCJwb3NpdGlvbiIsImJ1ZmZlciIsInVpbnQzMkFycmF5IiwidWludDE2QXJyYXkiLCJmbG9hdDMyQXJyYXkiLCJieXRlT2Zmc2V0Iiwicm9vdHMiLCJfcm9vdHMiLCJpIiwibCIsImxlbmd0aCIsIlVpbnQzMkFycmF5IiwiVWludDE2QXJyYXkiLCJGbG9hdDMyQXJyYXkiLCJfdHJhdmVyc2UiLCJieXRlTGVuZ3RoIiwibm9kZTMySW5kZXgiLCJmb3JjZSIsIm5vZGUxNkluZGV4IiwiaXNMZWFmIiwib2Zmc2V0IiwiY291bnQiLCJtaW54IiwiSW5maW5pdHkiLCJtaW55IiwibWlueiIsIm1heHgiLCJtYXh5IiwibWF4eiIsInQiLCJyZXNvbHZlVHJpYW5nbGVJbmRleCIsImoiLCJ4IiwiZ2V0WCIsInkiLCJnZXRZIiwieiIsImdldFoiLCJsZWZ0IiwicmlnaHQiLCJvZmZzZXRMZWZ0Iiwib2Zmc2V0UmlnaHQiLCJmb3JjZUNoaWxkcmVuIiwiaW5jbHVkZXNMZWZ0IiwiaW5jbHVkZXNSaWdodCIsImhhcyIsInRyYXZlcnNlTGVmdCIsInRyYXZlcnNlUmlnaHQiLCJsZWZ0Q2hhbmdlIiwicmlnaHRDaGFuZ2UiLCJkaWRDaGFuZ2UiLCJsZWZ0aSIsInJpZ2h0aSIsIm1pbkxlZnRWYWx1ZSIsIm1heExlZnRWYWx1ZSIsIm1pblJpZ2h0VmFsdWUiLCJtYXhSaWdodFZhbHVlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/refit_indirect.generated.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/shapecast.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/shapecast.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   shapecast: () => (/* binding */ shapecast)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var _Constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ../Constants.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/Constants.js\");\n/* harmony import */ var _utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ../../utils/ArrayBoxUtilities.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js\");\n/* harmony import */ var _utils_PrimitivePool_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/PrimitivePool.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/PrimitivePool.js\");\n/* harmony import */ var _utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ../utils/nodeBufferUtils.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/utils/nodeBufferUtils.js\");\n/* harmony import */ var _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../utils/BufferStack.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/utils/BufferStack.js\");\n\n\n\n\n\n\nlet _box1, _box2;\nconst boxStack = [];\nconst boxPool = /* @__PURE__ */ new _utils_PrimitivePool_js__WEBPACK_IMPORTED_MODULE_0__.PrimitivePool(()=>new three__WEBPACK_IMPORTED_MODULE_1__.Box3());\nfunction shapecast(bvh, root, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset) {\n    // setup\n    _box1 = boxPool.getPrimitive();\n    _box2 = boxPool.getPrimitive();\n    boxStack.push(_box1, _box2);\n    _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_2__.BufferStack.setBuffer(bvh._roots[root]);\n    const result = shapecastTraverse(0, bvh.geometry, intersectsBounds, intersectsRange, boundsTraverseOrder, byteOffset);\n    // cleanup\n    _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_2__.BufferStack.clearBuffer();\n    boxPool.releasePrimitive(_box1);\n    boxPool.releasePrimitive(_box2);\n    boxStack.pop();\n    boxStack.pop();\n    const length = boxStack.length;\n    if (length > 0) {\n        _box2 = boxStack[length - 1];\n        _box1 = boxStack[length - 2];\n    }\n    return result;\n}\nfunction shapecastTraverse(nodeIndex32, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc = null, nodeIndexByteOffset = 0, depth = 0) {\n    const { float32Array, uint16Array, uint32Array } = _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_2__.BufferStack;\n    let nodeIndex16 = nodeIndex32 * 2;\n    const isLeaf = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_3__.IS_LEAF)(nodeIndex16, uint16Array);\n    if (isLeaf) {\n        const offset = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_3__.OFFSET)(nodeIndex32, uint32Array);\n        const count = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_3__.COUNT)(nodeIndex16, uint16Array);\n        (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_4__.arrayToBox)((0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_3__.BOUNDING_DATA_INDEX)(nodeIndex32), float32Array, _box1);\n        return intersectsRangeFunc(offset, count, false, depth, nodeIndexByteOffset + nodeIndex32, _box1);\n    } else {\n        const left = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_3__.LEFT_NODE)(nodeIndex32);\n        const right = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_3__.RIGHT_NODE)(nodeIndex32, uint32Array);\n        let c1 = left;\n        let c2 = right;\n        let score1, score2;\n        let box1, box2;\n        if (nodeScoreFunc) {\n            box1 = _box1;\n            box2 = _box2;\n            // bounding data is not offset\n            (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_4__.arrayToBox)((0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_3__.BOUNDING_DATA_INDEX)(c1), float32Array, box1);\n            (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_4__.arrayToBox)((0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_3__.BOUNDING_DATA_INDEX)(c2), float32Array, box2);\n            score1 = nodeScoreFunc(box1);\n            score2 = nodeScoreFunc(box2);\n            if (score2 < score1) {\n                c1 = right;\n                c2 = left;\n                const temp = score1;\n                score1 = score2;\n                score2 = temp;\n                box1 = box2;\n            // box2 is always set before use below\n            }\n        }\n        // Check box 1 intersection\n        if (!box1) {\n            box1 = _box1;\n            (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_4__.arrayToBox)((0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_3__.BOUNDING_DATA_INDEX)(c1), float32Array, box1);\n        }\n        const isC1Leaf = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_3__.IS_LEAF)(c1 * 2, uint16Array);\n        const c1Intersection = intersectsBoundsFunc(box1, isC1Leaf, score1, depth + 1, nodeIndexByteOffset + c1);\n        let c1StopTraversal;\n        if (c1Intersection === _Constants_js__WEBPACK_IMPORTED_MODULE_5__.CONTAINED) {\n            const offset = getLeftOffset(c1);\n            const end = getRightEndOffset(c1);\n            const count = end - offset;\n            c1StopTraversal = intersectsRangeFunc(offset, count, true, depth + 1, nodeIndexByteOffset + c1, box1);\n        } else {\n            c1StopTraversal = c1Intersection && shapecastTraverse(c1, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc, nodeIndexByteOffset, depth + 1);\n        }\n        if (c1StopTraversal) return true;\n        // Check box 2 intersection\n        // cached box2 will have been overwritten by previous traversal\n        box2 = _box2;\n        (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_4__.arrayToBox)((0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_3__.BOUNDING_DATA_INDEX)(c2), float32Array, box2);\n        const isC2Leaf = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_3__.IS_LEAF)(c2 * 2, uint16Array);\n        const c2Intersection = intersectsBoundsFunc(box2, isC2Leaf, score2, depth + 1, nodeIndexByteOffset + c2);\n        let c2StopTraversal;\n        if (c2Intersection === _Constants_js__WEBPACK_IMPORTED_MODULE_5__.CONTAINED) {\n            const offset = getLeftOffset(c2);\n            const end = getRightEndOffset(c2);\n            const count = end - offset;\n            c2StopTraversal = intersectsRangeFunc(offset, count, true, depth + 1, nodeIndexByteOffset + c2, box2);\n        } else {\n            c2StopTraversal = c2Intersection && shapecastTraverse(c2, geometry, intersectsBoundsFunc, intersectsRangeFunc, nodeScoreFunc, nodeIndexByteOffset, depth + 1);\n        }\n        if (c2StopTraversal) return true;\n        return false;\n        // Define these inside the function so it has access to the local variables needed\n        // when converting to the buffer equivalents\n        function getLeftOffset(nodeIndex32) {\n            const { uint16Array, uint32Array } = _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_2__.BufferStack;\n            let nodeIndex16 = nodeIndex32 * 2;\n            // traverse until we find a leaf\n            while(!(0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_3__.IS_LEAF)(nodeIndex16, uint16Array)){\n                nodeIndex32 = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_3__.LEFT_NODE)(nodeIndex32);\n                nodeIndex16 = nodeIndex32 * 2;\n            }\n            return (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_3__.OFFSET)(nodeIndex32, uint32Array);\n        }\n        function getRightEndOffset(nodeIndex32) {\n            const { uint16Array, uint32Array } = _utils_BufferStack_js__WEBPACK_IMPORTED_MODULE_2__.BufferStack;\n            let nodeIndex16 = nodeIndex32 * 2;\n            // traverse until we find a leaf\n            while(!(0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_3__.IS_LEAF)(nodeIndex16, uint16Array)){\n                // adjust offset to point to the right node\n                nodeIndex32 = (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_3__.RIGHT_NODE)(nodeIndex32, uint32Array);\n                nodeIndex16 = nodeIndex32 * 2;\n            }\n            // return the end offset of the triangle range\n            return (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_3__.OFFSET)(nodeIndex32, uint32Array) + (0,_utils_nodeBufferUtils_js__WEBPACK_IMPORTED_MODULE_3__.COUNT)(nodeIndex16, uint16Array);\n        }\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9jb3JlL2Nhc3Qvc2hhcGVjYXN0LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7Ozs7QUFBNkI7QUFDZTtBQUNrQjtBQUNEO0FBQ29EO0FBQzNEO0FBRXRELElBQUlXLE9BQU9DO0FBQ1gsTUFBTUMsV0FBVyxFQUFFO0FBQ25CLE1BQU1DLFVBQVUsYUFBYSxHQUFHLElBQUlYLGtFQUFhQSxDQUFFLElBQU0sSUFBSUgsdUNBQUlBO0FBRTFELFNBQVNlLFVBQVdDLEdBQUcsRUFBRUMsSUFBSSxFQUFFQyxnQkFBZ0IsRUFBRUMsZUFBZSxFQUFFQyxtQkFBbUIsRUFBRUMsVUFBVTtJQUV2RyxRQUFRO0lBQ1JWLFFBQVFHLFFBQVFRLFlBQVk7SUFDNUJWLFFBQVFFLFFBQVFRLFlBQVk7SUFDNUJULFNBQVNVLElBQUksQ0FBRVosT0FBT0M7SUFDdEJGLDhEQUFXQSxDQUFDYyxTQUFTLENBQUVSLElBQUlTLE1BQU0sQ0FBRVIsS0FBTTtJQUV6QyxNQUFNUyxTQUFTQyxrQkFBbUIsR0FBR1gsSUFBSVksUUFBUSxFQUFFVixrQkFBa0JDLGlCQUFpQkMscUJBQXFCQztJQUUzRyxVQUFVO0lBQ1ZYLDhEQUFXQSxDQUFDbUIsV0FBVztJQUN2QmYsUUFBUWdCLGdCQUFnQixDQUFFbkI7SUFDMUJHLFFBQVFnQixnQkFBZ0IsQ0FBRWxCO0lBQzFCQyxTQUFTa0IsR0FBRztJQUNabEIsU0FBU2tCLEdBQUc7SUFFWixNQUFNQyxTQUFTbkIsU0FBU21CLE1BQU07SUFDOUIsSUFBS0EsU0FBUyxHQUFJO1FBRWpCcEIsUUFBUUMsUUFBUSxDQUFFbUIsU0FBUyxFQUFHO1FBQzlCckIsUUFBUUUsUUFBUSxDQUFFbUIsU0FBUyxFQUFHO0lBRS9CO0lBRUEsT0FBT047QUFFUjtBQUVBLFNBQVNDLGtCQUNSTSxXQUFXLEVBQ1hMLFFBQVEsRUFDUk0sb0JBQW9CLEVBQ3BCQyxt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QXJCLFVBQ0FNLHNCQUNBQyxxQkFDQUMsZUFDQUMscUJBQ0FDLFFBQVE7UUFHWDtRQUVBLElBQUt5QixpQkFBa0IsT0FBTztRQUU5QixPQUFPO1FBRVAsa0ZBQWtGO1FBQ2xGLDRDQUE0QztRQUM1QyxTQUFTTCxjQUFlekIsV0FBVztZQUVsQyxNQUFNLEVBQUVPLFdBQVcsRUFBRUMsV0FBVyxFQUFFLEdBQUcvQiw4REFBV0E7WUFDaEQsSUFBSWdDLGNBQWNULGNBQWM7WUFFaEMsZ0NBQWdDO1lBQ2hDLE1BQVEsQ0FBRXpCLGtFQUFPQSxDQUFFa0MsYUFBYUYsYUFBZ0I7Z0JBRS9DUCxjQUFjM0Isb0VBQVNBLENBQUUyQjtnQkFDekJTLGNBQWNULGNBQWM7WUFFN0I7WUFFQSxPQUFPNUIsaUVBQU1BLENBQUU0QixhQUFhUTtRQUU3QjtRQUVBLFNBQVNtQixrQkFBbUIzQixXQUFXO1lBRXRDLE1BQU0sRUFBRU8sV0FBVyxFQUFFQyxXQUFXLEVBQUUsR0FBRy9CLDhEQUFXQTtZQUNoRCxJQUFJZ0MsY0FBY1QsY0FBYztZQUVoQyxnQ0FBZ0M7WUFDaEMsTUFBUSxDQUFFekIsa0VBQU9BLENBQUVrQyxhQUFhRixhQUFnQjtnQkFFL0MsMkNBQTJDO2dCQUMzQ1AsY0FBYzFCLHFFQUFVQSxDQUFFMEIsYUFBYVE7Z0JBQ3ZDQyxjQUFjVCxjQUFjO1lBRTdCO1lBRUEsOENBQThDO1lBQzlDLE9BQU81QixpRUFBTUEsQ0FBRTRCLGFBQWFRLGVBQWdCckMsZ0VBQUtBLENBQUVzQyxhQUFhRjtRQUVqRTtJQUVEO0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aWJlLTNkLWNvZGUvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9jb3JlL2Nhc3Qvc2hhcGVjYXN0LmpzPzJjNTEiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQm94MyB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IENPTlRBSU5FRCB9IGZyb20gJy4uL0NvbnN0YW50cy5qcyc7XG5pbXBvcnQgeyBhcnJheVRvQm94IH0gZnJvbSAnLi4vLi4vdXRpbHMvQXJyYXlCb3hVdGlsaXRpZXMuanMnO1xuaW1wb3J0IHsgUHJpbWl0aXZlUG9vbCB9IGZyb20gJy4uLy4uL3V0aWxzL1ByaW1pdGl2ZVBvb2wuanMnO1xuaW1wb3J0IHsgQ09VTlQsIE9GRlNFVCwgTEVGVF9OT0RFLCBSSUdIVF9OT0RFLCBJU19MRUFGLCBCT1VORElOR19EQVRBX0lOREVYIH0gZnJvbSAnLi4vdXRpbHMvbm9kZUJ1ZmZlclV0aWxzLmpzJztcbmltcG9ydCB7IEJ1ZmZlclN0YWNrIH0gZnJvbSAnLi4vdXRpbHMvQnVmZmVyU3RhY2suanMnO1xuXG5sZXQgX2JveDEsIF9ib3gyO1xuY29uc3QgYm94U3RhY2sgPSBbXTtcbmNvbnN0IGJveFBvb2wgPSAvKiBAX19QVVJFX18gKi8gbmV3IFByaW1pdGl2ZVBvb2woICgpID0+IG5ldyBCb3gzKCkgKTtcblxuZXhwb3J0IGZ1bmN0aW9uIHNoYXBlY2FzdCggYnZoLCByb290LCBpbnRlcnNlY3RzQm91bmRzLCBpbnRlcnNlY3RzUmFuZ2UsIGJvdW5kc1RyYXZlcnNlT3JkZXIsIGJ5dGVPZmZzZXQgKSB7XG5cblx0Ly8gc2V0dXBcblx0X2JveDEgPSBib3hQb29sLmdldFByaW1pdGl2ZSgpO1xuXHRfYm94MiA9IGJveFBvb2wuZ2V0UHJpbWl0aXZlKCk7XG5cdGJveFN0YWNrLnB1c2goIF9ib3gxLCBfYm94MiApO1xuXHRCdWZmZXJTdGFjay5zZXRCdWZmZXIoIGJ2aC5fcm9vdHNbIHJvb3QgXSApO1xuXG5cdGNvbnN0IHJlc3VsdCA9IHNoYXBlY2FzdFRyYXZlcnNlKCAwLCBidmguZ2VvbWV0cnksIGludGVyc2VjdHNCb3VuZHMsIGludGVyc2VjdHNSYW5nZSwgYm91bmRzVHJhdmVyc2VPcmRlciwgYnl0ZU9mZnNldCApO1xuXG5cdC8vIGNsZWFudXBcblx0QnVmZmVyU3RhY2suY2xlYXJCdWZmZXIoKTtcblx0Ym94UG9vbC5yZWxlYXNlUHJpbWl0aXZlKCBfYm94MSApO1xuXHRib3hQb29sLnJlbGVhc2VQcmltaXRpdmUoIF9ib3gyICk7XG5cdGJveFN0YWNrLnBvcCgpO1xuXHRib3hTdGFjay5wb3AoKTtcblxuXHRjb25zdCBsZW5ndGggPSBib3hTdGFjay5sZW5ndGg7XG5cdGlmICggbGVuZ3RoID4gMCApIHtcblxuXHRcdF9ib3gyID0gYm94U3RhY2tbIGxlbmd0aCAtIDEgXTtcblx0XHRfYm94MSA9IGJveFN0YWNrWyBsZW5ndGggLSAyIF07XG5cblx0fVxuXG5cdHJldHVybiByZXN1bHQ7XG5cbn1cblxuZnVuY3Rpb24gc2hhcGVjYXN0VHJhdmVyc2UoXG5cdG5vZGVJbmRleDMyLFxuXHRnZW9tZXRyeSxcblx0aW50ZXJzZWN0c0JvdW5kc0Z1bmMsXG5cdGludGVyc2VjdHNSYW5nZUZ1bmMsXG5cdG5vZGVTY29yZUZ1bmMgPSBudWxsLFxuXHRub2RlSW5kZXhCeXRlT2Zmc2V0ID0gMCwgLy8gb2Zmc2V0IGZvciB1bmlxdWUgbm9kZSBpZGVudGlmaWVyXG5cdGRlcHRoID0gMFxuKSB7XG5cblx0Y29uc3QgeyBmbG9hdDMyQXJyYXksIHVpbnQxNkFycmF5LCB1aW50MzJBcnJheSB9ID0gQnVmZmVyU3RhY2s7XG5cdGxldCBub2RlSW5kZXgxNiA9IG5vZGVJbmRleDMyICogMjtcblxuXHRjb25zdCBpc0xlYWYgPSBJU19MRUFGKCBub2RlSW5kZXgxNiwgdWludDE2QXJyYXkgKTtcblx0aWYgKCBpc0xlYWYgKSB7XG5cblx0XHRjb25zdCBvZmZzZXQgPSBPRkZTRVQoIG5vZGVJbmRleDMyLCB1aW50MzJBcnJheSApO1xuXHRcdGNvbnN0IGNvdW50ID0gQ09VTlQoIG5vZGVJbmRleDE2LCB1aW50MTZBcnJheSApO1xuXHRcdGFycmF5VG9Cb3goIEJPVU5ESU5HX0RBVEFfSU5ERVgoIG5vZGVJbmRleDMyICksIGZsb2F0MzJBcnJheSwgX2JveDEgKTtcblx0XHRyZXR1cm4gaW50ZXJzZWN0c1JhbmdlRnVuYyggb2Zmc2V0LCBjb3VudCwgZmFsc2UsIGRlcHRoLCBub2RlSW5kZXhCeXRlT2Zmc2V0ICsgbm9kZUluZGV4MzIsIF9ib3gxICk7XG5cblx0fSBlbHNlIHtcblxuXHRcdGNvbnN0IGxlZnQgPSBMRUZUX05PREUoIG5vZGVJbmRleDMyICk7XG5cdFx0Y29uc3QgcmlnaHQgPSBSSUdIVF9OT0RFKCBub2RlSW5kZXgzMiwgdWludDMyQXJyYXkgKTtcblx0XHRsZXQgYzEgPSBsZWZ0O1xuXHRcdGxldCBjMiA9IHJpZ2h0O1xuXG5cdFx0bGV0IHNjb3JlMSwgc2NvcmUyO1xuXHRcdGxldCBib3gxLCBib3gyO1xuXHRcdGlmICggbm9kZVNjb3JlRnVuYyApIHtcblxuXHRcdFx0Ym94MSA9IF9ib3gxO1xuXHRcdFx0Ym94MiA9IF9ib3gyO1xuXG5cdFx0XHQvLyBib3VuZGluZyBkYXRhIGlzIG5vdCBvZmZzZXRcblx0XHRcdGFycmF5VG9Cb3goIEJPVU5ESU5HX0RBVEFfSU5ERVgoIGMxICksIGZsb2F0MzJBcnJheSwgYm94MSApO1xuXHRcdFx0YXJyYXlUb0JveCggQk9VTkRJTkdfREFUQV9JTkRFWCggYzIgKSwgZmxvYXQzMkFycmF5LCBib3gyICk7XG5cblx0XHRcdHNjb3JlMSA9IG5vZGVTY29yZUZ1bmMoIGJveDEgKTtcblx0XHRcdHNjb3JlMiA9IG5vZGVTY29yZUZ1bmMoIGJveDIgKTtcblxuXHRcdFx0aWYgKCBzY29yZTIgPCBzY29yZTEgKSB7XG5cblx0XHRcdFx0YzEgPSByaWdodDtcblx0XHRcdFx0YzIgPSBsZWZ0O1xuXG5cdFx0XHRcdGNvbnN0IHRlbXAgPSBzY29yZTE7XG5cdFx0XHRcdHNjb3JlMSA9IHNjb3JlMjtcblx0XHRcdFx0c2NvcmUyID0gdGVtcDtcblxuXHRcdFx0XHRib3gxID0gYm94Mjtcblx0XHRcdFx0Ly8gYm94MiBpcyBhbHdheXMgc2V0IGJlZm9yZSB1c2UgYmVsb3dcblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gQ2hlY2sgYm94IDEgaW50ZXJzZWN0aW9uXG5cdFx0aWYgKCAhIGJveDEgKSB7XG5cblx0XHRcdGJveDEgPSBfYm94MTtcblx0XHRcdGFycmF5VG9Cb3goIEJPVU5ESU5HX0RBVEFfSU5ERVgoIGMxICksIGZsb2F0MzJBcnJheSwgYm94MSApO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgaXNDMUxlYWYgPSBJU19MRUFGKCBjMSAqIDIsIHVpbnQxNkFycmF5ICk7XG5cdFx0Y29uc3QgYzFJbnRlcnNlY3Rpb24gPSBpbnRlcnNlY3RzQm91bmRzRnVuYyggYm94MSwgaXNDMUxlYWYsIHNjb3JlMSwgZGVwdGggKyAxLCBub2RlSW5kZXhCeXRlT2Zmc2V0ICsgYzEgKTtcblxuXHRcdGxldCBjMVN0b3BUcmF2ZXJzYWw7XG5cdFx0aWYgKCBjMUludGVyc2VjdGlvbiA9PT0gQ09OVEFJTkVEICkge1xuXG5cdFx0XHRjb25zdCBvZmZzZXQgPSBnZXRMZWZ0T2Zmc2V0KCBjMSApO1xuXHRcdFx0Y29uc3QgZW5kID0gZ2V0UmlnaHRFbmRPZmZzZXQoIGMxICk7XG5cdFx0XHRjb25zdCBjb3VudCA9IGVuZCAtIG9mZnNldDtcblxuXHRcdFx0YzFTdG9wVHJhdmVyc2FsID0gaW50ZXJzZWN0c1JhbmdlRnVuYyggb2Zmc2V0LCBjb3VudCwgdHJ1ZSwgZGVwdGggKyAxLCBub2RlSW5kZXhCeXRlT2Zmc2V0ICsgYzEsIGJveDEgKTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGMxU3RvcFRyYXZlcnNhbCA9XG5cdFx0XHRcdGMxSW50ZXJzZWN0aW9uICYmXG5cdFx0XHRcdHNoYXBlY2FzdFRyYXZlcnNlKFxuXHRcdFx0XHRcdGMxLFxuXHRcdFx0XHRcdGdlb21ldHJ5LFxuXHRcdFx0XHRcdGludGVyc2VjdHNCb3VuZHNGdW5jLFxuXHRcdFx0XHRcdGludGVyc2VjdHNSYW5nZUZ1bmMsXG5cdFx0XHRcdFx0bm9kZVNjb3JlRnVuYyxcblx0XHRcdFx0XHRub2RlSW5kZXhCeXRlT2Zmc2V0LFxuXHRcdFx0XHRcdGRlcHRoICsgMVxuXHRcdFx0XHQpO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCBjMVN0b3BUcmF2ZXJzYWwgKSByZXR1cm4gdHJ1ZTtcblxuXHRcdC8vIENoZWNrIGJveCAyIGludGVyc2VjdGlvblxuXHRcdC8vIGNhY2hlZCBib3gyIHdpbGwgaGF2ZSBiZWVuIG92ZXJ3cml0dGVuIGJ5IHByZXZpb3VzIHRyYXZlcnNhbFxuXHRcdGJveDIgPSBfYm94Mjtcblx0XHRhcnJheVRvQm94KCBCT1VORElOR19EQVRBX0lOREVYKCBjMiApLCBmbG9hdDMyQXJyYXksIGJveDIgKTtcblxuXHRcdGNvbnN0IGlzQzJMZWFmID0gSVNfTEVBRiggYzIgKiAyLCB1aW50MTZBcnJheSApO1xuXHRcdGNvbnN0IGMySW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0c0JvdW5kc0Z1bmMoIGJveDIsIGlzQzJMZWFmLCBzY29yZTIsIGRlcHRoICsgMSwgbm9kZUluZGV4Qnl0ZU9mZnNldCArIGMyICk7XG5cblx0XHRsZXQgYzJTdG9wVHJhdmVyc2FsO1xuXHRcdGlmICggYzJJbnRlcnNlY3Rpb24gPT09IENPTlRBSU5FRCApIHtcblxuXHRcdFx0Y29uc3Qgb2Zmc2V0ID0gZ2V0TGVmdE9mZnNldCggYzIgKTtcblx0XHRcdGNvbnN0IGVuZCA9IGdldFJpZ2h0RW5kT2Zmc2V0KCBjMiApO1xuXHRcdFx0Y29uc3QgY291bnQgPSBlbmQgLSBvZmZzZXQ7XG5cblx0XHRcdGMyU3RvcFRyYXZlcnNhbCA9IGludGVyc2VjdHNSYW5nZUZ1bmMoIG9mZnNldCwgY291bnQsIHRydWUsIGRlcHRoICsgMSwgbm9kZUluZGV4Qnl0ZU9mZnNldCArIGMyLCBib3gyICk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRjMlN0b3BUcmF2ZXJzYWwgPVxuXHRcdFx0XHRjMkludGVyc2VjdGlvbiAmJlxuXHRcdFx0XHRzaGFwZWNhc3RUcmF2ZXJzZShcblx0XHRcdFx0XHRjMixcblx0XHRcdFx0XHRnZW9tZXRyeSxcblx0XHRcdFx0XHRpbnRlcnNlY3RzQm91bmRzRnVuYyxcblx0XHRcdFx0XHRpbnRlcnNlY3RzUmFuZ2VGdW5jLFxuXHRcdFx0XHRcdG5vZGVTY29yZUZ1bmMsXG5cdFx0XHRcdFx0bm9kZUluZGV4Qnl0ZU9mZnNldCxcblx0XHRcdFx0XHRkZXB0aCArIDFcblx0XHRcdFx0KTtcblxuXHRcdH1cblxuXHRcdGlmICggYzJTdG9wVHJhdmVyc2FsICkgcmV0dXJuIHRydWU7XG5cblx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHQvLyBEZWZpbmUgdGhlc2UgaW5zaWRlIHRoZSBmdW5jdGlvbiBzbyBpdCBoYXMgYWNjZXNzIHRvIHRoZSBsb2NhbCB2YXJpYWJsZXMgbmVlZGVkXG5cdFx0Ly8gd2hlbiBjb252ZXJ0aW5nIHRvIHRoZSBidWZmZXIgZXF1aXZhbGVudHNcblx0XHRmdW5jdGlvbiBnZXRMZWZ0T2Zmc2V0KCBub2RlSW5kZXgzMiApIHtcblxuXHRcdFx0Y29uc3QgeyB1aW50MTZBcnJheSwgdWludDMyQXJyYXkgfSA9IEJ1ZmZlclN0YWNrO1xuXHRcdFx0bGV0IG5vZGVJbmRleDE2ID0gbm9kZUluZGV4MzIgKiAyO1xuXG5cdFx0XHQvLyB0cmF2ZXJzZSB1bnRpbCB3ZSBmaW5kIGEgbGVhZlxuXHRcdFx0d2hpbGUgKCAhIElTX0xFQUYoIG5vZGVJbmRleDE2LCB1aW50MTZBcnJheSApICkge1xuXG5cdFx0XHRcdG5vZGVJbmRleDMyID0gTEVGVF9OT0RFKCBub2RlSW5kZXgzMiApO1xuXHRcdFx0XHRub2RlSW5kZXgxNiA9IG5vZGVJbmRleDMyICogMjtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gT0ZGU0VUKCBub2RlSW5kZXgzMiwgdWludDMyQXJyYXkgKTtcblxuXHRcdH1cblxuXHRcdGZ1bmN0aW9uIGdldFJpZ2h0RW5kT2Zmc2V0KCBub2RlSW5kZXgzMiApIHtcblxuXHRcdFx0Y29uc3QgeyB1aW50MTZBcnJheSwgdWludDMyQXJyYXkgfSA9IEJ1ZmZlclN0YWNrO1xuXHRcdFx0bGV0IG5vZGVJbmRleDE2ID0gbm9kZUluZGV4MzIgKiAyO1xuXG5cdFx0XHQvLyB0cmF2ZXJzZSB1bnRpbCB3ZSBmaW5kIGEgbGVhZlxuXHRcdFx0d2hpbGUgKCAhIElTX0xFQUYoIG5vZGVJbmRleDE2LCB1aW50MTZBcnJheSApICkge1xuXG5cdFx0XHRcdC8vIGFkanVzdCBvZmZzZXQgdG8gcG9pbnQgdG8gdGhlIHJpZ2h0IG5vZGVcblx0XHRcdFx0bm9kZUluZGV4MzIgPSBSSUdIVF9OT0RFKCBub2RlSW5kZXgzMiwgdWludDMyQXJyYXkgKTtcblx0XHRcdFx0bm9kZUluZGV4MTYgPSBub2RlSW5kZXgzMiAqIDI7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gcmV0dXJuIHRoZSBlbmQgb2Zmc2V0IG9mIHRoZSB0cmlhbmdsZSByYW5nZVxuXHRcdFx0cmV0dXJuIE9GRlNFVCggbm9kZUluZGV4MzIsIHVpbnQzMkFycmF5ICkgKyBDT1VOVCggbm9kZUluZGV4MTYsIHVpbnQxNkFycmF5ICk7XG5cblx0XHR9XG5cblx0fVxuXG59XG4iXSwibmFtZXMiOlsiQm94MyIsIkNPTlRBSU5FRCIsImFycmF5VG9Cb3giLCJQcmltaXRpdmVQb29sIiwiQ09VTlQiLCJPRkZTRVQiLCJMRUZUX05PREUiLCJSSUdIVF9OT0RFIiwiSVNfTEVBRiIsIkJPVU5ESU5HX0RBVEFfSU5ERVgiLCJCdWZmZXJTdGFjayIsIl9ib3gxIiwiX2JveDIiLCJib3hTdGFjayIsImJveFBvb2wiLCJzaGFwZWNhc3QiLCJidmgiLCJyb290IiwiaW50ZXJzZWN0c0JvdW5kcyIsImludGVyc2VjdHNSYW5nZSIsImJvdW5kc1RyYXZlcnNlT3JkZXIiLCJieXRlT2Zmc2V0IiwiZ2V0UHJpbWl0aXZlIiwicHVzaCIsInNldEJ1ZmZlciIsIl9yb290cyIsInJlc3VsdCIsInNoYXBlY2FzdFRyYXZlcnNlIiwiZ2VvbWV0cnkiLCJjbGVhckJ1ZmZlciIsInJlbGVhc2VQcmltaXRpdmUiLCJwb3AiLCJsZW5ndGgiLCJub2RlSW5kZXgzMiIsImludGVyc2VjdHNCb3VuZHNGdW5jIiwiaW50ZXJzZWN0c1JhbmdlRnVuYyIsIm5vZGVTY29yZUZ1bmMiLCJub2RlSW5kZXhCeXRlT2Zmc2V0IiwiZGVwdGgiLCJmbG9hdDMyQXJyYXkiLCJ1aW50MTZBcnJheSIsInVpbnQzMkFycmF5Iiwibm9kZUluZGV4MTYiLCJpc0xlYWYiLCJvZmZzZXQiLCJjb3VudCIsImxlZnQiLCJyaWdodCIsImMxIiwiYzIiLCJzY29yZTEiLCJzY29yZTIiLCJib3gxIiwiYm94MiIsInRlbXAiLCJpc0MxTGVhZiIsImMxSW50ZXJzZWN0aW9uIiwiYzFTdG9wVHJhdmVyc2FsIiwiZ2V0TGVmdE9mZnNldCIsImVuZCIsImdldFJpZ2h0RW5kT2Zmc2V0IiwiaXNDMkxlYWYiLCJjMkludGVyc2VjdGlvbiIsImMyU3RvcFRyYXZlcnNhbCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/cast/shapecast.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/utils/BufferStack.js":
/*!**************************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/utils/BufferStack.js ***!
  \**************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BufferStack: () => (/* binding */ BufferStack)\n/* harmony export */ });\nclass _BufferStack {\n    constructor(){\n        this.float32Array = null;\n        this.uint16Array = null;\n        this.uint32Array = null;\n        const stack = [];\n        let prevBuffer = null;\n        this.setBuffer = (buffer)=>{\n            if (prevBuffer) {\n                stack.push(prevBuffer);\n            }\n            prevBuffer = buffer;\n            this.float32Array = new Float32Array(buffer);\n            this.uint16Array = new Uint16Array(buffer);\n            this.uint32Array = new Uint32Array(buffer);\n        };\n        this.clearBuffer = ()=>{\n            prevBuffer = null;\n            this.float32Array = null;\n            this.uint16Array = null;\n            this.uint32Array = null;\n            if (stack.length !== 0) {\n                this.setBuffer(stack.pop());\n            }\n        };\n    }\n}\nconst BufferStack = new _BufferStack();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9jb3JlL3V0aWxzL0J1ZmZlclN0YWNrLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBQSxNQUFNQTtJQUVMQyxhQUFjO1FBRWIsSUFBSSxDQUFDQyxZQUFZLEdBQUc7UUFDcEIsSUFBSSxDQUFDQyxXQUFXLEdBQUc7UUFDbkIsSUFBSSxDQUFDQyxXQUFXLEdBQUc7UUFFbkIsTUFBTUMsUUFBUSxFQUFFO1FBQ2hCLElBQUlDLGFBQWE7UUFDakIsSUFBSSxDQUFDQyxTQUFTLEdBQUdDLENBQUFBO1lBRWhCLElBQUtGLFlBQWE7Z0JBRWpCRCxNQUFNSSxJQUFJLENBQUVIO1lBRWI7WUFFQUEsYUFBYUU7WUFDYixJQUFJLENBQUNOLFlBQVksR0FBRyxJQUFJUSxhQUFjRjtZQUN0QyxJQUFJLENBQUNMLFdBQVcsR0FBRyxJQUFJUSxZQUFhSDtZQUNwQyxJQUFJLENBQUNKLFdBQVcsR0FBRyxJQUFJUSxZQUFhSjtRQUVyQztRQUVBLElBQUksQ0FBQ0ssV0FBVyxHQUFHO1lBRWxCUCxhQUFhO1lBQ2IsSUFBSSxDQUFDSixZQUFZLEdBQUc7WUFDcEIsSUFBSSxDQUFDQyxXQUFXLEdBQUc7WUFDbkIsSUFBSSxDQUFDQyxXQUFXLEdBQUc7WUFFbkIsSUFBS0MsTUFBTVMsTUFBTSxLQUFLLEdBQUk7Z0JBRXpCLElBQUksQ0FBQ1AsU0FBUyxDQUFFRixNQUFNVSxHQUFHO1lBRTFCO1FBRUQ7SUFFRDtBQUVEO0FBRU8sTUFBTUMsY0FBYyxJQUFJaEIsZUFBZSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpYmUtM2QtY29kZS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9ub2RlX21vZHVsZXMvdGhyZWUtbWVzaC1idmgvc3JjL2NvcmUvdXRpbHMvQnVmZmVyU3RhY2suanM/NTFjYSJdLCJzb3VyY2VzQ29udGVudCI6WyJjbGFzcyBfQnVmZmVyU3RhY2sge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0dGhpcy5mbG9hdDMyQXJyYXkgPSBudWxsO1xuXHRcdHRoaXMudWludDE2QXJyYXkgPSBudWxsO1xuXHRcdHRoaXMudWludDMyQXJyYXkgPSBudWxsO1xuXG5cdFx0Y29uc3Qgc3RhY2sgPSBbXTtcblx0XHRsZXQgcHJldkJ1ZmZlciA9IG51bGw7XG5cdFx0dGhpcy5zZXRCdWZmZXIgPSBidWZmZXIgPT4ge1xuXG5cdFx0XHRpZiAoIHByZXZCdWZmZXIgKSB7XG5cblx0XHRcdFx0c3RhY2sucHVzaCggcHJldkJ1ZmZlciApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHByZXZCdWZmZXIgPSBidWZmZXI7XG5cdFx0XHR0aGlzLmZsb2F0MzJBcnJheSA9IG5ldyBGbG9hdDMyQXJyYXkoIGJ1ZmZlciApO1xuXHRcdFx0dGhpcy51aW50MTZBcnJheSA9IG5ldyBVaW50MTZBcnJheSggYnVmZmVyICk7XG5cdFx0XHR0aGlzLnVpbnQzMkFycmF5ID0gbmV3IFVpbnQzMkFycmF5KCBidWZmZXIgKTtcblxuXHRcdH07XG5cblx0XHR0aGlzLmNsZWFyQnVmZmVyID0gKCkgPT4ge1xuXG5cdFx0XHRwcmV2QnVmZmVyID0gbnVsbDtcblx0XHRcdHRoaXMuZmxvYXQzMkFycmF5ID0gbnVsbDtcblx0XHRcdHRoaXMudWludDE2QXJyYXkgPSBudWxsO1xuXHRcdFx0dGhpcy51aW50MzJBcnJheSA9IG51bGw7XG5cblx0XHRcdGlmICggc3RhY2subGVuZ3RoICE9PSAwICkge1xuXG5cdFx0XHRcdHRoaXMuc2V0QnVmZmVyKCBzdGFjay5wb3AoKSApO1xuXG5cdFx0XHR9XG5cblx0XHR9O1xuXG5cdH1cblxufVxuXG5leHBvcnQgY29uc3QgQnVmZmVyU3RhY2sgPSBuZXcgX0J1ZmZlclN0YWNrKCk7XG4iXSwibmFtZXMiOlsiX0J1ZmZlclN0YWNrIiwiY29uc3RydWN0b3IiLCJmbG9hdDMyQXJyYXkiLCJ1aW50MTZBcnJheSIsInVpbnQzMkFycmF5Iiwic3RhY2siLCJwcmV2QnVmZmVyIiwic2V0QnVmZmVyIiwiYnVmZmVyIiwicHVzaCIsIkZsb2F0MzJBcnJheSIsIlVpbnQxNkFycmF5IiwiVWludDMyQXJyYXkiLCJjbGVhckJ1ZmZlciIsImxlbmd0aCIsInBvcCIsIkJ1ZmZlclN0YWNrIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/utils/BufferStack.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/utils/intersectUtils.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/utils/intersectUtils.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   intersectRay: () => (/* binding */ intersectRay)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var _utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/ArrayBoxUtilities.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js\");\n\n\nconst _boundingBox = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Box3();\nfunction intersectRay(nodeIndex32, array, ray, target) {\n    (0,_utils_ArrayBoxUtilities_js__WEBPACK_IMPORTED_MODULE_1__.arrayToBox)(nodeIndex32, array, _boundingBox);\n    return ray.intersectBox(_boundingBox, target);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9jb3JlL3V0aWxzL2ludGVyc2VjdFV0aWxzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUE2QjtBQUNpQztBQUU5RCxNQUFNRSxlQUFlLGFBQWEsR0FBRyxJQUFJRix1Q0FBSUE7QUFDdEMsU0FBU0csYUFBY0MsV0FBVyxFQUFFQyxLQUFLLEVBQUVDLEdBQUcsRUFBRUMsTUFBTTtJQUU1RE4sdUVBQVVBLENBQUVHLGFBQWFDLE9BQU9IO0lBQ2hDLE9BQU9JLElBQUlFLFlBQVksQ0FBRU4sY0FBY0s7QUFFeEMiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aWJlLTNkLWNvZGUvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9jb3JlL3V0aWxzL2ludGVyc2VjdFV0aWxzLmpzP2Q1ZjYiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgQm94MyB9IGZyb20gJ3RocmVlJztcbmltcG9ydCB7IGFycmF5VG9Cb3ggfSBmcm9tICcuLi8uLi91dGlscy9BcnJheUJveFV0aWxpdGllcy5qcyc7XG5cbmNvbnN0IF9ib3VuZGluZ0JveCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgQm94MygpO1xuZXhwb3J0IGZ1bmN0aW9uIGludGVyc2VjdFJheSggbm9kZUluZGV4MzIsIGFycmF5LCByYXksIHRhcmdldCApIHtcblxuXHRhcnJheVRvQm94KCBub2RlSW5kZXgzMiwgYXJyYXksIF9ib3VuZGluZ0JveCApO1xuXHRyZXR1cm4gcmF5LmludGVyc2VjdEJveCggX2JvdW5kaW5nQm94LCB0YXJnZXQgKTtcblxufVxuIl0sIm5hbWVzIjpbIkJveDMiLCJhcnJheVRvQm94IiwiX2JvdW5kaW5nQm94IiwiaW50ZXJzZWN0UmF5Iiwibm9kZUluZGV4MzIiLCJhcnJheSIsInJheSIsInRhcmdldCIsImludGVyc2VjdEJveCJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/utils/intersectUtils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/utils/iterationUtils.generated.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/utils/iterationUtils.generated.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   intersectClosestTri: () => (/* binding */ intersectClosestTri),\n/* harmony export */   intersectTris: () => (/* binding */ intersectTris),\n/* harmony export */   iterateOverTriangles: () => (/* binding */ iterateOverTriangles)\n/* harmony export */ });\n/* harmony import */ var _utils_ThreeRayIntersectUtilities_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/ThreeRayIntersectUtilities.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/ThreeRayIntersectUtilities.js\");\n/* harmony import */ var _utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/TriangleUtilities.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js\");\n\n\n/*************************************************************/ /* This file is generated from \"iterationUtils.template.js\". */ /*************************************************************/ /* eslint-disable indent */ function intersectTris(bvh, side, ray, offset, count, intersections) {\n    const { geometry, _indirectBuffer } = bvh;\n    for(let i = offset, end = offset + count; i < end; i++){\n        (0,_utils_ThreeRayIntersectUtilities_js__WEBPACK_IMPORTED_MODULE_0__.intersectTri)(geometry, side, ray, i, intersections);\n    }\n}\nfunction intersectClosestTri(bvh, side, ray, offset, count) {\n    const { geometry, _indirectBuffer } = bvh;\n    let dist = Infinity;\n    let res = null;\n    for(let i = offset, end = offset + count; i < end; i++){\n        let intersection;\n        intersection = (0,_utils_ThreeRayIntersectUtilities_js__WEBPACK_IMPORTED_MODULE_0__.intersectTri)(geometry, side, ray, i);\n        if (intersection && intersection.distance < dist) {\n            res = intersection;\n            dist = intersection.distance;\n        }\n    }\n    return res;\n}\nfunction iterateOverTriangles(offset, count, bvh, intersectsTriangleFunc, contained, depth, triangle) {\n    const { geometry } = bvh;\n    const { index } = geometry;\n    const pos = geometry.attributes.position;\n    for(let i = offset, l = count + offset; i < l; i++){\n        let tri;\n        tri = i;\n        (0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_1__.setTriangle)(triangle, tri * 3, index, pos);\n        triangle.needsUpdate = true;\n        if (intersectsTriangleFunc(triangle, tri, contained, depth)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9jb3JlL3V0aWxzL2l0ZXJhdGlvblV0aWxzLmdlbmVyYXRlZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUF5RTtBQUNWO0FBRS9ELDZEQUE2RCxHQUM3RCw2REFBNkQsR0FDN0QsNkRBQTZELEdBQzdELHlCQUF5QixHQUV6QixTQUFTRSxjQUFlQyxHQUFHLEVBQUVDLElBQUksRUFBRUMsR0FBRyxFQUFFQyxNQUFNLEVBQUVDLEtBQUssRUFBRUMsYUFBYTtJQUVuRSxNQUFNLEVBQUVDLFFBQVEsRUFBRUMsZUFBZSxFQUFFLEdBQUdQO0lBQ3RDLElBQU0sSUFBSVEsSUFBSUwsUUFBUU0sTUFBTU4sU0FBU0MsT0FBT0ksSUFBSUMsS0FBS0QsSUFBTztRQUczRFgsa0ZBQVlBLENBQUVTLFVBQVVMLE1BQU1DLEtBQUtNLEdBQUdIO0lBR3ZDO0FBRUQ7QUFFQSxTQUFTSyxvQkFBcUJWLEdBQUcsRUFBRUMsSUFBSSxFQUFFQyxHQUFHLEVBQUVDLE1BQU0sRUFBRUMsS0FBSztJQUUxRCxNQUFNLEVBQUVFLFFBQVEsRUFBRUMsZUFBZSxFQUFFLEdBQUdQO0lBQ3RDLElBQUlXLE9BQU9DO0lBQ1gsSUFBSUMsTUFBTTtJQUNWLElBQU0sSUFBSUwsSUFBSUwsUUFBUU0sTUFBTU4sU0FBU0MsT0FBT0ksSUFBSUMsS0FBS0QsSUFBTztRQUUzRCxJQUFJTTtRQUVKQSxlQUFlakIsa0ZBQVlBLENBQUVTLFVBQVVMLE1BQU1DLEtBQUtNO1FBR2xELElBQUtNLGdCQUFnQkEsYUFBYUMsUUFBUSxHQUFHSixNQUFPO1lBRW5ERSxNQUFNQztZQUNOSCxPQUFPRyxhQUFhQyxRQUFRO1FBRTdCO0lBRUQ7SUFFQSxPQUFPRjtBQUVSO0FBRUEsU0FBU0cscUJBQ1JiLE1BQU0sRUFDTkMsS0FBSyxFQUNMSixHQUFHLEVBQ0hpQixzQkFBc0IsRUFDdEJDLFNBQVMsRUFDVEMsS0FBSyxFQUNMQyxRQUFRO0lBR1IsTUFBTSxFQUFFZCxRQUFRLEVBQUUsR0FBR047SUFDckIsTUFBTSxFQUFFcUIsS0FBSyxFQUFFLEdBQUdmO0lBQ2xCLE1BQU1nQixNQUFNaEIsU0FBU2lCLFVBQVUsQ0FBQ0MsUUFBUTtJQUN4QyxJQUFNLElBQUloQixJQUFJTCxRQUFRc0IsSUFBSXJCLFFBQVFELFFBQVFLLElBQUlpQixHQUFHakIsSUFBTztRQUV2RCxJQUFJa0I7UUFFSkEsTUFBTWxCO1FBRU5WLHdFQUFXQSxDQUFFc0IsVUFBVU0sTUFBTSxHQUFHTCxPQUFPQztRQUN2Q0YsU0FBU08sV0FBVyxHQUFHO1FBRXZCLElBQUtWLHVCQUF3QkcsVUFBVU0sS0FBS1IsV0FBV0MsUUFBVTtZQUVoRSxPQUFPO1FBRVI7SUFFRDtJQUVBLE9BQU87QUFFUjtBQUVvRSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpYmUtM2QtY29kZS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9ub2RlX21vZHVsZXMvdGhyZWUtbWVzaC1idmgvc3JjL2NvcmUvdXRpbHMvaXRlcmF0aW9uVXRpbHMuZ2VuZXJhdGVkLmpzPzQ3ZjciXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgaW50ZXJzZWN0VHJpIH0gZnJvbSAnLi4vLi4vdXRpbHMvVGhyZWVSYXlJbnRlcnNlY3RVdGlsaXRpZXMuanMnO1xuaW1wb3J0IHsgc2V0VHJpYW5nbGUgfSBmcm9tICcuLi8uLi91dGlscy9UcmlhbmdsZVV0aWxpdGllcy5qcyc7XG5cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogVGhpcyBmaWxlIGlzIGdlbmVyYXRlZCBmcm9tIFwiaXRlcmF0aW9uVXRpbHMudGVtcGxhdGUuanNcIi4gKi9cbi8qKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqL1xuLyogZXNsaW50LWRpc2FibGUgaW5kZW50ICovXG5cbmZ1bmN0aW9uIGludGVyc2VjdFRyaXMoIGJ2aCwgc2lkZSwgcmF5LCBvZmZzZXQsIGNvdW50LCBpbnRlcnNlY3Rpb25zICkge1xuXG5cdGNvbnN0IHsgZ2VvbWV0cnksIF9pbmRpcmVjdEJ1ZmZlciB9ID0gYnZoO1xuXHRmb3IgKCBsZXQgaSA9IG9mZnNldCwgZW5kID0gb2Zmc2V0ICsgY291bnQ7IGkgPCBlbmQ7IGkgKysgKSB7XG5cblxuXHRcdGludGVyc2VjdFRyaSggZ2VvbWV0cnksIHNpZGUsIHJheSwgaSwgaW50ZXJzZWN0aW9ucyApO1xuXG5cblx0fVxuXG59XG5cbmZ1bmN0aW9uIGludGVyc2VjdENsb3Nlc3RUcmkoIGJ2aCwgc2lkZSwgcmF5LCBvZmZzZXQsIGNvdW50ICkge1xuXG5cdGNvbnN0IHsgZ2VvbWV0cnksIF9pbmRpcmVjdEJ1ZmZlciB9ID0gYnZoO1xuXHRsZXQgZGlzdCA9IEluZmluaXR5O1xuXHRsZXQgcmVzID0gbnVsbDtcblx0Zm9yICggbGV0IGkgPSBvZmZzZXQsIGVuZCA9IG9mZnNldCArIGNvdW50OyBpIDwgZW5kOyBpICsrICkge1xuXG5cdFx0bGV0IGludGVyc2VjdGlvbjtcblxuXHRcdGludGVyc2VjdGlvbiA9IGludGVyc2VjdFRyaSggZ2VvbWV0cnksIHNpZGUsIHJheSwgaSApO1xuXG5cblx0XHRpZiAoIGludGVyc2VjdGlvbiAmJiBpbnRlcnNlY3Rpb24uZGlzdGFuY2UgPCBkaXN0ICkge1xuXG5cdFx0XHRyZXMgPSBpbnRlcnNlY3Rpb247XG5cdFx0XHRkaXN0ID0gaW50ZXJzZWN0aW9uLmRpc3RhbmNlO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRyZXR1cm4gcmVzO1xuXG59XG5cbmZ1bmN0aW9uIGl0ZXJhdGVPdmVyVHJpYW5nbGVzKFxuXHRvZmZzZXQsXG5cdGNvdW50LFxuXHRidmgsXG5cdGludGVyc2VjdHNUcmlhbmdsZUZ1bmMsXG5cdGNvbnRhaW5lZCxcblx0ZGVwdGgsXG5cdHRyaWFuZ2xlXG4pIHtcblxuXHRjb25zdCB7IGdlb21ldHJ5IH0gPSBidmg7XG5cdGNvbnN0IHsgaW5kZXggfSA9IGdlb21ldHJ5O1xuXHRjb25zdCBwb3MgPSBnZW9tZXRyeS5hdHRyaWJ1dGVzLnBvc2l0aW9uO1xuXHRmb3IgKCBsZXQgaSA9IG9mZnNldCwgbCA9IGNvdW50ICsgb2Zmc2V0OyBpIDwgbDsgaSArKyApIHtcblxuXHRcdGxldCB0cmk7XG5cblx0XHR0cmkgPSBpO1xuXG5cdFx0c2V0VHJpYW5nbGUoIHRyaWFuZ2xlLCB0cmkgKiAzLCBpbmRleCwgcG9zICk7XG5cdFx0dHJpYW5nbGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0aWYgKCBpbnRlcnNlY3RzVHJpYW5nbGVGdW5jKCB0cmlhbmdsZSwgdHJpLCBjb250YWluZWQsIGRlcHRoICkgKSB7XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7XG5cbn1cblxuZXhwb3J0IHsgaW50ZXJzZWN0Q2xvc2VzdFRyaSwgaW50ZXJzZWN0VHJpcywgaXRlcmF0ZU92ZXJUcmlhbmdsZXMgfTtcbiJdLCJuYW1lcyI6WyJpbnRlcnNlY3RUcmkiLCJzZXRUcmlhbmdsZSIsImludGVyc2VjdFRyaXMiLCJidmgiLCJzaWRlIiwicmF5Iiwib2Zmc2V0IiwiY291bnQiLCJpbnRlcnNlY3Rpb25zIiwiZ2VvbWV0cnkiLCJfaW5kaXJlY3RCdWZmZXIiLCJpIiwiZW5kIiwiaW50ZXJzZWN0Q2xvc2VzdFRyaSIsImRpc3QiLCJJbmZpbml0eSIsInJlcyIsImludGVyc2VjdGlvbiIsImRpc3RhbmNlIiwiaXRlcmF0ZU92ZXJUcmlhbmdsZXMiLCJpbnRlcnNlY3RzVHJpYW5nbGVGdW5jIiwiY29udGFpbmVkIiwiZGVwdGgiLCJ0cmlhbmdsZSIsImluZGV4IiwicG9zIiwiYXR0cmlidXRlcyIsInBvc2l0aW9uIiwibCIsInRyaSIsIm5lZWRzVXBkYXRlIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/utils/iterationUtils.generated.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/utils/iterationUtils_indirect.generated.js":
/*!************************************************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/utils/iterationUtils_indirect.generated.js ***!
  \************************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   intersectClosestTri_indirect: () => (/* binding */ intersectClosestTri_indirect),\n/* harmony export */   intersectTris_indirect: () => (/* binding */ intersectTris_indirect),\n/* harmony export */   iterateOverTriangles_indirect: () => (/* binding */ iterateOverTriangles_indirect)\n/* harmony export */ });\n/* harmony import */ var _utils_ThreeRayIntersectUtilities_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ../../utils/ThreeRayIntersectUtilities.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/ThreeRayIntersectUtilities.js\");\n/* harmony import */ var _utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../../utils/TriangleUtilities.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js\");\n\n\n/*************************************************************/ /* This file is generated from \"iterationUtils.template.js\". */ /*************************************************************/ /* eslint-disable indent */ function intersectTris_indirect(bvh, side, ray, offset, count, intersections) {\n    const { geometry, _indirectBuffer } = bvh;\n    for(let i = offset, end = offset + count; i < end; i++){\n        let vi = _indirectBuffer ? _indirectBuffer[i] : i;\n        (0,_utils_ThreeRayIntersectUtilities_js__WEBPACK_IMPORTED_MODULE_0__.intersectTri)(geometry, side, ray, vi, intersections);\n    }\n}\nfunction intersectClosestTri_indirect(bvh, side, ray, offset, count) {\n    const { geometry, _indirectBuffer } = bvh;\n    let dist = Infinity;\n    let res = null;\n    for(let i = offset, end = offset + count; i < end; i++){\n        let intersection;\n        intersection = (0,_utils_ThreeRayIntersectUtilities_js__WEBPACK_IMPORTED_MODULE_0__.intersectTri)(geometry, side, ray, _indirectBuffer ? _indirectBuffer[i] : i);\n        if (intersection && intersection.distance < dist) {\n            res = intersection;\n            dist = intersection.distance;\n        }\n    }\n    return res;\n}\nfunction iterateOverTriangles_indirect(offset, count, bvh, intersectsTriangleFunc, contained, depth, triangle) {\n    const { geometry } = bvh;\n    const { index } = geometry;\n    const pos = geometry.attributes.position;\n    for(let i = offset, l = count + offset; i < l; i++){\n        let tri;\n        tri = bvh.resolveTriangleIndex(i);\n        (0,_utils_TriangleUtilities_js__WEBPACK_IMPORTED_MODULE_1__.setTriangle)(triangle, tri * 3, index, pos);\n        triangle.needsUpdate = true;\n        if (intersectsTriangleFunc(triangle, tri, contained, depth)) {\n            return true;\n        }\n    }\n    return false;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9jb3JlL3V0aWxzL2l0ZXJhdGlvblV0aWxzX2luZGlyZWN0LmdlbmVyYXRlZC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7OztBQUF5RTtBQUNWO0FBRS9ELDZEQUE2RCxHQUM3RCw2REFBNkQsR0FDN0QsNkRBQTZELEdBQzdELHlCQUF5QixHQUV6QixTQUFTRSx1QkFBd0JDLEdBQUcsRUFBRUMsSUFBSSxFQUFFQyxHQUFHLEVBQUVDLE1BQU0sRUFBRUMsS0FBSyxFQUFFQyxhQUFhO0lBRTVFLE1BQU0sRUFBRUMsUUFBUSxFQUFFQyxlQUFlLEVBQUUsR0FBR1A7SUFDdEMsSUFBTSxJQUFJUSxJQUFJTCxRQUFRTSxNQUFNTixTQUFTQyxPQUFPSSxJQUFJQyxLQUFLRCxJQUFPO1FBRTNELElBQUlFLEtBQUtILGtCQUFrQkEsZUFBZSxDQUFFQyxFQUFHLEdBQUdBO1FBQ2xEWCxrRkFBWUEsQ0FBRVMsVUFBVUwsTUFBTUMsS0FBS1EsSUFBSUw7SUFHeEM7QUFFRDtBQUVBLFNBQVNNLDZCQUE4QlgsR0FBRyxFQUFFQyxJQUFJLEVBQUVDLEdBQUcsRUFBRUMsTUFBTSxFQUFFQyxLQUFLO0lBRW5FLE1BQU0sRUFBRUUsUUFBUSxFQUFFQyxlQUFlLEVBQUUsR0FBR1A7SUFDdEMsSUFBSVksT0FBT0M7SUFDWCxJQUFJQyxNQUFNO0lBQ1YsSUFBTSxJQUFJTixJQUFJTCxRQUFRTSxNQUFNTixTQUFTQyxPQUFPSSxJQUFJQyxLQUFLRCxJQUFPO1FBRTNELElBQUlPO1FBQ0pBLGVBQWVsQixrRkFBWUEsQ0FBRVMsVUFBVUwsTUFBTUMsS0FBS0ssa0JBQWtCQSxlQUFlLENBQUVDLEVBQUcsR0FBR0E7UUFHM0YsSUFBS08sZ0JBQWdCQSxhQUFhQyxRQUFRLEdBQUdKLE1BQU87WUFFbkRFLE1BQU1DO1lBQ05ILE9BQU9HLGFBQWFDLFFBQVE7UUFFN0I7SUFFRDtJQUVBLE9BQU9GO0FBRVI7QUFFQSxTQUFTRyw4QkFDUmQsTUFBTSxFQUNOQyxLQUFLLEVBQ0xKLEdBQUcsRUFDSGtCLHNCQUFzQixFQUN0QkMsU0FBUyxFQUNUQyxLQUFLLEVBQ0xDLFFBQVE7SUFHUixNQUFNLEVBQUVmLFFBQVEsRUFBRSxHQUFHTjtJQUNyQixNQUFNLEVBQUVzQixLQUFLLEVBQUUsR0FBR2hCO0lBQ2xCLE1BQU1pQixNQUFNakIsU0FBU2tCLFVBQVUsQ0FBQ0MsUUFBUTtJQUN4QyxJQUFNLElBQUlqQixJQUFJTCxRQUFRdUIsSUFBSXRCLFFBQVFELFFBQVFLLElBQUlrQixHQUFHbEIsSUFBTztRQUV2RCxJQUFJbUI7UUFDSkEsTUFBTTNCLElBQUk0QixvQkFBb0IsQ0FBRXBCO1FBRWhDVix3RUFBV0EsQ0FBRXVCLFVBQVVNLE1BQU0sR0FBR0wsT0FBT0M7UUFDdkNGLFNBQVNRLFdBQVcsR0FBRztRQUV2QixJQUFLWCx1QkFBd0JHLFVBQVVNLEtBQUtSLFdBQVdDLFFBQVU7WUFFaEUsT0FBTztRQUVSO0lBRUQ7SUFFQSxPQUFPO0FBRVI7QUFFK0YiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aWJlLTNkLWNvZGUvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9jb3JlL3V0aWxzL2l0ZXJhdGlvblV0aWxzX2luZGlyZWN0LmdlbmVyYXRlZC5qcz85NDY4Il0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IGludGVyc2VjdFRyaSB9IGZyb20gJy4uLy4uL3V0aWxzL1RocmVlUmF5SW50ZXJzZWN0VXRpbGl0aWVzLmpzJztcbmltcG9ydCB7IHNldFRyaWFuZ2xlIH0gZnJvbSAnLi4vLi4vdXRpbHMvVHJpYW5nbGVVdGlsaXRpZXMuanMnO1xuXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qIFRoaXMgZmlsZSBpcyBnZW5lcmF0ZWQgZnJvbSBcIml0ZXJhdGlvblV0aWxzLnRlbXBsYXRlLmpzXCIuICovXG4vKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKioqKi9cbi8qIGVzbGludC1kaXNhYmxlIGluZGVudCAqL1xuXG5mdW5jdGlvbiBpbnRlcnNlY3RUcmlzX2luZGlyZWN0KCBidmgsIHNpZGUsIHJheSwgb2Zmc2V0LCBjb3VudCwgaW50ZXJzZWN0aW9ucyApIHtcblxuXHRjb25zdCB7IGdlb21ldHJ5LCBfaW5kaXJlY3RCdWZmZXIgfSA9IGJ2aDtcblx0Zm9yICggbGV0IGkgPSBvZmZzZXQsIGVuZCA9IG9mZnNldCArIGNvdW50OyBpIDwgZW5kOyBpICsrICkge1xuXG5cdFx0bGV0IHZpID0gX2luZGlyZWN0QnVmZmVyID8gX2luZGlyZWN0QnVmZmVyWyBpIF0gOiBpO1xuXHRcdGludGVyc2VjdFRyaSggZ2VvbWV0cnksIHNpZGUsIHJheSwgdmksIGludGVyc2VjdGlvbnMgKTtcblxuXG5cdH1cblxufVxuXG5mdW5jdGlvbiBpbnRlcnNlY3RDbG9zZXN0VHJpX2luZGlyZWN0KCBidmgsIHNpZGUsIHJheSwgb2Zmc2V0LCBjb3VudCApIHtcblxuXHRjb25zdCB7IGdlb21ldHJ5LCBfaW5kaXJlY3RCdWZmZXIgfSA9IGJ2aDtcblx0bGV0IGRpc3QgPSBJbmZpbml0eTtcblx0bGV0IHJlcyA9IG51bGw7XG5cdGZvciAoIGxldCBpID0gb2Zmc2V0LCBlbmQgPSBvZmZzZXQgKyBjb3VudDsgaSA8IGVuZDsgaSArKyApIHtcblxuXHRcdGxldCBpbnRlcnNlY3Rpb247XG5cdFx0aW50ZXJzZWN0aW9uID0gaW50ZXJzZWN0VHJpKCBnZW9tZXRyeSwgc2lkZSwgcmF5LCBfaW5kaXJlY3RCdWZmZXIgPyBfaW5kaXJlY3RCdWZmZXJbIGkgXSA6IGkgKTtcblxuXG5cdFx0aWYgKCBpbnRlcnNlY3Rpb24gJiYgaW50ZXJzZWN0aW9uLmRpc3RhbmNlIDwgZGlzdCApIHtcblxuXHRcdFx0cmVzID0gaW50ZXJzZWN0aW9uO1xuXHRcdFx0ZGlzdCA9IGludGVyc2VjdGlvbi5kaXN0YW5jZTtcblxuXHRcdH1cblxuXHR9XG5cblx0cmV0dXJuIHJlcztcblxufVxuXG5mdW5jdGlvbiBpdGVyYXRlT3ZlclRyaWFuZ2xlc19pbmRpcmVjdChcblx0b2Zmc2V0LFxuXHRjb3VudCxcblx0YnZoLFxuXHRpbnRlcnNlY3RzVHJpYW5nbGVGdW5jLFxuXHRjb250YWluZWQsXG5cdGRlcHRoLFxuXHR0cmlhbmdsZVxuKSB7XG5cblx0Y29uc3QgeyBnZW9tZXRyeSB9ID0gYnZoO1xuXHRjb25zdCB7IGluZGV4IH0gPSBnZW9tZXRyeTtcblx0Y29uc3QgcG9zID0gZ2VvbWV0cnkuYXR0cmlidXRlcy5wb3NpdGlvbjtcblx0Zm9yICggbGV0IGkgPSBvZmZzZXQsIGwgPSBjb3VudCArIG9mZnNldDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRsZXQgdHJpO1xuXHRcdHRyaSA9IGJ2aC5yZXNvbHZlVHJpYW5nbGVJbmRleCggaSApO1xuXG5cdFx0c2V0VHJpYW5nbGUoIHRyaWFuZ2xlLCB0cmkgKiAzLCBpbmRleCwgcG9zICk7XG5cdFx0dHJpYW5nbGUubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdFx0aWYgKCBpbnRlcnNlY3RzVHJpYW5nbGVGdW5jKCB0cmlhbmdsZSwgdHJpLCBjb250YWluZWQsIGRlcHRoICkgKSB7XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0fVxuXG5cdH1cblxuXHRyZXR1cm4gZmFsc2U7XG5cbn1cblxuZXhwb3J0IHsgaW50ZXJzZWN0Q2xvc2VzdFRyaV9pbmRpcmVjdCwgaW50ZXJzZWN0VHJpc19pbmRpcmVjdCwgaXRlcmF0ZU92ZXJUcmlhbmdsZXNfaW5kaXJlY3QgfTtcbiJdLCJuYW1lcyI6WyJpbnRlcnNlY3RUcmkiLCJzZXRUcmlhbmdsZSIsImludGVyc2VjdFRyaXNfaW5kaXJlY3QiLCJidmgiLCJzaWRlIiwicmF5Iiwib2Zmc2V0IiwiY291bnQiLCJpbnRlcnNlY3Rpb25zIiwiZ2VvbWV0cnkiLCJfaW5kaXJlY3RCdWZmZXIiLCJpIiwiZW5kIiwidmkiLCJpbnRlcnNlY3RDbG9zZXN0VHJpX2luZGlyZWN0IiwiZGlzdCIsIkluZmluaXR5IiwicmVzIiwiaW50ZXJzZWN0aW9uIiwiZGlzdGFuY2UiLCJpdGVyYXRlT3ZlclRyaWFuZ2xlc19pbmRpcmVjdCIsImludGVyc2VjdHNUcmlhbmdsZUZ1bmMiLCJjb250YWluZWQiLCJkZXB0aCIsInRyaWFuZ2xlIiwiaW5kZXgiLCJwb3MiLCJhdHRyaWJ1dGVzIiwicG9zaXRpb24iLCJsIiwidHJpIiwicmVzb2x2ZVRyaWFuZ2xlSW5kZXgiLCJuZWVkc1VwZGF0ZSJdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/utils/iterationUtils_indirect.generated.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/utils/nodeBufferUtils.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/utils/nodeBufferUtils.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   BOUNDING_DATA_INDEX: () => (/* binding */ BOUNDING_DATA_INDEX),\n/* harmony export */   COUNT: () => (/* binding */ COUNT),\n/* harmony export */   IS_LEAF: () => (/* binding */ IS_LEAF),\n/* harmony export */   LEFT_NODE: () => (/* binding */ LEFT_NODE),\n/* harmony export */   OFFSET: () => (/* binding */ OFFSET),\n/* harmony export */   RIGHT_NODE: () => (/* binding */ RIGHT_NODE),\n/* harmony export */   SPLIT_AXIS: () => (/* binding */ SPLIT_AXIS)\n/* harmony export */ });\nfunction IS_LEAF(n16, uint16Array) {\n    return uint16Array[n16 + 15] === 0xFFFF;\n}\nfunction OFFSET(n32, uint32Array) {\n    return uint32Array[n32 + 6];\n}\nfunction COUNT(n16, uint16Array) {\n    return uint16Array[n16 + 14];\n}\nfunction LEFT_NODE(n32) {\n    return n32 + 8;\n}\nfunction RIGHT_NODE(n32, uint32Array) {\n    return uint32Array[n32 + 6];\n}\nfunction SPLIT_AXIS(n32, uint32Array) {\n    return uint32Array[n32 + 7];\n}\nfunction BOUNDING_DATA_INDEX(n32) {\n    return n32;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9jb3JlL3V0aWxzL25vZGVCdWZmZXJVdGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQU8sU0FBU0EsUUFBU0MsR0FBRyxFQUFFQyxXQUFXO0lBRXhDLE9BQU9BLFdBQVcsQ0FBRUQsTUFBTSxHQUFJLEtBQUs7QUFFcEM7QUFFTyxTQUFTRSxPQUFRQyxHQUFHLEVBQUVDLFdBQVc7SUFFdkMsT0FBT0EsV0FBVyxDQUFFRCxNQUFNLEVBQUc7QUFFOUI7QUFFTyxTQUFTRSxNQUFPTCxHQUFHLEVBQUVDLFdBQVc7SUFFdEMsT0FBT0EsV0FBVyxDQUFFRCxNQUFNLEdBQUk7QUFFL0I7QUFFTyxTQUFTTSxVQUFXSCxHQUFHO0lBRTdCLE9BQU9BLE1BQU07QUFFZDtBQUVPLFNBQVNJLFdBQVlKLEdBQUcsRUFBRUMsV0FBVztJQUUzQyxPQUFPQSxXQUFXLENBQUVELE1BQU0sRUFBRztBQUU5QjtBQUVPLFNBQVNLLFdBQVlMLEdBQUcsRUFBRUMsV0FBVztJQUUzQyxPQUFPQSxXQUFXLENBQUVELE1BQU0sRUFBRztBQUU5QjtBQUVPLFNBQVNNLG9CQUFxQk4sR0FBRztJQUV2QyxPQUFPQTtBQUVSIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmliZS0zZC1jb2RlLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvY29yZS91dGlscy9ub2RlQnVmZmVyVXRpbHMuanM/ZmUxNyJdLCJzb3VyY2VzQ29udGVudCI6WyJleHBvcnQgZnVuY3Rpb24gSVNfTEVBRiggbjE2LCB1aW50MTZBcnJheSApIHtcblxuXHRyZXR1cm4gdWludDE2QXJyYXlbIG4xNiArIDE1IF0gPT09IDB4RkZGRjtcblxufVxuXG5leHBvcnQgZnVuY3Rpb24gT0ZGU0VUKCBuMzIsIHVpbnQzMkFycmF5ICkge1xuXG5cdHJldHVybiB1aW50MzJBcnJheVsgbjMyICsgNiBdO1xuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBDT1VOVCggbjE2LCB1aW50MTZBcnJheSApIHtcblxuXHRyZXR1cm4gdWludDE2QXJyYXlbIG4xNiArIDE0IF07XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIExFRlRfTk9ERSggbjMyICkge1xuXG5cdHJldHVybiBuMzIgKyA4O1xuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBSSUdIVF9OT0RFKCBuMzIsIHVpbnQzMkFycmF5ICkge1xuXG5cdHJldHVybiB1aW50MzJBcnJheVsgbjMyICsgNiBdO1xuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBTUExJVF9BWElTKCBuMzIsIHVpbnQzMkFycmF5ICkge1xuXG5cdHJldHVybiB1aW50MzJBcnJheVsgbjMyICsgNyBdO1xuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBCT1VORElOR19EQVRBX0lOREVYKCBuMzIgKSB7XG5cblx0cmV0dXJuIG4zMjtcblxufVxuIl0sIm5hbWVzIjpbIklTX0xFQUYiLCJuMTYiLCJ1aW50MTZBcnJheSIsIk9GRlNFVCIsIm4zMiIsInVpbnQzMkFycmF5IiwiQ09VTlQiLCJMRUZUX05PREUiLCJSSUdIVF9OT0RFIiwiU1BMSVRfQVhJUyIsIkJPVU5ESU5HX0RBVEFfSU5ERVgiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/utils/nodeBufferUtils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/math/ExtendedTriangle.js":
/*!*************************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/math/ExtendedTriangle.js ***!
  \*************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ExtendedTriangle: () => (/* binding */ ExtendedTriangle)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var _SeparatingAxisBounds_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SeparatingAxisBounds.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/math/SeparatingAxisBounds.js\");\n/* harmony import */ var _MathUtilities_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./MathUtilities.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/math/MathUtilities.js\");\n\n\n\nconst ZERO_EPSILON = 1e-15;\nfunction isNearZero(value) {\n    return Math.abs(value) < ZERO_EPSILON;\n}\nclass ExtendedTriangle extends three__WEBPACK_IMPORTED_MODULE_0__.Triangle {\n    constructor(...args){\n        super(...args);\n        this.isExtendedTriangle = true;\n        this.satAxes = new Array(4).fill().map(()=>new three__WEBPACK_IMPORTED_MODULE_0__.Vector3());\n        this.satBounds = new Array(4).fill().map(()=>new _SeparatingAxisBounds_js__WEBPACK_IMPORTED_MODULE_1__.SeparatingAxisBounds());\n        this.points = [\n            this.a,\n            this.b,\n            this.c\n        ];\n        this.sphere = new three__WEBPACK_IMPORTED_MODULE_0__.Sphere();\n        this.plane = new three__WEBPACK_IMPORTED_MODULE_0__.Plane();\n        this.needsUpdate = true;\n    }\n    intersectsSphere(sphere) {\n        return (0,_MathUtilities_js__WEBPACK_IMPORTED_MODULE_2__.sphereIntersectTriangle)(sphere, this);\n    }\n    update() {\n        const a = this.a;\n        const b = this.b;\n        const c = this.c;\n        const points = this.points;\n        const satAxes = this.satAxes;\n        const satBounds = this.satBounds;\n        const axis0 = satAxes[0];\n        const sab0 = satBounds[0];\n        this.getNormal(axis0);\n        sab0.setFromPoints(axis0, points);\n        const axis1 = satAxes[1];\n        const sab1 = satBounds[1];\n        axis1.subVectors(a, b);\n        sab1.setFromPoints(axis1, points);\n        const axis2 = satAxes[2];\n        const sab2 = satBounds[2];\n        axis2.subVectors(b, c);\n        sab2.setFromPoints(axis2, points);\n        const axis3 = satAxes[3];\n        const sab3 = satBounds[3];\n        axis3.subVectors(c, a);\n        sab3.setFromPoints(axis3, points);\n        this.sphere.setFromPoints(this.points);\n        this.plane.setFromNormalAndCoplanarPoint(axis0, a);\n        this.needsUpdate = false;\n    }\n}\nExtendedTriangle.prototype.closestPointToSegment = function() {\n    const point1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const point2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const edge = new three__WEBPACK_IMPORTED_MODULE_0__.Line3();\n    return function distanceToSegment(segment, target1 = null, target2 = null) {\n        const { start, end } = segment;\n        const points = this.points;\n        let distSq;\n        let closestDistanceSq = Infinity;\n        // check the triangle edges\n        for(let i = 0; i < 3; i++){\n            const nexti = (i + 1) % 3;\n            edge.start.copy(points[i]);\n            edge.end.copy(points[nexti]);\n            (0,_MathUtilities_js__WEBPACK_IMPORTED_MODULE_2__.closestPointsSegmentToSegment)(edge, segment, point1, point2);\n            distSq = point1.distanceToSquared(point2);\n            if (distSq < closestDistanceSq) {\n                closestDistanceSq = distSq;\n                if (target1) target1.copy(point1);\n                if (target2) target2.copy(point2);\n            }\n        }\n        // check end points\n        this.closestPointToPoint(start, point1);\n        distSq = start.distanceToSquared(point1);\n        if (distSq < closestDistanceSq) {\n            closestDistanceSq = distSq;\n            if (target1) target1.copy(point1);\n            if (target2) target2.copy(start);\n        }\n        this.closestPointToPoint(end, point1);\n        distSq = end.distanceToSquared(point1);\n        if (distSq < closestDistanceSq) {\n            closestDistanceSq = distSq;\n            if (target1) target1.copy(point1);\n            if (target2) target2.copy(end);\n        }\n        return Math.sqrt(closestDistanceSq);\n    };\n}();\nExtendedTriangle.prototype.intersectsTriangle = function() {\n    const saTri2 = new ExtendedTriangle();\n    const arr1 = new Array(3);\n    const arr2 = new Array(3);\n    const cachedSatBounds = new _SeparatingAxisBounds_js__WEBPACK_IMPORTED_MODULE_1__.SeparatingAxisBounds();\n    const cachedSatBounds2 = new _SeparatingAxisBounds_js__WEBPACK_IMPORTED_MODULE_1__.SeparatingAxisBounds();\n    const cachedAxis = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const dir = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const dir1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const dir2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const tempDir = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const edge = new three__WEBPACK_IMPORTED_MODULE_0__.Line3();\n    const edge1 = new three__WEBPACK_IMPORTED_MODULE_0__.Line3();\n    const edge2 = new three__WEBPACK_IMPORTED_MODULE_0__.Line3();\n    const tempPoint = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    function triIntersectPlane(tri, plane, targetEdge) {\n        // find the edge that intersects the other triangle plane\n        const points = tri.points;\n        let count = 0;\n        let startPointIntersection = -1;\n        for(let i = 0; i < 3; i++){\n            const { start, end } = edge;\n            start.copy(points[i]);\n            end.copy(points[(i + 1) % 3]);\n            edge.delta(dir);\n            const startIntersects = isNearZero(plane.distanceToPoint(start));\n            if (isNearZero(plane.normal.dot(dir)) && startIntersects) {\n                // if the edge lies on the plane then take the line\n                targetEdge.copy(edge);\n                count = 2;\n                break;\n            }\n            // check if the start point is near the plane because \"intersectLine\" is not robust to that case\n            const doesIntersect = plane.intersectLine(edge, tempPoint);\n            if (!doesIntersect && startIntersects) {\n                tempPoint.copy(start);\n            }\n            // ignore the end point\n            if ((doesIntersect || startIntersects) && !isNearZero(tempPoint.distanceTo(end))) {\n                if (count <= 1) {\n                    // assign to the start or end point and save which index was snapped to\n                    // the start point if necessary\n                    const point = count === 1 ? targetEdge.start : targetEdge.end;\n                    point.copy(tempPoint);\n                    if (startIntersects) {\n                        startPointIntersection = count;\n                    }\n                } else if (count >= 2) {\n                    // if we're here that means that there must have been one point that had\n                    // snapped to the start point so replace it here\n                    const point = startPointIntersection === 1 ? targetEdge.start : targetEdge.end;\n                    point.copy(tempPoint);\n                    count = 2;\n                    break;\n                }\n                count++;\n                if (count === 2 && startPointIntersection === -1) {\n                    break;\n                }\n            }\n        }\n        return count;\n    }\n    // TODO: If the triangles are coplanar and intersecting the target is nonsensical. It should at least\n    // be a line contained by both triangles if not a different special case somehow represented in the return result.\n    return function intersectsTriangle(other, target = null, suppressLog = false) {\n        if (this.needsUpdate) {\n            this.update();\n        }\n        if (!other.isExtendedTriangle) {\n            saTri2.copy(other);\n            saTri2.update();\n            other = saTri2;\n        } else if (other.needsUpdate) {\n            other.update();\n        }\n        const plane1 = this.plane;\n        const plane2 = other.plane;\n        if (Math.abs(plane1.normal.dot(plane2.normal)) > 1.0 - 1e-10) {\n            // perform separating axis intersection test only for coplanar triangles\n            const satBounds1 = this.satBounds;\n            const satAxes1 = this.satAxes;\n            arr2[0] = other.a;\n            arr2[1] = other.b;\n            arr2[2] = other.c;\n            for(let i = 0; i < 4; i++){\n                const sb = satBounds1[i];\n                const sa = satAxes1[i];\n                cachedSatBounds.setFromPoints(sa, arr2);\n                if (sb.isSeparated(cachedSatBounds)) return false;\n            }\n            const satBounds2 = other.satBounds;\n            const satAxes2 = other.satAxes;\n            arr1[0] = this.a;\n            arr1[1] = this.b;\n            arr1[2] = this.c;\n            for(let i = 0; i < 4; i++){\n                const sb = satBounds2[i];\n                const sa = satAxes2[i];\n                cachedSatBounds.setFromPoints(sa, arr1);\n                if (sb.isSeparated(cachedSatBounds)) return false;\n            }\n            // check crossed axes\n            for(let i = 0; i < 4; i++){\n                const sa1 = satAxes1[i];\n                for(let i2 = 0; i2 < 4; i2++){\n                    const sa2 = satAxes2[i2];\n                    cachedAxis.crossVectors(sa1, sa2);\n                    cachedSatBounds.setFromPoints(cachedAxis, arr1);\n                    cachedSatBounds2.setFromPoints(cachedAxis, arr2);\n                    if (cachedSatBounds.isSeparated(cachedSatBounds2)) return false;\n                }\n            }\n            if (target) {\n                // TODO find two points that intersect on the edges and make that the result\n                if (!suppressLog) {\n                    console.warn(\"ExtendedTriangle.intersectsTriangle: Triangles are coplanar which does not support an output edge. Setting edge to 0, 0, 0.\");\n                }\n                target.start.set(0, 0, 0);\n                target.end.set(0, 0, 0);\n            }\n            return true;\n        } else {\n            // find the edge that intersects the other triangle plane\n            const count1 = triIntersectPlane(this, plane2, edge1);\n            if (count1 === 1 && other.containsPoint(edge1.end)) {\n                if (target) {\n                    target.start.copy(edge1.end);\n                    target.end.copy(edge1.end);\n                }\n                return true;\n            } else if (count1 !== 2) {\n                return false;\n            }\n            // find the other triangles edge that intersects this plane\n            const count2 = triIntersectPlane(other, plane1, edge2);\n            if (count2 === 1 && this.containsPoint(edge2.end)) {\n                if (target) {\n                    target.start.copy(edge2.end);\n                    target.end.copy(edge2.end);\n                }\n                return true;\n            } else if (count2 !== 2) {\n                return false;\n            }\n            // find swap the second edge so both lines are running the same direction\n            edge1.delta(dir1);\n            edge2.delta(dir2);\n            if (dir1.dot(dir2) < 0) {\n                let tmp = edge2.start;\n                edge2.start = edge2.end;\n                edge2.end = tmp;\n            }\n            // check if the edges are overlapping\n            const s1 = edge1.start.dot(dir1);\n            const e1 = edge1.end.dot(dir1);\n            const s2 = edge2.start.dot(dir1);\n            const e2 = edge2.end.dot(dir1);\n            const separated1 = e1 < s2;\n            const separated2 = s1 < e2;\n            if (s1 !== e2 && s2 !== e1 && separated1 === separated2) {\n                return false;\n            }\n            // assign the target output\n            if (target) {\n                tempDir.subVectors(edge1.start, edge2.start);\n                if (tempDir.dot(dir1) > 0) {\n                    target.start.copy(edge1.start);\n                } else {\n                    target.start.copy(edge2.start);\n                }\n                tempDir.subVectors(edge1.end, edge2.end);\n                if (tempDir.dot(dir1) < 0) {\n                    target.end.copy(edge1.end);\n                } else {\n                    target.end.copy(edge2.end);\n                }\n            }\n            return true;\n        }\n    };\n}();\nExtendedTriangle.prototype.distanceToPoint = function() {\n    const target = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    return function distanceToPoint(point) {\n        this.closestPointToPoint(point, target);\n        return point.distanceTo(target);\n    };\n}();\nExtendedTriangle.prototype.distanceToTriangle = function() {\n    const point = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const point2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const cornerFields = [\n        \"a\",\n        \"b\",\n        \"c\"\n    ];\n    const line1 = new three__WEBPACK_IMPORTED_MODULE_0__.Line3();\n    const line2 = new three__WEBPACK_IMPORTED_MODULE_0__.Line3();\n    return function distanceToTriangle(other, target1 = null, target2 = null) {\n        const lineTarget = target1 || target2 ? line1 : null;\n        if (this.intersectsTriangle(other, lineTarget)) {\n            if (target1 || target2) {\n                if (target1) lineTarget.getCenter(target1);\n                if (target2) lineTarget.getCenter(target2);\n            }\n            return 0;\n        }\n        let closestDistanceSq = Infinity;\n        // check all point distances\n        for(let i = 0; i < 3; i++){\n            let dist;\n            const field = cornerFields[i];\n            const otherVec = other[field];\n            this.closestPointToPoint(otherVec, point);\n            dist = otherVec.distanceToSquared(point);\n            if (dist < closestDistanceSq) {\n                closestDistanceSq = dist;\n                if (target1) target1.copy(point);\n                if (target2) target2.copy(otherVec);\n            }\n            const thisVec = this[field];\n            other.closestPointToPoint(thisVec, point);\n            dist = thisVec.distanceToSquared(point);\n            if (dist < closestDistanceSq) {\n                closestDistanceSq = dist;\n                if (target1) target1.copy(thisVec);\n                if (target2) target2.copy(point);\n            }\n        }\n        for(let i = 0; i < 3; i++){\n            const f11 = cornerFields[i];\n            const f12 = cornerFields[(i + 1) % 3];\n            line1.set(this[f11], this[f12]);\n            for(let i2 = 0; i2 < 3; i2++){\n                const f21 = cornerFields[i2];\n                const f22 = cornerFields[(i2 + 1) % 3];\n                line2.set(other[f21], other[f22]);\n                (0,_MathUtilities_js__WEBPACK_IMPORTED_MODULE_2__.closestPointsSegmentToSegment)(line1, line2, point, point2);\n                const dist = point.distanceToSquared(point2);\n                if (dist < closestDistanceSq) {\n                    closestDistanceSq = dist;\n                    if (target1) target1.copy(point);\n                    if (target2) target2.copy(point2);\n                }\n            }\n        }\n        return Math.sqrt(closestDistanceSq);\n    };\n}();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9tYXRoL0V4dGVuZGVkVHJpYW5nbGUuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUFnRTtBQUNDO0FBQzJCO0FBRTVGLE1BQU1RLGVBQWU7QUFDckIsU0FBU0MsV0FBWUMsS0FBSztJQUV6QixPQUFPQyxLQUFLQyxHQUFHLENBQUVGLFNBQVVGO0FBRTVCO0FBRU8sTUFBTUsseUJBQXlCYiwyQ0FBUUE7SUFFN0NjLFlBQWEsR0FBR0MsSUFBSSxDQUFHO1FBRXRCLEtBQUssSUFBS0E7UUFFVixJQUFJLENBQUNDLGtCQUFrQixHQUFHO1FBQzFCLElBQUksQ0FBQ0MsT0FBTyxHQUFHLElBQUlDLE1BQU8sR0FBSUMsSUFBSSxHQUFHQyxHQUFHLENBQUUsSUFBTSxJQUFJbkIsMENBQU9BO1FBQzNELElBQUksQ0FBQ29CLFNBQVMsR0FBRyxJQUFJSCxNQUFPLEdBQUlDLElBQUksR0FBR0MsR0FBRyxDQUFFLElBQU0sSUFBSWYsMEVBQW9CQTtRQUMxRSxJQUFJLENBQUNpQixNQUFNLEdBQUc7WUFBRSxJQUFJLENBQUNDLENBQUM7WUFBRSxJQUFJLENBQUNDLENBQUM7WUFBRSxJQUFJLENBQUNDLENBQUM7U0FBRTtRQUN4QyxJQUFJLENBQUNDLE1BQU0sR0FBRyxJQUFJdkIseUNBQU1BO1FBQ3hCLElBQUksQ0FBQ3dCLEtBQUssR0FBRyxJQUFJdkIsd0NBQUtBO1FBQ3RCLElBQUksQ0FBQ3dCLFdBQVcsR0FBRztJQUVwQjtJQUVBQyxpQkFBa0JILE1BQU0sRUFBRztRQUUxQixPQUFPbkIsMEVBQXVCQSxDQUFFbUIsUUFBUSxJQUFJO0lBRTdDO0lBRUFJLFNBQVM7UUFFUixNQUFNUCxJQUFJLElBQUksQ0FBQ0EsQ0FBQztRQUNoQixNQUFNQyxJQUFJLElBQUksQ0FBQ0EsQ0FBQztRQUNoQixNQUFNQyxJQUFJLElBQUksQ0FBQ0EsQ0FBQztRQUNoQixN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QW9CdUU7Z0JBQ3BCLElBQUs1RSxTQUFVQSxRQUFRUyxJQUFJLENBQUVzRTtnQkFDN0IsSUFBSzlFLFNBQVVBLFFBQVFRLElBQUksQ0FBRStCO1lBRTlCO1FBRUQ7UUFFQSxJQUFNLElBQUlqQyxJQUFJLEdBQUdBLElBQUksR0FBR0EsSUFBTztZQUU5QixNQUFNeUUsTUFBTVQsWUFBWSxDQUFFaEUsRUFBRztZQUM3QixNQUFNMEUsTUFBTVYsWUFBWSxDQUFFLENBQUVoRSxJQUFJLEtBQU0sRUFBRztZQUN6Q2lFLE1BQU1iLEdBQUcsQ0FBRSxJQUFJLENBQUVxQixJQUFLLEVBQUUsSUFBSSxDQUFFQyxJQUFLO1lBQ25DLElBQU0sSUFBSTNCLEtBQUssR0FBR0EsS0FBSyxHQUFHQSxLQUFRO2dCQUVqQyxNQUFNNEIsTUFBTVgsWUFBWSxDQUFFakIsR0FBSTtnQkFDOUIsTUFBTTZCLE1BQU1aLFlBQVksQ0FBRSxDQUFFakIsS0FBSyxLQUFNLEVBQUc7Z0JBQzFDbUIsTUFBTWQsR0FBRyxDQUFFbEIsS0FBSyxDQUFFeUMsSUFBSyxFQUFFekMsS0FBSyxDQUFFMEMsSUFBSztnQkFFckMvSCxnRkFBNkJBLENBQUVvSCxPQUFPQyxPQUFPakMsT0FBTzVDO2dCQUVwRCxNQUFNZ0YsT0FBT3BDLE1BQU05QixpQkFBaUIsQ0FBRWQ7Z0JBQ3RDLElBQUtnRixPQUFPdkUsbUJBQW9CO29CQUUvQkEsb0JBQW9CdUU7b0JBQ3BCLElBQUs1RSxTQUFVQSxRQUFRUyxJQUFJLENBQUUrQjtvQkFDN0IsSUFBS3ZDLFNBQVVBLFFBQVFRLElBQUksQ0FBRWI7Z0JBRTlCO1lBRUQ7UUFFRDtRQUVBLE9BQU9uQyxLQUFLbUQsSUFBSSxDQUFFUDtJQUVuQjtBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmliZS0zZC1jb2RlLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvbWF0aC9FeHRlbmRlZFRyaWFuZ2xlLmpzPzNjZDUiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVHJpYW5nbGUsIFZlY3RvcjMsIExpbmUzLCBTcGhlcmUsIFBsYW5lIH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgU2VwYXJhdGluZ0F4aXNCb3VuZHMgfSBmcm9tICcuL1NlcGFyYXRpbmdBeGlzQm91bmRzLmpzJztcbmltcG9ydCB7IGNsb3Nlc3RQb2ludHNTZWdtZW50VG9TZWdtZW50LCBzcGhlcmVJbnRlcnNlY3RUcmlhbmdsZSB9IGZyb20gJy4vTWF0aFV0aWxpdGllcy5qcyc7XG5cbmNvbnN0IFpFUk9fRVBTSUxPTiA9IDFlLTE1O1xuZnVuY3Rpb24gaXNOZWFyWmVybyggdmFsdWUgKSB7XG5cblx0cmV0dXJuIE1hdGguYWJzKCB2YWx1ZSApIDwgWkVST19FUFNJTE9OO1xuXG59XG5cbmV4cG9ydCBjbGFzcyBFeHRlbmRlZFRyaWFuZ2xlIGV4dGVuZHMgVHJpYW5nbGUge1xuXG5cdGNvbnN0cnVjdG9yKCAuLi5hcmdzICkge1xuXG5cdFx0c3VwZXIoIC4uLmFyZ3MgKTtcblxuXHRcdHRoaXMuaXNFeHRlbmRlZFRyaWFuZ2xlID0gdHJ1ZTtcblx0XHR0aGlzLnNhdEF4ZXMgPSBuZXcgQXJyYXkoIDQgKS5maWxsKCkubWFwKCAoKSA9PiBuZXcgVmVjdG9yMygpICk7XG5cdFx0dGhpcy5zYXRCb3VuZHMgPSBuZXcgQXJyYXkoIDQgKS5maWxsKCkubWFwKCAoKSA9PiBuZXcgU2VwYXJhdGluZ0F4aXNCb3VuZHMoKSApO1xuXHRcdHRoaXMucG9pbnRzID0gWyB0aGlzLmEsIHRoaXMuYiwgdGhpcy5jIF07XG5cdFx0dGhpcy5zcGhlcmUgPSBuZXcgU3BoZXJlKCk7XG5cdFx0dGhpcy5wbGFuZSA9IG5ldyBQbGFuZSgpO1xuXHRcdHRoaXMubmVlZHNVcGRhdGUgPSB0cnVlO1xuXG5cdH1cblxuXHRpbnRlcnNlY3RzU3BoZXJlKCBzcGhlcmUgKSB7XG5cblx0XHRyZXR1cm4gc3BoZXJlSW50ZXJzZWN0VHJpYW5nbGUoIHNwaGVyZSwgdGhpcyApO1xuXG5cdH1cblxuXHR1cGRhdGUoKSB7XG5cblx0XHRjb25zdCBhID0gdGhpcy5hO1xuXHRcdGNvbnN0IGIgPSB0aGlzLmI7XG5cdFx0Y29uc3QgYyA9IHRoaXMuYztcblx0XHRjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcblxuXHRcdGNvbnN0IHNhdEF4ZXMgPSB0aGlzLnNhdEF4ZXM7XG5cdFx0Y29uc3Qgc2F0Qm91bmRzID0gdGhpcy5zYXRCb3VuZHM7XG5cblx0XHRjb25zdCBheGlzMCA9IHNhdEF4ZXNbIDAgXTtcblx0XHRjb25zdCBzYWIwID0gc2F0Qm91bmRzWyAwIF07XG5cdFx0dGhpcy5nZXROb3JtYWwoIGF4aXMwICk7XG5cdFx0c2FiMC5zZXRGcm9tUG9pbnRzKCBheGlzMCwgcG9pbnRzICk7XG5cblx0XHRjb25zdCBheGlzMSA9IHNhdEF4ZXNbIDEgXTtcblx0XHRjb25zdCBzYWIxID0gc2F0Qm91bmRzWyAxIF07XG5cdFx0YXhpczEuc3ViVmVjdG9ycyggYSwgYiApO1xuXHRcdHNhYjEuc2V0RnJvbVBvaW50cyggYXhpczEsIHBvaW50cyApO1xuXG5cdFx0Y29uc3QgYXhpczIgPSBzYXRBeGVzWyAyIF07XG5cdFx0Y29uc3Qgc2FiMiA9IHNhdEJvdW5kc1sgMiBdO1xuXHRcdGF4aXMyLnN1YlZlY3RvcnMoIGIsIGMgKTtcblx0XHRzYWIyLnNldEZyb21Qb2ludHMoIGF4aXMyLCBwb2ludHMgKTtcblxuXHRcdGNvbnN0IGF4aXMzID0gc2F0QXhlc1sgMyBdO1xuXHRcdGNvbnN0IHNhYjMgPSBzYXRCb3VuZHNbIDMgXTtcblx0XHRheGlzMy5zdWJWZWN0b3JzKCBjLCBhICk7XG5cdFx0c2FiMy5zZXRGcm9tUG9pbnRzKCBheGlzMywgcG9pbnRzICk7XG5cblx0XHR0aGlzLnNwaGVyZS5zZXRGcm9tUG9pbnRzKCB0aGlzLnBvaW50cyApO1xuXHRcdHRoaXMucGxhbmUuc2V0RnJvbU5vcm1hbEFuZENvcGxhbmFyUG9pbnQoIGF4aXMwLCBhICk7XG5cdFx0dGhpcy5uZWVkc1VwZGF0ZSA9IGZhbHNlO1xuXG5cdH1cblxufVxuXG5FeHRlbmRlZFRyaWFuZ2xlLnByb3RvdHlwZS5jbG9zZXN0UG9pbnRUb1NlZ21lbnQgPSAoIGZ1bmN0aW9uICgpIHtcblxuXHRjb25zdCBwb2ludDEgPSBuZXcgVmVjdG9yMygpO1xuXHRjb25zdCBwb2ludDIgPSBuZXcgVmVjdG9yMygpO1xuXHRjb25zdCBlZGdlID0gbmV3IExpbmUzKCk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIGRpc3RhbmNlVG9TZWdtZW50KCBzZWdtZW50LCB0YXJnZXQxID0gbnVsbCwgdGFyZ2V0MiA9IG51bGwgKSB7XG5cblx0XHRjb25zdCB7IHN0YXJ0LCBlbmQgfSA9IHNlZ21lbnQ7XG5cdFx0Y29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG5cdFx0bGV0IGRpc3RTcTtcblx0XHRsZXQgY2xvc2VzdERpc3RhbmNlU3EgPSBJbmZpbml0eTtcblxuXHRcdC8vIGNoZWNrIHRoZSB0cmlhbmdsZSBlZGdlc1xuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IG5leHRpID0gKCBpICsgMSApICUgMztcblx0XHRcdGVkZ2Uuc3RhcnQuY29weSggcG9pbnRzWyBpIF0gKTtcblx0XHRcdGVkZ2UuZW5kLmNvcHkoIHBvaW50c1sgbmV4dGkgXSApO1xuXG5cdFx0XHRjbG9zZXN0UG9pbnRzU2VnbWVudFRvU2VnbWVudCggZWRnZSwgc2VnbWVudCwgcG9pbnQxLCBwb2ludDIgKTtcblxuXHRcdFx0ZGlzdFNxID0gcG9pbnQxLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludDIgKTtcblx0XHRcdGlmICggZGlzdFNxIDwgY2xvc2VzdERpc3RhbmNlU3EgKSB7XG5cblx0XHRcdFx0Y2xvc2VzdERpc3RhbmNlU3EgPSBkaXN0U3E7XG5cdFx0XHRcdGlmICggdGFyZ2V0MSApIHRhcmdldDEuY29weSggcG9pbnQxICk7XG5cdFx0XHRcdGlmICggdGFyZ2V0MiApIHRhcmdldDIuY29weSggcG9pbnQyICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdC8vIGNoZWNrIGVuZCBwb2ludHNcblx0XHR0aGlzLmNsb3Nlc3RQb2ludFRvUG9pbnQoIHN0YXJ0LCBwb2ludDEgKTtcblx0XHRkaXN0U3EgPSBzdGFydC5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQxICk7XG5cdFx0aWYgKCBkaXN0U3EgPCBjbG9zZXN0RGlzdGFuY2VTcSApIHtcblxuXHRcdFx0Y2xvc2VzdERpc3RhbmNlU3EgPSBkaXN0U3E7XG5cdFx0XHRpZiAoIHRhcmdldDEgKSB0YXJnZXQxLmNvcHkoIHBvaW50MSApO1xuXHRcdFx0aWYgKCB0YXJnZXQyICkgdGFyZ2V0Mi5jb3B5KCBzdGFydCApO1xuXG5cdFx0fVxuXG5cdFx0dGhpcy5jbG9zZXN0UG9pbnRUb1BvaW50KCBlbmQsIHBvaW50MSApO1xuXHRcdGRpc3RTcSA9IGVuZC5kaXN0YW5jZVRvU3F1YXJlZCggcG9pbnQxICk7XG5cdFx0aWYgKCBkaXN0U3EgPCBjbG9zZXN0RGlzdGFuY2VTcSApIHtcblxuXHRcdFx0Y2xvc2VzdERpc3RhbmNlU3EgPSBkaXN0U3E7XG5cdFx0XHRpZiAoIHRhcmdldDEgKSB0YXJnZXQxLmNvcHkoIHBvaW50MSApO1xuXHRcdFx0aWYgKCB0YXJnZXQyICkgdGFyZ2V0Mi5jb3B5KCBlbmQgKTtcblxuXHRcdH1cblxuXHRcdHJldHVybiBNYXRoLnNxcnQoIGNsb3Nlc3REaXN0YW5jZVNxICk7XG5cblx0fTtcblxufSApKCk7XG5cbkV4dGVuZGVkVHJpYW5nbGUucHJvdG90eXBlLmludGVyc2VjdHNUcmlhbmdsZSA9ICggZnVuY3Rpb24gKCkge1xuXG5cdGNvbnN0IHNhVHJpMiA9IG5ldyBFeHRlbmRlZFRyaWFuZ2xlKCk7XG5cdGNvbnN0IGFycjEgPSBuZXcgQXJyYXkoIDMgKTtcblx0Y29uc3QgYXJyMiA9IG5ldyBBcnJheSggMyApO1xuXHRjb25zdCBjYWNoZWRTYXRCb3VuZHMgPSBuZXcgU2VwYXJhdGluZ0F4aXNCb3VuZHMoKTtcblx0Y29uc3QgY2FjaGVkU2F0Qm91bmRzMiA9IG5ldyBTZXBhcmF0aW5nQXhpc0JvdW5kcygpO1xuXHRjb25zdCBjYWNoZWRBeGlzID0gbmV3IFZlY3RvcjMoKTtcblx0Y29uc3QgZGlyID0gbmV3IFZlY3RvcjMoKTtcblx0Y29uc3QgZGlyMSA9IG5ldyBWZWN0b3IzKCk7XG5cdGNvbnN0IGRpcjIgPSBuZXcgVmVjdG9yMygpO1xuXHRjb25zdCB0ZW1wRGlyID0gbmV3IFZlY3RvcjMoKTtcblx0Y29uc3QgZWRnZSA9IG5ldyBMaW5lMygpO1xuXHRjb25zdCBlZGdlMSA9IG5ldyBMaW5lMygpO1xuXHRjb25zdCBlZGdlMiA9IG5ldyBMaW5lMygpO1xuXHRjb25zdCB0ZW1wUG9pbnQgPSBuZXcgVmVjdG9yMygpO1xuXG5cdGZ1bmN0aW9uIHRyaUludGVyc2VjdFBsYW5lKCB0cmksIHBsYW5lLCB0YXJnZXRFZGdlICkge1xuXG5cdFx0Ly8gZmluZCB0aGUgZWRnZSB0aGF0IGludGVyc2VjdHMgdGhlIG90aGVyIHRyaWFuZ2xlIHBsYW5lXG5cdFx0Y29uc3QgcG9pbnRzID0gdHJpLnBvaW50cztcblx0XHRsZXQgY291bnQgPSAwO1xuXHRcdGxldCBzdGFydFBvaW50SW50ZXJzZWN0aW9uID0gLSAxO1xuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHsgc3RhcnQsIGVuZCB9ID0gZWRnZTtcblx0XHRcdHN0YXJ0LmNvcHkoIHBvaW50c1sgaSBdICk7XG5cdFx0XHRlbmQuY29weSggcG9pbnRzWyAoIGkgKyAxICkgJSAzIF0gKTtcblx0XHRcdGVkZ2UuZGVsdGEoIGRpciApO1xuXG5cdFx0XHRjb25zdCBzdGFydEludGVyc2VjdHMgPSBpc05lYXJaZXJvKCBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIHN0YXJ0ICkgKTtcblx0XHRcdGlmICggaXNOZWFyWmVybyggcGxhbmUubm9ybWFsLmRvdCggZGlyICkgKSAmJiBzdGFydEludGVyc2VjdHMgKSB7XG5cblx0XHRcdFx0Ly8gaWYgdGhlIGVkZ2UgbGllcyBvbiB0aGUgcGxhbmUgdGhlbiB0YWtlIHRoZSBsaW5lXG5cdFx0XHRcdHRhcmdldEVkZ2UuY29weSggZWRnZSApO1xuXHRcdFx0XHRjb3VudCA9IDI7XG5cdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGNoZWNrIGlmIHRoZSBzdGFydCBwb2ludCBpcyBuZWFyIHRoZSBwbGFuZSBiZWNhdXNlIFwiaW50ZXJzZWN0TGluZVwiIGlzIG5vdCByb2J1c3QgdG8gdGhhdCBjYXNlXG5cdFx0XHRjb25zdCBkb2VzSW50ZXJzZWN0ID0gcGxhbmUuaW50ZXJzZWN0TGluZSggZWRnZSwgdGVtcFBvaW50ICk7XG5cdFx0XHRpZiAoICEgZG9lc0ludGVyc2VjdCAmJiBzdGFydEludGVyc2VjdHMgKSB7XG5cblx0XHRcdFx0dGVtcFBvaW50LmNvcHkoIHN0YXJ0ICk7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gaWdub3JlIHRoZSBlbmQgcG9pbnRcblx0XHRcdGlmICggKCBkb2VzSW50ZXJzZWN0IHx8IHN0YXJ0SW50ZXJzZWN0cyApICYmICEgaXNOZWFyWmVybyggdGVtcFBvaW50LmRpc3RhbmNlVG8oIGVuZCApICkgKSB7XG5cblx0XHRcdFx0aWYgKCBjb3VudCA8PSAxICkge1xuXG5cdFx0XHRcdFx0Ly8gYXNzaWduIHRvIHRoZSBzdGFydCBvciBlbmQgcG9pbnQgYW5kIHNhdmUgd2hpY2ggaW5kZXggd2FzIHNuYXBwZWQgdG9cblx0XHRcdFx0XHQvLyB0aGUgc3RhcnQgcG9pbnQgaWYgbmVjZXNzYXJ5XG5cdFx0XHRcdFx0Y29uc3QgcG9pbnQgPSBjb3VudCA9PT0gMSA/IHRhcmdldEVkZ2Uuc3RhcnQgOiB0YXJnZXRFZGdlLmVuZDtcblx0XHRcdFx0XHRwb2ludC5jb3B5KCB0ZW1wUG9pbnQgKTtcblx0XHRcdFx0XHRpZiAoIHN0YXJ0SW50ZXJzZWN0cyApIHtcblxuXHRcdFx0XHRcdFx0c3RhcnRQb2ludEludGVyc2VjdGlvbiA9IGNvdW50O1xuXG5cdFx0XHRcdFx0fVxuXG5cdFx0XHRcdH0gZWxzZSBpZiAoIGNvdW50ID49IDIgKSB7XG5cblx0XHRcdFx0XHQvLyBpZiB3ZSdyZSBoZXJlIHRoYXQgbWVhbnMgdGhhdCB0aGVyZSBtdXN0IGhhdmUgYmVlbiBvbmUgcG9pbnQgdGhhdCBoYWRcblx0XHRcdFx0XHQvLyBzbmFwcGVkIHRvIHRoZSBzdGFydCBwb2ludCBzbyByZXBsYWNlIGl0IGhlcmVcblx0XHRcdFx0XHRjb25zdCBwb2ludCA9IHN0YXJ0UG9pbnRJbnRlcnNlY3Rpb24gPT09IDEgPyB0YXJnZXRFZGdlLnN0YXJ0IDogdGFyZ2V0RWRnZS5lbmQ7XG5cdFx0XHRcdFx0cG9pbnQuY29weSggdGVtcFBvaW50ICk7XG5cdFx0XHRcdFx0Y291bnQgPSAyO1xuXHRcdFx0XHRcdGJyZWFrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0XHRjb3VudCArKztcblx0XHRcdFx0aWYgKCBjb3VudCA9PT0gMiAmJiBzdGFydFBvaW50SW50ZXJzZWN0aW9uID09PSAtIDEgKSB7XG5cblx0XHRcdFx0XHRicmVhaztcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBjb3VudDtcblxuXHR9XG5cblx0Ly8gVE9ETzogSWYgdGhlIHRyaWFuZ2xlcyBhcmUgY29wbGFuYXIgYW5kIGludGVyc2VjdGluZyB0aGUgdGFyZ2V0IGlzIG5vbnNlbnNpY2FsLiBJdCBzaG91bGQgYXQgbGVhc3Rcblx0Ly8gYmUgYSBsaW5lIGNvbnRhaW5lZCBieSBib3RoIHRyaWFuZ2xlcyBpZiBub3QgYSBkaWZmZXJlbnQgc3BlY2lhbCBjYXNlIHNvbWVob3cgcmVwcmVzZW50ZWQgaW4gdGhlIHJldHVybiByZXN1bHQuXG5cdHJldHVybiBmdW5jdGlvbiBpbnRlcnNlY3RzVHJpYW5nbGUoIG90aGVyLCB0YXJnZXQgPSBudWxsLCBzdXBwcmVzc0xvZyA9IGZhbHNlICkge1xuXG5cdFx0aWYgKCB0aGlzLm5lZWRzVXBkYXRlICkge1xuXG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCAhIG90aGVyLmlzRXh0ZW5kZWRUcmlhbmdsZSApIHtcblxuXHRcdFx0c2FUcmkyLmNvcHkoIG90aGVyICk7XG5cdFx0XHRzYVRyaTIudXBkYXRlKCk7XG5cdFx0XHRvdGhlciA9IHNhVHJpMjtcblxuXHRcdH0gZWxzZSBpZiAoIG90aGVyLm5lZWRzVXBkYXRlICkge1xuXG5cdFx0XHRvdGhlci51cGRhdGUoKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHBsYW5lMSA9IHRoaXMucGxhbmU7XG5cdFx0Y29uc3QgcGxhbmUyID0gb3RoZXIucGxhbmU7XG5cblx0XHRpZiAoIE1hdGguYWJzKCBwbGFuZTEubm9ybWFsLmRvdCggcGxhbmUyLm5vcm1hbCApICkgPiAxLjAgLSAxZS0xMCApIHtcblxuXHRcdFx0Ly8gcGVyZm9ybSBzZXBhcmF0aW5nIGF4aXMgaW50ZXJzZWN0aW9uIHRlc3Qgb25seSBmb3IgY29wbGFuYXIgdHJpYW5nbGVzXG5cdFx0XHRjb25zdCBzYXRCb3VuZHMxID0gdGhpcy5zYXRCb3VuZHM7XG5cdFx0XHRjb25zdCBzYXRBeGVzMSA9IHRoaXMuc2F0QXhlcztcblx0XHRcdGFycjJbIDAgXSA9IG90aGVyLmE7XG5cdFx0XHRhcnIyWyAxIF0gPSBvdGhlci5iO1xuXHRcdFx0YXJyMlsgMiBdID0gb3RoZXIuYztcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDQ7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3Qgc2IgPSBzYXRCb3VuZHMxWyBpIF07XG5cdFx0XHRcdGNvbnN0IHNhID0gc2F0QXhlczFbIGkgXTtcblx0XHRcdFx0Y2FjaGVkU2F0Qm91bmRzLnNldEZyb21Qb2ludHMoIHNhLCBhcnIyICk7XG5cdFx0XHRcdGlmICggc2IuaXNTZXBhcmF0ZWQoIGNhY2hlZFNhdEJvdW5kcyApICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IHNhdEJvdW5kczIgPSBvdGhlci5zYXRCb3VuZHM7XG5cdFx0XHRjb25zdCBzYXRBeGVzMiA9IG90aGVyLnNhdEF4ZXM7XG5cdFx0XHRhcnIxWyAwIF0gPSB0aGlzLmE7XG5cdFx0XHRhcnIxWyAxIF0gPSB0aGlzLmI7XG5cdFx0XHRhcnIxWyAyIF0gPSB0aGlzLmM7XG5cdFx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCA0OyBpICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHNiID0gc2F0Qm91bmRzMlsgaSBdO1xuXHRcdFx0XHRjb25zdCBzYSA9IHNhdEF4ZXMyWyBpIF07XG5cdFx0XHRcdGNhY2hlZFNhdEJvdW5kcy5zZXRGcm9tUG9pbnRzKCBzYSwgYXJyMSApO1xuXHRcdFx0XHRpZiAoIHNiLmlzU2VwYXJhdGVkKCBjYWNoZWRTYXRCb3VuZHMgKSApIHJldHVybiBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBjaGVjayBjcm9zc2VkIGF4ZXNcblx0XHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDQ7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3Qgc2ExID0gc2F0QXhlczFbIGkgXTtcblx0XHRcdFx0Zm9yICggbGV0IGkyID0gMDsgaTIgPCA0OyBpMiArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IHNhMiA9IHNhdEF4ZXMyWyBpMiBdO1xuXHRcdFx0XHRcdGNhY2hlZEF4aXMuY3Jvc3NWZWN0b3JzKCBzYTEsIHNhMiApO1xuXHRcdFx0XHRcdGNhY2hlZFNhdEJvdW5kcy5zZXRGcm9tUG9pbnRzKCBjYWNoZWRBeGlzLCBhcnIxICk7XG5cdFx0XHRcdFx0Y2FjaGVkU2F0Qm91bmRzMi5zZXRGcm9tUG9pbnRzKCBjYWNoZWRBeGlzLCBhcnIyICk7XG5cdFx0XHRcdFx0aWYgKCBjYWNoZWRTYXRCb3VuZHMuaXNTZXBhcmF0ZWQoIGNhY2hlZFNhdEJvdW5kczIgKSApIHJldHVybiBmYWxzZTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdFx0aWYgKCB0YXJnZXQgKSB7XG5cblx0XHRcdFx0Ly8gVE9ETyBmaW5kIHR3byBwb2ludHMgdGhhdCBpbnRlcnNlY3Qgb24gdGhlIGVkZ2VzIGFuZCBtYWtlIHRoYXQgdGhlIHJlc3VsdFxuXHRcdFx0XHRpZiAoICEgc3VwcHJlc3NMb2cgKSB7XG5cblx0XHRcdFx0XHRjb25zb2xlLndhcm4oICdFeHRlbmRlZFRyaWFuZ2xlLmludGVyc2VjdHNUcmlhbmdsZTogVHJpYW5nbGVzIGFyZSBjb3BsYW5hciB3aGljaCBkb2VzIG5vdCBzdXBwb3J0IGFuIG91dHB1dCBlZGdlLiBTZXR0aW5nIGVkZ2UgdG8gMCwgMCwgMC4nICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRhcmdldC5zdGFydC5zZXQoIDAsIDAsIDAgKTtcblx0XHRcdFx0dGFyZ2V0LmVuZC5zZXQoIDAsIDAsIDAgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gdHJ1ZTtcblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdC8vIGZpbmQgdGhlIGVkZ2UgdGhhdCBpbnRlcnNlY3RzIHRoZSBvdGhlciB0cmlhbmdsZSBwbGFuZVxuXHRcdFx0Y29uc3QgY291bnQxID0gdHJpSW50ZXJzZWN0UGxhbmUoIHRoaXMsIHBsYW5lMiwgZWRnZTEgKTtcblx0XHRcdGlmICggY291bnQxID09PSAxICYmIG90aGVyLmNvbnRhaW5zUG9pbnQoIGVkZ2UxLmVuZCApICkge1xuXG5cdFx0XHRcdGlmICggdGFyZ2V0ICkge1xuXG5cdFx0XHRcdFx0dGFyZ2V0LnN0YXJ0LmNvcHkoIGVkZ2UxLmVuZCApO1xuXHRcdFx0XHRcdHRhcmdldC5lbmQuY29weSggZWRnZTEuZW5kICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0XHR9IGVsc2UgaWYgKCBjb3VudDEgIT09IDIgKSB7XG5cblx0XHRcdFx0cmV0dXJuIGZhbHNlO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGZpbmQgdGhlIG90aGVyIHRyaWFuZ2xlcyBlZGdlIHRoYXQgaW50ZXJzZWN0cyB0aGlzIHBsYW5lXG5cdFx0XHRjb25zdCBjb3VudDIgPSB0cmlJbnRlcnNlY3RQbGFuZSggb3RoZXIsIHBsYW5lMSwgZWRnZTIgKTtcblx0XHRcdGlmICggY291bnQyID09PSAxICYmIHRoaXMuY29udGFpbnNQb2ludCggZWRnZTIuZW5kICkgKSB7XG5cblx0XHRcdFx0aWYgKCB0YXJnZXQgKSB7XG5cblx0XHRcdFx0XHR0YXJnZXQuc3RhcnQuY29weSggZWRnZTIuZW5kICk7XG5cdFx0XHRcdFx0dGFyZ2V0LmVuZC5jb3B5KCBlZGdlMi5lbmQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdFx0cmV0dXJuIHRydWU7XG5cblx0XHRcdH0gZWxzZSBpZiAoIGNvdW50MiAhPT0gMiApIHtcblxuXHRcdFx0XHRyZXR1cm4gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdFx0Ly8gZmluZCBzd2FwIHRoZSBzZWNvbmQgZWRnZSBzbyBib3RoIGxpbmVzIGFyZSBydW5uaW5nIHRoZSBzYW1lIGRpcmVjdGlvblxuXHRcdFx0ZWRnZTEuZGVsdGEoIGRpcjEgKTtcblx0XHRcdGVkZ2UyLmRlbHRhKCBkaXIyICk7XG5cblx0XHRcdGlmICggZGlyMS5kb3QoIGRpcjIgKSA8IDAgKSB7XG5cblx0XHRcdFx0bGV0IHRtcCA9IGVkZ2UyLnN0YXJ0O1xuXHRcdFx0XHRlZGdlMi5zdGFydCA9IGVkZ2UyLmVuZDtcblx0XHRcdFx0ZWRnZTIuZW5kID0gdG1wO1xuXG5cdFx0XHR9XG5cblx0XHRcdC8vIGNoZWNrIGlmIHRoZSBlZGdlcyBhcmUgb3ZlcmxhcHBpbmdcblx0XHRcdGNvbnN0IHMxID0gZWRnZTEuc3RhcnQuZG90KCBkaXIxICk7XG5cdFx0XHRjb25zdCBlMSA9IGVkZ2UxLmVuZC5kb3QoIGRpcjEgKTtcblx0XHRcdGNvbnN0IHMyID0gZWRnZTIuc3RhcnQuZG90KCBkaXIxICk7XG5cdFx0XHRjb25zdCBlMiA9IGVkZ2UyLmVuZC5kb3QoIGRpcjEgKTtcblx0XHRcdGNvbnN0IHNlcGFyYXRlZDEgPSBlMSA8IHMyO1xuXHRcdFx0Y29uc3Qgc2VwYXJhdGVkMiA9IHMxIDwgZTI7XG5cblx0XHRcdGlmICggczEgIT09IGUyICYmIHMyICE9PSBlMSAmJiBzZXBhcmF0ZWQxID09PSBzZXBhcmF0ZWQyICkge1xuXG5cdFx0XHRcdHJldHVybiBmYWxzZTtcblxuXHRcdFx0fVxuXG5cdFx0XHQvLyBhc3NpZ24gdGhlIHRhcmdldCBvdXRwdXRcblx0XHRcdGlmICggdGFyZ2V0ICkge1xuXG5cdFx0XHRcdHRlbXBEaXIuc3ViVmVjdG9ycyggZWRnZTEuc3RhcnQsIGVkZ2UyLnN0YXJ0ICk7XG5cdFx0XHRcdGlmICggdGVtcERpci5kb3QoIGRpcjEgKSA+IDAgKSB7XG5cblx0XHRcdFx0XHR0YXJnZXQuc3RhcnQuY29weSggZWRnZTEuc3RhcnQgKTtcblxuXHRcdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdFx0dGFyZ2V0LnN0YXJ0LmNvcHkoIGVkZ2UyLnN0YXJ0ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHRcdHRlbXBEaXIuc3ViVmVjdG9ycyggZWRnZTEuZW5kLCBlZGdlMi5lbmQgKTtcblx0XHRcdFx0aWYgKCB0ZW1wRGlyLmRvdCggZGlyMSApIDwgMCApIHtcblxuXHRcdFx0XHRcdHRhcmdldC5lbmQuY29weSggZWRnZTEuZW5kICk7XG5cblx0XHRcdFx0fSBlbHNlIHtcblxuXHRcdFx0XHRcdHRhcmdldC5lbmQuY29weSggZWRnZTIuZW5kICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiB0cnVlO1xuXG5cdFx0fVxuXG5cdH07XG5cbn0gKSgpO1xuXG5cbkV4dGVuZGVkVHJpYW5nbGUucHJvdG90eXBlLmRpc3RhbmNlVG9Qb2ludCA9ICggZnVuY3Rpb24gKCkge1xuXG5cdGNvbnN0IHRhcmdldCA9IG5ldyBWZWN0b3IzKCk7XG5cdHJldHVybiBmdW5jdGlvbiBkaXN0YW5jZVRvUG9pbnQoIHBvaW50ICkge1xuXG5cdFx0dGhpcy5jbG9zZXN0UG9pbnRUb1BvaW50KCBwb2ludCwgdGFyZ2V0ICk7XG5cdFx0cmV0dXJuIHBvaW50LmRpc3RhbmNlVG8oIHRhcmdldCApO1xuXG5cdH07XG5cbn0gKSgpO1xuXG5cbkV4dGVuZGVkVHJpYW5nbGUucHJvdG90eXBlLmRpc3RhbmNlVG9UcmlhbmdsZSA9ICggZnVuY3Rpb24gKCkge1xuXG5cdGNvbnN0IHBvaW50ID0gbmV3IFZlY3RvcjMoKTtcblx0Y29uc3QgcG9pbnQyID0gbmV3IFZlY3RvcjMoKTtcblx0Y29uc3QgY29ybmVyRmllbGRzID0gWyAnYScsICdiJywgJ2MnIF07XG5cdGNvbnN0IGxpbmUxID0gbmV3IExpbmUzKCk7XG5cdGNvbnN0IGxpbmUyID0gbmV3IExpbmUzKCk7XG5cblx0cmV0dXJuIGZ1bmN0aW9uIGRpc3RhbmNlVG9UcmlhbmdsZSggb3RoZXIsIHRhcmdldDEgPSBudWxsLCB0YXJnZXQyID0gbnVsbCApIHtcblxuXHRcdGNvbnN0IGxpbmVUYXJnZXQgPSB0YXJnZXQxIHx8IHRhcmdldDIgPyBsaW5lMSA6IG51bGw7XG5cdFx0aWYgKCB0aGlzLmludGVyc2VjdHNUcmlhbmdsZSggb3RoZXIsIGxpbmVUYXJnZXQgKSApIHtcblxuXHRcdFx0aWYgKCB0YXJnZXQxIHx8IHRhcmdldDIgKSB7XG5cblx0XHRcdFx0aWYgKCB0YXJnZXQxICkgbGluZVRhcmdldC5nZXRDZW50ZXIoIHRhcmdldDEgKTtcblx0XHRcdFx0aWYgKCB0YXJnZXQyICkgbGluZVRhcmdldC5nZXRDZW50ZXIoIHRhcmdldDIgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRyZXR1cm4gMDtcblxuXHRcdH1cblxuXHRcdGxldCBjbG9zZXN0RGlzdGFuY2VTcSA9IEluZmluaXR5O1xuXG5cdFx0Ly8gY2hlY2sgYWxsIHBvaW50IGRpc3RhbmNlc1xuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XG5cblx0XHRcdGxldCBkaXN0O1xuXHRcdFx0Y29uc3QgZmllbGQgPSBjb3JuZXJGaWVsZHNbIGkgXTtcblx0XHRcdGNvbnN0IG90aGVyVmVjID0gb3RoZXJbIGZpZWxkIF07XG5cdFx0XHR0aGlzLmNsb3Nlc3RQb2ludFRvUG9pbnQoIG90aGVyVmVjLCBwb2ludCApO1xuXG5cdFx0XHRkaXN0ID0gb3RoZXJWZWMuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50ICk7XG5cblx0XHRcdGlmICggZGlzdCA8IGNsb3Nlc3REaXN0YW5jZVNxICkge1xuXG5cdFx0XHRcdGNsb3Nlc3REaXN0YW5jZVNxID0gZGlzdDtcblx0XHRcdFx0aWYgKCB0YXJnZXQxICkgdGFyZ2V0MS5jb3B5KCBwb2ludCApO1xuXHRcdFx0XHRpZiAoIHRhcmdldDIgKSB0YXJnZXQyLmNvcHkoIG90aGVyVmVjICk7XG5cblx0XHRcdH1cblxuXG5cdFx0XHRjb25zdCB0aGlzVmVjID0gdGhpc1sgZmllbGQgXTtcblx0XHRcdG90aGVyLmNsb3Nlc3RQb2ludFRvUG9pbnQoIHRoaXNWZWMsIHBvaW50ICk7XG5cblx0XHRcdGRpc3QgPSB0aGlzVmVjLmRpc3RhbmNlVG9TcXVhcmVkKCBwb2ludCApO1xuXG5cdFx0XHRpZiAoIGRpc3QgPCBjbG9zZXN0RGlzdGFuY2VTcSApIHtcblxuXHRcdFx0XHRjbG9zZXN0RGlzdGFuY2VTcSA9IGRpc3Q7XG5cdFx0XHRcdGlmICggdGFyZ2V0MSApIHRhcmdldDEuY29weSggdGhpc1ZlYyApO1xuXHRcdFx0XHRpZiAoIHRhcmdldDIgKSB0YXJnZXQyLmNvcHkoIHBvaW50ICk7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGYxMSA9IGNvcm5lckZpZWxkc1sgaSBdO1xuXHRcdFx0Y29uc3QgZjEyID0gY29ybmVyRmllbGRzWyAoIGkgKyAxICkgJSAzIF07XG5cdFx0XHRsaW5lMS5zZXQoIHRoaXNbIGYxMSBdLCB0aGlzWyBmMTIgXSApO1xuXHRcdFx0Zm9yICggbGV0IGkyID0gMDsgaTIgPCAzOyBpMiArKyApIHtcblxuXHRcdFx0XHRjb25zdCBmMjEgPSBjb3JuZXJGaWVsZHNbIGkyIF07XG5cdFx0XHRcdGNvbnN0IGYyMiA9IGNvcm5lckZpZWxkc1sgKCBpMiArIDEgKSAlIDMgXTtcblx0XHRcdFx0bGluZTIuc2V0KCBvdGhlclsgZjIxIF0sIG90aGVyWyBmMjIgXSApO1xuXG5cdFx0XHRcdGNsb3Nlc3RQb2ludHNTZWdtZW50VG9TZWdtZW50KCBsaW5lMSwgbGluZTIsIHBvaW50LCBwb2ludDIgKTtcblxuXHRcdFx0XHRjb25zdCBkaXN0ID0gcG9pbnQuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50MiApO1xuXHRcdFx0XHRpZiAoIGRpc3QgPCBjbG9zZXN0RGlzdGFuY2VTcSApIHtcblxuXHRcdFx0XHRcdGNsb3Nlc3REaXN0YW5jZVNxID0gZGlzdDtcblx0XHRcdFx0XHRpZiAoIHRhcmdldDEgKSB0YXJnZXQxLmNvcHkoIHBvaW50ICk7XG5cdFx0XHRcdFx0aWYgKCB0YXJnZXQyICkgdGFyZ2V0Mi5jb3B5KCBwb2ludDIgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiBNYXRoLnNxcnQoIGNsb3Nlc3REaXN0YW5jZVNxICk7XG5cblx0fTtcblxufSApKCk7XG4iXSwibmFtZXMiOlsiVHJpYW5nbGUiLCJWZWN0b3IzIiwiTGluZTMiLCJTcGhlcmUiLCJQbGFuZSIsIlNlcGFyYXRpbmdBeGlzQm91bmRzIiwiY2xvc2VzdFBvaW50c1NlZ21lbnRUb1NlZ21lbnQiLCJzcGhlcmVJbnRlcnNlY3RUcmlhbmdsZSIsIlpFUk9fRVBTSUxPTiIsImlzTmVhclplcm8iLCJ2YWx1ZSIsIk1hdGgiLCJhYnMiLCJFeHRlbmRlZFRyaWFuZ2xlIiwiY29uc3RydWN0b3IiLCJhcmdzIiwiaXNFeHRlbmRlZFRyaWFuZ2xlIiwic2F0QXhlcyIsIkFycmF5IiwiZmlsbCIsIm1hcCIsInNhdEJvdW5kcyIsInBvaW50cyIsImEiLCJiIiwiYyIsInNwaGVyZSIsInBsYW5lIiwibmVlZHNVcGRhdGUiLCJpbnRlcnNlY3RzU3BoZXJlIiwidXBkYXRlIiwiYXhpczAiLCJzYWIwIiwiZ2V0Tm9ybWFsIiwic2V0RnJvbVBvaW50cyIsImF4aXMxIiwic2FiMSIsInN1YlZlY3RvcnMiLCJheGlzMiIsInNhYjIiLCJheGlzMyIsInNhYjMiLCJzZXRGcm9tTm9ybWFsQW5kQ29wbGFuYXJQb2ludCIsInByb3RvdHlwZSIsImNsb3Nlc3RQb2ludFRvU2VnbWVudCIsInBvaW50MSIsInBvaW50MiIsImVkZ2UiLCJkaXN0YW5jZVRvU2VnbWVudCIsInNlZ21lbnQiLCJ0YXJnZXQxIiwidGFyZ2V0MiIsInN0YXJ0IiwiZW5kIiwiZGlzdFNxIiwiY2xvc2VzdERpc3RhbmNlU3EiLCJJbmZpbml0eSIsImkiLCJuZXh0aSIsImNvcHkiLCJkaXN0YW5jZVRvU3F1YXJlZCIsImNsb3Nlc3RQb2ludFRvUG9pbnQiLCJzcXJ0IiwiaW50ZXJzZWN0c1RyaWFuZ2xlIiwic2FUcmkyIiwiYXJyMSIsImFycjIiLCJjYWNoZWRTYXRCb3VuZHMiLCJjYWNoZWRTYXRCb3VuZHMyIiwiY2FjaGVkQXhpcyIsImRpciIsImRpcjEiLCJkaXIyIiwidGVtcERpciIsImVkZ2UxIiwiZWRnZTIiLCJ0ZW1wUG9pbnQiLCJ0cmlJbnRlcnNlY3RQbGFuZSIsInRyaSIsInRhcmdldEVkZ2UiLCJjb3VudCIsInN0YXJ0UG9pbnRJbnRlcnNlY3Rpb24iLCJkZWx0YSIsInN0YXJ0SW50ZXJzZWN0cyIsImRpc3RhbmNlVG9Qb2ludCIsIm5vcm1hbCIsImRvdCIsImRvZXNJbnRlcnNlY3QiLCJpbnRlcnNlY3RMaW5lIiwiZGlzdGFuY2VUbyIsInBvaW50Iiwib3RoZXIiLCJ0YXJnZXQiLCJzdXBwcmVzc0xvZyIsInBsYW5lMSIsInBsYW5lMiIsInNhdEJvdW5kczEiLCJzYXRBeGVzMSIsInNiIiwic2EiLCJpc1NlcGFyYXRlZCIsInNhdEJvdW5kczIiLCJzYXRBeGVzMiIsInNhMSIsImkyIiwic2EyIiwiY3Jvc3NWZWN0b3JzIiwiY29uc29sZSIsIndhcm4iLCJzZXQiLCJjb3VudDEiLCJjb250YWluc1BvaW50IiwiY291bnQyIiwidG1wIiwiczEiLCJlMSIsInMyIiwiZTIiLCJzZXBhcmF0ZWQxIiwic2VwYXJhdGVkMiIsImRpc3RhbmNlVG9UcmlhbmdsZSIsImNvcm5lckZpZWxkcyIsImxpbmUxIiwibGluZTIiLCJsaW5lVGFyZ2V0IiwiZ2V0Q2VudGVyIiwiZGlzdCIsImZpZWxkIiwib3RoZXJWZWMiLCJ0aGlzVmVjIiwiZjExIiwiZjEyIiwiZjIxIiwiZjIyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/math/ExtendedTriangle.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/math/MathUtilities.js":
/*!**********************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/math/MathUtilities.js ***!
  \**********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   closestPointLineToLine: () => (/* binding */ closestPointLineToLine),\n/* harmony export */   closestPointsSegmentToSegment: () => (/* binding */ closestPointsSegmentToSegment),\n/* harmony export */   sphereIntersectTriangle: () => (/* binding */ sphereIntersectTriangle)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n\nconst closestPointLineToLine = function() {\n    // https://github.com/juj/MathGeoLib/blob/master/src/Geometry/Line.cpp#L56\n    const dir1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const dir2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const v02 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    return function closestPointLineToLine(l1, l2, result) {\n        const v0 = l1.start;\n        const v10 = dir1;\n        const v2 = l2.start;\n        const v32 = dir2;\n        v02.subVectors(v0, v2);\n        dir1.subVectors(l1.end, l1.start);\n        dir2.subVectors(l2.end, l2.start);\n        // float d0232 = v02.Dot(v32);\n        const d0232 = v02.dot(v32);\n        // float d3210 = v32.Dot(v10);\n        const d3210 = v32.dot(v10);\n        // float d3232 = v32.Dot(v32);\n        const d3232 = v32.dot(v32);\n        // float d0210 = v02.Dot(v10);\n        const d0210 = v02.dot(v10);\n        // float d1010 = v10.Dot(v10);\n        const d1010 = v10.dot(v10);\n        // float denom = d1010*d3232 - d3210*d3210;\n        const denom = d1010 * d3232 - d3210 * d3210;\n        let d, d2;\n        if (denom !== 0) {\n            d = (d0232 * d3210 - d0210 * d3232) / denom;\n        } else {\n            d = 0;\n        }\n        d2 = (d0232 + d * d3210) / d3232;\n        result.x = d;\n        result.y = d2;\n    };\n}();\nconst closestPointsSegmentToSegment = function() {\n    // https://github.com/juj/MathGeoLib/blob/master/src/Geometry/LineSegment.cpp#L187\n    const paramResult = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n    const temp1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const temp2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    return function closestPointsSegmentToSegment(l1, l2, target1, target2) {\n        closestPointLineToLine(l1, l2, paramResult);\n        let d = paramResult.x;\n        let d2 = paramResult.y;\n        if (d >= 0 && d <= 1 && d2 >= 0 && d2 <= 1) {\n            l1.at(d, target1);\n            l2.at(d2, target2);\n            return;\n        } else if (d >= 0 && d <= 1) {\n            // Only d2 is out of bounds.\n            if (d2 < 0) {\n                l2.at(0, target2);\n            } else {\n                l2.at(1, target2);\n            }\n            l1.closestPointToPoint(target2, true, target1);\n            return;\n        } else if (d2 >= 0 && d2 <= 1) {\n            // Only d is out of bounds.\n            if (d < 0) {\n                l1.at(0, target1);\n            } else {\n                l1.at(1, target1);\n            }\n            l2.closestPointToPoint(target1, true, target2);\n            return;\n        } else {\n            // Both u and u2 are out of bounds.\n            let p;\n            if (d < 0) {\n                p = l1.start;\n            } else {\n                p = l1.end;\n            }\n            let p2;\n            if (d2 < 0) {\n                p2 = l2.start;\n            } else {\n                p2 = l2.end;\n            }\n            const closestPoint = temp1;\n            const closestPoint2 = temp2;\n            l1.closestPointToPoint(p2, true, temp1);\n            l2.closestPointToPoint(p, true, temp2);\n            if (closestPoint.distanceToSquared(p2) <= closestPoint2.distanceToSquared(p)) {\n                target1.copy(closestPoint);\n                target2.copy(p2);\n                return;\n            } else {\n                target1.copy(p);\n                target2.copy(closestPoint2);\n                return;\n            }\n        }\n    };\n}();\nconst sphereIntersectTriangle = function() {\n    // https://stackoverflow.com/questions/34043955/detect-collision-between-sphere-and-triangle-in-three-js\n    const closestPointTemp = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const projectedPointTemp = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const planeTemp = new three__WEBPACK_IMPORTED_MODULE_0__.Plane();\n    const lineTemp = new three__WEBPACK_IMPORTED_MODULE_0__.Line3();\n    return function sphereIntersectTriangle(sphere, triangle) {\n        const { radius, center } = sphere;\n        const { a, b, c } = triangle;\n        // phase 1\n        lineTemp.start = a;\n        lineTemp.end = b;\n        const closestPoint1 = lineTemp.closestPointToPoint(center, true, closestPointTemp);\n        if (closestPoint1.distanceTo(center) <= radius) return true;\n        lineTemp.start = a;\n        lineTemp.end = c;\n        const closestPoint2 = lineTemp.closestPointToPoint(center, true, closestPointTemp);\n        if (closestPoint2.distanceTo(center) <= radius) return true;\n        lineTemp.start = b;\n        lineTemp.end = c;\n        const closestPoint3 = lineTemp.closestPointToPoint(center, true, closestPointTemp);\n        if (closestPoint3.distanceTo(center) <= radius) return true;\n        // phase 2\n        const plane = triangle.getPlane(planeTemp);\n        const dp = Math.abs(plane.distanceToPoint(center));\n        if (dp <= radius) {\n            const pp = plane.projectPoint(center, projectedPointTemp);\n            const cp = triangle.containsPoint(pp);\n            if (cp) return true;\n        }\n        return false;\n    };\n}();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9tYXRoL01hdGhVdGlsaXRpZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7OztBQUF1RDtBQUVoRCxNQUFNSSx5QkFBeUI7SUFFckMsMEVBQTBFO0lBQzFFLE1BQU1DLE9BQU8sSUFBSUwsMENBQU9BO0lBQ3hCLE1BQU1NLE9BQU8sSUFBSU4sMENBQU9BO0lBQ3hCLE1BQU1PLE1BQU0sSUFBSVAsMENBQU9BO0lBQ3ZCLE9BQU8sU0FBU0ksdUJBQXdCSSxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsTUFBTTtRQUVyRCxNQUFNQyxLQUFLSCxHQUFHSSxLQUFLO1FBQ25CLE1BQU1DLE1BQU1SO1FBQ1osTUFBTVMsS0FBS0wsR0FBR0csS0FBSztRQUNuQixNQUFNRyxNQUFNVDtRQUVaQyxJQUFJUyxVQUFVLENBQUVMLElBQUlHO1FBQ3BCVCxLQUFLVyxVQUFVLENBQUVSLEdBQUdTLEdBQUcsRUFBRVQsR0FBR0ksS0FBSztRQUNqQ04sS0FBS1UsVUFBVSxDQUFFUCxHQUFHUSxHQUFHLEVBQUVSLEdBQUdHLEtBQUs7UUFFakMsOEJBQThCO1FBQzlCLE1BQU1NLFFBQVFYLElBQUlZLEdBQUcsQ0FBRUo7UUFFdkIsOEJBQThCO1FBQzlCLE1BQU1LLFFBQVFMLElBQUlJLEdBQUcsQ0FBRU47UUFFdkIsOEJBQThCO1FBQzlCLE1BQU1RLFFBQVFOLElBQUlJLEdBQUcsQ0FBRUo7UUFFdkIsOEJBQThCO1FBQzlCLE1BQU1PLFFBQVFmLElBQUlZLEdBQUcsQ0FBRU47UUFFdkIsOEJBQThCO1FBQzlCLE1BQU1VLFFBQVFWLElBQUlNLEdBQUcsQ0FBRU47UUFFdkIsMkNBQTJDO1FBQzNDLE1BQU1XLFFBQVFELFFBQVFGLFFBQVFELFFBQVFBO1FBRXRDLElBQUlLLEdBQUdDO1FBQ1AsSUFBS0YsVUFBVSxHQUFJO1lBRWxCQyxJQUFJLENBQUVQLFFBQVFFLFFBQVFFLFFB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QyxLQUFLLEdBQUd3QztRQUNqQkwsU0FBUzlCLEdBQUcsR0FBR29DO1FBQ2YsTUFBTUUsZ0JBQWdCUixTQUFTWCxtQkFBbUIsQ0FBRWUsUUFBUSxNQUFNUDtRQUNsRSxJQUFLVyxjQUFjQyxVQUFVLENBQUVMLFdBQVlELFFBQVMsT0FBTztRQUUzREgsU0FBU25DLEtBQUssR0FBR3dDO1FBQ2pCTCxTQUFTOUIsR0FBRyxHQUFHcUM7UUFDZixNQUFNZCxnQkFBZ0JPLFNBQVNYLG1CQUFtQixDQUFFZSxRQUFRLE1BQU1QO1FBQ2xFLElBQUtKLGNBQWNnQixVQUFVLENBQUVMLFdBQVlELFFBQVMsT0FBTztRQUUzREgsU0FBU25DLEtBQUssR0FBR3lDO1FBQ2pCTixTQUFTOUIsR0FBRyxHQUFHcUM7UUFDZixNQUFNRyxnQkFBZ0JWLFNBQVNYLG1CQUFtQixDQUFFZSxRQUFRLE1BQU1QO1FBQ2xFLElBQUthLGNBQWNELFVBQVUsQ0FBRUwsV0FBWUQsUUFBUyxPQUFPO1FBRTNELFVBQVU7UUFDVixNQUFNUSxRQUFRVCxTQUFTVSxRQUFRLENBQUViO1FBQ2pDLE1BQU1jLEtBQUtDLEtBQUtDLEdBQUcsQ0FBRUosTUFBTUssZUFBZSxDQUFFWjtRQUM1QyxJQUFLUyxNQUFNVixRQUFTO1lBRW5CLE1BQU1jLEtBQUtOLE1BQU1PLFlBQVksQ0FBRWQsUUFBUU47WUFDdkMsTUFBTXFCLEtBQUtqQixTQUFTa0IsYUFBYSxDQUFFSDtZQUNuQyxJQUFLRSxJQUFLLE9BQU87UUFFbEI7UUFFQSxPQUFPO0lBRVI7QUFFRCxJQUFNIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmliZS0zZC1jb2RlLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvbWF0aC9NYXRoVXRpbGl0aWVzLmpzP2RjNDQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVmVjdG9yMywgVmVjdG9yMiwgUGxhbmUsIExpbmUzIH0gZnJvbSAndGhyZWUnO1xuXG5leHBvcnQgY29uc3QgY2xvc2VzdFBvaW50TGluZVRvTGluZSA9ICggZnVuY3Rpb24gKCkge1xuXG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qdWovTWF0aEdlb0xpYi9ibG9iL21hc3Rlci9zcmMvR2VvbWV0cnkvTGluZS5jcHAjTDU2XG5cdGNvbnN0IGRpcjEgPSBuZXcgVmVjdG9yMygpO1xuXHRjb25zdCBkaXIyID0gbmV3IFZlY3RvcjMoKTtcblx0Y29uc3QgdjAyID0gbmV3IFZlY3RvcjMoKTtcblx0cmV0dXJuIGZ1bmN0aW9uIGNsb3Nlc3RQb2ludExpbmVUb0xpbmUoIGwxLCBsMiwgcmVzdWx0ICkge1xuXG5cdFx0Y29uc3QgdjAgPSBsMS5zdGFydDtcblx0XHRjb25zdCB2MTAgPSBkaXIxO1xuXHRcdGNvbnN0IHYyID0gbDIuc3RhcnQ7XG5cdFx0Y29uc3QgdjMyID0gZGlyMjtcblxuXHRcdHYwMi5zdWJWZWN0b3JzKCB2MCwgdjIgKTtcblx0XHRkaXIxLnN1YlZlY3RvcnMoIGwxLmVuZCwgbDEuc3RhcnQgKTtcblx0XHRkaXIyLnN1YlZlY3RvcnMoIGwyLmVuZCwgbDIuc3RhcnQgKTtcblxuXHRcdC8vIGZsb2F0IGQwMjMyID0gdjAyLkRvdCh2MzIpO1xuXHRcdGNvbnN0IGQwMjMyID0gdjAyLmRvdCggdjMyICk7XG5cblx0XHQvLyBmbG9hdCBkMzIxMCA9IHYzMi5Eb3QodjEwKTtcblx0XHRjb25zdCBkMzIxMCA9IHYzMi5kb3QoIHYxMCApO1xuXG5cdFx0Ly8gZmxvYXQgZDMyMzIgPSB2MzIuRG90KHYzMik7XG5cdFx0Y29uc3QgZDMyMzIgPSB2MzIuZG90KCB2MzIgKTtcblxuXHRcdC8vIGZsb2F0IGQwMjEwID0gdjAyLkRvdCh2MTApO1xuXHRcdGNvbnN0IGQwMjEwID0gdjAyLmRvdCggdjEwICk7XG5cblx0XHQvLyBmbG9hdCBkMTAxMCA9IHYxMC5Eb3QodjEwKTtcblx0XHRjb25zdCBkMTAxMCA9IHYxMC5kb3QoIHYxMCApO1xuXG5cdFx0Ly8gZmxvYXQgZGVub20gPSBkMTAxMCpkMzIzMiAtIGQzMjEwKmQzMjEwO1xuXHRcdGNvbnN0IGRlbm9tID0gZDEwMTAgKiBkMzIzMiAtIGQzMjEwICogZDMyMTA7XG5cblx0XHRsZXQgZCwgZDI7XG5cdFx0aWYgKCBkZW5vbSAhPT0gMCApIHtcblxuXHRcdFx0ZCA9ICggZDAyMzIgKiBkMzIxMCAtIGQwMjEwICogZDMyMzIgKSAvIGRlbm9tO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0ZCA9IDA7XG5cblx0XHR9XG5cblx0XHRkMiA9ICggZDAyMzIgKyBkICogZDMyMTAgKSAvIGQzMjMyO1xuXG5cdFx0cmVzdWx0LnggPSBkO1xuXHRcdHJlc3VsdC55ID0gZDI7XG5cblx0fTtcblxufSApKCk7XG5cbmV4cG9ydCBjb25zdCBjbG9zZXN0UG9pbnRzU2VnbWVudFRvU2VnbWVudCA9ICggZnVuY3Rpb24gKCkge1xuXG5cdC8vIGh0dHBzOi8vZ2l0aHViLmNvbS9qdWovTWF0aEdlb0xpYi9ibG9iL21hc3Rlci9zcmMvR2VvbWV0cnkvTGluZVNlZ21lbnQuY3BwI0wxODdcblx0Y29uc3QgcGFyYW1SZXN1bHQgPSBuZXcgVmVjdG9yMigpO1xuXHRjb25zdCB0ZW1wMSA9IG5ldyBWZWN0b3IzKCk7XG5cdGNvbnN0IHRlbXAyID0gbmV3IFZlY3RvcjMoKTtcblx0cmV0dXJuIGZ1bmN0aW9uIGNsb3Nlc3RQb2ludHNTZWdtZW50VG9TZWdtZW50KCBsMSwgbDIsIHRhcmdldDEsIHRhcmdldDIgKSB7XG5cblx0XHRjbG9zZXN0UG9pbnRMaW5lVG9MaW5lKCBsMSwgbDIsIHBhcmFtUmVzdWx0ICk7XG5cblx0XHRsZXQgZCA9IHBhcmFtUmVzdWx0Lng7XG5cdFx0bGV0IGQyID0gcGFyYW1SZXN1bHQueTtcblx0XHRpZiAoIGQgPj0gMCAmJiBkIDw9IDEgJiYgZDIgPj0gMCAmJiBkMiA8PSAxICkge1xuXG5cdFx0XHRsMS5hdCggZCwgdGFyZ2V0MSApO1xuXHRcdFx0bDIuYXQoIGQyLCB0YXJnZXQyICk7XG5cblx0XHRcdHJldHVybjtcblxuXHRcdH0gZWxzZSBpZiAoIGQgPj0gMCAmJiBkIDw9IDEgKSB7XG5cblx0XHRcdC8vIE9ubHkgZDIgaXMgb3V0IG9mIGJvdW5kcy5cblx0XHRcdGlmICggZDIgPCAwICkge1xuXG5cdFx0XHRcdGwyLmF0KCAwLCB0YXJnZXQyICk7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0bDIuYXQoIDEsIHRhcmdldDIgKTtcblxuXHRcdFx0fVxuXG5cdFx0XHRsMS5jbG9zZXN0UG9pbnRUb1BvaW50KCB0YXJnZXQyLCB0cnVlLCB0YXJnZXQxICk7XG5cdFx0XHRyZXR1cm47XG5cblx0XHR9IGVsc2UgaWYgKCBkMiA+PSAwICYmIGQyIDw9IDEgKSB7XG5cblx0XHRcdC8vIE9ubHkgZCBpcyBvdXQgb2YgYm91bmRzLlxuXHRcdFx0aWYgKCBkIDwgMCApIHtcblxuXHRcdFx0XHRsMS5hdCggMCwgdGFyZ2V0MSApO1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdGwxLmF0KCAxLCB0YXJnZXQxICk7XG5cblx0XHRcdH1cblxuXHRcdFx0bDIuY2xvc2VzdFBvaW50VG9Qb2ludCggdGFyZ2V0MSwgdHJ1ZSwgdGFyZ2V0MiApO1xuXHRcdFx0cmV0dXJuO1xuXG5cdFx0fSBlbHNlIHtcblxuXHRcdFx0Ly8gQm90aCB1IGFuZCB1MiBhcmUgb3V0IG9mIGJvdW5kcy5cblx0XHRcdGxldCBwO1xuXHRcdFx0aWYgKCBkIDwgMCApIHtcblxuXHRcdFx0XHRwID0gbDEuc3RhcnQ7XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0cCA9IGwxLmVuZDtcblxuXHRcdFx0fVxuXG5cdFx0XHRsZXQgcDI7XG5cdFx0XHRpZiAoIGQyIDwgMCApIHtcblxuXHRcdFx0XHRwMiA9IGwyLnN0YXJ0O1xuXG5cdFx0XHR9IGVsc2Uge1xuXG5cdFx0XHRcdHAyID0gbDIuZW5kO1xuXG5cdFx0XHR9XG5cblx0XHRcdGNvbnN0IGNsb3Nlc3RQb2ludCA9IHRlbXAxO1xuXHRcdFx0Y29uc3QgY2xvc2VzdFBvaW50MiA9IHRlbXAyO1xuXHRcdFx0bDEuY2xvc2VzdFBvaW50VG9Qb2ludCggcDIsIHRydWUsIHRlbXAxICk7XG5cdFx0XHRsMi5jbG9zZXN0UG9pbnRUb1BvaW50KCBwLCB0cnVlLCB0ZW1wMiApO1xuXG5cdFx0XHRpZiAoIGNsb3Nlc3RQb2ludC5kaXN0YW5jZVRvU3F1YXJlZCggcDIgKSA8PSBjbG9zZXN0UG9pbnQyLmRpc3RhbmNlVG9TcXVhcmVkKCBwICkgKSB7XG5cblx0XHRcdFx0dGFyZ2V0MS5jb3B5KCBjbG9zZXN0UG9pbnQgKTtcblx0XHRcdFx0dGFyZ2V0Mi5jb3B5KCBwMiApO1xuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdH0gZWxzZSB7XG5cblx0XHRcdFx0dGFyZ2V0MS5jb3B5KCBwICk7XG5cdFx0XHRcdHRhcmdldDIuY29weSggY2xvc2VzdFBvaW50MiApO1xuXHRcdFx0XHRyZXR1cm47XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9O1xuXG59ICkoKTtcblxuXG5leHBvcnQgY29uc3Qgc3BoZXJlSW50ZXJzZWN0VHJpYW5nbGUgPSAoIGZ1bmN0aW9uICgpIHtcblxuXHQvLyBodHRwczovL3N0YWNrb3ZlcmZsb3cuY29tL3F1ZXN0aW9ucy8zNDA0Mzk1NS9kZXRlY3QtY29sbGlzaW9uLWJldHdlZW4tc3BoZXJlLWFuZC10cmlhbmdsZS1pbi10aHJlZS1qc1xuXHRjb25zdCBjbG9zZXN0UG9pbnRUZW1wID0gbmV3IFZlY3RvcjMoKTtcblx0Y29uc3QgcHJvamVjdGVkUG9pbnRUZW1wID0gbmV3IFZlY3RvcjMoKTtcblx0Y29uc3QgcGxhbmVUZW1wID0gbmV3IFBsYW5lKCk7XG5cdGNvbnN0IGxpbmVUZW1wID0gbmV3IExpbmUzKCk7XG5cdHJldHVybiBmdW5jdGlvbiBzcGhlcmVJbnRlcnNlY3RUcmlhbmdsZSggc3BoZXJlLCB0cmlhbmdsZSApIHtcblxuXHRcdGNvbnN0IHsgcmFkaXVzLCBjZW50ZXIgfSA9IHNwaGVyZTtcblx0XHRjb25zdCB7IGEsIGIsIGMgfSA9IHRyaWFuZ2xlO1xuXG5cdFx0Ly8gcGhhc2UgMVxuXHRcdGxpbmVUZW1wLnN0YXJ0ID0gYTtcblx0XHRsaW5lVGVtcC5lbmQgPSBiO1xuXHRcdGNvbnN0IGNsb3Nlc3RQb2ludDEgPSBsaW5lVGVtcC5jbG9zZXN0UG9pbnRUb1BvaW50KCBjZW50ZXIsIHRydWUsIGNsb3Nlc3RQb2ludFRlbXAgKTtcblx0XHRpZiAoIGNsb3Nlc3RQb2ludDEuZGlzdGFuY2VUbyggY2VudGVyICkgPD0gcmFkaXVzICkgcmV0dXJuIHRydWU7XG5cblx0XHRsaW5lVGVtcC5zdGFydCA9IGE7XG5cdFx0bGluZVRlbXAuZW5kID0gYztcblx0XHRjb25zdCBjbG9zZXN0UG9pbnQyID0gbGluZVRlbXAuY2xvc2VzdFBvaW50VG9Qb2ludCggY2VudGVyLCB0cnVlLCBjbG9zZXN0UG9pbnRUZW1wICk7XG5cdFx0aWYgKCBjbG9zZXN0UG9pbnQyLmRpc3RhbmNlVG8oIGNlbnRlciApIDw9IHJhZGl1cyApIHJldHVybiB0cnVlO1xuXG5cdFx0bGluZVRlbXAuc3RhcnQgPSBiO1xuXHRcdGxpbmVUZW1wLmVuZCA9IGM7XG5cdFx0Y29uc3QgY2xvc2VzdFBvaW50MyA9IGxpbmVUZW1wLmNsb3Nlc3RQb2ludFRvUG9pbnQoIGNlbnRlciwgdHJ1ZSwgY2xvc2VzdFBvaW50VGVtcCApO1xuXHRcdGlmICggY2xvc2VzdFBvaW50My5kaXN0YW5jZVRvKCBjZW50ZXIgKSA8PSByYWRpdXMgKSByZXR1cm4gdHJ1ZTtcblxuXHRcdC8vIHBoYXNlIDJcblx0XHRjb25zdCBwbGFuZSA9IHRyaWFuZ2xlLmdldFBsYW5lKCBwbGFuZVRlbXAgKTtcblx0XHRjb25zdCBkcCA9IE1hdGguYWJzKCBwbGFuZS5kaXN0YW5jZVRvUG9pbnQoIGNlbnRlciApICk7XG5cdFx0aWYgKCBkcCA8PSByYWRpdXMgKSB7XG5cblx0XHRcdGNvbnN0IHBwID0gcGxhbmUucHJvamVjdFBvaW50KCBjZW50ZXIsIHByb2plY3RlZFBvaW50VGVtcCApO1xuXHRcdFx0Y29uc3QgY3AgPSB0cmlhbmdsZS5jb250YWluc1BvaW50KCBwcCApO1xuXHRcdFx0aWYgKCBjcCApIHJldHVybiB0cnVlO1xuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIGZhbHNlO1xuXG5cdH07XG5cbn0gKSgpO1xuIl0sIm5hbWVzIjpbIlZlY3RvcjMiLCJWZWN0b3IyIiwiUGxhbmUiLCJMaW5lMyIsImNsb3Nlc3RQb2ludExpbmVUb0xpbmUiLCJkaXIxIiwiZGlyMiIsInYwMiIsImwxIiwibDIiLCJyZXN1bHQiLCJ2MCIsInN0YXJ0IiwidjEwIiwidjIiLCJ2MzIiLCJzdWJWZWN0b3JzIiwiZW5kIiwiZDAyMzIiLCJkb3QiLCJkMzIxMCIsImQzMjMyIiwiZDAyMTAiLCJkMTAxMCIsImRlbm9tIiwiZCIsImQyIiwieCIsInkiLCJjbG9zZXN0UG9pbnRzU2VnbWVudFRvU2VnbWVudCIsInBhcmFtUmVzdWx0IiwidGVtcDEiLCJ0ZW1wMiIsInRhcmdldDEiLCJ0YXJnZXQyIiwiYXQiLCJjbG9zZXN0UG9pbnRUb1BvaW50IiwicCIsInAyIiwiY2xvc2VzdFBvaW50IiwiY2xvc2VzdFBvaW50MiIsImRpc3RhbmNlVG9TcXVhcmVkIiwiY29weSIsInNwaGVyZUludGVyc2VjdFRyaWFuZ2xlIiwiY2xvc2VzdFBvaW50VGVtcCIsInByb2plY3RlZFBvaW50VGVtcCIsInBsYW5lVGVtcCIsImxpbmVUZW1wIiwic3BoZXJlIiwidHJpYW5nbGUiLCJyYWRpdXMiLCJjZW50ZXIiLCJhIiwiYiIsImMiLCJjbG9zZXN0UG9pbnQxIiwiZGlzdGFuY2VUbyIsImNsb3Nlc3RQb2ludDMiLCJwbGFuZSIsImdldFBsYW5lIiwiZHAiLCJNYXRoIiwiYWJzIiwiZGlzdGFuY2VUb1BvaW50IiwicHAiLCJwcm9qZWN0UG9pbnQiLCJjcCIsImNvbnRhaW5zUG9pbnQiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/math/MathUtilities.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/math/OrientedBox.js":
/*!********************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/math/OrientedBox.js ***!
  \********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   OrientedBox: () => (/* binding */ OrientedBox)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var _SeparatingAxisBounds_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./SeparatingAxisBounds.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/math/SeparatingAxisBounds.js\");\n/* harmony import */ var _ExtendedTriangle_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./ExtendedTriangle.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/math/ExtendedTriangle.js\");\n/* harmony import */ var _MathUtilities_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./MathUtilities.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/math/MathUtilities.js\");\n\n\n\n\nclass OrientedBox {\n    constructor(min, max, matrix){\n        this.isOrientedBox = true;\n        this.min = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.max = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        this.matrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        this.invMatrix = new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\n        this.points = new Array(8).fill().map(()=>new three__WEBPACK_IMPORTED_MODULE_0__.Vector3());\n        this.satAxes = new Array(3).fill().map(()=>new three__WEBPACK_IMPORTED_MODULE_0__.Vector3());\n        this.satBounds = new Array(3).fill().map(()=>new _SeparatingAxisBounds_js__WEBPACK_IMPORTED_MODULE_1__.SeparatingAxisBounds());\n        this.alignedSatBounds = new Array(3).fill().map(()=>new _SeparatingAxisBounds_js__WEBPACK_IMPORTED_MODULE_1__.SeparatingAxisBounds());\n        this.needsUpdate = false;\n        if (min) this.min.copy(min);\n        if (max) this.max.copy(max);\n        if (matrix) this.matrix.copy(matrix);\n    }\n    set(min, max, matrix) {\n        this.min.copy(min);\n        this.max.copy(max);\n        this.matrix.copy(matrix);\n        this.needsUpdate = true;\n    }\n    copy(other) {\n        this.min.copy(other.min);\n        this.max.copy(other.max);\n        this.matrix.copy(other.matrix);\n        this.needsUpdate = true;\n    }\n}\nOrientedBox.prototype.update = function() {\n    return function update() {\n        const matrix = this.matrix;\n        const min = this.min;\n        const max = this.max;\n        const points = this.points;\n        for(let x = 0; x <= 1; x++){\n            for(let y = 0; y <= 1; y++){\n                for(let z = 0; z <= 1; z++){\n                    const i = (1 << 0) * x | (1 << 1) * y | (1 << 2) * z;\n                    const v = points[i];\n                    v.x = x ? max.x : min.x;\n                    v.y = y ? max.y : min.y;\n                    v.z = z ? max.z : min.z;\n                    v.applyMatrix4(matrix);\n                }\n            }\n        }\n        const satBounds = this.satBounds;\n        const satAxes = this.satAxes;\n        const minVec = points[0];\n        for(let i = 0; i < 3; i++){\n            const axis = satAxes[i];\n            const sb = satBounds[i];\n            const index = 1 << i;\n            const pi = points[index];\n            axis.subVectors(minVec, pi);\n            sb.setFromPoints(axis, points);\n        }\n        const alignedSatBounds = this.alignedSatBounds;\n        alignedSatBounds[0].setFromPointsField(points, \"x\");\n        alignedSatBounds[1].setFromPointsField(points, \"y\");\n        alignedSatBounds[2].setFromPointsField(points, \"z\");\n        this.invMatrix.copy(this.matrix).invert();\n        this.needsUpdate = false;\n    };\n}();\nOrientedBox.prototype.intersectsBox = function() {\n    const aabbBounds = new _SeparatingAxisBounds_js__WEBPACK_IMPORTED_MODULE_1__.SeparatingAxisBounds();\n    return function intersectsBox(box) {\n        // TODO: should this be doing SAT against the AABB?\n        if (this.needsUpdate) {\n            this.update();\n        }\n        const min = box.min;\n        const max = box.max;\n        const satBounds = this.satBounds;\n        const satAxes = this.satAxes;\n        const alignedSatBounds = this.alignedSatBounds;\n        aabbBounds.min = min.x;\n        aabbBounds.max = max.x;\n        if (alignedSatBounds[0].isSeparated(aabbBounds)) return false;\n        aabbBounds.min = min.y;\n        aabbBounds.max = max.y;\n        if (alignedSatBounds[1].isSeparated(aabbBounds)) return false;\n        aabbBounds.min = min.z;\n        aabbBounds.max = max.z;\n        if (alignedSatBounds[2].isSeparated(aabbBounds)) return false;\n        for(let i = 0; i < 3; i++){\n            const axis = satAxes[i];\n            const sb = satBounds[i];\n            aabbBounds.setFromBox(axis, box);\n            if (sb.isSeparated(aabbBounds)) return false;\n        }\n        return true;\n    };\n}();\nOrientedBox.prototype.intersectsTriangle = function() {\n    const saTri = new _ExtendedTriangle_js__WEBPACK_IMPORTED_MODULE_2__.ExtendedTriangle();\n    const pointsArr = new Array(3);\n    const cachedSatBounds = new _SeparatingAxisBounds_js__WEBPACK_IMPORTED_MODULE_1__.SeparatingAxisBounds();\n    const cachedSatBounds2 = new _SeparatingAxisBounds_js__WEBPACK_IMPORTED_MODULE_1__.SeparatingAxisBounds();\n    const cachedAxis = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    return function intersectsTriangle(triangle) {\n        if (this.needsUpdate) {\n            this.update();\n        }\n        if (!triangle.isExtendedTriangle) {\n            saTri.copy(triangle);\n            saTri.update();\n            triangle = saTri;\n        } else if (triangle.needsUpdate) {\n            triangle.update();\n        }\n        const satBounds = this.satBounds;\n        const satAxes = this.satAxes;\n        pointsArr[0] = triangle.a;\n        pointsArr[1] = triangle.b;\n        pointsArr[2] = triangle.c;\n        for(let i = 0; i < 3; i++){\n            const sb = satBounds[i];\n            const sa = satAxes[i];\n            cachedSatBounds.setFromPoints(sa, pointsArr);\n            if (sb.isSeparated(cachedSatBounds)) return false;\n        }\n        const triSatBounds = triangle.satBounds;\n        const triSatAxes = triangle.satAxes;\n        const points = this.points;\n        for(let i = 0; i < 3; i++){\n            const sb = triSatBounds[i];\n            const sa = triSatAxes[i];\n            cachedSatBounds.setFromPoints(sa, points);\n            if (sb.isSeparated(cachedSatBounds)) return false;\n        }\n        // check crossed axes\n        for(let i = 0; i < 3; i++){\n            const sa1 = satAxes[i];\n            for(let i2 = 0; i2 < 4; i2++){\n                const sa2 = triSatAxes[i2];\n                cachedAxis.crossVectors(sa1, sa2);\n                cachedSatBounds.setFromPoints(cachedAxis, pointsArr);\n                cachedSatBounds2.setFromPoints(cachedAxis, points);\n                if (cachedSatBounds.isSeparated(cachedSatBounds2)) return false;\n            }\n        }\n        return true;\n    };\n}();\nOrientedBox.prototype.closestPointToPoint = function() {\n    return function closestPointToPoint(point, target1) {\n        if (this.needsUpdate) {\n            this.update();\n        }\n        target1.copy(point).applyMatrix4(this.invMatrix).clamp(this.min, this.max).applyMatrix4(this.matrix);\n        return target1;\n    };\n}();\nOrientedBox.prototype.distanceToPoint = function() {\n    const target = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    return function distanceToPoint(point) {\n        this.closestPointToPoint(point, target);\n        return point.distanceTo(target);\n    };\n}();\nOrientedBox.prototype.distanceToBox = function() {\n    const xyzFields = [\n        \"x\",\n        \"y\",\n        \"z\"\n    ];\n    const segments1 = new Array(12).fill().map(()=>new three__WEBPACK_IMPORTED_MODULE_0__.Line3());\n    const segments2 = new Array(12).fill().map(()=>new three__WEBPACK_IMPORTED_MODULE_0__.Line3());\n    const point1 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    const point2 = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    // early out if we find a value below threshold\n    return function distanceToBox(box, threshold = 0, target1 = null, target2 = null) {\n        if (this.needsUpdate) {\n            this.update();\n        }\n        if (this.intersectsBox(box)) {\n            if (target1 || target2) {\n                box.getCenter(point2);\n                this.closestPointToPoint(point2, point1);\n                box.closestPointToPoint(point1, point2);\n                if (target1) target1.copy(point1);\n                if (target2) target2.copy(point2);\n            }\n            return 0;\n        }\n        const threshold2 = threshold * threshold;\n        const min = box.min;\n        const max = box.max;\n        const points = this.points;\n        // iterate over every edge and compare distances\n        let closestDistanceSq = Infinity;\n        // check over all these points\n        for(let i = 0; i < 8; i++){\n            const p = points[i];\n            point2.copy(p).clamp(min, max);\n            const dist = p.distanceToSquared(point2);\n            if (dist < closestDistanceSq) {\n                closestDistanceSq = dist;\n                if (target1) target1.copy(p);\n                if (target2) target2.copy(point2);\n                if (dist < threshold2) return Math.sqrt(dist);\n            }\n        }\n        // generate and check all line segment distances\n        let count = 0;\n        for(let i = 0; i < 3; i++){\n            for(let i1 = 0; i1 <= 1; i1++){\n                for(let i2 = 0; i2 <= 1; i2++){\n                    const nextIndex = (i + 1) % 3;\n                    const nextIndex2 = (i + 2) % 3;\n                    // get obb line segments\n                    const index = i1 << nextIndex | i2 << nextIndex2;\n                    const index2 = 1 << i | i1 << nextIndex | i2 << nextIndex2;\n                    const p1 = points[index];\n                    const p2 = points[index2];\n                    const line1 = segments1[count];\n                    line1.set(p1, p2);\n                    // get aabb line segments\n                    const f1 = xyzFields[i];\n                    const f2 = xyzFields[nextIndex];\n                    const f3 = xyzFields[nextIndex2];\n                    const line2 = segments2[count];\n                    const start = line2.start;\n                    const end = line2.end;\n                    start[f1] = min[f1];\n                    start[f2] = i1 ? min[f2] : max[f2];\n                    start[f3] = i2 ? min[f3] : max[f2];\n                    end[f1] = max[f1];\n                    end[f2] = i1 ? min[f2] : max[f2];\n                    end[f3] = i2 ? min[f3] : max[f2];\n                    count++;\n                }\n            }\n        }\n        // check all the other boxes point\n        for(let x = 0; x <= 1; x++){\n            for(let y = 0; y <= 1; y++){\n                for(let z = 0; z <= 1; z++){\n                    point2.x = x ? max.x : min.x;\n                    point2.y = y ? max.y : min.y;\n                    point2.z = z ? max.z : min.z;\n                    this.closestPointToPoint(point2, point1);\n                    const dist = point2.distanceToSquared(point1);\n                    if (dist < closestDistanceSq) {\n                        closestDistanceSq = dist;\n                        if (target1) target1.copy(point1);\n                        if (target2) target2.copy(point2);\n                        if (dist < threshold2) return Math.sqrt(dist);\n                    }\n                }\n            }\n        }\n        for(let i = 0; i < 12; i++){\n            const l1 = segments1[i];\n            for(let i2 = 0; i2 < 12; i2++){\n                const l2 = segments2[i2];\n                (0,_MathUtilities_js__WEBPACK_IMPORTED_MODULE_3__.closestPointsSegmentToSegment)(l1, l2, point1, point2);\n                const dist = point1.distanceToSquared(point2);\n                if (dist < closestDistanceSq) {\n                    closestDistanceSq = dist;\n                    if (target1) target1.copy(point1);\n                    if (target2) target2.copy(point2);\n                    if (dist < threshold2) return Math.sqrt(dist);\n                }\n            }\n        }\n        return Math.sqrt(closestDistanceSq);\n    };\n}();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9tYXRoL09yaWVudGVkQm94LmpzIiwibWFwcGluZ3MiOiI7Ozs7Ozs7O0FBQWdEO0FBQ2lCO0FBQ1I7QUFDVTtBQUU1RCxNQUFNTTtJQUVaQyxZQUFhQyxHQUFHLEVBQUVDLEdBQUcsRUFBRUMsTUFBTSxDQUFHO1FBRS9CLElBQUksQ0FBQ0MsYUFBYSxHQUFHO1FBQ3JCLElBQUksQ0FBQ0gsR0FBRyxHQUFHLElBQUlSLDBDQUFPQTtRQUN0QixJQUFJLENBQUNTLEdBQUcsR0FBRyxJQUFJVCwwQ0FBT0E7UUFDdEIsSUFBSSxDQUFDVSxNQUFNLEdBQUcsSUFBSVQsMENBQU9BO1FBQ3pCLElBQUksQ0FBQ1csU0FBUyxHQUFHLElBQUlYLDBDQUFPQTtRQUM1QixJQUFJLENBQUNZLE1BQU0sR0FBRyxJQUFJQyxNQUFPLEdBQUlDLElBQUksR0FBR0MsR0FBRyxDQUFFLElBQU0sSUFBSWhCLDBDQUFPQTtRQUMxRCxJQUFJLENBQUNpQixPQUFPLEdBQUcsSUFBSUgsTUFBTyxHQUFJQyxJQUFJLEdBQUdDLEdBQUcsQ0FBRSxJQUFNLElBQUloQiwwQ0FBT0E7UUFDM0QsSUFBSSxDQUFDa0IsU0FBUyxHQUFHLElBQUlKLE1BQU8sR0FBSUMsSUFBSSxHQUFHQyxHQUFHLENBQUUsSUFBTSxJQUFJYiwwRUFBb0JBO1FBQzFFLElBQUksQ0FBQ2dCLGdCQUFnQixHQUFHLElBQUlMLE1BQU8sR0FBSUMsSUFBSSxHQUFHQyxHQUFHLENBQUUsSUFBTSxJQUFJYiwwRUFBb0JBO1FBQ2pGLElBQUksQ0FBQ2lCLFdBQVcsR0FBRztRQUVuQixJQUFLWixLQUFNLElBQUksQ0FBQ0EsR0FBRyxDQUFDYSxJQUFJLENBQUViO1FBQzFCLElBQUtDLEtBQU0sSUFBSSxDQUFDQSxHQUFHLENBQUNZLElBQUksQ0FBRVo7UUFDMUIsSUFBS0MsUUFBUyxJQUFJLENBQUNBLE1BQU0s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QUFJa0IsQ0FBQyxHQUFHbkIsSUFBSW1CLENBQUM7b0JBQzVCaUQsT0FBT2hELENBQUMsR0FBR0EsSUFBSW5CLElBQUltQixDQUFDLEdBQUdwQixJQUFJb0IsQ0FBQztvQkFFNUIsSUFBSSxDQUFDb0MsbUJBQW1CLENBQUVZLFFBQVFEO29CQUNsQyxNQUFNUyxPQUFPUixPQUFPUyxpQkFBaUIsQ0FBRVY7b0JBQ3ZDLElBQUtTLE9BQU9ILG1CQUFvQjt3QkFFL0JBLG9CQUFvQkc7d0JBQ3BCLElBQUtsQixTQUFVQSxRQUFRN0MsSUFBSSxDQUFFc0Q7d0JBQzdCLElBQUtHLFNBQVVBLFFBQVF6RCxJQUFJLENBQUV1RDt3QkFFN0IsSUFBS1EsT0FBT0osWUFBYSxPQUFPTSxLQUFLQyxJQUFJLENBQUVIO29CQUU1QztnQkFFRDtZQUVEO1FBRUQ7UUFFQSxJQUFNLElBQUl2RCxJQUFJLEdBQUdBLElBQUksSUFBSUEsSUFBTztZQUUvQixNQUFNeUUsS0FBSzdCLFNBQVMsQ0FBRTVDLEVBQUc7WUFDekIsSUFBTSxJQUFJZ0MsS0FBSyxHQUFHQSxLQUFLLElBQUlBLEtBQVE7Z0JBRWxDLE1BQU0wQyxLQUFLN0IsU0FBUyxDQUFFYixHQUFJO2dCQUMxQnhELGdGQUE2QkEsQ0FBRWlHLElBQUlDLElBQUk1QixRQUFRQztnQkFDL0MsTUFBTVEsT0FBT1QsT0FBT1UsaUJBQWlCLENBQUVUO2dCQUN2QyxJQUFLUSxPQUFPSCxtQkFBb0I7b0JBRS9CQSxvQkFBb0JHO29CQUNwQixJQUFLbEIsU0FBVUEsUUFBUTdDLElBQUksQ0FBRXNEO29CQUM3QixJQUFLRyxTQUFVQSxRQUFRekQsSUFBSSxDQUFFdUQ7b0JBRTdCLElBQUtRLE9BQU9KLFlBQWEsT0FBT00sS0FBS0MsSUFBSSxDQUFFSDtnQkFFNUM7WUFFRDtRQUVEO1FBRUEsT0FBT0UsS0FBS0MsSUFBSSxDQUFFTjtJQUVuQjtBQUVEIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmliZS0zZC1jb2RlLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvbWF0aC9PcmllbnRlZEJveC5qcz9mZTAyIl0sInNvdXJjZXNDb250ZW50IjpbImltcG9ydCB7IFZlY3RvcjMsIE1hdHJpeDQsIExpbmUzIH0gZnJvbSAndGhyZWUnO1xuaW1wb3J0IHsgU2VwYXJhdGluZ0F4aXNCb3VuZHMgfSBmcm9tICcuL1NlcGFyYXRpbmdBeGlzQm91bmRzLmpzJztcbmltcG9ydCB7IEV4dGVuZGVkVHJpYW5nbGUgfSBmcm9tICcuL0V4dGVuZGVkVHJpYW5nbGUuanMnO1xuaW1wb3J0IHsgY2xvc2VzdFBvaW50c1NlZ21lbnRUb1NlZ21lbnQgfSBmcm9tICcuL01hdGhVdGlsaXRpZXMuanMnO1xuXG5leHBvcnQgY2xhc3MgT3JpZW50ZWRCb3gge1xuXG5cdGNvbnN0cnVjdG9yKCBtaW4sIG1heCwgbWF0cml4ICkge1xuXG5cdFx0dGhpcy5pc09yaWVudGVkQm94ID0gdHJ1ZTtcblx0XHR0aGlzLm1pbiA9IG5ldyBWZWN0b3IzKCk7XG5cdFx0dGhpcy5tYXggPSBuZXcgVmVjdG9yMygpO1xuXHRcdHRoaXMubWF0cml4ID0gbmV3IE1hdHJpeDQoKTtcblx0XHR0aGlzLmludk1hdHJpeCA9IG5ldyBNYXRyaXg0KCk7XG5cdFx0dGhpcy5wb2ludHMgPSBuZXcgQXJyYXkoIDggKS5maWxsKCkubWFwKCAoKSA9PiBuZXcgVmVjdG9yMygpICk7XG5cdFx0dGhpcy5zYXRBeGVzID0gbmV3IEFycmF5KCAzICkuZmlsbCgpLm1hcCggKCkgPT4gbmV3IFZlY3RvcjMoKSApO1xuXHRcdHRoaXMuc2F0Qm91bmRzID0gbmV3IEFycmF5KCAzICkuZmlsbCgpLm1hcCggKCkgPT4gbmV3IFNlcGFyYXRpbmdBeGlzQm91bmRzKCkgKTtcblx0XHR0aGlzLmFsaWduZWRTYXRCb3VuZHMgPSBuZXcgQXJyYXkoIDMgKS5maWxsKCkubWFwKCAoKSA9PiBuZXcgU2VwYXJhdGluZ0F4aXNCb3VuZHMoKSApO1xuXHRcdHRoaXMubmVlZHNVcGRhdGUgPSBmYWxzZTtcblxuXHRcdGlmICggbWluICkgdGhpcy5taW4uY29weSggbWluICk7XG5cdFx0aWYgKCBtYXggKSB0aGlzLm1heC5jb3B5KCBtYXggKTtcblx0XHRpZiAoIG1hdHJpeCApIHRoaXMubWF0cml4LmNvcHkoIG1hdHJpeCApO1xuXG5cdH1cblxuXHRzZXQoIG1pbiwgbWF4LCBtYXRyaXggKSB7XG5cblx0XHR0aGlzLm1pbi5jb3B5KCBtaW4gKTtcblx0XHR0aGlzLm1heC5jb3B5KCBtYXggKTtcblx0XHR0aGlzLm1hdHJpeC5jb3B5KCBtYXRyaXggKTtcblx0XHR0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHR9XG5cblx0Y29weSggb3RoZXIgKSB7XG5cblx0XHR0aGlzLm1pbi5jb3B5KCBvdGhlci5taW4gKTtcblx0XHR0aGlzLm1heC5jb3B5KCBvdGhlci5tYXggKTtcblx0XHR0aGlzLm1hdHJpeC5jb3B5KCBvdGhlci5tYXRyaXggKTtcblx0XHR0aGlzLm5lZWRzVXBkYXRlID0gdHJ1ZTtcblxuXHR9XG5cbn1cblxuT3JpZW50ZWRCb3gucHJvdG90eXBlLnVwZGF0ZSA9ICggZnVuY3Rpb24gKCkge1xuXG5cdHJldHVybiBmdW5jdGlvbiB1cGRhdGUoKSB7XG5cblx0XHRjb25zdCBtYXRyaXggPSB0aGlzLm1hdHJpeDtcblx0XHRjb25zdCBtaW4gPSB0aGlzLm1pbjtcblx0XHRjb25zdCBtYXggPSB0aGlzLm1heDtcblxuXHRcdGNvbnN0IHBvaW50cyA9IHRoaXMucG9pbnRzO1xuXHRcdGZvciAoIGxldCB4ID0gMDsgeCA8PSAxOyB4ICsrICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgeSA9IDA7IHkgPD0gMTsgeSArKyApIHtcblxuXHRcdFx0XHRmb3IgKCBsZXQgeiA9IDA7IHogPD0gMTsgeiArKyApIHtcblxuXHRcdFx0XHRcdGNvbnN0IGkgPSAoICggMSA8PCAwICkgKiB4ICkgfCAoICggMSA8PCAxICkgKiB5ICkgfCAoICggMSA8PCAyICkgKiB6ICk7XG5cdFx0XHRcdFx0Y29uc3QgdiA9IHBvaW50c1sgaSBdO1xuXHRcdFx0XHRcdHYueCA9IHggPyBtYXgueCA6IG1pbi54O1xuXHRcdFx0XHRcdHYueSA9IHkgPyBtYXgueSA6IG1pbi55O1xuXHRcdFx0XHRcdHYueiA9IHogPyBtYXgueiA6IG1pbi56O1xuXG5cdFx0XHRcdFx0di5hcHBseU1hdHJpeDQoIG1hdHJpeCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Y29uc3Qgc2F0Qm91bmRzID0gdGhpcy5zYXRCb3VuZHM7XG5cdFx0Y29uc3Qgc2F0QXhlcyA9IHRoaXMuc2F0QXhlcztcblx0XHRjb25zdCBtaW5WZWMgPSBwb2ludHNbIDAgXTtcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBheGlzID0gc2F0QXhlc1sgaSBdO1xuXHRcdFx0Y29uc3Qgc2IgPSBzYXRCb3VuZHNbIGkgXTtcblx0XHRcdGNvbnN0IGluZGV4ID0gMSA8PCBpO1xuXHRcdFx0Y29uc3QgcGkgPSBwb2ludHNbIGluZGV4IF07XG5cblx0XHRcdGF4aXMuc3ViVmVjdG9ycyggbWluVmVjLCBwaSApO1xuXHRcdFx0c2Iuc2V0RnJvbVBvaW50cyggYXhpcywgcG9pbnRzICk7XG5cblx0XHR9XG5cblx0XHRjb25zdCBhbGlnbmVkU2F0Qm91bmRzID0gdGhpcy5hbGlnbmVkU2F0Qm91bmRzO1xuXHRcdGFsaWduZWRTYXRCb3VuZHNbIDAgXS5zZXRGcm9tUG9pbnRzRmllbGQoIHBvaW50cywgJ3gnICk7XG5cdFx0YWxpZ25lZFNhdEJvdW5kc1sgMSBdLnNldEZyb21Qb2ludHNGaWVsZCggcG9pbnRzLCAneScgKTtcblx0XHRhbGlnbmVkU2F0Qm91bmRzWyAyIF0uc2V0RnJvbVBvaW50c0ZpZWxkKCBwb2ludHMsICd6JyApO1xuXG5cdFx0dGhpcy5pbnZNYXRyaXguY29weSggdGhpcy5tYXRyaXggKS5pbnZlcnQoKTtcblx0XHR0aGlzLm5lZWRzVXBkYXRlID0gZmFsc2U7XG5cblx0fTtcblxufSApKCk7XG5cbk9yaWVudGVkQm94LnByb3RvdHlwZS5pbnRlcnNlY3RzQm94ID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0Y29uc3QgYWFiYkJvdW5kcyA9IG5ldyBTZXBhcmF0aW5nQXhpc0JvdW5kcygpO1xuXHRyZXR1cm4gZnVuY3Rpb24gaW50ZXJzZWN0c0JveCggYm94ICkge1xuXG5cdFx0Ly8gVE9ETzogc2hvdWxkIHRoaXMgYmUgZG9pbmcgU0FUIGFnYWluc3QgdGhlIEFBQkI/XG5cdFx0aWYgKCB0aGlzLm5lZWRzVXBkYXRlICkge1xuXG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgbWluID0gYm94Lm1pbjtcblx0XHRjb25zdCBtYXggPSBib3gubWF4O1xuXHRcdGNvbnN0IHNhdEJvdW5kcyA9IHRoaXMuc2F0Qm91bmRzO1xuXHRcdGNvbnN0IHNhdEF4ZXMgPSB0aGlzLnNhdEF4ZXM7XG5cdFx0Y29uc3QgYWxpZ25lZFNhdEJvdW5kcyA9IHRoaXMuYWxpZ25lZFNhdEJvdW5kcztcblxuXHRcdGFhYmJCb3VuZHMubWluID0gbWluLng7XG5cdFx0YWFiYkJvdW5kcy5tYXggPSBtYXgueDtcblx0XHRpZiAoIGFsaWduZWRTYXRCb3VuZHNbIDAgXS5pc1NlcGFyYXRlZCggYWFiYkJvdW5kcyApICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0YWFiYkJvdW5kcy5taW4gPSBtaW4ueTtcblx0XHRhYWJiQm91bmRzLm1heCA9IG1heC55O1xuXHRcdGlmICggYWxpZ25lZFNhdEJvdW5kc1sgMSBdLmlzU2VwYXJhdGVkKCBhYWJiQm91bmRzICkgKSByZXR1cm4gZmFsc2U7XG5cblx0XHRhYWJiQm91bmRzLm1pbiA9IG1pbi56O1xuXHRcdGFhYmJCb3VuZHMubWF4ID0gbWF4Lno7XG5cdFx0aWYgKCBhbGlnbmVkU2F0Qm91bmRzWyAyIF0uaXNTZXBhcmF0ZWQoIGFhYmJCb3VuZHMgKSApIHJldHVybiBmYWxzZTtcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IGF4aXMgPSBzYXRBeGVzWyBpIF07XG5cdFx0XHRjb25zdCBzYiA9IHNhdEJvdW5kc1sgaSBdO1xuXHRcdFx0YWFiYkJvdW5kcy5zZXRGcm9tQm94KCBheGlzLCBib3ggKTtcblx0XHRcdGlmICggc2IuaXNTZXBhcmF0ZWQoIGFhYmJCb3VuZHMgKSApIHJldHVybiBmYWxzZTtcblxuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXG5cdH07XG5cbn0gKSgpO1xuXG5PcmllbnRlZEJveC5wcm90b3R5cGUuaW50ZXJzZWN0c1RyaWFuZ2xlID0gKCBmdW5jdGlvbiAoKSB7XG5cblx0Y29uc3Qgc2FUcmkgPSBuZXcgRXh0ZW5kZWRUcmlhbmdsZSgpO1xuXHRjb25zdCBwb2ludHNBcnIgPSBuZXcgQXJyYXkoIDMgKTtcblx0Y29uc3QgY2FjaGVkU2F0Qm91bmRzID0gbmV3IFNlcGFyYXRpbmdBeGlzQm91bmRzKCk7XG5cdGNvbnN0IGNhY2hlZFNhdEJvdW5kczIgPSBuZXcgU2VwYXJhdGluZ0F4aXNCb3VuZHMoKTtcblx0Y29uc3QgY2FjaGVkQXhpcyA9IG5ldyBWZWN0b3IzKCk7XG5cdHJldHVybiBmdW5jdGlvbiBpbnRlcnNlY3RzVHJpYW5nbGUoIHRyaWFuZ2xlICkge1xuXG5cdFx0aWYgKCB0aGlzLm5lZWRzVXBkYXRlICkge1xuXG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCAhIHRyaWFuZ2xlLmlzRXh0ZW5kZWRUcmlhbmdsZSApIHtcblxuXHRcdFx0c2FUcmkuY29weSggdHJpYW5nbGUgKTtcblx0XHRcdHNhVHJpLnVwZGF0ZSgpO1xuXHRcdFx0dHJpYW5nbGUgPSBzYVRyaTtcblxuXHRcdH0gZWxzZSBpZiAoIHRyaWFuZ2xlLm5lZWRzVXBkYXRlICkge1xuXG5cdFx0XHR0cmlhbmdsZS51cGRhdGUoKTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHNhdEJvdW5kcyA9IHRoaXMuc2F0Qm91bmRzO1xuXHRcdGNvbnN0IHNhdEF4ZXMgPSB0aGlzLnNhdEF4ZXM7XG5cblx0XHRwb2ludHNBcnJbIDAgXSA9IHRyaWFuZ2xlLmE7XG5cdFx0cG9pbnRzQXJyWyAxIF0gPSB0cmlhbmdsZS5iO1xuXHRcdHBvaW50c0FyclsgMiBdID0gdHJpYW5nbGUuYztcblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHNiID0gc2F0Qm91bmRzWyBpIF07XG5cdFx0XHRjb25zdCBzYSA9IHNhdEF4ZXNbIGkgXTtcblx0XHRcdGNhY2hlZFNhdEJvdW5kcy5zZXRGcm9tUG9pbnRzKCBzYSwgcG9pbnRzQXJyICk7XG5cdFx0XHRpZiAoIHNiLmlzU2VwYXJhdGVkKCBjYWNoZWRTYXRCb3VuZHMgKSApIHJldHVybiBmYWxzZTtcblxuXHRcdH1cblxuXHRcdGNvbnN0IHRyaVNhdEJvdW5kcyA9IHRyaWFuZ2xlLnNhdEJvdW5kcztcblx0XHRjb25zdCB0cmlTYXRBeGVzID0gdHJpYW5nbGUuc2F0QXhlcztcblx0XHRjb25zdCBwb2ludHMgPSB0aGlzLnBvaW50cztcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBzYiA9IHRyaVNhdEJvdW5kc1sgaSBdO1xuXHRcdFx0Y29uc3Qgc2EgPSB0cmlTYXRBeGVzWyBpIF07XG5cdFx0XHRjYWNoZWRTYXRCb3VuZHMuc2V0RnJvbVBvaW50cyggc2EsIHBvaW50cyApO1xuXHRcdFx0aWYgKCBzYi5pc1NlcGFyYXRlZCggY2FjaGVkU2F0Qm91bmRzICkgKSByZXR1cm4gZmFsc2U7XG5cblx0XHR9XG5cblx0XHQvLyBjaGVjayBjcm9zc2VkIGF4ZXNcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBzYTEgPSBzYXRBeGVzWyBpIF07XG5cdFx0XHRmb3IgKCBsZXQgaTIgPSAwOyBpMiA8IDQ7IGkyICsrICkge1xuXG5cdFx0XHRcdGNvbnN0IHNhMiA9IHRyaVNhdEF4ZXNbIGkyIF07XG5cdFx0XHRcdGNhY2hlZEF4aXMuY3Jvc3NWZWN0b3JzKCBzYTEsIHNhMiApO1xuXHRcdFx0XHRjYWNoZWRTYXRCb3VuZHMuc2V0RnJvbVBvaW50cyggY2FjaGVkQXhpcywgcG9pbnRzQXJyICk7XG5cdFx0XHRcdGNhY2hlZFNhdEJvdW5kczIuc2V0RnJvbVBvaW50cyggY2FjaGVkQXhpcywgcG9pbnRzICk7XG5cdFx0XHRcdGlmICggY2FjaGVkU2F0Qm91bmRzLmlzU2VwYXJhdGVkKCBjYWNoZWRTYXRCb3VuZHMyICkgKSByZXR1cm4gZmFsc2U7XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdHJldHVybiB0cnVlO1xuXG5cdH07XG5cbn0gKSgpO1xuXG5PcmllbnRlZEJveC5wcm90b3R5cGUuY2xvc2VzdFBvaW50VG9Qb2ludCA9ICggZnVuY3Rpb24gKCkge1xuXG5cdHJldHVybiBmdW5jdGlvbiBjbG9zZXN0UG9pbnRUb1BvaW50KCBwb2ludCwgdGFyZ2V0MSApIHtcblxuXHRcdGlmICggdGhpcy5uZWVkc1VwZGF0ZSApIHtcblxuXHRcdFx0dGhpcy51cGRhdGUoKTtcblxuXHRcdH1cblxuXHRcdHRhcmdldDFcblx0XHRcdC5jb3B5KCBwb2ludCApXG5cdFx0XHQuYXBwbHlNYXRyaXg0KCB0aGlzLmludk1hdHJpeCApXG5cdFx0XHQuY2xhbXAoIHRoaXMubWluLCB0aGlzLm1heCApXG5cdFx0XHQuYXBwbHlNYXRyaXg0KCB0aGlzLm1hdHJpeCApO1xuXG5cdFx0cmV0dXJuIHRhcmdldDE7XG5cblx0fTtcblxufSApKCk7XG5cbk9yaWVudGVkQm94LnByb3RvdHlwZS5kaXN0YW5jZVRvUG9pbnQgPSAoIGZ1bmN0aW9uICgpIHtcblxuXHRjb25zdCB0YXJnZXQgPSBuZXcgVmVjdG9yMygpO1xuXHRyZXR1cm4gZnVuY3Rpb24gZGlzdGFuY2VUb1BvaW50KCBwb2ludCApIHtcblxuXHRcdHRoaXMuY2xvc2VzdFBvaW50VG9Qb2ludCggcG9pbnQsIHRhcmdldCApO1xuXHRcdHJldHVybiBwb2ludC5kaXN0YW5jZVRvKCB0YXJnZXQgKTtcblxuXHR9O1xuXG59ICkoKTtcblxuT3JpZW50ZWRCb3gucHJvdG90eXBlLmRpc3RhbmNlVG9Cb3ggPSAoIGZ1bmN0aW9uICgpIHtcblxuXHRjb25zdCB4eXpGaWVsZHMgPSBbICd4JywgJ3knLCAneicgXTtcblx0Y29uc3Qgc2VnbWVudHMxID0gbmV3IEFycmF5KCAxMiApLmZpbGwoKS5tYXAoICgpID0+IG5ldyBMaW5lMygpICk7XG5cdGNvbnN0IHNlZ21lbnRzMiA9IG5ldyBBcnJheSggMTIgKS5maWxsKCkubWFwKCAoKSA9PiBuZXcgTGluZTMoKSApO1xuXG5cdGNvbnN0IHBvaW50MSA9IG5ldyBWZWN0b3IzKCk7XG5cdGNvbnN0IHBvaW50MiA9IG5ldyBWZWN0b3IzKCk7XG5cblx0Ly8gZWFybHkgb3V0IGlmIHdlIGZpbmQgYSB2YWx1ZSBiZWxvdyB0aHJlc2hvbGRcblx0cmV0dXJuIGZ1bmN0aW9uIGRpc3RhbmNlVG9Cb3goIGJveCwgdGhyZXNob2xkID0gMCwgdGFyZ2V0MSA9IG51bGwsIHRhcmdldDIgPSBudWxsICkge1xuXG5cdFx0aWYgKCB0aGlzLm5lZWRzVXBkYXRlICkge1xuXG5cdFx0XHR0aGlzLnVwZGF0ZSgpO1xuXG5cdFx0fVxuXG5cdFx0aWYgKCB0aGlzLmludGVyc2VjdHNCb3goIGJveCApICkge1xuXG5cdFx0XHRpZiAoIHRhcmdldDEgfHwgdGFyZ2V0MiApIHtcblxuXHRcdFx0XHRib3guZ2V0Q2VudGVyKCBwb2ludDIgKTtcblx0XHRcdFx0dGhpcy5jbG9zZXN0UG9pbnRUb1BvaW50KCBwb2ludDIsIHBvaW50MSApO1xuXHRcdFx0XHRib3guY2xvc2VzdFBvaW50VG9Qb2ludCggcG9pbnQxLCBwb2ludDIgKTtcblxuXHRcdFx0XHRpZiAoIHRhcmdldDEgKSB0YXJnZXQxLmNvcHkoIHBvaW50MSApO1xuXHRcdFx0XHRpZiAoIHRhcmdldDIgKSB0YXJnZXQyLmNvcHkoIHBvaW50MiApO1xuXG5cdFx0XHR9XG5cblx0XHRcdHJldHVybiAwO1xuXG5cdFx0fVxuXG5cdFx0Y29uc3QgdGhyZXNob2xkMiA9IHRocmVzaG9sZCAqIHRocmVzaG9sZDtcblx0XHRjb25zdCBtaW4gPSBib3gubWluO1xuXHRcdGNvbnN0IG1heCA9IGJveC5tYXg7XG5cdFx0Y29uc3QgcG9pbnRzID0gdGhpcy5wb2ludHM7XG5cblxuXHRcdC8vIGl0ZXJhdGUgb3ZlciBldmVyeSBlZGdlIGFuZCBjb21wYXJlIGRpc3RhbmNlc1xuXHRcdGxldCBjbG9zZXN0RGlzdGFuY2VTcSA9IEluZmluaXR5O1xuXG5cdFx0Ly8gY2hlY2sgb3ZlciBhbGwgdGhlc2UgcG9pbnRzXG5cdFx0Zm9yICggbGV0IGkgPSAwOyBpIDwgODsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgcCA9IHBvaW50c1sgaSBdO1xuXHRcdFx0cG9pbnQyLmNvcHkoIHAgKS5jbGFtcCggbWluLCBtYXggKTtcblxuXHRcdFx0Y29uc3QgZGlzdCA9IHAuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50MiApO1xuXHRcdFx0aWYgKCBkaXN0IDwgY2xvc2VzdERpc3RhbmNlU3EgKSB7XG5cblx0XHRcdFx0Y2xvc2VzdERpc3RhbmNlU3EgPSBkaXN0O1xuXHRcdFx0XHRpZiAoIHRhcmdldDEgKSB0YXJnZXQxLmNvcHkoIHAgKTtcblx0XHRcdFx0aWYgKCB0YXJnZXQyICkgdGFyZ2V0Mi5jb3B5KCBwb2ludDIgKTtcblxuXHRcdFx0XHRpZiAoIGRpc3QgPCB0aHJlc2hvbGQyICkgcmV0dXJuIE1hdGguc3FydCggZGlzdCApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHQvLyBnZW5lcmF0ZSBhbmQgY2hlY2sgYWxsIGxpbmUgc2VnbWVudCBkaXN0YW5jZXNcblx0XHRsZXQgY291bnQgPSAwO1xuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XG5cblx0XHRcdGZvciAoIGxldCBpMSA9IDA7IGkxIDw9IDE7IGkxICsrICkge1xuXG5cdFx0XHRcdGZvciAoIGxldCBpMiA9IDA7IGkyIDw9IDE7IGkyICsrICkge1xuXG5cdFx0XHRcdFx0Y29uc3QgbmV4dEluZGV4ID0gKCBpICsgMSApICUgMztcblx0XHRcdFx0XHRjb25zdCBuZXh0SW5kZXgyID0gKCBpICsgMiApICUgMztcblxuXHRcdFx0XHRcdC8vIGdldCBvYmIgbGluZSBzZWdtZW50c1xuXHRcdFx0XHRcdGNvbnN0IGluZGV4ID0gaTEgPDwgbmV4dEluZGV4IHwgaTIgPDwgbmV4dEluZGV4Mjtcblx0XHRcdFx0XHRjb25zdCBpbmRleDIgPSAxIDw8IGkgfCBpMSA8PCBuZXh0SW5kZXggfCBpMiA8PCBuZXh0SW5kZXgyO1xuXHRcdFx0XHRcdGNvbnN0IHAxID0gcG9pbnRzWyBpbmRleCBdO1xuXHRcdFx0XHRcdGNvbnN0IHAyID0gcG9pbnRzWyBpbmRleDIgXTtcblx0XHRcdFx0XHRjb25zdCBsaW5lMSA9IHNlZ21lbnRzMVsgY291bnQgXTtcblx0XHRcdFx0XHRsaW5lMS5zZXQoIHAxLCBwMiApO1xuXG5cblx0XHRcdFx0XHQvLyBnZXQgYWFiYiBsaW5lIHNlZ21lbnRzXG5cdFx0XHRcdFx0Y29uc3QgZjEgPSB4eXpGaWVsZHNbIGkgXTtcblx0XHRcdFx0XHRjb25zdCBmMiA9IHh5ekZpZWxkc1sgbmV4dEluZGV4IF07XG5cdFx0XHRcdFx0Y29uc3QgZjMgPSB4eXpGaWVsZHNbIG5leHRJbmRleDIgXTtcblx0XHRcdFx0XHRjb25zdCBsaW5lMiA9IHNlZ21lbnRzMlsgY291bnQgXTtcblx0XHRcdFx0XHRjb25zdCBzdGFydCA9IGxpbmUyLnN0YXJ0O1xuXHRcdFx0XHRcdGNvbnN0IGVuZCA9IGxpbmUyLmVuZDtcblxuXHRcdFx0XHRcdHN0YXJ0WyBmMSBdID0gbWluWyBmMSBdO1xuXHRcdFx0XHRcdHN0YXJ0WyBmMiBdID0gaTEgPyBtaW5bIGYyIF0gOiBtYXhbIGYyIF07XG5cdFx0XHRcdFx0c3RhcnRbIGYzIF0gPSBpMiA/IG1pblsgZjMgXSA6IG1heFsgZjIgXTtcblxuXHRcdFx0XHRcdGVuZFsgZjEgXSA9IG1heFsgZjEgXTtcblx0XHRcdFx0XHRlbmRbIGYyIF0gPSBpMSA/IG1pblsgZjIgXSA6IG1heFsgZjIgXTtcblx0XHRcdFx0XHRlbmRbIGYzIF0gPSBpMiA/IG1pblsgZjMgXSA6IG1heFsgZjIgXTtcblxuXHRcdFx0XHRcdGNvdW50ICsrO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0Ly8gY2hlY2sgYWxsIHRoZSBvdGhlciBib3hlcyBwb2ludFxuXHRcdGZvciAoIGxldCB4ID0gMDsgeCA8PSAxOyB4ICsrICkge1xuXG5cdFx0XHRmb3IgKCBsZXQgeSA9IDA7IHkgPD0gMTsgeSArKyApIHtcblxuXHRcdFx0XHRmb3IgKCBsZXQgeiA9IDA7IHogPD0gMTsgeiArKyApIHtcblxuXHRcdFx0XHRcdHBvaW50Mi54ID0geCA/IG1heC54IDogbWluLng7XG5cdFx0XHRcdFx0cG9pbnQyLnkgPSB5ID8gbWF4LnkgOiBtaW4ueTtcblx0XHRcdFx0XHRwb2ludDIueiA9IHogPyBtYXgueiA6IG1pbi56O1xuXG5cdFx0XHRcdFx0dGhpcy5jbG9zZXN0UG9pbnRUb1BvaW50KCBwb2ludDIsIHBvaW50MSApO1xuXHRcdFx0XHRcdGNvbnN0IGRpc3QgPSBwb2ludDIuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50MSApO1xuXHRcdFx0XHRcdGlmICggZGlzdCA8IGNsb3Nlc3REaXN0YW5jZVNxICkge1xuXG5cdFx0XHRcdFx0XHRjbG9zZXN0RGlzdGFuY2VTcSA9IGRpc3Q7XG5cdFx0XHRcdFx0XHRpZiAoIHRhcmdldDEgKSB0YXJnZXQxLmNvcHkoIHBvaW50MSApO1xuXHRcdFx0XHRcdFx0aWYgKCB0YXJnZXQyICkgdGFyZ2V0Mi5jb3B5KCBwb2ludDIgKTtcblxuXHRcdFx0XHRcdFx0aWYgKCBkaXN0IDwgdGhyZXNob2xkMiApIHJldHVybiBNYXRoLnNxcnQoIGRpc3QgKTtcblxuXHRcdFx0XHRcdH1cblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDEyOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBsMSA9IHNlZ21lbnRzMVsgaSBdO1xuXHRcdFx0Zm9yICggbGV0IGkyID0gMDsgaTIgPCAxMjsgaTIgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgbDIgPSBzZWdtZW50czJbIGkyIF07XG5cdFx0XHRcdGNsb3Nlc3RQb2ludHNTZWdtZW50VG9TZWdtZW50KCBsMSwgbDIsIHBvaW50MSwgcG9pbnQyICk7XG5cdFx0XHRcdGNvbnN0IGRpc3QgPSBwb2ludDEuZGlzdGFuY2VUb1NxdWFyZWQoIHBvaW50MiApO1xuXHRcdFx0XHRpZiAoIGRpc3QgPCBjbG9zZXN0RGlzdGFuY2VTcSApIHtcblxuXHRcdFx0XHRcdGNsb3Nlc3REaXN0YW5jZVNxID0gZGlzdDtcblx0XHRcdFx0XHRpZiAoIHRhcmdldDEgKSB0YXJnZXQxLmNvcHkoIHBvaW50MSApO1xuXHRcdFx0XHRcdGlmICggdGFyZ2V0MiApIHRhcmdldDIuY29weSggcG9pbnQyICk7XG5cblx0XHRcdFx0XHRpZiAoIGRpc3QgPCB0aHJlc2hvbGQyICkgcmV0dXJuIE1hdGguc3FydCggZGlzdCApO1xuXG5cdFx0XHRcdH1cblxuXHRcdFx0fVxuXG5cdFx0fVxuXG5cdFx0cmV0dXJuIE1hdGguc3FydCggY2xvc2VzdERpc3RhbmNlU3EgKTtcblxuXHR9O1xuXG59ICkoKTtcbiJdLCJuYW1lcyI6WyJWZWN0b3IzIiwiTWF0cml4NCIsIkxpbmUzIiwiU2VwYXJhdGluZ0F4aXNCb3VuZHMiLCJFeHRlbmRlZFRyaWFuZ2xlIiwiY2xvc2VzdFBvaW50c1NlZ21lbnRUb1NlZ21lbnQiLCJPcmllbnRlZEJveCIsImNvbnN0cnVjdG9yIiwibWluIiwibWF4IiwibWF0cml4IiwiaXNPcmllbnRlZEJveCIsImludk1hdHJpeCIsInBvaW50cyIsIkFycmF5IiwiZmlsbCIsIm1hcCIsInNhdEF4ZXMiLCJzYXRCb3VuZHMiLCJhbGlnbmVkU2F0Qm91bmRzIiwibmVlZHNVcGRhdGUiLCJjb3B5Iiwic2V0Iiwib3RoZXIiLCJwcm90b3R5cGUiLCJ1cGRhdGUiLCJ4IiwieSIsInoiLCJpIiwidiIsImFwcGx5TWF0cml4NCIsIm1pblZlYyIsImF4aXMiLCJzYiIsImluZGV4IiwicGkiLCJzdWJWZWN0b3JzIiwic2V0RnJvbVBvaW50cyIsInNldEZyb21Qb2ludHNGaWVsZCIsImludmVydCIsImludGVyc2VjdHNCb3giLCJhYWJiQm91bmRzIiwiYm94IiwiaXNTZXBhcmF0ZWQiLCJzZXRGcm9tQm94IiwiaW50ZXJzZWN0c1RyaWFuZ2xlIiwic2FUcmkiLCJwb2ludHNBcnIiLCJjYWNoZWRTYXRCb3VuZHMiLCJjYWNoZWRTYXRCb3VuZHMyIiwiY2FjaGVkQXhpcyIsInRyaWFuZ2xlIiwiaXNFeHRlbmRlZFRyaWFuZ2xlIiwiYSIsImIiLCJjIiwic2EiLCJ0cmlTYXRCb3VuZHMiLCJ0cmlTYXRBeGVzIiwic2ExIiwiaTIiLCJzYTIiLCJjcm9zc1ZlY3RvcnMiLCJjbG9zZXN0UG9pbnRUb1BvaW50IiwicG9pbnQiLCJ0YXJnZXQxIiwiY2xhbXAiLCJkaXN0YW5jZVRvUG9pbnQiLCJ0YXJnZXQiLCJkaXN0YW5jZVRvIiwiZGlzdGFuY2VUb0JveCIsInh5ekZpZWxkcyIsInNlZ21lbnRzMSIsInNlZ21lbnRzMiIsInBvaW50MSIsInBvaW50MiIsInRocmVzaG9sZCIsInRhcmdldDIiLCJnZXRDZW50ZXIiLCJ0aHJlc2hvbGQyIiwiY2xvc2VzdERpc3RhbmNlU3EiLCJJbmZpbml0eSIsInAiLCJkaXN0IiwiZGlzdGFuY2VUb1NxdWFyZWQiLCJNYXRoIiwic3FydCIsImNvdW50IiwiaTEiLCJuZXh0SW5kZXgiLCJuZXh0SW5kZXgyIiwiaW5kZXgyIiwicDEiLCJwMiIsImxpbmUxIiwiZjEiLCJmMiIsImYzIiwibGluZTIiLCJzdGFydCIsImVuZCIsImwxIiwibDIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/math/OrientedBox.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/math/SeparatingAxisBounds.js":
/*!*****************************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/math/SeparatingAxisBounds.js ***!
  \*****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   SeparatingAxisBounds: () => (/* binding */ SeparatingAxisBounds),\n/* harmony export */   areIntersecting: () => (/* binding */ areIntersecting)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n\nclass SeparatingAxisBounds {\n    constructor(){\n        this.min = Infinity;\n        this.max = -Infinity;\n    }\n    setFromPointsField(points, field) {\n        let min = Infinity;\n        let max = -Infinity;\n        for(let i = 0, l = points.length; i < l; i++){\n            const p = points[i];\n            const val = p[field];\n            min = val < min ? val : min;\n            max = val > max ? val : max;\n        }\n        this.min = min;\n        this.max = max;\n    }\n    setFromPoints(axis, points) {\n        let min = Infinity;\n        let max = -Infinity;\n        for(let i = 0, l = points.length; i < l; i++){\n            const p = points[i];\n            const val = axis.dot(p);\n            min = val < min ? val : min;\n            max = val > max ? val : max;\n        }\n        this.min = min;\n        this.max = max;\n    }\n    isSeparated(other) {\n        return this.min > other.max || other.min > this.max;\n    }\n}\nSeparatingAxisBounds.prototype.setFromBox = function() {\n    const p = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n    return function setFromBox(axis, box) {\n        const boxMin = box.min;\n        const boxMax = box.max;\n        let min = Infinity;\n        let max = -Infinity;\n        for(let x = 0; x <= 1; x++){\n            for(let y = 0; y <= 1; y++){\n                for(let z = 0; z <= 1; z++){\n                    p.x = boxMin.x * x + boxMax.x * (1 - x);\n                    p.y = boxMin.y * y + boxMax.y * (1 - y);\n                    p.z = boxMin.z * z + boxMax.z * (1 - z);\n                    const val = axis.dot(p);\n                    min = Math.min(val, min);\n                    max = Math.max(val, max);\n                }\n            }\n        }\n        this.min = min;\n        this.max = max;\n    };\n}();\nconst areIntersecting = function() {\n    const cacheSatBounds = new SeparatingAxisBounds();\n    return function areIntersecting(shape1, shape2) {\n        const points1 = shape1.points;\n        const satAxes1 = shape1.satAxes;\n        const satBounds1 = shape1.satBounds;\n        const points2 = shape2.points;\n        const satAxes2 = shape2.satAxes;\n        const satBounds2 = shape2.satBounds;\n        // check axes of the first shape\n        for(let i = 0; i < 3; i++){\n            const sb = satBounds1[i];\n            const sa = satAxes1[i];\n            cacheSatBounds.setFromPoints(sa, points2);\n            if (sb.isSeparated(cacheSatBounds)) return false;\n        }\n        // check axes of the second shape\n        for(let i = 0; i < 3; i++){\n            const sb = satBounds2[i];\n            const sa = satAxes2[i];\n            cacheSatBounds.setFromPoints(sa, points1);\n            if (sb.isSeparated(cacheSatBounds)) return false;\n        }\n    };\n}();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy9tYXRoL1NlcGFyYXRpbmdBeGlzQm91bmRzLmpzIiwibWFwcGluZ3MiOiI7Ozs7OztBQUFnQztBQUV6QixNQUFNQztJQUVaQyxhQUFjO1FBRWIsSUFBSSxDQUFDQyxHQUFHLEdBQUdDO1FBQ1gsSUFBSSxDQUFDQyxHQUFHLEdBQUcsQ0FBRUQ7SUFFZDtJQUVBRSxtQkFBb0JDLE1BQU0sRUFBRUMsS0FBSyxFQUFHO1FBRW5DLElBQUlMLE1BQU1DO1FBQ1YsSUFBSUMsTUFBTSxDQUFFRDtRQUNaLElBQU0sSUFBSUssSUFBSSxHQUFHQyxJQUFJSCxPQUFPSSxNQUFNLEVBQUVGLElBQUlDLEdBQUdELElBQU87WUFFakQsTUFBTUcsSUFBSUwsTUFBTSxDQUFFRSxFQUFHO1lBQ3JCLE1BQU1JLE1BQU1ELENBQUMsQ0FBRUosTUFBTztZQUN0QkwsTUFBTVUsTUFBTVYsTUFBTVUsTUFBTVY7WUFDeEJFLE1BQU1RLE1BQU1SLE1BQU1RLE1BQU1SO1FBRXpCO1FBRUEsSUFBSSxDQUFDRixHQUFHLEdBQUdBO1FBQ1gsSUFBSSxDQUFDRSxHQUFHLEdBQUdBO0lBRVo7SUFFQVMsY0FBZUMsSUFBSSxFQUFFUixNQUFNLEVBQUc7UUFFN0IsSUFBSUosTUFBTUM7UUFDVixJQUFJQyxNQUFNLENBQUVEO1FBQ1osSUFBTSxJQUFJSyxJQUFJLEdBQUdDLElBQUlILE9BQU9JLE1BQU0sRUFBRUYsSUFBSUMsR0FBR0QsSUFBTztZQUVqRCxNQUFNRyxJQUFJTCxNQUFNLENBQUVFLEVBQUc7WUFDckIsTUFBTUksTUFBTUUsS0FBS0MsR0FBRyxDQUFFSjtZQUN0QlQsTUFBTVUsTUFBTVYsTUFBTVUsTUFBTVY7WUFDeEJFLE1BQU1RLE1BQU1SLE1BQU1RLE1BQU1SO1FBRXpCO1FBRUEsSUFBSSxDQUFDRixHQUFHLEdBQUdBO1FBQ1gsSUFBSSxDQUFDRSxHQUFHLEdBQUdBO0lBRVo7SUFFQVksWUFBYUMsS0FBSyxFQUFHO1FBRXBCLE9BQU8sSUFBSSxDQUFDZixHQUFHLEdBQUdlLE1BQU1iLEdBQUcsSUFBSWEsTUFBTWYsR0FBRyxHQUFHLElBQUksQ0FBQ0UsR0FBRztJQUVwRDtBQUVEO0FBRUFKLHFCQUFxQmtCLFNBQVMsQ0FBQ0MsVUFBVSxHQUFHO0lBRTNDLE1BQU1SLElBQUksSUFBSVosMENBQU9BO0lBQ3JCLE9BQU8sU0FBU29CLFdBQVlMLElBQUksRUFBRU0sR0FBRztRQUVwQyxNQUFNQyxTQUFTRCxJQUFJbEIsR0FBRztRQUN0QixNQUFNb0IsU0FBU0YsSUFBSWhCLEdBQUc7UUFDdEIsSUFBSUYsTUFBTUM7UUFDVixJQUFJQyxNQUFNLENBQUVEO1FBQ1osSUFBTSxJQUFJb0IsSUFBSSxHQUFHQSxLQUFLLEdBQUdBLElBQU87WUFFL0IsSUFBTSxJQUFJQyxJQUFJLEdBQUdBLEtBQUssR0FBR0EsSUFBTztnQkFFL0IsSUFBTSxJQUFJQyxJQUFJLEdBQUdBLEtBQUssR0FBR0EsSUFBTztvQkFFL0JkLEVBQUVZLENBQUMsR0FBR0YsT0FBT0UsQ0FBQyxHQUFHQSxJQUFJRCxPQUFPQyxDQUFDLEdBQUssS0FBSUEsQ0FBQUE7b0JBQ3RDWixFQUFFYSxDQUFDLEdBQUdILE9BQU9HLENBQUMsR0FBR0EsSUFBSUYsT0FBT0UsQ0FBQyxHQUFLLEtBQUlBLENBQUFBO29CQUN0Q2IsRUFBRWMsQ0FBQyxHQUFHSixPQUFPSSxDQUFDLEdBQUdBLElBQUlILE9BQU9HLENBQUMsR0FBSyxLQUFJQSxDQUFBQTtvQkFFdEMsTUFBTWIsTUFBTUUsS0FBS0MsR0FBRyxDQUFFSjtvQkFDdEJULE1BQU13QixLQUFLeEIsR0FBRyxDQUFFVSxLQUFLVjtvQkFDckJFLE1BQU1zQixLQUFLdEIsR0FBRyxDQUFFUSxLQUFLUjtnQkFFdEI7WUFFRDtRQUVEO1FBRUEsSUFBSSxDQUFDRixHQUFHLEdBQUdBO1FBQ1gsSUFBSSxDQUFDRSxHQUFHLEdBQUdBO0lBRVo7QUFFRDtBQUVPLE1BQU11QixrQkFBa0I7SUFFOUIsTUFBTUMsaUJBQWlCLElBQUk1QjtJQUMzQixPQUFPLFNBQVMyQixnQkFBaUJFLE1BQU0sRUFBRUMsTUFBTTtRQUU5QyxNQUFNQyxVQUFVRixPQUFPdkIsTUFBTTtRQUM3QixNQUFNMEIsV0FBV0gsT0FBT0ksT0FBTztRQUMvQixNQUFNQyxhQUFhTCxPQUFPTSxTQUFTO1FBRW5DLE1BQU1DLFVBQVVOLE9BQU94QixNQUFNO1FBQzdCLE1BQU0rQixXQUFXUCxPQUFPRyxPQUFPO1FBQy9CLE1BQU1LLGFBQWFSLE9BQU9LLFNBQVM7UUFFbkMsZ0NBQWdDO1FBQ2hDLElBQU0sSUFBSTNCLElBQUksR0FBR0EsSUFBSSxHQUFHQSxJQUFPO1lBRTlCLE1BQU0rQixLQUFLTCxVQUFVLENBQUUxQixFQUFHO1lBQzFCLE1BQU1nQyxLQUFLUixRQUFRLENBQUV4QixFQUFHO1lBQ3hCb0IsZUFBZWYsYUFBYSxDQUFFMkIsSUFBSUo7WUFDbEMsSUFBS0csR0FBR3ZCLFdBQVcsQ0FBRVksaUJBQW1CLE9BQU87UUFFaEQ7UUFFQSxpQ0FBaUM7UUFDakMsSUFBTSxJQUFJcEIsSUFBSSxHQUFHQSxJQUFJLEdBQUdBLElBQU87WUFFOUIsTUFBTStCLEtBQUtELFVBQVUsQ0FBRTlCLEVBQUc7WUFDMUIsTUFBTWdDLEtBQUtILFFBQVEsQ0FBRTdCLEVBQUc7WUFDeEJvQixlQUFlZixhQUFhLENBQUUyQixJQUFJVDtZQUNsQyxJQUFLUSxHQUFHdkIsV0FBVyxDQUFFWSxpQkFBbUIsT0FBTztRQUVoRDtJQUVEO0FBRUQsSUFBTSIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpYmUtM2QtY29kZS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9ub2RlX21vZHVsZXMvdGhyZWUtbWVzaC1idmgvc3JjL21hdGgvU2VwYXJhdGluZ0F4aXNCb3VuZHMuanM/YjFkMiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBWZWN0b3IzIH0gZnJvbSAndGhyZWUnO1xuXG5leHBvcnQgY2xhc3MgU2VwYXJhdGluZ0F4aXNCb3VuZHMge1xuXG5cdGNvbnN0cnVjdG9yKCkge1xuXG5cdFx0dGhpcy5taW4gPSBJbmZpbml0eTtcblx0XHR0aGlzLm1heCA9IC0gSW5maW5pdHk7XG5cblx0fVxuXG5cdHNldEZyb21Qb2ludHNGaWVsZCggcG9pbnRzLCBmaWVsZCApIHtcblxuXHRcdGxldCBtaW4gPSBJbmZpbml0eTtcblx0XHRsZXQgbWF4ID0gLSBJbmZpbml0eTtcblx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBwb2ludHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdFx0Y29uc3QgcCA9IHBvaW50c1sgaSBdO1xuXHRcdFx0Y29uc3QgdmFsID0gcFsgZmllbGQgXTtcblx0XHRcdG1pbiA9IHZhbCA8IG1pbiA/IHZhbCA6IG1pbjtcblx0XHRcdG1heCA9IHZhbCA+IG1heCA/IHZhbCA6IG1heDtcblxuXHRcdH1cblxuXHRcdHRoaXMubWluID0gbWluO1xuXHRcdHRoaXMubWF4ID0gbWF4O1xuXG5cdH1cblxuXHRzZXRGcm9tUG9pbnRzKCBheGlzLCBwb2ludHMgKSB7XG5cblx0XHRsZXQgbWluID0gSW5maW5pdHk7XG5cdFx0bGV0IG1heCA9IC0gSW5maW5pdHk7XG5cdFx0Zm9yICggbGV0IGkgPSAwLCBsID0gcG9pbnRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHAgPSBwb2ludHNbIGkgXTtcblx0XHRcdGNvbnN0IHZhbCA9IGF4aXMuZG90KCBwICk7XG5cdFx0XHRtaW4gPSB2YWwgPCBtaW4gPyB2YWwgOiBtaW47XG5cdFx0XHRtYXggPSB2YWwgPiBtYXggPyB2YWwgOiBtYXg7XG5cblx0XHR9XG5cblx0XHR0aGlzLm1pbiA9IG1pbjtcblx0XHR0aGlzLm1heCA9IG1heDtcblxuXHR9XG5cblx0aXNTZXBhcmF0ZWQoIG90aGVyICkge1xuXG5cdFx0cmV0dXJuIHRoaXMubWluID4gb3RoZXIubWF4IHx8IG90aGVyLm1pbiA+IHRoaXMubWF4O1xuXG5cdH1cblxufVxuXG5TZXBhcmF0aW5nQXhpc0JvdW5kcy5wcm90b3R5cGUuc2V0RnJvbUJveCA9ICggZnVuY3Rpb24gKCkge1xuXG5cdGNvbnN0IHAgPSBuZXcgVmVjdG9yMygpO1xuXHRyZXR1cm4gZnVuY3Rpb24gc2V0RnJvbUJveCggYXhpcywgYm94ICkge1xuXG5cdFx0Y29uc3QgYm94TWluID0gYm94Lm1pbjtcblx0XHRjb25zdCBib3hNYXggPSBib3gubWF4O1xuXHRcdGxldCBtaW4gPSBJbmZpbml0eTtcblx0XHRsZXQgbWF4ID0gLSBJbmZpbml0eTtcblx0XHRmb3IgKCBsZXQgeCA9IDA7IHggPD0gMTsgeCArKyApIHtcblxuXHRcdFx0Zm9yICggbGV0IHkgPSAwOyB5IDw9IDE7IHkgKysgKSB7XG5cblx0XHRcdFx0Zm9yICggbGV0IHogPSAwOyB6IDw9IDE7IHogKysgKSB7XG5cblx0XHRcdFx0XHRwLnggPSBib3hNaW4ueCAqIHggKyBib3hNYXgueCAqICggMSAtIHggKTtcblx0XHRcdFx0XHRwLnkgPSBib3hNaW4ueSAqIHkgKyBib3hNYXgueSAqICggMSAtIHkgKTtcblx0XHRcdFx0XHRwLnogPSBib3hNaW4ueiAqIHogKyBib3hNYXgueiAqICggMSAtIHogKTtcblxuXHRcdFx0XHRcdGNvbnN0IHZhbCA9IGF4aXMuZG90KCBwICk7XG5cdFx0XHRcdFx0bWluID0gTWF0aC5taW4oIHZhbCwgbWluICk7XG5cdFx0XHRcdFx0bWF4ID0gTWF0aC5tYXgoIHZhbCwgbWF4ICk7XG5cblx0XHRcdFx0fVxuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHR0aGlzLm1pbiA9IG1pbjtcblx0XHR0aGlzLm1heCA9IG1heDtcblxuXHR9O1xuXG59ICkoKTtcblxuZXhwb3J0IGNvbnN0IGFyZUludGVyc2VjdGluZyA9ICggZnVuY3Rpb24gKCkge1xuXG5cdGNvbnN0IGNhY2hlU2F0Qm91bmRzID0gbmV3IFNlcGFyYXRpbmdBeGlzQm91bmRzKCk7XG5cdHJldHVybiBmdW5jdGlvbiBhcmVJbnRlcnNlY3RpbmcoIHNoYXBlMSwgc2hhcGUyICkge1xuXG5cdFx0Y29uc3QgcG9pbnRzMSA9IHNoYXBlMS5wb2ludHM7XG5cdFx0Y29uc3Qgc2F0QXhlczEgPSBzaGFwZTEuc2F0QXhlcztcblx0XHRjb25zdCBzYXRCb3VuZHMxID0gc2hhcGUxLnNhdEJvdW5kcztcblxuXHRcdGNvbnN0IHBvaW50czIgPSBzaGFwZTIucG9pbnRzO1xuXHRcdGNvbnN0IHNhdEF4ZXMyID0gc2hhcGUyLnNhdEF4ZXM7XG5cdFx0Y29uc3Qgc2F0Qm91bmRzMiA9IHNoYXBlMi5zYXRCb3VuZHM7XG5cblx0XHQvLyBjaGVjayBheGVzIG9mIHRoZSBmaXJzdCBzaGFwZVxuXHRcdGZvciAoIGxldCBpID0gMDsgaSA8IDM7IGkgKysgKSB7XG5cblx0XHRcdGNvbnN0IHNiID0gc2F0Qm91bmRzMVsgaSBdO1xuXHRcdFx0Y29uc3Qgc2EgPSBzYXRBeGVzMVsgaSBdO1xuXHRcdFx0Y2FjaGVTYXRCb3VuZHMuc2V0RnJvbVBvaW50cyggc2EsIHBvaW50czIgKTtcblx0XHRcdGlmICggc2IuaXNTZXBhcmF0ZWQoIGNhY2hlU2F0Qm91bmRzICkgKSByZXR1cm4gZmFsc2U7XG5cblx0XHR9XG5cblx0XHQvLyBjaGVjayBheGVzIG9mIHRoZSBzZWNvbmQgc2hhcGVcblx0XHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0XHRjb25zdCBzYiA9IHNhdEJvdW5kczJbIGkgXTtcblx0XHRcdGNvbnN0IHNhID0gc2F0QXhlczJbIGkgXTtcblx0XHRcdGNhY2hlU2F0Qm91bmRzLnNldEZyb21Qb2ludHMoIHNhLCBwb2ludHMxICk7XG5cdFx0XHRpZiAoIHNiLmlzU2VwYXJhdGVkKCBjYWNoZVNhdEJvdW5kcyApICkgcmV0dXJuIGZhbHNlO1xuXG5cdFx0fVxuXG5cdH07XG5cbn0gKSgpO1xuIl0sIm5hbWVzIjpbIlZlY3RvcjMiLCJTZXBhcmF0aW5nQXhpc0JvdW5kcyIsImNvbnN0cnVjdG9yIiwibWluIiwiSW5maW5pdHkiLCJtYXgiLCJzZXRGcm9tUG9pbnRzRmllbGQiLCJwb2ludHMiLCJmaWVsZCIsImkiLCJsIiwibGVuZ3RoIiwicCIsInZhbCIsInNldEZyb21Qb2ludHMiLCJheGlzIiwiZG90IiwiaXNTZXBhcmF0ZWQiLCJvdGhlciIsInByb3RvdHlwZSIsInNldEZyb21Cb3giLCJib3giLCJib3hNaW4iLCJib3hNYXgiLCJ4IiwieSIsInoiLCJNYXRoIiwiYXJlSW50ZXJzZWN0aW5nIiwiY2FjaGVTYXRCb3VuZHMiLCJzaGFwZTEiLCJzaGFwZTIiLCJwb2ludHMxIiwic2F0QXhlczEiLCJzYXRBeGVzIiwic2F0Qm91bmRzMSIsInNhdEJvdW5kcyIsInBvaW50czIiLCJzYXRBeGVzMiIsInNhdEJvdW5kczIiLCJzYiIsInNhIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/math/SeparatingAxisBounds.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   arrayToBox: () => (/* binding */ arrayToBox),\n/* harmony export */   computeSurfaceArea: () => (/* binding */ computeSurfaceArea),\n/* harmony export */   copyBounds: () => (/* binding */ copyBounds),\n/* harmony export */   expandByTriangleBounds: () => (/* binding */ expandByTriangleBounds),\n/* harmony export */   getLongestEdgeIndex: () => (/* binding */ getLongestEdgeIndex),\n/* harmony export */   makeEmptyBounds: () => (/* binding */ makeEmptyBounds),\n/* harmony export */   unionBounds: () => (/* binding */ unionBounds)\n/* harmony export */ });\nfunction arrayToBox(nodeIndex32, array, target) {\n    target.min.x = array[nodeIndex32];\n    target.min.y = array[nodeIndex32 + 1];\n    target.min.z = array[nodeIndex32 + 2];\n    target.max.x = array[nodeIndex32 + 3];\n    target.max.y = array[nodeIndex32 + 4];\n    target.max.z = array[nodeIndex32 + 5];\n    return target;\n}\nfunction makeEmptyBounds(target) {\n    target[0] = target[1] = target[2] = Infinity;\n    target[3] = target[4] = target[5] = -Infinity;\n}\nfunction getLongestEdgeIndex(bounds) {\n    let splitDimIdx = -1;\n    let splitDist = -Infinity;\n    for(let i = 0; i < 3; i++){\n        const dist = bounds[i + 3] - bounds[i];\n        if (dist > splitDist) {\n            splitDist = dist;\n            splitDimIdx = i;\n        }\n    }\n    return splitDimIdx;\n}\n// copies bounds a into bounds b\nfunction copyBounds(source, target) {\n    target.set(source);\n}\n// sets bounds target to the union of bounds a and b\nfunction unionBounds(a, b, target) {\n    let aVal, bVal;\n    for(let d = 0; d < 3; d++){\n        const d3 = d + 3;\n        // set the minimum values\n        aVal = a[d];\n        bVal = b[d];\n        target[d] = aVal < bVal ? aVal : bVal;\n        // set the max values\n        aVal = a[d3];\n        bVal = b[d3];\n        target[d3] = aVal > bVal ? aVal : bVal;\n    }\n}\n// expands the given bounds by the provided triangle bounds\nfunction expandByTriangleBounds(startIndex, triangleBounds, bounds) {\n    for(let d = 0; d < 3; d++){\n        const tCenter = triangleBounds[startIndex + 2 * d];\n        const tHalf = triangleBounds[startIndex + 2 * d + 1];\n        const tMin = tCenter - tHalf;\n        const tMax = tCenter + tHalf;\n        if (tMin < bounds[d]) {\n            bounds[d] = tMin;\n        }\n        if (tMax > bounds[d + 3]) {\n            bounds[d + 3] = tMax;\n        }\n    }\n}\n// compute bounds surface area\nfunction computeSurfaceArea(bounds) {\n    const d0 = bounds[3] - bounds[0];\n    const d1 = bounds[4] - bounds[1];\n    const d2 = bounds[5] - bounds[2];\n    return 2 * (d0 * d1 + d1 * d2 + d2 * d0);\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy91dGlscy9BcnJheUJveFV0aWxpdGllcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7Ozs7O0FBQU8sU0FBU0EsV0FBWUMsV0FBVyxFQUFFQyxLQUFLLEVBQUVDLE1BQU07SUFFckRBLE9BQU9DLEdBQUcsQ0FBQ0MsQ0FBQyxHQUFHSCxLQUFLLENBQUVELFlBQWE7SUFDbkNFLE9BQU9DLEdBQUcsQ0FBQ0UsQ0FBQyxHQUFHSixLQUFLLENBQUVELGNBQWMsRUFBRztJQUN2Q0UsT0FBT0MsR0FBRyxDQUFDRyxDQUFDLEdBQUdMLEtBQUssQ0FBRUQsY0FBYyxFQUFHO0lBRXZDRSxPQUFPSyxHQUFHLENBQUNILENBQUMsR0FBR0gsS0FBSyxDQUFFRCxjQUFjLEVBQUc7SUFDdkNFLE9BQU9LLEdBQUcsQ0FBQ0YsQ0FBQyxHQUFHSixLQUFLLENBQUVELGNBQWMsRUFBRztJQUN2Q0UsT0FBT0ssR0FBRyxDQUFDRCxDQUFDLEdBQUdMLEtBQUssQ0FBRUQsY0FBYyxFQUFHO0lBRXZDLE9BQU9FO0FBRVI7QUFFTyxTQUFTTSxnQkFBaUJOLE1BQU07SUFFdENBLE1BQU0sQ0FBRSxFQUFHLEdBQUdBLE1BQU0sQ0FBRSxFQUFHLEdBQUdBLE1BQU0sQ0FBRSxFQUFHLEdBQUdPO0lBQzFDUCxNQUFNLENBQUUsRUFBRyxHQUFHQSxNQUFNLENBQUUsRUFBRyxHQUFHQSxNQUFNLENBQUUsRUFBRyxHQUFHLENBQUVPO0FBRTdDO0FBRU8sU0FBU0Msb0JBQXFCQyxNQUFNO0lBRTFDLElBQUlDLGNBQWMsQ0FBRTtJQUNwQixJQUFJQyxZQUFZLENBQUVKO0lBRWxCLElBQU0sSUFBSUssSUFBSSxHQUFHQSxJQUFJLEdBQUdBLElBQU87UUFFOUIsTUFBTUMsT0FBT0osTUFBTSxDQUFFRyxJQUFJLEVBQUcsR0FBR0gsTUFBTSxDQUFFRyxFQUFHO1FBQzFDLElBQUtDLE9BQU9GLFdBQVk7WUFFdkJBLFlBQVlFO1lBQ1pILGNBQWNFO1FBRWY7SUFFRDtJQUVBLE9BQU9GO0FBRVI7QUFFQSxnQ0FBZ0M7QUFDekIsU0FBU0ksV0FBWUMsTUFBTSxFQUFFZixNQUFNO0lBRXpDQSxPQUFPZ0IsR0FBRyxDQUFFRDtBQUViO0FBRUEsb0RBQW9EO0FBQzdDLFNBQVNFLFlBQWFDLENBQUMsRUFBRUMsQ0FBQyxFQUFFbkIsTUFBTTtJQUV4QyxJQUFJb0IsTUFBTUM7SUFDVixJQUFNLElBQUlDLElBQUksR0FBR0EsSUFBSSxHQUFHQSxJQUFPO1FBRTlCLE1BQU1DLEtBQUtELElBQUk7UUFFZix5QkFBeUI7UUFDekJGLE9BQU9GLENBQUMsQ0FBRUksRUFBRztRQUNiRCxPQUFPRixDQUFDLENBQUVHLEVBQUc7UUFDYnRCLE1BQU0sQ0FBRXNCLEVBQUcsR0FBR0YsT0FBT0MsT0FBT0QsT0FBT0M7UUFFbkMscUJBQXFCO1FBQ3JCRCxPQUFPRixDQUFDLENBQUVLLEdBQUk7UUFDZEYsT0FBT0YsQ0FBQyxDQUFFSSxHQUFJO1FBQ2R2QixNQUFNLENBQUV1QixHQUFJLEdBQUdILE9BQU9DLE9BQU9ELE9BQU9DO0lBRXJDO0FBRUQ7QUFFQSwyREFBMkQ7QUFDcEQsU0FBU0csdUJBQXdCQyxVQUFVLEVBQUVDLGNBQWMsRUFBRWpCLE1BQU07SUFFekUsSUFBTSxJQUFJYSxJQUFJLEdBQUdBLElBQUksR0FBR0EsSUFBTztRQUU5QixNQUFNSyxVQUFVRCxjQUFjLENBQUVELGFBQWEsSUFBSUgsRUFBRztRQUNwRCxNQUFNTSxRQUFRRixjQUFjLENBQUVELGFBQWEsSUFBSUgsSUFBSSxFQUFHO1FBRXRELE1BQU1PLE9BQU9GLFVBQVVDO1FBQ3ZCLE1BQU1FLE9BQU9ILFVBQVVDO1FBRXZCLElBQUtDLE9BQU9wQixNQUFNLENBQUVhLEVBQUcsRUFBRztZQUV6QmIsTUFBTSxDQUFFYSxFQUFHLEdBQUdPO1FBRWY7UUFFQSxJQUFLQyxPQUFPckIsTUFBTSxDQUFFYSxJQUFJLEVBQUcsRUFBRztZQUU3QmIsTUFBTSxDQUFFYSxJQUFJLEVBQUcsR0FBR1E7UUFFbkI7SUFFRDtBQUVEO0FBRUEsOEJBQThCO0FBQ3ZCLFNBQVNDLG1CQUFvQnRCLE1BQU07SUFFekMsTUFBTXVCLEtBQUt2QixNQUFNLENBQUUsRUFBRyxHQUFHQSxNQUFNLENBQUUsRUFBRztJQUNwQyxNQUFNd0IsS0FBS3hCLE1BQU0sQ0FBRSxFQUFHLEdBQUdBLE1BQU0sQ0FBRSxFQUFHO0lBQ3BDLE1BQU15QixLQUFLekIsTUFBTSxDQUFFLEVBQUcsR0FBR0EsTUFBTSxDQUFFLEVBQUc7SUFFcEMsT0FBTyxJQUFNdUIsQ0FBQUEsS0FBS0MsS0FBS0EsS0FBS0MsS0FBS0EsS0FBS0YsRUFBQztBQUV4QyIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpYmUtM2QtY29kZS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9ub2RlX21vZHVsZXMvdGhyZWUtbWVzaC1idmgvc3JjL3V0aWxzL0FycmF5Qm94VXRpbGl0aWVzLmpzPzI4NWQiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGFycmF5VG9Cb3goIG5vZGVJbmRleDMyLCBhcnJheSwgdGFyZ2V0ICkge1xuXG5cdHRhcmdldC5taW4ueCA9IGFycmF5WyBub2RlSW5kZXgzMiBdO1xuXHR0YXJnZXQubWluLnkgPSBhcnJheVsgbm9kZUluZGV4MzIgKyAxIF07XG5cdHRhcmdldC5taW4ueiA9IGFycmF5WyBub2RlSW5kZXgzMiArIDIgXTtcblxuXHR0YXJnZXQubWF4LnggPSBhcnJheVsgbm9kZUluZGV4MzIgKyAzIF07XG5cdHRhcmdldC5tYXgueSA9IGFycmF5WyBub2RlSW5kZXgzMiArIDQgXTtcblx0dGFyZ2V0Lm1heC56ID0gYXJyYXlbIG5vZGVJbmRleDMyICsgNSBdO1xuXG5cdHJldHVybiB0YXJnZXQ7XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIG1ha2VFbXB0eUJvdW5kcyggdGFyZ2V0ICkge1xuXG5cdHRhcmdldFsgMCBdID0gdGFyZ2V0WyAxIF0gPSB0YXJnZXRbIDIgXSA9IEluZmluaXR5O1xuXHR0YXJnZXRbIDMgXSA9IHRhcmdldFsgNCBdID0gdGFyZ2V0WyA1IF0gPSAtIEluZmluaXR5O1xuXG59XG5cbmV4cG9ydCBmdW5jdGlvbiBnZXRMb25nZXN0RWRnZUluZGV4KCBib3VuZHMgKSB7XG5cblx0bGV0IHNwbGl0RGltSWR4ID0gLSAxO1xuXHRsZXQgc3BsaXREaXN0ID0gLSBJbmZpbml0eTtcblxuXHRmb3IgKCBsZXQgaSA9IDA7IGkgPCAzOyBpICsrICkge1xuXG5cdFx0Y29uc3QgZGlzdCA9IGJvdW5kc1sgaSArIDMgXSAtIGJvdW5kc1sgaSBdO1xuXHRcdGlmICggZGlzdCA+IHNwbGl0RGlzdCApIHtcblxuXHRcdFx0c3BsaXREaXN0ID0gZGlzdDtcblx0XHRcdHNwbGl0RGltSWR4ID0gaTtcblxuXHRcdH1cblxuXHR9XG5cblx0cmV0dXJuIHNwbGl0RGltSWR4O1xuXG59XG5cbi8vIGNvcGllcyBib3VuZHMgYSBpbnRvIGJvdW5kcyBiXG5leHBvcnQgZnVuY3Rpb24gY29weUJvdW5kcyggc291cmNlLCB0YXJnZXQgKSB7XG5cblx0dGFyZ2V0LnNldCggc291cmNlICk7XG5cbn1cblxuLy8gc2V0cyBib3VuZHMgdGFyZ2V0IHRvIHRoZSB1bmlvbiBvZiBib3VuZHMgYSBhbmQgYlxuZXhwb3J0IGZ1bmN0aW9uIHVuaW9uQm91bmRzKCBhLCBiLCB0YXJnZXQgKSB7XG5cblx0bGV0IGFWYWwsIGJWYWw7XG5cdGZvciAoIGxldCBkID0gMDsgZCA8IDM7IGQgKysgKSB7XG5cblx0XHRjb25zdCBkMyA9IGQgKyAzO1xuXG5cdFx0Ly8gc2V0IHRoZSBtaW5pbXVtIHZhbHVlc1xuXHRcdGFWYWwgPSBhWyBkIF07XG5cdFx0YlZhbCA9IGJbIGQgXTtcblx0XHR0YXJnZXRbIGQgXSA9IGFWYWwgPCBiVmFsID8gYVZhbCA6IGJWYWw7XG5cblx0XHQvLyBzZXQgdGhlIG1heCB2YWx1ZXNcblx0XHRhVmFsID0gYVsgZDMgXTtcblx0XHRiVmFsID0gYlsgZDMgXTtcblx0XHR0YXJnZXRbIGQzIF0gPSBhVmFsID4gYlZhbCA/IGFWYWwgOiBiVmFsO1xuXG5cdH1cblxufVxuXG4vLyBleHBhbmRzIHRoZSBnaXZlbiBib3VuZHMgYnkgdGhlIHByb3ZpZGVkIHRyaWFuZ2xlIGJvdW5kc1xuZXhwb3J0IGZ1bmN0aW9uIGV4cGFuZEJ5VHJpYW5nbGVCb3VuZHMoIHN0YXJ0SW5kZXgsIHRyaWFuZ2xlQm91bmRzLCBib3VuZHMgKSB7XG5cblx0Zm9yICggbGV0IGQgPSAwOyBkIDwgMzsgZCArKyApIHtcblxuXHRcdGNvbnN0IHRDZW50ZXIgPSB0cmlhbmdsZUJvdW5kc1sgc3RhcnRJbmRleCArIDIgKiBkIF07XG5cdFx0Y29uc3QgdEhhbGYgPSB0cmlhbmdsZUJvdW5kc1sgc3RhcnRJbmRleCArIDIgKiBkICsgMSBdO1xuXG5cdFx0Y29uc3QgdE1pbiA9IHRDZW50ZXIgLSB0SGFsZjtcblx0XHRjb25zdCB0TWF4ID0gdENlbnRlciArIHRIYWxmO1xuXG5cdFx0aWYgKCB0TWluIDwgYm91bmRzWyBkIF0gKSB7XG5cblx0XHRcdGJvdW5kc1sgZCBdID0gdE1pbjtcblxuXHRcdH1cblxuXHRcdGlmICggdE1heCA+IGJvdW5kc1sgZCArIDMgXSApIHtcblxuXHRcdFx0Ym91bmRzWyBkICsgMyBdID0gdE1heDtcblxuXHRcdH1cblxuXHR9XG5cbn1cblxuLy8gY29tcHV0ZSBib3VuZHMgc3VyZmFjZSBhcmVhXG5leHBvcnQgZnVuY3Rpb24gY29tcHV0ZVN1cmZhY2VBcmVhKCBib3VuZHMgKSB7XG5cblx0Y29uc3QgZDAgPSBib3VuZHNbIDMgXSAtIGJvdW5kc1sgMCBdO1xuXHRjb25zdCBkMSA9IGJvdW5kc1sgNCBdIC0gYm91bmRzWyAxIF07XG5cdGNvbnN0IGQyID0gYm91bmRzWyA1IF0gLSBib3VuZHNbIDIgXTtcblxuXHRyZXR1cm4gMiAqICggZDAgKiBkMSArIGQxICogZDIgKyBkMiAqIGQwICk7XG5cbn1cbiJdLCJuYW1lcyI6WyJhcnJheVRvQm94Iiwibm9kZUluZGV4MzIiLCJhcnJheSIsInRhcmdldCIsIm1pbiIsIngiLCJ5IiwieiIsIm1heCIsIm1ha2VFbXB0eUJvdW5kcyIsIkluZmluaXR5IiwiZ2V0TG9uZ2VzdEVkZ2VJbmRleCIsImJvdW5kcyIsInNwbGl0RGltSWR4Iiwic3BsaXREaXN0IiwiaSIsImRpc3QiLCJjb3B5Qm91bmRzIiwic291cmNlIiwic2V0IiwidW5pb25Cb3VuZHMiLCJhIiwiYiIsImFWYWwiLCJiVmFsIiwiZCIsImQzIiwiZXhwYW5kQnlUcmlhbmdsZUJvdW5kcyIsInN0YXJ0SW5kZXgiLCJ0cmlhbmdsZUJvdW5kcyIsInRDZW50ZXIiLCJ0SGFsZiIsInRNaW4iLCJ0TWF4IiwiY29tcHV0ZVN1cmZhY2VBcmVhIiwiZDAiLCJkMSIsImQyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/ArrayBoxUtilities.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/BufferUtils.js":
/*!*********************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/BufferUtils.js ***!
  \*********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   isSharedArrayBufferSupported: () => (/* binding */ isSharedArrayBufferSupported)\n/* harmony export */ });\nfunction isSharedArrayBufferSupported() {\n    return typeof SharedArrayBuffer !== \"undefined\";\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy91dGlscy9CdWZmZXJVdGlscy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQU8sU0FBU0E7SUFFZixPQUFPLE9BQU9DLHNCQUFzQjtBQUVyQyIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpYmUtM2QtY29kZS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9ub2RlX21vZHVsZXMvdGhyZWUtbWVzaC1idmgvc3JjL3V0aWxzL0J1ZmZlclV0aWxzLmpzPzA1YWEiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGZ1bmN0aW9uIGlzU2hhcmVkQXJyYXlCdWZmZXJTdXBwb3J0ZWQoKSB7XG5cblx0cmV0dXJuIHR5cGVvZiBTaGFyZWRBcnJheUJ1ZmZlciAhPT0gJ3VuZGVmaW5lZCc7XG5cbn1cbiJdLCJuYW1lcyI6WyJpc1NoYXJlZEFycmF5QnVmZmVyU3VwcG9ydGVkIiwiU2hhcmVkQXJyYXlCdWZmZXIiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/BufferUtils.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/ExtendedTrianglePool.js":
/*!******************************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/ExtendedTrianglePool.js ***!
  \******************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   ExtendedTrianglePool: () => (/* binding */ ExtendedTrianglePool)\n/* harmony export */ });\n/* harmony import */ var _math_ExtendedTriangle_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ../math/ExtendedTriangle.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/math/ExtendedTriangle.js\");\n/* harmony import */ var _PrimitivePool_js__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! ./PrimitivePool.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/PrimitivePool.js\");\n\n\nclass ExtendedTrianglePoolBase extends _PrimitivePool_js__WEBPACK_IMPORTED_MODULE_0__.PrimitivePool {\n    constructor(){\n        super(()=>new _math_ExtendedTriangle_js__WEBPACK_IMPORTED_MODULE_1__.ExtendedTriangle());\n    }\n}\nconst ExtendedTrianglePool = /* @__PURE__ */ new ExtendedTrianglePoolBase();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy91dGlscy9FeHRlbmRlZFRyaWFuZ2xlUG9vbC5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFBK0Q7QUFDWjtBQUVuRCxNQUFNRSxpQ0FBaUNELDREQUFhQTtJQUVuREUsYUFBYztRQUViLEtBQUssQ0FBRSxJQUFNLElBQUlILHVFQUFnQkE7SUFFbEM7QUFFRDtBQUVPLE1BQU1JLHVCQUF1QixhQUFhLEdBQUcsSUFBSUYsMkJBQTJCIiwic291cmNlcyI6WyJ3ZWJwYWNrOi8vdmliZS0zZC1jb2RlLy4vbm9kZV9tb2R1bGVzL0ByZWFjdC10aHJlZS9kcmVpL25vZGVfbW9kdWxlcy90aHJlZS1tZXNoLWJ2aC9zcmMvdXRpbHMvRXh0ZW5kZWRUcmlhbmdsZVBvb2wuanM/ZDA0NiJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBFeHRlbmRlZFRyaWFuZ2xlIH0gZnJvbSAnLi4vbWF0aC9FeHRlbmRlZFRyaWFuZ2xlLmpzJztcbmltcG9ydCB7IFByaW1pdGl2ZVBvb2wgfSBmcm9tICcuL1ByaW1pdGl2ZVBvb2wuanMnO1xuXG5jbGFzcyBFeHRlbmRlZFRyaWFuZ2xlUG9vbEJhc2UgZXh0ZW5kcyBQcmltaXRpdmVQb29sIHtcblxuXHRjb25zdHJ1Y3RvcigpIHtcblxuXHRcdHN1cGVyKCAoKSA9PiBuZXcgRXh0ZW5kZWRUcmlhbmdsZSgpICk7XG5cblx0fVxuXG59XG5cbmV4cG9ydCBjb25zdCBFeHRlbmRlZFRyaWFuZ2xlUG9vbCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgRXh0ZW5kZWRUcmlhbmdsZVBvb2xCYXNlKCk7XG4iXSwibmFtZXMiOlsiRXh0ZW5kZWRUcmlhbmdsZSIsIlByaW1pdGl2ZVBvb2wiLCJFeHRlbmRlZFRyaWFuZ2xlUG9vbEJhc2UiLCJjb25zdHJ1Y3RvciIsIkV4dGVuZGVkVHJpYW5nbGVQb29sIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/ExtendedTrianglePool.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/ExtensionUtilities.js":
/*!****************************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/ExtensionUtilities.js ***!
  \****************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   acceleratedRaycast: () => (/* binding */ acceleratedRaycast),\n/* harmony export */   computeBoundsTree: () => (/* binding */ computeBoundsTree),\n/* harmony export */   disposeBoundsTree: () => (/* binding */ disposeBoundsTree)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n/* harmony import */ var _GeometryRayIntersectUtilities_js__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! ./GeometryRayIntersectUtilities.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/GeometryRayIntersectUtilities.js\");\n/* harmony import */ var _core_MeshBVH_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ../core/MeshBVH.js */ \"(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/core/MeshBVH.js\");\n\n\n\nconst ray = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Ray();\nconst tmpInverseMatrix = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Matrix4();\nconst origMeshRaycastFunc = three__WEBPACK_IMPORTED_MODULE_0__.Mesh.prototype.raycast;\nfunction acceleratedRaycast(raycaster, intersects) {\n    if (this.geometry.boundsTree) {\n        if (this.material === undefined) return;\n        tmpInverseMatrix.copy(this.matrixWorld).invert();\n        ray.copy(raycaster.ray).applyMatrix4(tmpInverseMatrix);\n        const bvh = this.geometry.boundsTree;\n        if (raycaster.firstHitOnly === true) {\n            const hit = (0,_GeometryRayIntersectUtilities_js__WEBPACK_IMPORTED_MODULE_1__.convertRaycastIntersect)(bvh.raycastFirst(ray, this.material), this, raycaster);\n            if (hit) {\n                intersects.push(hit);\n            }\n        } else {\n            const hits = bvh.raycast(ray, this.material);\n            for(let i = 0, l = hits.length; i < l; i++){\n                const hit = (0,_GeometryRayIntersectUtilities_js__WEBPACK_IMPORTED_MODULE_1__.convertRaycastIntersect)(hits[i], this, raycaster);\n                if (hit) {\n                    intersects.push(hit);\n                }\n            }\n        }\n    } else {\n        origMeshRaycastFunc.call(this, raycaster, intersects);\n    }\n}\nfunction computeBoundsTree(options) {\n    this.boundsTree = new _core_MeshBVH_js__WEBPACK_IMPORTED_MODULE_2__.MeshBVH(this, options);\n    return this.boundsTree;\n}\nfunction disposeBoundsTree() {\n    this.boundsTree = null;\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy91dGlscy9FeHRlbnNpb25VdGlsaXRpZXMuanMiLCJtYXBwaW5ncyI6Ijs7Ozs7Ozs7O0FBQTJDO0FBQ2tDO0FBQ2hDO0FBRTdDLE1BQU1LLE1BQU0sYUFBYSxHQUFHLElBQUlMLHNDQUFHQTtBQUNuQyxNQUFNTSxtQkFBbUIsYUFBYSxHQUFHLElBQUlMLDBDQUFPQTtBQUNwRCxNQUFNTSxzQkFBc0JMLHVDQUFJQSxDQUFDTSxTQUFTLENBQUNDLE9BQU87QUFFM0MsU0FBU0MsbUJBQW9CQyxTQUFTLEVBQUVDLFVBQVU7SUFFeEQsSUFBSyxJQUFJLENBQUNDLFFBQVEsQ0FBQ0MsVUFBVSxFQUFHO1FBRS9CLElBQUssSUFBSSxDQUFDQyxRQUFRLEtBQUtDLFdBQVk7UUFFbkNWLGlCQUFpQlcsSUFBSSxDQUFFLElBQUksQ0FBQ0MsV0FBVyxFQUFHQyxNQUFNO1FBQ2hEZCxJQUFJWSxJQUFJLENBQUVOLFVBQVVOLEdBQUcsRUFBR2UsWUFBWSxDQUFFZDtRQUV4QyxNQUFNZSxNQUFNLElBQUksQ0FBQ1IsUUFBUSxDQUFDQyxVQUFVO1FBQ3BDLElBQUtILFVBQVVXLFlBQVksS0FBSyxNQUFPO1lBRXRDLE1BQU1DLE1BQU1wQiwwRkFBdUJBLENBQUVrQixJQUFJRyxZQUFZLENBQUVuQixLQUFLLElBQUksQ0FBQ1UsUUFBUSxHQUFJLElBQUksRUFBRUo7WUFDbkYsSUFBS1ksS0FBTTtnQkFFVlgsV0FBV2EsSUFBSSxDQUFFRjtZQUVsQjtRQUVELE9BQU87WUFFTixNQUFNRyxPQUFPTCxJQUFJWixPQUFPLENBQUVKLEtBQUssSUFBSSxDQUFDVSxRQUFRO1lBQzVDLElBQU0sSUFBSVksSUFBSSxHQUFHQyxJQUFJRixLQUFLRyxNQUFNLEVBQUVGLElBQUlDLEdBQUdELElBQU87Z0JBRS9DLE1BQU1KLE1BQU1wQiwwRkFBdUJBLENBQUV1QixJQUFJLENBQUVDLEVBQUcsRUFBRSxJQUFJLEVBQUVoQjtnQkFDdEQsSUFBS1ksS0FBTTtvQkFFVlgsV0FBV2EsSUFBSSxDQUFFRjtnQkFFbEI7WUFFRDtRQUVEO0lBRUQsT0FBTztRQUVOaEIsb0JBQW9CdUIsSUFBSSxDQUFFLElBQUksRUFBRW5CLFdBQVdDO0lBRTVDO0FBRUQ7QUFFTyxTQUFTbUIsa0JBQW1CQyxPQUFPO0lBRXpDLElBQUksQ0FBQ2xCLFVBQVUsR0FBRyxJQUFJVixxREFBT0EsQ0FBRSxJQUFJLEVBQUU0QjtJQUNyQyxPQUFPLElBQUksQ0FBQ2xCLFVBQVU7QUFFdkI7QUFFTyxTQUFTbUI7SUFFZixJQUFJLENBQUNuQixVQUFVLEdBQUc7QUFFbkIiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aWJlLTNkLWNvZGUvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy91dGlscy9FeHRlbnNpb25VdGlsaXRpZXMuanM/OTExZSJdLCJzb3VyY2VzQ29udGVudCI6WyJpbXBvcnQgeyBSYXksIE1hdHJpeDQsIE1lc2ggfSBmcm9tICd0aHJlZSc7XG5pbXBvcnQgeyBjb252ZXJ0UmF5Y2FzdEludGVyc2VjdCB9IGZyb20gJy4vR2VvbWV0cnlSYXlJbnRlcnNlY3RVdGlsaXRpZXMuanMnO1xuaW1wb3J0IHsgTWVzaEJWSCB9IGZyb20gJy4uL2NvcmUvTWVzaEJWSC5qcyc7XG5cbmNvbnN0IHJheSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgUmF5KCk7XG5jb25zdCB0bXBJbnZlcnNlTWF0cml4ID0gLyogQF9fUFVSRV9fICovIG5ldyBNYXRyaXg0KCk7XG5jb25zdCBvcmlnTWVzaFJheWNhc3RGdW5jID0gTWVzaC5wcm90b3R5cGUucmF5Y2FzdDtcblxuZXhwb3J0IGZ1bmN0aW9uIGFjY2VsZXJhdGVkUmF5Y2FzdCggcmF5Y2FzdGVyLCBpbnRlcnNlY3RzICkge1xuXG5cdGlmICggdGhpcy5nZW9tZXRyeS5ib3VuZHNUcmVlICkge1xuXG5cdFx0aWYgKCB0aGlzLm1hdGVyaWFsID09PSB1bmRlZmluZWQgKSByZXR1cm47XG5cblx0XHR0bXBJbnZlcnNlTWF0cml4LmNvcHkoIHRoaXMubWF0cml4V29ybGQgKS5pbnZlcnQoKTtcblx0XHRyYXkuY29weSggcmF5Y2FzdGVyLnJheSApLmFwcGx5TWF0cml4NCggdG1wSW52ZXJzZU1hdHJpeCApO1xuXG5cdFx0Y29uc3QgYnZoID0gdGhpcy5nZW9tZXRyeS5ib3VuZHNUcmVlO1xuXHRcdGlmICggcmF5Y2FzdGVyLmZpcnN0SGl0T25seSA9PT0gdHJ1ZSApIHtcblxuXHRcdFx0Y29uc3QgaGl0ID0gY29udmVydFJheWNhc3RJbnRlcnNlY3QoIGJ2aC5yYXljYXN0Rmlyc3QoIHJheSwgdGhpcy5tYXRlcmlhbCApLCB0aGlzLCByYXljYXN0ZXIgKTtcblx0XHRcdGlmICggaGl0ICkge1xuXG5cdFx0XHRcdGludGVyc2VjdHMucHVzaCggaGl0ICk7XG5cblx0XHRcdH1cblxuXHRcdH0gZWxzZSB7XG5cblx0XHRcdGNvbnN0IGhpdHMgPSBidmgucmF5Y2FzdCggcmF5LCB0aGlzLm1hdGVyaWFsICk7XG5cdFx0XHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBoaXRzLmxlbmd0aDsgaSA8IGw7IGkgKysgKSB7XG5cblx0XHRcdFx0Y29uc3QgaGl0ID0gY29udmVydFJheWNhc3RJbnRlcnNlY3QoIGhpdHNbIGkgXSwgdGhpcywgcmF5Y2FzdGVyICk7XG5cdFx0XHRcdGlmICggaGl0ICkge1xuXG5cdFx0XHRcdFx0aW50ZXJzZWN0cy5wdXNoKCBoaXQgKTtcblxuXHRcdFx0XHR9XG5cblx0XHRcdH1cblxuXHRcdH1cblxuXHR9IGVsc2Uge1xuXG5cdFx0b3JpZ01lc2hSYXljYXN0RnVuYy5jYWxsKCB0aGlzLCByYXljYXN0ZXIsIGludGVyc2VjdHMgKTtcblxuXHR9XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGNvbXB1dGVCb3VuZHNUcmVlKCBvcHRpb25zICkge1xuXG5cdHRoaXMuYm91bmRzVHJlZSA9IG5ldyBNZXNoQlZIKCB0aGlzLCBvcHRpb25zICk7XG5cdHJldHVybiB0aGlzLmJvdW5kc1RyZWU7XG5cbn1cblxuZXhwb3J0IGZ1bmN0aW9uIGRpc3Bvc2VCb3VuZHNUcmVlKCkge1xuXG5cdHRoaXMuYm91bmRzVHJlZSA9IG51bGw7XG5cbn1cbiJdLCJuYW1lcyI6WyJSYXkiLCJNYXRyaXg0IiwiTWVzaCIsImNvbnZlcnRSYXljYXN0SW50ZXJzZWN0IiwiTWVzaEJWSCIsInJheSIsInRtcEludmVyc2VNYXRyaXgiLCJvcmlnTWVzaFJheWNhc3RGdW5jIiwicHJvdG90eXBlIiwicmF5Y2FzdCIsImFjY2VsZXJhdGVkUmF5Y2FzdCIsInJheWNhc3RlciIsImludGVyc2VjdHMiLCJnZW9tZXRyeSIsImJvdW5kc1RyZWUiLCJtYXRlcmlhbCIsInVuZGVmaW5lZCIsImNvcHkiLCJtYXRyaXhXb3JsZCIsImludmVydCIsImFwcGx5TWF0cml4NCIsImJ2aCIsImZpcnN0SGl0T25seSIsImhpdCIsInJheWNhc3RGaXJzdCIsInB1c2giLCJoaXRzIiwiaSIsImwiLCJsZW5ndGgiLCJjYWxsIiwiY29tcHV0ZUJvdW5kc1RyZWUiLCJvcHRpb25zIiwiZGlzcG9zZUJvdW5kc1RyZWUiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/ExtensionUtilities.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/GeometryRayIntersectUtilities.js":
/*!***************************************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/GeometryRayIntersectUtilities.js ***!
  \***************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   convertRaycastIntersect: () => (/* binding */ convertRaycastIntersect)\n/* harmony export */ });\n// converts the given BVH raycast intersection to align with the three.js raycast\n// structure (include object, world space distance and point).\nfunction convertRaycastIntersect(hit, object, raycaster) {\n    if (hit === null) {\n        return null;\n    }\n    hit.point.applyMatrix4(object.matrixWorld);\n    hit.distance = hit.point.distanceTo(raycaster.ray.origin);\n    hit.object = object;\n    if (hit.distance < raycaster.near || hit.distance > raycaster.far) {\n        return null;\n    } else {\n        return hit;\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy91dGlscy9HZW9tZXRyeVJheUludGVyc2VjdFV0aWxpdGllcy5qcyIsIm1hcHBpbmdzIjoiOzs7O0FBQUEsaUZBQWlGO0FBQ2pGLDhEQUE4RDtBQUN2RCxTQUFTQSx3QkFBeUJDLEdBQUcsRUFBRUMsTUFBTSxFQUFFQyxTQUFTO0lBRTlELElBQUtGLFFBQVEsTUFBTztRQUVuQixPQUFPO0lBRVI7SUFFQUEsSUFBSUcsS0FBSyxDQUFDQyxZQUFZLENBQUVILE9BQU9JLFdBQVc7SUFDMUNMLElBQUlNLFFBQVEsR0FBR04sSUFBSUcsS0FBSyxDQUFDSSxVQUFVLENBQUVMLFVBQVVNLEdBQUcsQ0FBQ0MsTUFBTTtJQUN6RFQsSUFBSUMsTUFBTSxHQUFHQTtJQUViLElBQUtELElBQUlNLFFBQVEsR0FBR0osVUFBVVEsSUFBSSxJQUFJVixJQUFJTSxRQUFRLEdBQUdKLFVBQVVTLEdBQUcsRUFBRztRQUVwRSxPQUFPO0lBRVIsT0FBTztRQUVOLE9BQU9YO0lBRVI7QUFFRCIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpYmUtM2QtY29kZS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9ub2RlX21vZHVsZXMvdGhyZWUtbWVzaC1idmgvc3JjL3V0aWxzL0dlb21ldHJ5UmF5SW50ZXJzZWN0VXRpbGl0aWVzLmpzP2I0NDciXSwic291cmNlc0NvbnRlbnQiOlsiLy8gY29udmVydHMgdGhlIGdpdmVuIEJWSCByYXljYXN0IGludGVyc2VjdGlvbiB0byBhbGlnbiB3aXRoIHRoZSB0aHJlZS5qcyByYXljYXN0XG4vLyBzdHJ1Y3R1cmUgKGluY2x1ZGUgb2JqZWN0LCB3b3JsZCBzcGFjZSBkaXN0YW5jZSBhbmQgcG9pbnQpLlxuZXhwb3J0IGZ1bmN0aW9uIGNvbnZlcnRSYXljYXN0SW50ZXJzZWN0KCBoaXQsIG9iamVjdCwgcmF5Y2FzdGVyICkge1xuXG5cdGlmICggaGl0ID09PSBudWxsICkge1xuXG5cdFx0cmV0dXJuIG51bGw7XG5cblx0fVxuXG5cdGhpdC5wb2ludC5hcHBseU1hdHJpeDQoIG9iamVjdC5tYXRyaXhXb3JsZCApO1xuXHRoaXQuZGlzdGFuY2UgPSBoaXQucG9pbnQuZGlzdGFuY2VUbyggcmF5Y2FzdGVyLnJheS5vcmlnaW4gKTtcblx0aGl0Lm9iamVjdCA9IG9iamVjdDtcblxuXHRpZiAoIGhpdC5kaXN0YW5jZSA8IHJheWNhc3Rlci5uZWFyIHx8IGhpdC5kaXN0YW5jZSA+IHJheWNhc3Rlci5mYXIgKSB7XG5cblx0XHRyZXR1cm4gbnVsbDtcblxuXHR9IGVsc2Uge1xuXG5cdFx0cmV0dXJuIGhpdDtcblxuXHR9XG5cbn1cbiJdLCJuYW1lcyI6WyJjb252ZXJ0UmF5Y2FzdEludGVyc2VjdCIsImhpdCIsIm9iamVjdCIsInJheWNhc3RlciIsInBvaW50IiwiYXBwbHlNYXRyaXg0IiwibWF0cml4V29ybGQiLCJkaXN0YW5jZSIsImRpc3RhbmNlVG8iLCJyYXkiLCJvcmlnaW4iLCJuZWFyIiwiZmFyIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/GeometryRayIntersectUtilities.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/PrimitivePool.js":
/*!***********************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/PrimitivePool.js ***!
  \***********************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   PrimitivePool: () => (/* binding */ PrimitivePool)\n/* harmony export */ });\nclass PrimitivePool {\n    constructor(getNewPrimitive){\n        this._getNewPrimitive = getNewPrimitive;\n        this._primitives = [];\n    }\n    getPrimitive() {\n        const primitives = this._primitives;\n        if (primitives.length === 0) {\n            return this._getNewPrimitive();\n        } else {\n            return primitives.pop();\n        }\n    }\n    releasePrimitive(primitive) {\n        this._primitives.push(primitive);\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy91dGlscy9QcmltaXRpdmVQb29sLmpzIiwibWFwcGluZ3MiOiI7Ozs7QUFBTyxNQUFNQTtJQUVaQyxZQUFhQyxlQUFlLENBQUc7UUFFOUIsSUFBSSxDQUFDQyxnQkFBZ0IsR0FBR0Q7UUFDeEIsSUFBSSxDQUFDRSxXQUFXLEdBQUcsRUFBRTtJQUV0QjtJQUVBQyxlQUFlO1FBRWQsTUFBTUMsYUFBYSxJQUFJLENBQUNGLFdBQVc7UUFDbkMsSUFBS0UsV0FBV0MsTUFBTSxLQUFLLEdBQUk7WUFFOUIsT0FBTyxJQUFJLENBQUNKLGdCQUFnQjtRQUU3QixPQUFPO1lBRU4sT0FBT0csV0FBV0UsR0FBRztRQUV0QjtJQUVEO0lBRUFDLGlCQUFrQkMsU0FBUyxFQUFHO1FBRTdCLElBQUksQ0FBQ04sV0FBVyxDQUFDTyxJQUFJLENBQUVEO0lBRXhCO0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aWJlLTNkLWNvZGUvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy91dGlscy9QcmltaXRpdmVQb29sLmpzPzRiZjgiXSwic291cmNlc0NvbnRlbnQiOlsiZXhwb3J0IGNsYXNzIFByaW1pdGl2ZVBvb2wge1xuXG5cdGNvbnN0cnVjdG9yKCBnZXROZXdQcmltaXRpdmUgKSB7XG5cblx0XHR0aGlzLl9nZXROZXdQcmltaXRpdmUgPSBnZXROZXdQcmltaXRpdmU7XG5cdFx0dGhpcy5fcHJpbWl0aXZlcyA9IFtdO1xuXG5cdH1cblxuXHRnZXRQcmltaXRpdmUoKSB7XG5cblx0XHRjb25zdCBwcmltaXRpdmVzID0gdGhpcy5fcHJpbWl0aXZlcztcblx0XHRpZiAoIHByaW1pdGl2ZXMubGVuZ3RoID09PSAwICkge1xuXG5cdFx0XHRyZXR1cm4gdGhpcy5fZ2V0TmV3UHJpbWl0aXZlKCk7XG5cblx0XHR9IGVsc2Uge1xuXG5cdFx0XHRyZXR1cm4gcHJpbWl0aXZlcy5wb3AoKTtcblxuXHRcdH1cblxuXHR9XG5cblx0cmVsZWFzZVByaW1pdGl2ZSggcHJpbWl0aXZlICkge1xuXG5cdFx0dGhpcy5fcHJpbWl0aXZlcy5wdXNoKCBwcmltaXRpdmUgKTtcblxuXHR9XG5cbn1cbiJdLCJuYW1lcyI6WyJQcmltaXRpdmVQb29sIiwiY29uc3RydWN0b3IiLCJnZXROZXdQcmltaXRpdmUiLCJfZ2V0TmV3UHJpbWl0aXZlIiwiX3ByaW1pdGl2ZXMiLCJnZXRQcmltaXRpdmUiLCJwcmltaXRpdmVzIiwibGVuZ3RoIiwicG9wIiwicmVsZWFzZVByaW1pdGl2ZSIsInByaW1pdGl2ZSIsInB1c2giXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/PrimitivePool.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/ThreeRayIntersectUtilities.js":
/*!************************************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/ThreeRayIntersectUtilities.js ***!
  \************************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   intersectTri: () => (/* binding */ intersectTri)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n\n// Ripped and modified From THREE.js Mesh raycast\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L115\nconst _vA = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst _vB = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst _vC = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst _uvA = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\nconst _uvB = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\nconst _uvC = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\nconst _normalA = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst _normalB = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst _normalC = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst _intersectionPoint = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nfunction checkIntersection(ray, pA, pB, pC, point, side) {\n    let intersect;\n    if (side === three__WEBPACK_IMPORTED_MODULE_0__.BackSide) {\n        intersect = ray.intersectTriangle(pC, pB, pA, true, point);\n    } else {\n        intersect = ray.intersectTriangle(pA, pB, pC, side !== three__WEBPACK_IMPORTED_MODULE_0__.DoubleSide, point);\n    }\n    if (intersect === null) return null;\n    const distance = ray.origin.distanceTo(point);\n    return {\n        distance: distance,\n        point: point.clone()\n    };\n}\nfunction checkBufferGeometryIntersection(ray, position, normal, uv, uv1, a, b, c, side) {\n    _vA.fromBufferAttribute(position, a);\n    _vB.fromBufferAttribute(position, b);\n    _vC.fromBufferAttribute(position, c);\n    const intersection = checkIntersection(ray, _vA, _vB, _vC, _intersectionPoint, side);\n    if (intersection) {\n        if (uv) {\n            _uvA.fromBufferAttribute(uv, a);\n            _uvB.fromBufferAttribute(uv, b);\n            _uvC.fromBufferAttribute(uv, c);\n            intersection.uv = three__WEBPACK_IMPORTED_MODULE_0__.Triangle.getInterpolation(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new three__WEBPACK_IMPORTED_MODULE_0__.Vector2());\n        }\n        if (uv1) {\n            _uvA.fromBufferAttribute(uv1, a);\n            _uvB.fromBufferAttribute(uv1, b);\n            _uvC.fromBufferAttribute(uv1, c);\n            intersection.uv1 = three__WEBPACK_IMPORTED_MODULE_0__.Triangle.getInterpolation(_intersectionPoint, _vA, _vB, _vC, _uvA, _uvB, _uvC, new three__WEBPACK_IMPORTED_MODULE_0__.Vector2());\n        }\n        if (normal) {\n            _normalA.fromBufferAttribute(normal, a);\n            _normalB.fromBufferAttribute(normal, b);\n            _normalC.fromBufferAttribute(normal, c);\n            intersection.normal = three__WEBPACK_IMPORTED_MODULE_0__.Triangle.getInterpolation(_intersectionPoint, _vA, _vB, _vC, _normalA, _normalB, _normalC, new three__WEBPACK_IMPORTED_MODULE_0__.Vector3());\n            if (intersection.normal.dot(ray.direction) > 0) {\n                intersection.normal.multiplyScalar(-1);\n            }\n        }\n        const face = {\n            a: a,\n            b: b,\n            c: c,\n            normal: new three__WEBPACK_IMPORTED_MODULE_0__.Vector3(),\n            materialIndex: 0\n        };\n        three__WEBPACK_IMPORTED_MODULE_0__.Triangle.getNormal(_vA, _vB, _vC, face.normal);\n        intersection.face = face;\n        intersection.faceIndex = a;\n    }\n    return intersection;\n}\n// https://github.com/mrdoob/three.js/blob/0aa87c999fe61e216c1133fba7a95772b503eddf/src/objects/Mesh.js#L258\nfunction intersectTri(geo, side, ray, tri, intersections) {\n    const triOffset = tri * 3;\n    let a = triOffset + 0;\n    let b = triOffset + 1;\n    let c = triOffset + 2;\n    const index = geo.index;\n    if (geo.index) {\n        a = index.getX(a);\n        b = index.getX(b);\n        c = index.getX(c);\n    }\n    const { position, normal, uv, uv1 } = geo.attributes;\n    const intersection = checkBufferGeometryIntersection(ray, position, normal, uv, uv1, a, b, c, side);\n    if (intersection) {\n        intersection.faceIndex = tri;\n        if (intersections) intersections.push(intersection);\n        return intersection;\n    }\n    return null;\n}\n\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy91dGlscy9UaHJlZVJheUludGVyc2VjdFV0aWxpdGllcy5qcyIsIm1hcHBpbmdzIjoiOzs7OztBQUF5RTtBQUV6RSxpREFBaUQ7QUFDakQsNEdBQTRHO0FBQzVHLE1BQU1LLE1BQU0sYUFBYSxHQUFHLElBQUlMLDBDQUFPQTtBQUN2QyxNQUFNTSxNQUFNLGFBQWEsR0FBRyxJQUFJTiwwQ0FBT0E7QUFDdkMsTUFBTU8sTUFBTSxhQUFhLEdBQUcsSUFBSVAsMENBQU9BO0FBRXZDLE1BQU1RLE9BQU8sYUFBYSxHQUFHLElBQUlQLDBDQUFPQTtBQUN4QyxNQUFNUSxPQUFPLGFBQWEsR0FBRyxJQUFJUiwwQ0FBT0E7QUFDeEMsTUFBTVMsT0FBTyxhQUFhLEdBQUcsSUFBSVQsMENBQU9BO0FBRXhDLE1BQU1VLFdBQVcsYUFBYSxHQUFHLElBQUlYLDBDQUFPQTtBQUM1QyxNQUFNWSxXQUFXLGFBQWEsR0FBRyxJQUFJWiwwQ0FBT0E7QUFDNUMsTUFBTWEsV0FBVyxhQUFhLEdBQUcsSUFBSWIsMENBQU9BO0FBRTVDLE1BQU1jLHFCQUFxQixhQUFhLEdBQUcsSUFBSWQsMENBQU9BO0FBQ3RELFNBQVNlLGtCQUFtQkMsR0FBRyxFQUFFQyxFQUFFLEVBQUVDLEVBQUUsRUFBRUMsRUFBRSxFQUFFQyxLQUFLLEVBQUVDLElBQUk7SUFFdkQsSUFBSUM7SUFDSixJQUFLRCxTQUFTakIsMkNBQVFBLEVBQUc7UUFFeEJrQixZQUFZTixJQUFJTyxpQkFBaUIsQ0FBRUosSUFBSUQsSUFBSUQsSUFBSSxNQUFNRztJQUV0RCxPQUFPO1FBRU5FLFlBQVlOLElBQUlPLGlCQUFpQixDQUFFTixJQUFJQyxJQUFJQyxJQUFJRSxTQUFTbEIsNkNBQVVBLEVBQUVpQjtJQUVyRTtJQUVBLElBQUtFLGNBQWMsTUFBTyxPQUFPO0lBRWpDLE1BQU1FLFdBQVdSLElBQUlTLE1BQU0s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R2UsSUFBSU0sVUFBVTtJQUNwRCxNQUFNaEIsZUFBZVQsZ0NBQWlDWixLQUFLYSxVQUFVQyxRQUFRQyxJQUFJQyxLQUFLQyxHQUFHQyxHQUFHQyxHQUFHZDtJQUUvRixJQUFLZ0IsY0FBZTtRQUVuQkEsYUFBYVEsU0FBUyxHQUFHRztRQUN6QixJQUFLQyxlQUFnQkEsY0FBY0ssSUFBSSxDQUFFakI7UUFDekMsT0FBT0E7SUFFUjtJQUVBLE9BQU87QUFFUjtBQUV3QiIsInNvdXJjZXMiOlsid2VicGFjazovL3ZpYmUtM2QtY29kZS8uL25vZGVfbW9kdWxlcy9AcmVhY3QtdGhyZWUvZHJlaS9ub2RlX21vZHVsZXMvdGhyZWUtbWVzaC1idmgvc3JjL3V0aWxzL1RocmVlUmF5SW50ZXJzZWN0VXRpbGl0aWVzLmpzPzhiNjQiXSwic291cmNlc0NvbnRlbnQiOlsiaW1wb3J0IHsgVmVjdG9yMywgVmVjdG9yMiwgVHJpYW5nbGUsIERvdWJsZVNpZGUsIEJhY2tTaWRlIH0gZnJvbSAndGhyZWUnO1xuXG4vLyBSaXBwZWQgYW5kIG1vZGlmaWVkIEZyb20gVEhSRUUuanMgTWVzaCByYXljYXN0XG4vLyBodHRwczovL2dpdGh1Yi5jb20vbXJkb29iL3RocmVlLmpzL2Jsb2IvMGFhODdjOTk5ZmU2MWUyMTZjMTEzM2ZiYTdhOTU3NzJiNTAzZWRkZi9zcmMvb2JqZWN0cy9NZXNoLmpzI0wxMTVcbmNvbnN0IF92QSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX3ZCID0gLyogQF9fUFVSRV9fICovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCBfdkMgPSAvKiBAX19QVVJFX18gKi8gbmV3IFZlY3RvcjMoKTtcblxuY29uc3QgX3V2QSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVmVjdG9yMigpO1xuY29uc3QgX3V2QiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVmVjdG9yMigpO1xuY29uc3QgX3V2QyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVmVjdG9yMigpO1xuXG5jb25zdCBfbm9ybWFsQSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgX25vcm1hbEIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IF9ub3JtYWxDID0gLyogQF9fUFVSRV9fICovIG5ldyBWZWN0b3IzKCk7XG5cbmNvbnN0IF9pbnRlcnNlY3Rpb25Qb2ludCA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVmVjdG9yMygpO1xuZnVuY3Rpb24gY2hlY2tJbnRlcnNlY3Rpb24oIHJheSwgcEEsIHBCLCBwQywgcG9pbnQsIHNpZGUgKSB7XG5cblx0bGV0IGludGVyc2VjdDtcblx0aWYgKCBzaWRlID09PSBCYWNrU2lkZSApIHtcblxuXHRcdGludGVyc2VjdCA9IHJheS5pbnRlcnNlY3RUcmlhbmdsZSggcEMsIHBCLCBwQSwgdHJ1ZSwgcG9pbnQgKTtcblxuXHR9IGVsc2Uge1xuXG5cdFx0aW50ZXJzZWN0ID0gcmF5LmludGVyc2VjdFRyaWFuZ2xlKCBwQSwgcEIsIHBDLCBzaWRlICE9PSBEb3VibGVTaWRlLCBwb2ludCApO1xuXG5cdH1cblxuXHRpZiAoIGludGVyc2VjdCA9PT0gbnVsbCApIHJldHVybiBudWxsO1xuXG5cdGNvbnN0IGRpc3RhbmNlID0gcmF5Lm9yaWdpbi5kaXN0YW5jZVRvKCBwb2ludCApO1xuXG5cdHJldHVybiB7XG5cblx0XHRkaXN0YW5jZTogZGlzdGFuY2UsXG5cdFx0cG9pbnQ6IHBvaW50LmNsb25lKCksXG5cblx0fTtcblxufVxuXG5mdW5jdGlvbiBjaGVja0J1ZmZlckdlb21ldHJ5SW50ZXJzZWN0aW9uKCByYXksIHBvc2l0aW9uLCBub3JtYWwsIHV2LCB1djEsIGEsIGIsIGMsIHNpZGUgKSB7XG5cblx0X3ZBLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9uLCBhICk7XG5cdF92Qi5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbiwgYiApO1xuXHRfdkMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb24sIGMgKTtcblxuXHRjb25zdCBpbnRlcnNlY3Rpb24gPSBjaGVja0ludGVyc2VjdGlvbiggcmF5LCBfdkEsIF92QiwgX3ZDLCBfaW50ZXJzZWN0aW9uUG9pbnQsIHNpZGUgKTtcblxuXHRpZiAoIGludGVyc2VjdGlvbiApIHtcblxuXHRcdGlmICggdXYgKSB7XG5cblx0XHRcdF91dkEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdXYsIGEgKTtcblx0XHRcdF91dkIuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdXYsIGIgKTtcblx0XHRcdF91dkMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdXYsIGMgKTtcblxuXHRcdFx0aW50ZXJzZWN0aW9uLnV2ID0gVHJpYW5nbGUuZ2V0SW50ZXJwb2xhdGlvbiggX2ludGVyc2VjdGlvblBvaW50LCBfdkEsIF92QiwgX3ZDLCBfdXZBLCBfdXZCLCBfdXZDLCBuZXcgVmVjdG9yMigpICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIHV2MSApIHtcblxuXHRcdFx0X3V2QS5mcm9tQnVmZmVyQXR0cmlidXRlKCB1djEsIGEgKTtcblx0XHRcdF91dkIuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdXYxLCBiICk7XG5cdFx0XHRfdXZDLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHV2MSwgYyApO1xuXG5cdFx0XHRpbnRlcnNlY3Rpb24udXYxID0gVHJpYW5nbGUuZ2V0SW50ZXJwb2xhdGlvbiggX2ludGVyc2VjdGlvblBvaW50LCBfdkEsIF92QiwgX3ZDLCBfdXZBLCBfdXZCLCBfdXZDLCBuZXcgVmVjdG9yMigpICk7XG5cblx0XHR9XG5cblx0XHRpZiAoIG5vcm1hbCApIHtcblxuXHRcdFx0X25vcm1hbEEuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggbm9ybWFsLCBhICk7XG5cdFx0XHRfbm9ybWFsQi5mcm9tQnVmZmVyQXR0cmlidXRlKCBub3JtYWwsIGIgKTtcblx0XHRcdF9ub3JtYWxDLmZyb21CdWZmZXJBdHRyaWJ1dGUoIG5vcm1hbCwgYyApO1xuXG5cdFx0XHRpbnRlcnNlY3Rpb24ubm9ybWFsID0gVHJpYW5nbGUuZ2V0SW50ZXJwb2xhdGlvbiggX2ludGVyc2VjdGlvblBvaW50LCBfdkEsIF92QiwgX3ZDLCBfbm9ybWFsQSwgX25vcm1hbEIsIF9ub3JtYWxDLCBuZXcgVmVjdG9yMygpICk7XG5cdFx0XHRpZiAoIGludGVyc2VjdGlvbi5ub3JtYWwuZG90KCByYXkuZGlyZWN0aW9uICkgPiAwICkge1xuXG5cdFx0XHRcdGludGVyc2VjdGlvbi5ub3JtYWwubXVsdGlwbHlTY2FsYXIoIC0gMSApO1xuXG5cdFx0XHR9XG5cblx0XHR9XG5cblx0XHRjb25zdCBmYWNlID0ge1xuXHRcdFx0YTogYSxcblx0XHRcdGI6IGIsXG5cdFx0XHRjOiBjLFxuXHRcdFx0bm9ybWFsOiBuZXcgVmVjdG9yMygpLFxuXHRcdFx0bWF0ZXJpYWxJbmRleDogMFxuXHRcdH07XG5cblx0XHRUcmlhbmdsZS5nZXROb3JtYWwoIF92QSwgX3ZCLCBfdkMsIGZhY2Uubm9ybWFsICk7XG5cblx0XHRpbnRlcnNlY3Rpb24uZmFjZSA9IGZhY2U7XG5cdFx0aW50ZXJzZWN0aW9uLmZhY2VJbmRleCA9IGE7XG5cblx0fVxuXG5cdHJldHVybiBpbnRlcnNlY3Rpb247XG5cbn1cblxuLy8gaHR0cHM6Ly9naXRodWIuY29tL21yZG9vYi90aHJlZS5qcy9ibG9iLzBhYTg3Yzk5OWZlNjFlMjE2YzExMzNmYmE3YTk1NzcyYjUwM2VkZGYvc3JjL29iamVjdHMvTWVzaC5qcyNMMjU4XG5mdW5jdGlvbiBpbnRlcnNlY3RUcmkoIGdlbywgc2lkZSwgcmF5LCB0cmksIGludGVyc2VjdGlvbnMgKSB7XG5cblx0Y29uc3QgdHJpT2Zmc2V0ID0gdHJpICogMztcblx0bGV0IGEgPSB0cmlPZmZzZXQgKyAwO1xuXHRsZXQgYiA9IHRyaU9mZnNldCArIDE7XG5cdGxldCBjID0gdHJpT2Zmc2V0ICsgMjtcblxuXHRjb25zdCBpbmRleCA9IGdlby5pbmRleDtcblx0aWYgKCBnZW8uaW5kZXggKSB7XG5cblx0XHRhID0gaW5kZXguZ2V0WCggYSApO1xuXHRcdGIgPSBpbmRleC5nZXRYKCBiICk7XG5cdFx0YyA9IGluZGV4LmdldFgoIGMgKTtcblxuXHR9XG5cblx0Y29uc3QgeyBwb3NpdGlvbiwgbm9ybWFsLCB1diwgdXYxIH0gPSBnZW8uYXR0cmlidXRlcztcblx0Y29uc3QgaW50ZXJzZWN0aW9uID0gY2hlY2tCdWZmZXJHZW9tZXRyeUludGVyc2VjdGlvbiggcmF5LCBwb3NpdGlvbiwgbm9ybWFsLCB1diwgdXYxLCBhLCBiLCBjLCBzaWRlICk7XG5cblx0aWYgKCBpbnRlcnNlY3Rpb24gKSB7XG5cblx0XHRpbnRlcnNlY3Rpb24uZmFjZUluZGV4ID0gdHJpO1xuXHRcdGlmICggaW50ZXJzZWN0aW9ucyApIGludGVyc2VjdGlvbnMucHVzaCggaW50ZXJzZWN0aW9uICk7XG5cdFx0cmV0dXJuIGludGVyc2VjdGlvbjtcblxuXHR9XG5cblx0cmV0dXJuIG51bGw7XG5cbn1cblxuZXhwb3J0IHsgaW50ZXJzZWN0VHJpIH07XG4iXSwibmFtZXMiOlsiVmVjdG9yMyIsIlZlY3RvcjIiLCJUcmlhbmdsZSIsIkRvdWJsZVNpZGUiLCJCYWNrU2lkZSIsIl92QSIsIl92QiIsIl92QyIsIl91dkEiLCJfdXZCIiwiX3V2QyIsIl9ub3JtYWxBIiwiX25vcm1hbEIiLCJfbm9ybWFsQyIsIl9pbnRlcnNlY3Rpb25Qb2ludCIsImNoZWNrSW50ZXJzZWN0aW9uIiwicmF5IiwicEEiLCJwQiIsInBDIiwicG9pbnQiLCJzaWRlIiwiaW50ZXJzZWN0IiwiaW50ZXJzZWN0VHJpYW5nbGUiLCJkaXN0YW5jZSIsIm9yaWdpbiIsImRpc3RhbmNlVG8iLCJjbG9uZSIsImNoZWNrQnVmZmVyR2VvbWV0cnlJbnRlcnNlY3Rpb24iLCJwb3NpdGlvbiIsIm5vcm1hbCIsInV2IiwidXYxIiwiYSIsImIiLCJjIiwiZnJvbUJ1ZmZlckF0dHJpYnV0ZSIsImludGVyc2VjdGlvbiIsImdldEludGVycG9sYXRpb24iLCJkb3QiLCJkaXJlY3Rpb24iLCJtdWx0aXBseVNjYWxhciIsImZhY2UiLCJtYXRlcmlhbEluZGV4IiwiZ2V0Tm9ybWFsIiwiZmFjZUluZGV4IiwiaW50ZXJzZWN0VHJpIiwiZ2VvIiwidHJpIiwiaW50ZXJzZWN0aW9ucyIsInRyaU9mZnNldCIsImluZGV4IiwiZ2V0WCIsImF0dHJpYnV0ZXMiLCJwdXNoIl0sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/ThreeRayIntersectUtilities.js\n");

/***/ }),

/***/ "(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js":
/*!***************************************************************************************************!*\
  !*** ./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js ***!
  \***************************************************************************************************/
/***/ ((__unused_webpack___webpack_module__, __webpack_exports__, __webpack_require__) => {

eval("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   getTriangleHitPointInfo: () => (/* binding */ getTriangleHitPointInfo),\n/* harmony export */   setTriangle: () => (/* binding */ setTriangle)\n/* harmony export */ });\n/* harmony import */ var three__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! three */ \"(ssr)/./node_modules/three/build/three.core.js\");\n\n// sets the vertices of triangle `tri` with the 3 vertices after i\nfunction setTriangle(tri, i, index, pos) {\n    const ta = tri.a;\n    const tb = tri.b;\n    const tc = tri.c;\n    let i0 = i;\n    let i1 = i + 1;\n    let i2 = i + 2;\n    if (index) {\n        i0 = index.getX(i0);\n        i1 = index.getX(i1);\n        i2 = index.getX(i2);\n    }\n    ta.x = pos.getX(i0);\n    ta.y = pos.getY(i0);\n    ta.z = pos.getZ(i0);\n    tb.x = pos.getX(i1);\n    tb.y = pos.getY(i1);\n    tb.z = pos.getZ(i1);\n    tc.x = pos.getX(i2);\n    tc.y = pos.getY(i2);\n    tc.z = pos.getZ(i2);\n}\nconst tempV1 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst tempV2 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst tempV3 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\nconst tempUV1 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\nconst tempUV2 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\nconst tempUV3 = /* @__PURE__ */ new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\nfunction getTriangleHitPointInfo(point, geometry, triangleIndex, target) {\n    const indices = geometry.getIndex().array;\n    const positions = geometry.getAttribute(\"position\");\n    const uvs = geometry.getAttribute(\"uv\");\n    const a = indices[triangleIndex * 3];\n    const b = indices[triangleIndex * 3 + 1];\n    const c = indices[triangleIndex * 3 + 2];\n    tempV1.fromBufferAttribute(positions, a);\n    tempV2.fromBufferAttribute(positions, b);\n    tempV3.fromBufferAttribute(positions, c);\n    // find the associated material index\n    let materialIndex = 0;\n    const groups = geometry.groups;\n    const firstVertexIndex = triangleIndex * 3;\n    for(let i = 0, l = groups.length; i < l; i++){\n        const group = groups[i];\n        const { start, count } = group;\n        if (firstVertexIndex >= start && firstVertexIndex < start + count) {\n            materialIndex = group.materialIndex;\n            break;\n        }\n    }\n    // extract uvs\n    let uv = null;\n    if (uvs) {\n        tempUV1.fromBufferAttribute(uvs, a);\n        tempUV2.fromBufferAttribute(uvs, b);\n        tempUV3.fromBufferAttribute(uvs, c);\n        if (target && target.uv) uv = target.uv;\n        else uv = new three__WEBPACK_IMPORTED_MODULE_0__.Vector2();\n        three__WEBPACK_IMPORTED_MODULE_0__.Triangle.getInterpolation(point, tempV1, tempV2, tempV3, tempUV1, tempUV2, tempUV3, uv);\n    }\n    // adjust the provided target or create a new one\n    if (target) {\n        if (!target.face) target.face = {};\n        target.face.a = a;\n        target.face.b = b;\n        target.face.c = c;\n        target.face.materialIndex = materialIndex;\n        if (!target.face.normal) target.face.normal = new three__WEBPACK_IMPORTED_MODULE_0__.Vector3();\n        three__WEBPACK_IMPORTED_MODULE_0__.Triangle.getNormal(tempV1, tempV2, tempV3, target.face.normal);\n        if (uv) target.uv = uv;\n        return target;\n    } else {\n        return {\n            face: {\n                a: a,\n                b: b,\n                c: c,\n                materialIndex: materialIndex,\n                normal: three__WEBPACK_IMPORTED_MODULE_0__.Triangle.getNormal(tempV1, tempV2, tempV3, new three__WEBPACK_IMPORTED_MODULE_0__.Vector3())\n            },\n            uv: uv\n        };\n    }\n}\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,eyJ2ZXJzaW9uIjozLCJmaWxlIjoiKHNzcikvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy91dGlscy9UcmlhbmdsZVV0aWxpdGllcy5qcyIsIm1hcHBpbmdzIjoiOzs7Ozs7QUFDbUQ7QUFFbkQsa0VBQWtFO0FBQzNELFNBQVNHLFlBQWFDLEdBQUcsRUFBRUMsQ0FBQyxFQUFFQyxLQUFLLEVBQUVDLEdBQUc7SUFFOUMsTUFBTUMsS0FBS0osSUFBSUssQ0FBQztJQUNoQixNQUFNQyxLQUFLTixJQUFJTyxDQUFDO0lBQ2hCLE1BQU1DLEtBQUtSLElBQUlTLENBQUM7SUFFaEIsSUFBSUMsS0FBS1Q7SUFDVCxJQUFJVSxLQUFLVixJQUFJO0lBQ2IsSUFBSVcsS0FBS1gsSUFBSTtJQUNiLElBQUtDLE9BQVE7UUFFWlEsS0FBS1IsTUFBTVcsSUFBSSxDQUFFSDtRQUNqQkMsS0FBS1QsTUFBTVcsSUFBSSxDQUFFRjtRQUNqQkMsS0FBS1YsTUFBTVcsSUFBSSxDQUFFRDtJQUVsQjtJQUVBUixHQUFHVSxDQUFDLEdBQUdYLElBQUlVLElBQUksQ0FBRUg7SUFDakJOLEdBQUdXLENBQUMsR0FBR1osSUFBSWEsSUFBSSxDQUFFTjtJQUNqQk4sR0FBR2EsQ0FBQyxHQUFHZCxJQUFJZSxJQUFJLENBQUVSO0lBRWpCSixHQUFHUSxDQUFDLEdBQUdYLElBQUlVLElBQUksQ0FBRUY7SUFDakJMLEdBQUdTLENBQUMsR0FBR1osSUFBSWEsSUFBSSxDQUFFTDtJQUNqQkwsR0FBR1csQ0FBQyxHQUFHZCxJQUFJZSxJQUFJLENBQUVQO0lBRWpCSCxHQUFHTSxDQUFDLEdBQUdYLElBQUlVLElBQUksQ0FBRUQ7SUFDakJKLEdBQUdPLENBQUMsR0FBR1osSUFBSWEsSUFBSSxDQUFFSjtJQUNqQkosR0FBR1MsQ0FBQyxHQUFHZCxJQUFJZSxJQUFJLENBQUVOO0FBRWxCO0FBRUEsTUFBTU8sU0FBUyxhQUFhLEdBQUcsSUFBSXRCLDBDQUFPQTtBQUMxQyxNQUFNdUIsU0FBUyxhQUFhLEdBQUcsSUFBSXZCLDBDQUFPQTtBQUMxQyxNQUFNd0IsU0FBUyxhQUFhLEdBQUcsSUFBSXhCLDBDQUFPQTtBQUMxQyxNQUFNeUIsVUFBVSxhQUFhLEdBQUcsSUFBSTFCLDBDQUFPQTtBQUMzQyxNQUFNMkIsVUFBVSxhQUFhLEdBQUcsSUFBSTNCLDBDQUFPQTtBQUMzQyxNQUFNNEIsVUFBVSxhQUFhLEdBQUcsSUFBSTVCLDBDQUFPQTtBQUVwQyxTQUFTNkIsd0JBQXlCQyxLQUFLLEVBQUVDLFFBQVEsRUFBRUMsYUFBYSxFQUFFQyxNQUFNO0lBRTlFLE1BQU1DLFVBQVVILFNBQVNJLFFBQVEsR0FBR0MsS0FBSztJQUN6QyxNQUFNQyxZQUFZTixTQUFTTyxZQUFZLENBQUU7SUFDekMsTUFBTUMsTUFBTVIsU0FBU08sWUFBWSxDQUFFO0lBRW5DLE1BQU03QixJQUFJeUIsT0FBTyxDQUFFRixnQkFBZ0IsRUFBRztJQUN0QyxNQUFNckIsSUFBSXVCLE9BQU8sQ0FBRUYsZ0JBQWdCLElBQUksRUFBRztJQUMxQyxNQUFNbkIsSUFBSXFCLE9BQU8sQ0FBRUYsZ0JBQWdCLElBQUksRUFBRztJQUUxQ1QsT0FBT2lCLG1CQUFtQixDQUFFSCxXQUFXNUI7SUFDdkNlLE9BQU9nQixtQkFBbUIsQ0FBRUgsV0FBVzFCO0lBQ3ZDYyxPQUFPZSxtQkFBbUIsQ0FBRUgsV0FBV3hCO0lBRXZDLHFDQUFxQztJQUNyQyxJQUFJNEIsZ0JBQWdCO0lBQ3BCLE1BQU1DLFNBQVNYLFNBQVNXLE1BQU07SUFDOUIsTUFBTUMsbUJBQW1CWCxnQkFBZ0I7SUFDekMsSUFBTSxJQUFJM0IsSUFBSSxHQUFHdUMsSUFBSUYsT0FBT0csTUFBTSxFQUFFeEMsSUFBSXVDLEdBQUd2QyxJQUFPO1FBRWpELE1BQU15QyxRQUFRSixNQUFNLENBQUVyQyxFQUFHO1FBQ3pCLE1BQU0sRUFBRTBDLEtBQUssRUFBRUMsS0FBSyxFQUFFLEdBQUdGO1FBQ3pCLElBQUtILG9CQUFvQkksU0FBU0osbUJBQW1CSSxRQUFRQyxPQUFRO1lBRXBFUCxnQkFBZ0JLLE1BQU1MLGFBQWE7WUFDbkM7UUFFRDtJQUVEO0lBRUEsY0FBYztJQUNkLElBQUlRLEtBQUs7SUFDVCxJQUFLVixLQUFNO1FBRVZiLFFBQVFjLG1CQUFtQixDQUFFRCxLQUFLOUI7UUFDbENrQixRQUFRYSxtQkFBbUIsQ0FBRUQsS0FBSzVCO1FBQ2xDaUIsUUFBUVksbUJBQW1CLENBQUVELEtBQUsxQjtRQUVsQyxJQUFLb0IsVUFBVUEsT0FBT2dCLEVBQUUsRUFBR0EsS0FBS2hCLE9BQU9nQixFQUFFO2FBQ3BDQSxLQUFLLElBQUlqRCwwQ0FBT0E7UUFFckJFLDJDQUFRQSxDQUFDZ0QsZ0JBQWdCLENBQUVwQixPQUFPUCxRQUFRQyxRQUFRQyxRQUFRQyxTQUFTQyxTQUFTQyxTQUFTcUI7SUFFdEY7SUFFQSxpREFBaUQ7SUFDakQsSUFBS2hCLFFBQVM7UUFFYixJQUFLLENBQUVBLE9BQU9rQixJQUFJLEVBQUdsQixPQUFPa0IsSUFBSSxHQUFHLENBQUU7UUFDckNsQixPQUFPa0IsSUFBSSxDQUFDMUMsQ0FBQyxHQUFHQTtRQUNoQndCLE9BQU9rQixJQUFJLENBQUN4QyxDQUFDLEdBQUdBO1FBQ2hCc0IsT0FBT2tCLElBQUksQ0FBQ3RDLENBQUMsR0FBR0E7UUFDaEJvQixPQUFPa0IsSUFBSSxDQUFDVixhQUFhLEdBQUdBO1FBQzVCLElBQUssQ0FBRVIsT0FBT2tCLElBQUksQ0FBQ0MsTUFBTSxFQUFHbkIsT0FBT2tCLElBQUksQ0FBQ0MsTUFBTSxHQUFHLElBQUluRCwwQ0FBT0E7UUFDNURDLDJDQUFRQSxDQUFDbUQsU0FBUyxDQUFFOUIsUUFBUUMsUUFBUUMsUUFBUVEsT0FBT2tCLElBQUksQ0FBQ0MsTUFBTTtRQUU5RCxJQUFLSCxJQUFLaEIsT0FBT2dCLEVBQUUsR0FBR0E7UUFFdEIsT0FBT2hCO0lBRVIsT0FBTztRQUVOLE9BQU87WUFDTmtCLE1BQU07Z0JBQ0wxQyxHQUFHQTtnQkFDSEUsR0FBR0E7Z0JBQ0hFLEdBQUdBO2dCQUNINEIsZUFBZUE7Z0JBQ2ZXLFFBQVFsRCwyQ0FBUUEsQ0FBQ21ELFNBQVMsQ0FBRTlCLFFBQVFDLFFBQVFDLFFBQVEsSUFBSXhCLDBDQUFPQTtZQUNoRTtZQUNBZ0QsSUFBSUE7UUFDTDtJQUVEO0FBRUQiLCJzb3VyY2VzIjpbIndlYnBhY2s6Ly92aWJlLTNkLWNvZGUvLi9ub2RlX21vZHVsZXMvQHJlYWN0LXRocmVlL2RyZWkvbm9kZV9tb2R1bGVzL3RocmVlLW1lc2gtYnZoL3NyYy91dGlscy9UcmlhbmdsZVV0aWxpdGllcy5qcz9mM2ZkIl0sInNvdXJjZXNDb250ZW50IjpbIlxuaW1wb3J0IHsgVmVjdG9yMiwgVmVjdG9yMywgVHJpYW5nbGUgfSBmcm9tICd0aHJlZSc7XG5cbi8vIHNldHMgdGhlIHZlcnRpY2VzIG9mIHRyaWFuZ2xlIGB0cmlgIHdpdGggdGhlIDMgdmVydGljZXMgYWZ0ZXIgaVxuZXhwb3J0IGZ1bmN0aW9uIHNldFRyaWFuZ2xlKCB0cmksIGksIGluZGV4LCBwb3MgKSB7XG5cblx0Y29uc3QgdGEgPSB0cmkuYTtcblx0Y29uc3QgdGIgPSB0cmkuYjtcblx0Y29uc3QgdGMgPSB0cmkuYztcblxuXHRsZXQgaTAgPSBpO1xuXHRsZXQgaTEgPSBpICsgMTtcblx0bGV0IGkyID0gaSArIDI7XG5cdGlmICggaW5kZXggKSB7XG5cblx0XHRpMCA9IGluZGV4LmdldFgoIGkwICk7XG5cdFx0aTEgPSBpbmRleC5nZXRYKCBpMSApO1xuXHRcdGkyID0gaW5kZXguZ2V0WCggaTIgKTtcblxuXHR9XG5cblx0dGEueCA9IHBvcy5nZXRYKCBpMCApO1xuXHR0YS55ID0gcG9zLmdldFkoIGkwICk7XG5cdHRhLnogPSBwb3MuZ2V0WiggaTAgKTtcblxuXHR0Yi54ID0gcG9zLmdldFgoIGkxICk7XG5cdHRiLnkgPSBwb3MuZ2V0WSggaTEgKTtcblx0dGIueiA9IHBvcy5nZXRaKCBpMSApO1xuXG5cdHRjLnggPSBwb3MuZ2V0WCggaTIgKTtcblx0dGMueSA9IHBvcy5nZXRZKCBpMiApO1xuXHR0Yy56ID0gcG9zLmdldFooIGkyICk7XG5cbn1cblxuY29uc3QgdGVtcFYxID0gLyogQF9fUFVSRV9fICovIG5ldyBWZWN0b3IzKCk7XG5jb25zdCB0ZW1wVjIgPSAvKiBAX19QVVJFX18gKi8gbmV3IFZlY3RvcjMoKTtcbmNvbnN0IHRlbXBWMyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVmVjdG9yMygpO1xuY29uc3QgdGVtcFVWMSA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVmVjdG9yMigpO1xuY29uc3QgdGVtcFVWMiA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVmVjdG9yMigpO1xuY29uc3QgdGVtcFVWMyA9IC8qIEBfX1BVUkVfXyAqLyBuZXcgVmVjdG9yMigpO1xuXG5leHBvcnQgZnVuY3Rpb24gZ2V0VHJpYW5nbGVIaXRQb2ludEluZm8oIHBvaW50LCBnZW9tZXRyeSwgdHJpYW5nbGVJbmRleCwgdGFyZ2V0ICkge1xuXG5cdGNvbnN0IGluZGljZXMgPSBnZW9tZXRyeS5nZXRJbmRleCgpLmFycmF5O1xuXHRjb25zdCBwb3NpdGlvbnMgPSBnZW9tZXRyeS5nZXRBdHRyaWJ1dGUoICdwb3NpdGlvbicgKTtcblx0Y29uc3QgdXZzID0gZ2VvbWV0cnkuZ2V0QXR0cmlidXRlKCAndXYnICk7XG5cblx0Y29uc3QgYSA9IGluZGljZXNbIHRyaWFuZ2xlSW5kZXggKiAzIF07XG5cdGNvbnN0IGIgPSBpbmRpY2VzWyB0cmlhbmdsZUluZGV4ICogMyArIDEgXTtcblx0Y29uc3QgYyA9IGluZGljZXNbIHRyaWFuZ2xlSW5kZXggKiAzICsgMiBdO1xuXG5cdHRlbXBWMS5mcm9tQnVmZmVyQXR0cmlidXRlKCBwb3NpdGlvbnMsIGEgKTtcblx0dGVtcFYyLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHBvc2l0aW9ucywgYiApO1xuXHR0ZW1wVjMuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggcG9zaXRpb25zLCBjICk7XG5cblx0Ly8gZmluZCB0aGUgYXNzb2NpYXRlZCBtYXRlcmlhbCBpbmRleFxuXHRsZXQgbWF0ZXJpYWxJbmRleCA9IDA7XG5cdGNvbnN0IGdyb3VwcyA9IGdlb21ldHJ5Lmdyb3Vwcztcblx0Y29uc3QgZmlyc3RWZXJ0ZXhJbmRleCA9IHRyaWFuZ2xlSW5kZXggKiAzO1xuXHRmb3IgKCBsZXQgaSA9IDAsIGwgPSBncm91cHMubGVuZ3RoOyBpIDwgbDsgaSArKyApIHtcblxuXHRcdGNvbnN0IGdyb3VwID0gZ3JvdXBzWyBpIF07XG5cdFx0Y29uc3QgeyBzdGFydCwgY291bnQgfSA9IGdyb3VwO1xuXHRcdGlmICggZmlyc3RWZXJ0ZXhJbmRleCA+PSBzdGFydCAmJiBmaXJzdFZlcnRleEluZGV4IDwgc3RhcnQgKyBjb3VudCApIHtcblxuXHRcdFx0bWF0ZXJpYWxJbmRleCA9IGdyb3VwLm1hdGVyaWFsSW5kZXg7XG5cdFx0XHRicmVhaztcblxuXHRcdH1cblxuXHR9XG5cblx0Ly8gZXh0cmFjdCB1dnNcblx0bGV0IHV2ID0gbnVsbDtcblx0aWYgKCB1dnMgKSB7XG5cblx0XHR0ZW1wVVYxLmZyb21CdWZmZXJBdHRyaWJ1dGUoIHV2cywgYSApO1xuXHRcdHRlbXBVVjIuZnJvbUJ1ZmZlckF0dHJpYnV0ZSggdXZzLCBiICk7XG5cdFx0dGVtcFVWMy5mcm9tQnVmZmVyQXR0cmlidXRlKCB1dnMsIGMgKTtcblxuXHRcdGlmICggdGFyZ2V0ICYmIHRhcmdldC51diApIHV2ID0gdGFyZ2V0LnV2O1xuXHRcdGVsc2UgdXYgPSBuZXcgVmVjdG9yMigpO1xuXG5cdFx0VHJpYW5nbGUuZ2V0SW50ZXJwb2xhdGlvbiggcG9pbnQsIHRlbXBWMSwgdGVtcFYyLCB0ZW1wVjMsIHRlbXBVVjEsIHRlbXBVVjIsIHRlbXBVVjMsIHV2ICk7XG5cblx0fVxuXG5cdC8vIGFkanVzdCB0aGUgcHJvdmlkZWQgdGFyZ2V0IG9yIGNyZWF0ZSBhIG5ldyBvbmVcblx0aWYgKCB0YXJnZXQgKSB7XG5cblx0XHRpZiAoICEgdGFyZ2V0LmZhY2UgKSB0YXJnZXQuZmFjZSA9IHsgfTtcblx0XHR0YXJnZXQuZmFjZS5hID0gYTtcblx0XHR0YXJnZXQuZmFjZS5iID0gYjtcblx0XHR0YXJnZXQuZmFjZS5jID0gYztcblx0XHR0YXJnZXQuZmFjZS5tYXRlcmlhbEluZGV4ID0gbWF0ZXJpYWxJbmRleDtcblx0XHRpZiAoICEgdGFyZ2V0LmZhY2Uubm9ybWFsICkgdGFyZ2V0LmZhY2Uubm9ybWFsID0gbmV3IFZlY3RvcjMoKTtcblx0XHRUcmlhbmdsZS5nZXROb3JtYWwoIHRlbXBWMSwgdGVtcFYyLCB0ZW1wVjMsIHRhcmdldC5mYWNlLm5vcm1hbCApO1xuXG5cdFx0aWYgKCB1diApIHRhcmdldC51diA9IHV2O1xuXG5cdFx0cmV0dXJuIHRhcmdldDtcblxuXHR9IGVsc2Uge1xuXG5cdFx0cmV0dXJuIHtcblx0XHRcdGZhY2U6IHtcblx0XHRcdFx0YTogYSxcblx0XHRcdFx0YjogYixcblx0XHRcdFx0YzogYyxcblx0XHRcdFx0bWF0ZXJpYWxJbmRleDogbWF0ZXJpYWxJbmRleCxcblx0XHRcdFx0bm9ybWFsOiBUcmlhbmdsZS5nZXROb3JtYWwoIHRlbXBWMSwgdGVtcFYyLCB0ZW1wVjMsIG5ldyBWZWN0b3IzKCkgKVxuXHRcdFx0fSxcblx0XHRcdHV2OiB1dlxuXHRcdH07XG5cblx0fVxuXG59XG4iXSwibmFtZXMiOlsiVmVjdG9yMiIsIlZlY3RvcjMiLCJUcmlhbmdsZSIsInNldFRyaWFuZ2xlIiwidHJpIiwiaSIsImluZGV4IiwicG9zIiwidGEiLCJhIiwidGIiLCJiIiwidGMiLCJjIiwiaTAiLCJpMSIsImkyIiwiZ2V0WCIsIngiLCJ5IiwiZ2V0WSIsInoiLCJnZXRaIiwidGVtcFYxIiwidGVtcFYyIiwidGVtcFYzIiwidGVtcFVWMSIsInRlbXBVVjIiLCJ0ZW1wVVYzIiwiZ2V0VHJpYW5nbGVIaXRQb2ludEluZm8iLCJwb2ludCIsImdlb21ldHJ5IiwidHJpYW5nbGVJbmRleCIsInRhcmdldCIsImluZGljZXMiLCJnZXRJbmRleCIsImFycmF5IiwicG9zaXRpb25zIiwiZ2V0QXR0cmlidXRlIiwidXZzIiwiZnJvbUJ1ZmZlckF0dHJpYnV0ZSIsIm1hdGVyaWFsSW5kZXgiLCJncm91cHMiLCJmaXJzdFZlcnRleEluZGV4IiwibCIsImxlbmd0aCIsImdyb3VwIiwic3RhcnQiLCJjb3VudCIsInV2IiwiZ2V0SW50ZXJwb2xhdGlvbiIsImZhY2UiLCJub3JtYWwiLCJnZXROb3JtYWwiXSwic291cmNlUm9vdCI6IiJ9\n//# sourceURL=webpack-internal:///(ssr)/./node_modules/@react-three/drei/node_modules/three-mesh-bvh/src/utils/TriangleUtilities.js\n");

/***/ })

};
;